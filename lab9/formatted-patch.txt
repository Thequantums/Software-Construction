From 494be9198b0febdc5fd318639a15935f07d7bd1a Mon Sep 17 00:00:00 2001
From: Sokchetra Eung <sokchetr@lnxsrv09.seas.ucla.edu>
Date: Sat, 16 Mar 2019 14:17:30 -0700
Subject: [PATCH] 2019-03-16  Sokchetra Eung  <sokchetr@lnxsrv09.seas.ucla.edu>

	* utils.c: convert apostrophe in string constant
	* sdiff.c: convert apostrophe in string constant
	* dir.c  : convert apostrophe in string constant
	* diff3.c: convert apostrophe in string constant
	* diff.c : convert apostrophe in string constant
	* cmp.c  : convert apostrophe in string constant
---
 diffutils-gets.diff                  |   11 +
 git-log.txt                          | 9628 ++++++++++++++++++++++++++++++++++
 quote-3.0-patch.txt                  |  326 ++
 src/cmp.c                            |   12 +-
 src/cmp.c.orig                       |  685 +++
 src/cmp.c.rej                        |   56 +
 src/diff.c                           |   28 +-
 src/diff.c.orig                      | 1330 +++++
 src/diff3.c                          |   20 +-
 src/diff3.c.orig                     | 1747 ++++++
 src/dir.c                            |    2 +-
 src/dir.c.orig                       |  283 +
 src/sdiff.c                          |   16 +-
 src/sdiff.c.orig                     | 1236 +++++
 src/util.c                           |    8 +-
 src/util.c.orig                      |  788 +++
 test/diffutils                       |    1 +
 test/diffutils-3.0-patch/Makefile.am |   55 +
 test/diffutils-3.0-patch/analyze.c   |  723 +++
 test/diffutils-3.0-patch/cmp         |  Bin 0 -> 178488 bytes
 test/diffutils-3.0-patch/cmp.c       |  685 +++
 test/diffutils-3.0-patch/context.c   |  493 ++
 test/diffutils-3.0-patch/diff        |  Bin 0 -> 807328 bytes
 test/diffutils-3.0-patch/diff.c      | 1330 +++++
 test/diffutils-3.0-patch/diff.h      |  373 ++
 test/diffutils-3.0-patch/diff3       |  Bin 0 -> 236056 bytes
 test/diffutils-3.0-patch/diff3.c     | 1747 ++++++
 test/diffutils-3.0-patch/dir.c       |  283 +
 test/diffutils-3.0-patch/ed.c        |  175 +
 test/diffutils-3.0-patch/ifdef.c     |  430 ++
 test/diffutils-3.0-patch/io.c        |  845 +++
 test/diffutils-3.0-patch/normal.c    |   69 +
 test/diffutils-3.0-patch/paths.h     |    2 +
 test/diffutils-3.0-patch/sdiff       |  Bin 0 -> 184496 bytes
 test/diffutils-3.0-patch/sdiff.c     | 1236 +++++
 test/diffutils-3.0-patch/side.c      |  320 ++
 test/diffutils-3.0-patch/system.h    |  228 +
 test/diffutils-3.0-patch/util.c      |  788 +++
 test/diffutils-3.0/Makefile.am       |   80 +
 test/diffutils-3.0/analyze.c         |  716 +++
 test/diffutils-3.0/cmp.c             |  693 +++
 test/diffutils-3.0/context.c         |  537 ++
 test/diffutils-3.0/die.h             |   31 +
 test/diffutils-3.0/diff.c            | 1473 ++++++
 test/diffutils-3.0/diff.h            |  423 ++
 test/diffutils-3.0/diff3.c           | 1790 +++++++
 test/diffutils-3.0/dir.c             |  385 ++
 test/diffutils-3.0/ed.c              |  177 +
 test/diffutils-3.0/ifdef.c           |  431 ++
 test/diffutils-3.0/io.c              |  830 +++
 test/diffutils-3.0/normal.c          |   91 +
 test/diffutils-3.0/sdiff.c           | 1173 +++++
 test/diffutils-3.0/side.c            |  335 ++
 test/diffutils-3.0/system.h          |  240 +
 test/diffutils-3.0/util.c            | 1576 ++++++
 test/quote-3.0-test.txt              | 5088 ++++++++++++++++++
 56 files changed, 41985 insertions(+), 43 deletions(-)
 create mode 100644 diffutils-gets.diff
 create mode 100644 git-log.txt
 create mode 100644 quote-3.0-patch.txt
 create mode 100644 src/cmp.c.orig
 create mode 100644 src/cmp.c.rej
 create mode 100644 src/diff.c.orig
 create mode 100644 src/diff3.c.orig
 create mode 100644 src/dir.c.orig
 create mode 100644 src/sdiff.c.orig
 create mode 100644 src/util.c.orig
 create mode 160000 test/diffutils
 create mode 100644 test/diffutils-3.0-patch/Makefile.am
 create mode 100644 test/diffutils-3.0-patch/analyze.c
 create mode 100755 test/diffutils-3.0-patch/cmp
 create mode 100644 test/diffutils-3.0-patch/cmp.c
 create mode 100644 test/diffutils-3.0-patch/context.c
 create mode 100755 test/diffutils-3.0-patch/diff
 create mode 100644 test/diffutils-3.0-patch/diff.c
 create mode 100644 test/diffutils-3.0-patch/diff.h
 create mode 100755 test/diffutils-3.0-patch/diff3
 create mode 100644 test/diffutils-3.0-patch/diff3.c
 create mode 100644 test/diffutils-3.0-patch/dir.c
 create mode 100644 test/diffutils-3.0-patch/ed.c
 create mode 100644 test/diffutils-3.0-patch/ifdef.c
 create mode 100644 test/diffutils-3.0-patch/io.c
 create mode 100644 test/diffutils-3.0-patch/normal.c
 create mode 100644 test/diffutils-3.0-patch/paths.h
 create mode 100755 test/diffutils-3.0-patch/sdiff
 create mode 100644 test/diffutils-3.0-patch/sdiff.c
 create mode 100644 test/diffutils-3.0-patch/side.c
 create mode 100644 test/diffutils-3.0-patch/system.h
 create mode 100644 test/diffutils-3.0-patch/util.c
 create mode 100644 test/diffutils-3.0/Makefile.am
 create mode 100644 test/diffutils-3.0/analyze.c
 create mode 100644 test/diffutils-3.0/cmp.c
 create mode 100644 test/diffutils-3.0/context.c
 create mode 100644 test/diffutils-3.0/die.h
 create mode 100644 test/diffutils-3.0/diff.c
 create mode 100644 test/diffutils-3.0/diff.h
 create mode 100644 test/diffutils-3.0/diff3.c
 create mode 100644 test/diffutils-3.0/dir.c
 create mode 100644 test/diffutils-3.0/ed.c
 create mode 100644 test/diffutils-3.0/ifdef.c
 create mode 100644 test/diffutils-3.0/io.c
 create mode 100644 test/diffutils-3.0/normal.c
 create mode 100644 test/diffutils-3.0/sdiff.c
 create mode 100644 test/diffutils-3.0/side.c
 create mode 100644 test/diffutils-3.0/system.h
 create mode 100644 test/diffutils-3.0/util.c
 create mode 100644 test/quote-3.0-test.txt

diff --git a/diffutils-gets.diff b/diffutils-gets.diff
new file mode 100644
index 0000000..30800b6
--- /dev/null
+++ b/diffutils-gets.diff
@@ -0,0 +1,11 @@
+--- old/stdio.in.h	2016-01-25 16:53:50.846901000 -0800
++++ lib/stdio.in.h	2016-01-25 16:55:28.997468000 -0800
+@@ -139,7 +139,7 @@ _GL_WARN_ON_USE (fflush, "fflush is not
+    so any use of gets warrants an unconditional warning.  Assume it is
+    always declared, since it is required by C89.  */
+ #undef gets
+-_GL_WARN_ON_USE (gets, "gets is a security hole - use fgets instead");
++/* _GL_WARN_ON_USE (gets, "gets is a security hole - use fgets instead"); */
+ 
+ #if @GNULIB_FOPEN@
+ # if @REPLACE_FOPEN@
diff --git a/git-log.txt b/git-log.txt
new file mode 100644
index 0000000..f895d69
--- /dev/null
+++ b/git-log.txt
@@ -0,0 +1,9628 @@
+commit 487e009ed7294021dcc0b66c2b5a5046aea51ab4
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun May 21 15:27:10 2017 -0700
+
+    maint: make the announcement template Cc the devel- list
+    
+    * cfg.mk (announcement_Cc_): Define.
+
+commit 592e503b48e42981b0a7fa308a6c3b06f08d582b
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun May 21 13:27:36 2017 -0700
+
+    maint: post-release administrivia
+    
+    * NEWS: Add header line for next release.
+    * .prev-version: Record previous version.
+    * cfg.mk (old_NEWS_hash): Auto-update.
+
+commit e73a3d5e44c2e46e2ae947eb99b3834874a601a8
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun May 21 13:25:42 2017 -0700
+
+    version 3.6
+    
+    * NEWS: Record release date.
+
+commit 7c2a2d63f42135f676aec054583242734ef348c2
+Author: Jim Meyering <meyering@fb.com>
+Date:   Fri May 19 17:14:09 2017 -0700
+
+    gnulib: update to latest
+
+commit d3b51e7f02994c76b88b83857e253b4116706f91
+Author: Jim Meyering <meyering@fb.com>
+Date:   Wed May 17 22:51:31 2017 -0700
+
+    maint: update to work with GCC7's -Werror=implicit-fallthrough=
+    
+    * src/system.h (FALLTHROUGH): Define.
+    Use new FALLTHROUGH macro in place of comments
+    * src/cmp.c: FIXME
+    * src/diff3.c: FIXME
+    * src/ifdef.c: FIXME
+    * src/sdiff.c: FIXME
+    * src/side.c: FIXME
+    * src/util.c: FIXME
+
+commit 646268f5c6472d248ae0e98960f7983656a9d0e3
+Author: Jim Meyering <meyering@fb.com>
+Date:   Thu May 18 09:23:06 2017 -0700
+
+    gnulib: update to latest
+
+commit 20b31314c3d72af7159cc6ba3cdb9b1288263858
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue May 9 11:55:46 2017 -0700
+
+    tests: new-file: closed-stdin: also ensure stdout was empty
+    
+    * tests/new-file: Also require that "out" be empty.
+
+commit c881afb9b82a4943b47880d2e607825ceff286be
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat May 6 12:09:43 2017 -0700
+
+    maint: stop using @acronym{...} in texinfo sources
+    
+    * doc/diffutils.texi: Remove all uses of @acronym{...},
+    per recommendation by Karl Berry.
+    * cfg.mk (local-checks-to-skip): Remove exemption, enabling
+    the @acronym{-prohibiting syntax-check rule.
+
+commit ac05c6d549bb0731386ca2251c92b91be2e95228
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu May 4 17:17:23 2017 -0700
+
+    cmp: improve EOF diagnostic
+    
+    This improves on yesterday's change, following up on a
+    remark by Jim Meyering (Bug#22816#21).
+    * doc/diffutils.texi (Invoking cmp, cmp Options): Follow POSIX more
+    closely in the documentation of the information appended to the EOF
+    diagnostic.
+    * src/cmp.c (cmp): Be more specific about the shorter file's length
+    and fix some off-by-1 issues in reporting line counts.
+    * tests/cmp: Adjust to match new behavior.
+    Don't assume internal details about stdio buffering.
+
+commit 98b6fc2f320cfb6a1b55dc032b7de26188c04479
+Author: Benno Schulenberg <bensberg@justemail.net>
+Date:   Sat Feb 4 10:55:54 2017 +0100
+
+    diff: describe each --help option with a single string
+    
+    * src/diff.c: To ease translating, fuse four description pieces
+    into two whole ones.  Also reword and rewrap one of them to fit
+    within eighty characters.
+
+commit 1b1526b4f57649d206c61f494d4f7ac48fa12a45
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu May 4 17:17:23 2017 -0700
+
+    cmp: report prefix length when one file is shorter
+    
+    Requested by Dan Jacobson (Bug#22816).
+    * NEWS:
+    * doc/diffutils.texi (Invoking cmp, cmp Options): Document this.
+    * src/cmp.c (cmp): Implement it.
+    * tests/Makefile.am (TESTS): Add cmp.
+    * tests/cmp: New file.
+
+commit 4e40686e23dba2e89aec76ee009049602caa19ca
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue May 2 19:52:37 2017 -0700
+
+    tests: add test for latest fix
+    
+    * NEWS (Bug fixes): Describe it.
+    * tests/invalid-re: New test for just-fixed bug.
+    * tests/Makefile.am (TESTS): Add it.
+
+commit af6d2e0dbddcdcd52ba36636c72b3ffa774238c8
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue May 2 16:28:30 2017 -0700
+
+    gnulib: update to latest
+
+commit 2acb5aae869310f75dc8aa4d81a6b2e4870c1000
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Apr 27 22:39:07 2017 -0700
+
+    diff: don't crash if regexp is invalid
+    
+    Problem reported by Marcel Böhme in:
+    http://lists.gnu.org/archive/html/bug-diffutils/2017-04/msg00002.html
+    * src/diff.c (add_regexp): Exit if re_compile_pattern fails.
+
+commit 7c636563c24982f6eb7896ef8aa24e6f78c5d48b
+Author: julama <julama@fake-box.com>
+Date:   Wed Mar 22 21:38:32 2017 -0700
+
+    tests: avoid false failure for unreadable /proc/cmdline
+    
+    * tests/brief-vs-stat-zero-kernel-lies: Use "test -r" rather than
+    just "test -f".  This avoids a false test failure on a linux system
+    with grsecurity and its GRKERNSEC_PROC_USER option enabled, for which
+    /proc/cmdline is unreadable.  Reported in https://bugs.gnu.org/26155
+
+commit 198c55a64557c89f201ddea7cbcb14c09c400071
+Author: Jim Meyering <meyering@fb.com>
+Date:   Wed Feb 1 23:06:29 2017 -0800
+
+    tests: avoid false failure with some shells on debian, freebsd
+    
+    * tests/colors: Move the TERM=dumb setting into the code run by
+    "returns_", since some shells do not propagate envvar setting through
+    to a use of a function like this.  That would cause this test to fail
+    because results were colorized when they should not have been.
+    Reported by Nelson Beebe.
+
+commit affa30def0d530022a03845372ec19c644f8f1ac
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue Jan 31 17:06:10 2017 -0800
+
+    maint: add "introduced in 3.4" in latest NEWS entry
+    
+    * NEWS: Update.  Also, thanks to Nelson Beebe for reporting this.
+
+commit eaa2a24345fba918eb7ad7a6a263e7e639d82d5f
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue Jan 31 16:44:03 2017 -0800
+
+    diff: avoid UMR with ---presume-output-tty
+    
+    * src/diff.c (main): Always define presume_output_tty.
+    Otherwise, it would be read uninitialized.
+    Introduced in v3.3-45-g17e2698
+    * NEWS (Bug fixes): Mention it.
+
+commit 8420aff7e0eac5b6d02dcb60b88b9f9c2150f85a
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue Jan 31 10:36:25 2017 -0800
+
+    gnulib: update to latest; and update bootstrap and init.sh
+
+commit 75173432ed47ae77d3024da8e5daa70f1f8d2650
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue Jan 31 10:45:11 2017 -0800
+
+    maint: change "time stamp" to "timestamp" globally
+    
+    This avoids a new syntax-check failure.
+    * ChangeLog-2008: Perform that change.
+    * doc/diffutils.texi: Likewise.
+    * NEWS: Likewise.
+    * cfg.mk: Update the old news hash accordingly.
+
+commit 90106d33ab3004872f8cfe46779683be48b7bd12
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Jan 1 03:22:44 2017 -0800
+
+    maint: update gnulib and copyright dates for 2017
+    
+    * gnulib: Update to latest.
+    * all files: Run "make update-copyright".
+
+commit a9cc55101cc9c10cf7a8857034fef88559f4c656
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Oct 30 12:13:13 2016 -0700
+
+    tests: use "returns_" rather than explicit comparison with "$?"
+    
+    * tests/colors: Use "returns_ 1" rather than testing $? = 1
+    * tests/basic: Likewise.
+    * tests/binary: Likewise.
+    * tests/filename-quoting: Likewise.
+    * tests/function-line-vs-leading-space: Likewise.
+    * tests/ignore-matching-lines: Likewise.
+    * tests/label-vs-func: Likewise.
+    * tests/new-file: Likewise.
+    * tests/no-dereference: Likewise.
+    * tests/no-newline-at-eof: Likewise.
+    * tests/stdin: Likewise.
+
+commit 68b82f6f8419a815cfcf962b3061352d414dc606
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Oct 25 21:57:56 2016 -0700
+
+    diff: fix big performance degradation in 3.4
+    
+    * NEWS, doc/diffutils.texi (Overview): Document this.
+    * src/analyze.c (diff_2_files): Restore too_expensive heuristic,
+    but this time with a floor that is 16 times the old floor.  This
+    should fix Bug#16848, by generating good-quality output for its
+    test case, while not introducing Bug#24715, by running nearly as
+    fast as diff-3.3 for that test case.
+
+commit 571f01c069dfc7f860e5500a5d08ebfdaf9c3068
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Oct 25 21:52:31 2016 -0700
+
+    build: update gnulib submodule to latest
+
+commit 1c1de418606f163a0027b3e7305ca91708616219
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Oct 16 08:43:14 2016 -0700
+
+    maint: use die rather than error
+    
+    Use "die (N, ..." rather than "error (N, ..." whenever N is a nonzero
+    constant.  That lets the compiler know that control never goes beyond
+    that point, and thus makes unnecessary the occasional following
+    "abort ();" or "break;" statement we have historically added to inform
+    static analysis tools of this aspect of "error" semantics.
+    * src/die.h: New file.
+    * src/Makefile.am (noinst_HEADERS): Add it.
+    * src/cmp.c: Use die in place of error whenever the first
+    argument is a nonzero constant.  Also remove any immediately-
+    following call to abort, and include "die.h".
+    * src/diff.c: Likewise.
+    * src/diff3.c: Likewise.
+    * src/sdiff.c: Likewise.
+    * src/util.c: Likewise.
+
+commit 84387b8f5fa66ecb4c2ac46a2a8cde909222f090
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Oct 1 13:00:35 2016 -0700
+
+    gnulib: update to latest
+
+commit 8db62fe5ec9b81899c39461c4380fcf2bb7a9d82
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Oct 2 10:56:55 2016 -0700
+
+    build: avoid GCC 7's new warnings
+    
+    * src/util.c (get_funky_string): Adjust comment so that GCC 7's
+    -Wimplicit-fallthrough recognizes it.
+    * src/diff3.c (main): Cast boolean MERGE to "int" to avoid this:
+    diff3.c:341:25: error: '~' on a boolean expression \
+    [-Werror=bool-operation]
+
+commit ff2b22a8b3fafe6407ecebd95ddc41a13551879b
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue Aug 30 12:41:38 2016 -0700
+
+    gnulib: update to latest
+
+commit 65185e4c62028b468ad8a0602a33561561d9d0be
+Author: Jim Meyering <meyering@fb.com>
+Date:   Mon Aug 29 20:07:16 2016 -0700
+
+    gnulib: update to latest, to port to upcoming GCC 7
+    
+    This fixes compilation errors when using gcc-7-to-be that were
+    due to missing backslashes in gnulib's intprops.h and an API
+    change in functions like __builtin_add_overflow.  This ports
+    to GCC 7's newer built-in overflow-checking functions.
+
+commit 688f4fb211b603050ef7efd6cbe1db63b31f2fd7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Aug 28 16:46:34 2016 -0700
+
+    diff: don't assume ptrdiff_t <= long long int
+    
+    * src/system.h (printint, pI): Port to (theoretical) platforms
+    where ptrdiff_t is wider than long long int (Bug#24311).
+
+commit f2712fcddff9c7ff571b19ace30d0d3a195ebde8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Aug 27 14:59:13 2016 -0700
+
+    diff: port line numbers to mingw64
+    
+    Problem reported by Peter Rosin (Bug#24311).
+    * src/system.h (printint, pI): New typedef and macro.
+    All uses of 'long int' and "%l" in printf format replaced by
+    'printint' and "%"pI respectively.
+    * src/ifdef.c (do_printf_spec): Don't assume pI is length 1.
+
+commit 34823e7e6770042ec5d7349218efdb34307349e9
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Aug 20 22:23:28 2016 -0700
+
+    maint: post-release administrivia
+    
+    * NEWS: Add header line for next release.
+    * .prev-version: Record previous version.
+    * cfg.mk (old_NEWS_hash): Auto-update.
+
+commit d1145efd81ffbcc0b00f138ede826d3d6f640200
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Aug 20 22:21:26 2016 -0700
+
+    version 3.5
+    
+    * NEWS: Record release date.
+
+commit 24792668f02cb915a170a8098d945da325287288
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue Aug 16 22:20:28 2016 -0700
+
+    build: arrange to build with -fno-common, when possible
+    
+    * configure.ac (WERROR_CFLAGS): Add -fno-common, when possible.
+    This would have prevented the duplicate definition of
+    presume_output_tty that was fixed in v3.4-10-gc2dc91f.
+
+commit c2dc91f1968c6ccd8ba623f9fa391f529ab800ab
+Author: Hanno Böck <hanno@hboeck.de>
+Date:   Tue Aug 16 22:02:13 2016 -0700
+
+    diff: avoid duplicate definition of presume_output_tty
+    
+    * src/util.c (presume_output_tty): Remove this definition.
+    The other is in diff.h.  Reported in https://bugs.gnu.org/24248
+
+commit d6474c4c512d9196d7d9a6086a96eac6813a5c19
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Aug 14 17:16:59 2016 -0700
+
+    gnulib: update to latest
+
+commit c61efccd23c827a03bdd1d41211c70479a632b86
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Aug 14 22:25:49 2016 -0700
+
+    tests: diff3: work around missing seq on some systems
+    
+    * tests/diff3 (seq): Provide a seq replacement function,
+    since at least AIX, SunOS 5.10, OpenBSD-5.8 lack it.
+    Reported by Assaf Gordon in https://bugs.gnu.org/24227#8
+
+commit edd942ca27d570a33d612b12eecaa33a76640e46
+Author: Jim Meyering <meyering@fb.com>
+Date:   Fri Aug 12 21:40:29 2016 -0700
+
+    diff3: fix leaks, for real
+    
+    * src/diff3.c (struct diff_block)[lint]: Add member, n2.
+    (free_diff_block, next_to_n2): New functions.
+    * tests/diff3: Add more test coverage.
+
+commit b3def738f3b435cbe6f2a8406bae5a71175a0b80
+Author: Jim Meyering <meyering@fb.com>
+Date:   Fri Aug 12 11:17:26 2016 -0700
+
+    maint: require that commit messages be of a certain form
+    
+    * bootstrap.conf (bootstrap_epilogue): Merge from coreutils, so that
+    a local commit hook will now help enforce consistent commit messages.
+    * Makefile.am (check-git-hook-script-sync): New rule, largely copied
+    from coreutils.
+    * scripts/git-hooks/commit-msg: New file, from coreutils, but
+    with adapted list of program names.
+    * scripts/git-hooks/applypatch-msg: New file, from git.
+    * scripts/git-hooks/pre-applypatch: Likewise.
+    * scripts/git-hooks/pre-commit: Likewise.
+
+commit 1a0df4396ebe3b9a58b882bb976cfce3f50d3cac
+Author: Bastian Beischer <bastian.beischer@rwth-aachen.de>
+Date:   Sat Aug 13 18:53:36 2016 -0700
+
+    diff3: fix heap use-after-free; add minimal diff3 test coverage
+    
+    Commit v3.3-42-g3b74a90, "FIXME: src/diff3: plug a leak" added an
+    invalid use of free, leading to use-after-free in nearly any invocation
+    of diff3.  Revert that commit.
+    * NEWS (Bug fixes): Mention it.
+    * tests/diff3: New file, to add minimal test coverage.
+    * tests/Makefile.am (TESTS): Add it.
+    Reported by Bastian Beischer in http://bugs.gnu.org/24210
+
+commit 88d911dbc717494febee4b0ebc790808054fefff
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Aug 13 19:40:20 2016 -0700
+
+    build: ignore texinfo build artifacts
+    
+    * .gitignore: Ignore texinfo artifacts in doc/.
+
+commit 1b3907f976df79e45063901d5f7de76e3f1c7f43
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Aug 13 19:42:57 2016 -0700
+
+    maint: diff3: remove an unreachable statement
+    
+    * src/diff3.c (main): Remove unreachable "return" after exit from main.
+
+commit 697c1f4fa93ac971c487725e9e53fc211cd3c670
+Author: Jim Meyering <meyering@fb.com>
+Date:   Mon Aug 8 18:50:15 2016 -0700
+
+    diff: disable colorization for TERM=dumb
+    
+    * src/diff.c (main): With --color or --color=auto, when TERM is
+    "dumb", disable colorization.  Suggested by Daniel Colascione.
+    * NEWS (Bug fixes): Mention it.
+    * tests/colors: Add a test that would fail without this change,
+    yet passes with it.
+
+commit 09369932527342a4fb0ccc6677184c3d3ce7fc49
+Author: Jim Meyering <meyering@fb.com>
+Date:   Mon Aug 8 10:14:00 2016 -0700
+
+    maint: post-release administrivia
+    
+    * NEWS: Add header line for next release.
+    * .prev-version: Record previous version.
+    * cfg.mk (old_NEWS_hash): Auto-update.
+
+commit 5ac64141edd699566edfa9a6659c0d7586f019e4
+Author: Jim Meyering <meyering@fb.com>
+Date:   Mon Aug 8 10:10:51 2016 -0700
+
+    version 3.4
+    
+    * NEWS: Record release date.
+
+commit 05476e882f0aa6b032d7cf3859214210a5ccc1fb
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Aug 6 13:50:06 2016 -0700
+
+    gnulib: update to latest
+
+commit 91d23408864f70ce2da19d0b272b298e72fad018
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Aug 6 11:19:07 2016 -0700
+
+    tests: tweak built_programs definition
+    
+    * tests/Makefile.am (built_programs): Adjust to work around what
+    may be a problem due to interaction between Solaris 10's /bin/sh
+    and an old version of GNU make. Reported by Dagobert Michelsen
+    in https https://bugs.gnu.org/24137.
+
+commit a37c5846867defe109e1eefe550793cd8947fbb2
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue Aug 2 19:09:20 2016 -0700
+
+    gnulib: update to latest
+
+commit 38e3a1dd49d6a2793eb990da60efae25a2ba1fcf
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue Aug 2 09:30:06 2016 -0700
+
+    tests: skip a /proc/self-dependent test on the Hurd
+    
+    * tests/brief-vs-stat-zero-kernel-lies: The Hurd's /proc/self
+    is not useful, so detect that and skip the test that requires it.
+    Reported by Assaf Gordon in https://debbugs.gnu.org/24121#29
+
+commit df14e616b3d497c611edb04d6071b09565f65434
+Author: Jim Meyering <meyering@fb.com>
+Date:   Mon Aug 1 09:23:03 2016 -0700
+
+    tests/colors: fix portability problem with touch --date
+    
+    * tests/colors (epoch): Don't use GNU touch's --date=$epoch option.
+    Use the portable -t 197001010000.00.
+    Reported by Assaf Gordon in https://debbugs.gnu.org/24121#8
+
+commit 47f84d5a75bd46822c000ceab4abea5c11079d17
+Author: Jim Meyering <meyering@fb.com>
+Date:   Mon Aug 1 08:03:22 2016 -0700
+
+    build: Solaris 9: avoid link failure due to isblank use
+    
+    * bootstrap.conf (gnulib_modules): Add isblank, to avoid a link
+    error on Solaris 9 Sparc.  Reported by Dagobert Michelsen.
+
+commit b43e6fed25d5fbd0243224753e14be2f4eb00b7e
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Jul 31 21:29:21 2016 -0700
+
+    test: improve test infrastructure
+    
+    * tests/envvar-check: New file, copied from grep, with the addition
+    of the EDITOR and GREP_OPTIONS envvar names.
+    * tests/Makefile.am (EXTRA_DIST): Add it.
+    (TESTS_ENVIRONMENT): Revamp, to be more like that of grep.
+
+commit e974118719b9f79adf36454151b13eb2622faa93
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Jul 31 17:46:17 2016 -0700
+
+    maint: remove gl/lib/reg*.c.diff; no longer needed
+    
+    * gl/lib/regcomp.c.diff: Remove file, now that gnulib's
+    regcomp.c compiles regex.c with -Wno-unused-parameter.
+    * gl/lib/regex_internal.c.diff: This file induced a change to ensure
+    that the "Idx" type was unsigned and to remove a few "VAR < 0"
+    comparisons.  These days, it is probably fine to stay in sync with
+    gnulib/glibc's copies
+    of these files, so remove these patches, too.
+    * gl/lib/regexec.c.diff: Likewise.
+    Prompted by a report by Assaf Gordon and a suggestion from Paul Eggert.
+
+commit 55596fcd4846a802da9bce831547a9a01e4cbe15
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Jul 31 17:33:34 2016 -0700
+
+    tests: colors: fix a portability problem and work around a shell bug
+    
+    * tests/colors (e): Fix a portability bug: use printf '\033'
+    rather than '\e' to generate the required byte sequence, since
+    for some shells (at least dash 0.5.8), the latter doesn't work.
+    Work around a shell bug whereby "local tab=$(printf '\t')"
+    would result in an empty value for "$tab": hoist each "tab"
+    definition up/out of its function to global scope.
+    Reported by Assaf Gordon in http://debbugs.gnu.org/24116#8
+
+commit 0353af91a02d1bd14b18d10293f1ef27dd6c0a58
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Jul 23 16:33:35 2016 -0700
+
+    gnulib: update to latest; and tests/init.sh
+    
+    * gnulib: Update to latest.
+    * init.sh: Update from gnulib.
+
+commit a10ff125c8ff7fbaf1100cd41ea4e8ac0d594c82
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Apr 2 18:42:19 2016 -0700
+
+    maint: arrange for "make distcheck" to work with unreleased automake
+    
+    * dist-check.mk (my-distcheck): Remove all .deps directories
+    before performing the recursive comparison.
+
+commit 752679190cf610ea32c54d625c368bb87da156fc
+Author: Glenn Morris <rgm@gnu.org>
+Date:   Tue May 24 19:51:36 2016 -0700
+
+    doc: fix a reference to emacs' emerge node
+    
+    * doc/diffutils.texi (Interactive Merging): Correct a reference to
+    emacs' emerge node: s/emerge/Emerge/.
+    This addresses http://debbugs.gnu.org/23613
+
+commit 8c19e4a18ef037b97054f6ea4aefa94f62ac9dbc
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Apr 30 19:23:24 2016 +0100
+
+    maint: arrange for better URLs in generated announcement message
+    
+    * cfg.mk (url_dir_list): Define.  I had been correcting the generated
+    URLs by hand, just before the announcement.  This is better.
+
+commit 5a485511d77a23d144a05266482ce89171249156
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue Mar 15 10:38:23 2016 -0700
+
+    maint: don't ignore gitlog-to-changelog failure
+    
+    * Makefile.am (gen-ChangeLog): Don't ignore failure of
+    gitlog-to-changelog. This syncs to coreutils' copy of this rule.
+
+commit 17e2698bcbee30a6cc282d61ad6242a64ba9c7cf
+Author: Giuseppe Scrivano <gscrivano@gnu.org>
+Date:   Mon Feb 1 09:58:52 2016 +0100
+
+    diff: --color: fix an infinite recursion bug
+    
+    * src/diff.h (presume_output_tty): New extern variable.
+    * src/diff.c (PRESUME_OUTPUT_TTY_OPTION): New enum.
+    (group_format_option): Add '-presume-output-tty'.
+    (main): Handle PRESUME_OUTPUT_TTY_OPTION.
+    * src/util.c: New variable `presume_output_tty'.
+    (check_color_output): Handle presume_output_tty.
+    (set_color_context): Call process_signals only when color_context is
+    not RESET_CONTEXT.
+    * tests/colors: Check that diff doesn't crash when interrupted
+    in the middle of a color sequence.
+    
+    Reported by Gisle Vanem in http://debbugs.gnu.org/22067
+
+commit 3d8affcc9dd85da0de0121e95a6f932d68feb5fa
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Jan 31 18:01:27 2016 -0800
+
+    maint: update prereq version of gettext
+    
+    * configure.ac: Increase designated gettext version to 0.19.2
+    * bootstrap.conf (buildreq): Likewise.
+    Remove now-unnecessary code to remove gettext-provided files.
+
+commit a19bcfd9e7eec512abb774797da33c630b632082
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Jan 31 16:53:39 2016 -0800
+
+    gnulib: update to latest
+
+commit 3b74a905c5460e7979c53273ac90345860d001a7
+Author: Jim Meyering <meyering@fb.com>
+Date:   Fri Jan 1 18:24:25 2016 -0800
+
+    FIXME: src/diff3: plug a leak
+
+commit 7346a030108e032b0e8523f381f1a95b91806890
+Author: Jim Meyering <meyering@fb.com>
+Date:   Fri Jan 1 15:06:05 2016 -0800
+
+    maint: update copyright year, bootstrap, init.sh
+    
+    Run "make update-copyright" and then...
+    
+    * gnulib: Update to latest.
+    * tests/init.sh: Update from gnulib.
+    * bootstrap: Likewise.
+
+commit a3ea9cd5cb911a0319c81b01e205b24c92a8535c
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Nov 28 18:02:05 2015 -0800
+
+    diff --brief no longer mistakenly reports diff. with 0-sized /proc/ files
+    
+    Normally, it is safe to assume two regular files are different when
+    their st_size values are different.  However, that assumption may
+    be invalid if either value is zero, as happens with files on Linux
+    /proc and /sys file systems. Since skipping this optimization will
+    usually cost very little (one read syscall, to read zero bytes),
+    it is fine to accommodate those unusual files.
+    * src/analyze.c (diff_2_files): Do not assume regular files differ
+    just because their st_size values differ when one or more is 0.
+    * src/diff.c (compare_files): Likewise.
+    * tests/brief-vs-proc-stat-zero: New test.
+    * tests/Makefile.am: Add it.
+    * NEWS (Bug fixes): Describe it.
+    Reported by Stephan Müller in http://debbugs.gnu.org/21942
+
+commit a1140dd45845d838401425f9a3c0af944abb5795
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Dec 6 10:38:17 2015 -0800
+
+    tests: arrange to print any skipped-test explanation to tty, too
+    
+    I noticed that when a test was skipped, the reason was not printed.
+    This fixes it.  In coreutils, this variable is set in init.cfg,
+    but there is no point in putting the definition so far from the
+    code that chooses the file descriptor number in tests/Makefile.am.
+    * tests/Makefile.am (TESTS_ENVIRONMENT) [stderr_fileno_]: Define
+    here (to 9), right next to the companion "9>&2".
+
+commit d77f95f8dcbfa6e160d74e07cbd5f7def737975e
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Nov 28 19:29:37 2015 -0800
+
+    build: add gperf to the list of required programs
+    
+    * bootstrap.conf (buildreq): Add gperf to the list.
+    Reported by Stephan Müller in http://debbugs.gnu.org/21945
+
+commit 875ca7183bd4b098f2d8fb71b10553df2d4d2d11
+Author: Giuseppe Scrivano <gscrivano@gnu.org>
+Date:   Mon Nov 2 19:05:10 2015 +0000
+
+    tests: Add tests for --color and --palette
+    
+    * tests/colors: New file.
+    * tests/Makefile.am (TESTS): Add colors.
+
+commit 0e72de47952beead69e44a4a8c9b4994992ef8ac
+Author: Giuseppe Scrivano <gscrivano@gnu.org>
+Date:   Mon Nov 2 19:03:32 2015 +0000
+
+    doc: mention --color and --palette in NEWS
+
+commit 04f6d57177fb6c9e7bbcf716c521bc323936a9a5
+Author: Giuseppe Scrivano <gscrivano@gnu.org>
+Date:   Mon Oct 19 10:29:41 2015 +0200
+
+    diff: add --palette
+    
+    * bootstrap (gnulib_modules): Add 'argmatch'.
+    * doc/diffutils.texi: Add documentation for --palette
+    * src/diff.h (set_color_palette): New prototype.
+    * src/diff.c (set_color_palette): New function.
+    (color_palette): New variable.
+    * src/utils.c: Include "argmatch.h".
+    (struct bin_str): New struct.
+    (struct color_ext_type): New struct.
+    (color_indicator): New array.
+    (indicator_name): New array.
+    (indicator_no): New enum.
+    (parse_state): New enum.
+    (put_indicator): New function.
+    (get_funky_string): New function. Copied from coreutils ls.
+    (parse_diff_color):  New function. Copied from coreutils ls
+    "parse_ls_color" function.
+    (set_color_context): Use put_indicator instead of directly
+    outputting the sequence.
+    * po/POTFILES.in: Add 'lib/argmatch.c'
+
+commit c0fa19fe92da71404f809aafb5f51cfd99b1bee2
+Author: Giuseppe Scrivano <gscrivano@gnu.org>
+Date:   Sun Mar 8 22:45:11 2015 +0100
+
+    diff: add support for --color
+    
+    * doc/diffutils.texi (diff Options): Add documentation for --color.
+    Copied from coreutils ls --color.
+    * src/context.c (pr_unidiff_hunk): Set the color context.
+    (print_context_header): Likewise.
+    (pr_context_hunk): Likewise.
+    * src/diff.h (enum colors_style): New enum to record when to use colors.
+    (colors_style): New variable to memorize the argument value.
+    (set_color_context): Add function definition.
+    * src/diff.c: : Define COLOR_OPTION.
+    (specify_colors_style): New function.
+    (longopts): Add --color.
+    (main): Handle --color argument.
+    (option_help_msgid): Add usage string for --color.
+    * src/normal.c (print_normal_hunk): Set the color context.
+    * src/side.c (print_1sdiff_line): Likewise.
+    * src/util.c (print_1_line_nl): New function.
+    (print_1_line): Make it a wrapper of 'print_1_line_nl'.
+    (colors_enabled): New boolean variable.
+    (begin_output): Call check_color_output once the output file is
+    configured.
+    (output_1_line): Periodically call `process_signals'.
+    (caught_signals): New sigset_t.
+    (colors_enabled): New boolean variable.
+    (interrupt_signal): New sig_atomic_t.
+    (stop_signal_count): New sig_atomic_t.
+    (check_color_output): New function.
+    (install_signal_handlers): Likewise. Copied from coreutils ls.
+    (process_signals): Likewise.  Copied from coreutils ls.
+    (set_color_context): New function.
+    (sighandler): Likewise.  Copied from coreutils ls.
+    (stophandler): Likewise.  Copied from coreutils ls.
+
+commit b4efca9de418c0166f0b106fef068a594b4ab483
+Author: Andreas Grünbacher <agruen@gnu.org>
+Date:   Thu Sep 24 07:36:31 2015 -0700
+
+    diff: Improve help text of option --label
+    
+    * src/diff.c (option_help_msgid): Improve help text of option --label.
+
+commit 2cd4ff3a5ff52d89b6b992d158f389b757f4faf4
+Author: Jim Meyering <meyering@fb.com>
+Date:   Mon Aug 31 23:12:43 2015 -0700
+
+    build: correct man-page generation rule
+    
+    The PATH was set incorrectly, so that the diff used by
+    help2man was the one from $PATH, rather than the just-built
+    one.
+    * man/Makefile.am (bin_dir): New variable, to...
+    (dist_man1_MANS): ...prepend ../src to PATH, not just "..".
+    Also, add a test to ensure that each $(bin_dir)/$$base is
+    executable, so this doesn't happen again.
+    In http://debbugs.gnu.org/21023, Rodrigo Valiña
+    Gutiérrez reported that diff.1 from the diffutils-3.3 tarball
+    contained no description of the then-new --no-dereference option.
+
+commit 5801f8add854c842e8065225d261f459089d7ac8
+Author: Jim Meyering <meyering@fb.com>
+Date:   Fri Jul 10 09:55:43 2015 -0700
+
+    doc: --no-dereference: improve wording/description
+    
+    * doc/diffutils.texi (Comparing Directories): Correct grammar.
+    (diff Options) [--no-dereference]: Say a little more.
+
+commit 29e8de4885e0d9f2b4fd2ed9acc09d4a41267329
+Author: Jim Meyering <meyering@fb.com>
+Date:   Thu Jan 1 22:17:39 2015 -0800
+
+    maint: update copyright year ranges to include 2015; update gnulib
+
+commit ec60c3b6d1754ad88ffd7fc2f00b72ae835f9ca8
+Author: KO Myung-Hun <komh@chollian.net>
+Date:   Tue Jul 15 11:50:53 2014 +0900
+
+    diff: skip test if seek is not possible on OS/2 kLIBC
+    
+    This fixes the problem that 'diff - file' and 'cat file | diff - file'
+    fail due to a seek failure with a message 'diff.exe: -: Invalid seek',
+    because seek does not work on stdin and a pipe on OS/2 kLIBC.
+    
+    * src/io.c (sip): Set skip_test to true if seek is not possible on
+    OS/2 kLIBC.
+
+commit ecf6a420586272e618652a33074bc38de75052dc
+Author: Jim Meyering <meyering@fb.com>
+Date:   Tue Dec 9 06:51:03 2014 -0800
+
+    gnulib: update to latest
+
+commit 3ef90a7e7cc5f318ff7b4e674d717e1cb6dc2d1d
+Author: KO Myung-Hun <komh78@gmail.com>
+Date:   Tue Dec 9 06:49:25 2014 -0800
+
+    build: double-quote use of $PATH
+    
+    * man/Makefile.am (dist_man1_MANS): On OS/2, PATH_SEPARATOR is ';',
+    but unquoted, that is interpreted as the shell's statement
+    terminator.  Quote it.
+
+commit 1fa6140faacb29e44f2d666c74529ed27b0abb5a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 27 19:53:08 2014 -0700
+
+    diff: fix integer overflow problem with --tabsize
+    
+    Reported by Tobias Stoeckmann in: http://bugs.gnu.org/18857
+    * src/diff.c (main): Don't overflow if INTMAX_MAX / 2 < tabsize.
+    * tests/bignum: New file, to test for this bug.
+    * tests/Makefile.am (TESTS): Add it.
+
+commit df3af29627a92495a740da13cb8bb0d4fcc1bf84
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 3 16:02:35 2014 -0700
+
+    doc: mention diff -B fix in NEWS
+
+commit d2fd9d4683ef60c259a3b426f71cef1b89ff383d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 3 15:58:03 2014 -0700
+
+    diff: fix bug with diff -B and incomplete lines
+    
+    Reported by Navin Kabra via Eric Blake in:
+    http://bugs.gnu.org/18402
+    * src/util.c (analyze_hunk): Don't mishandle incomplete
+    lines at end of file.
+    * tests/no-newline-at-eof: Test for the bug.
+
+commit 7bdd6479ce43d6b45803fd0bc4b363370975ceab
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 3 15:25:21 2014 -0700
+
+    diff: fix performance bug with prefix computation
+    
+    * src/io.c (find_identical_ends): Fix performance bug:
+    the test for when the prefix was needed messed up by
+    the 2002-02-28 integer-overflow fixes, causing performance to be
+    worse than it needed to be.
+
+commit b6e691277288c4e8d53b1d2577137d265008d13e
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Aug 23 14:10:20 2014 -0700
+
+    gnulib: update to latest, as well as bootstrap
+
+commit cfcba8735034e5aa4dae7fa4b3290ef25b0c3c52
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Jun 8 19:10:24 2014 -0700
+
+    maint: update copyright year range in texinfo documentation
+    
+    * doc/diffutils.texi: Update copyright.
+
+commit 667864f2844c417090149b7948052fbd757d3b48
+Author: Jim Meyering <meyering@fb.com>
+Date:   Mon Dec 23 07:06:41 2013 -0800
+
+    maint: update bug-reporting address
+    
+    * README: Change bug-gnu-utils@... to bug-diffutils@gnu.org.
+    * doc/diffutils.texi: Likewise.
+    Reported by Jamie Landeg Jones.
+
+commit f6f1b1b49c5dc1c8265f457012cdd78fe71ad4f5
+Author: Paul Eggert <eggert@penguin.cs.ucla.edu>
+Date:   Wed Mar 26 11:12:12 2014 -0700
+
+    diff: fix two "..." typos in --help output
+    
+    * src/diff.c (option_help_msgid): Remove two "..." typos (Bug#17102).
+
+commit fee3cad6b7e039e7bba524c3264f368af69396cd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 25 17:55:26 2014 -0700
+
+    doc: improve documentation about reading and stdin
+    
+    See Bug#17075.
+    * doc/diffutils.texi (Comparison): Say that files need not be read.
+    (Invoking diff): Remove confusing remark about 'diff - -'.
+    It's not that useful, and it's not portable anyway.
+
+commit ed8975e7de513e0edaf77ea3f15dcce3f39b8d97
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Feb 24 21:56:21 2014 -0800
+
+    diff, sdiff: minor integer overflow fixes
+    
+    * src/context.c (find_hunk):
+    Simplify, now that 2 * context + 1 cannot overflow.
+    * src/diff.c (main):
+    * src/sdiff.c (interact):
+    Don't rely on undefined behavior on signed integer overflow.
+    * src/diff.c (main): Don't let contexts exceed CONTEXT_MAX.
+    * src/system.h (CONTEXT_MAX): New macro.
+
+commit c26334b7df5a10a70447d762711380c693fdc2a7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Feb 24 21:38:02 2014 -0800
+
+    diff: fix bug with -I and overlapping hunks
+    
+    Problem reported by Vincent Lefevre in <http://bugs.gnu.org/16864>.
+    * src/context.c (find_hunk): Threshold is CONTEXT only if
+    the second change is ignorable.
+    * tests/ignore-matching-lines: New test.
+    * tests/Makefile.am (TESTS): Add it.
+
+commit 9b48bf3d3ed002e32fad5de5f539745bc861a104
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Feb 23 22:49:27 2014 -0800
+
+    diff: remove TOO_EXPENSIVE heuristic
+    
+    Problem reported by Vincent Lefevre in <http://bugs.gnu.org/16848>.
+    The simplest solution is to remove the TOO_EXPENSIVE heuristic
+    that I added to GNU diff in 1993.  Although appropriate for
+    circa-1993 hardware, these days the heuristic seems to be more
+    trouble than it's worth.
+    * NEWS: Document this.
+    * doc/diffutils.texi (Overview): Modernize citations.
+    Remove mention of TOO_EXPENSIVE heuristic.
+    * src/analyze.c (diff_2_files): Adjust to TOO_EXPENSIVE-related
+    API changes in gnulib's diffseq module.
+
+commit bc51e4bcb4a843998c3cd89f8c2ba00e73bb5381
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Feb 23 16:23:17 2014 -0800
+
+    build: update gnulib submodule to latest
+
+commit bc4b4b2bbf699267bab167af0484336780791953
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Jan 31 17:15:26 2014 -0800
+
+    diff: exit with status 1, not 2, when binary files differ
+    
+    Problem reported by Vincent Lefevre in <http://bugs.gnu.org/16608>.
+    * NEWS:
+    * doc/diffutils.texi (Binary, Invoking diff): Document this.
+    * src/analyze.c (briefly_report): Return void, not int.
+    All uses changed.  Do not futz with exit status.  Simplify.
+    * tests/binary: Adjust to match new behavior.
+
+commit 1875453ee6e1021d67c6856c46e7024bcecdbea8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 26 12:20:00 2013 -0700
+
+    build: omit -Wsuggest-attribute=pure for lib
+    
+    * configure.ac (WARN_CFLAGS): Omit -Wsuggest-attribute=pure
+    when compiling the lib subdirectory.  Reported for Fedora 19
+    by Eric Blake in <http://bugs.gnu.org/15463>.
+
+commit 59f4ef95f8a9c0583d1560ef447eab9d44e32cd1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Aug 22 15:45:56 2013 -0700
+
+    cmp, diff, sdiff: tune by using rawmemchr
+    
+    On my platform (AMD Phenom II X4 910e, Fedora 17 x86-64), this sped up
+    'cmp -n 8GiB /dev/full /dev/zero' by a factor of 3.8, and
+    'cmp -sn 8GiB /dev/full /dev/zero' by a factor of 1.8.
+    * bootstrap.conf (gnulib_modules): Add rawmemchr.
+    * src/cmp.c (cmp): Optimize the common case where buffers are the same,
+    by using count_newlines rather than block_compare_and_count.
+    (block_compare_and_count): Remove.
+    (count_newlines): New function.
+    * src/cmp.c (count_newlines):
+    * src/io.c (prepare_text):
+    * src/sdiff.c (lf_copy, lf_skip, lf_snarf):
+    Use rawmemchr instead of memchr, for speed.
+
+commit 9350980d5dd0d922845bcbb225207a775cf40697
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Aug 12 16:24:01 2013 -0700
+
+    cmp: tune 'cmp a b' for GCC x86
+    
+    Performance problem reported by David Balažic in:
+    http://lists.gnu.org/archive/html/bug-diffutils/2013-08/msg00013.html
+    * src/system.h (word): Make it size_t, not uintmax_t.
+    This sped up plain cmp 90% on my tests (GCC 4.8.1, x86).
+
+commit 8f248489ebcc39c9e553f749c90b4bbdf19eb5bd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Jul 6 17:41:19 2013 -0700
+
+    build: update gnulib submodule to latest
+
+commit d1d1df8e369b0f31e5e6f2784dbfa35d7ddc3647
+Author: Stefano Lattarini <stefano.lattarini@gmail.com>
+Date:   Fri May 3 12:10:32 2013 +0200
+
+    build: enable 'subdir-objects' automake option
+    
+    The future major Automake version (2.0, ETA at least one year from now)
+    might enable that option unconditionally, so better get prepared in due
+    time.
+    
+    * configure.ac (AM_INIT_AUTOMAKE): Adjust.
+    (AM_PROG_CC_C_O): New, required by Automake up to 1.13.x when the
+    'subdir-objects' is in use.
+
+commit 1280234016e4eece403b72fc69f53e13044df5ef
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Apr 28 20:48:44 2013 -0700
+
+    build: update gnulib submodule to latest
+
+commit 4825b8d70cff23f6ebe0dfa0ab181bc8401007a5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Apr 3 08:20:31 2013 -0700
+
+    diff: fix bug with Asian file names
+    
+    Problem reported by Errembault Philippe in:
+    http://lists.gnu.org/archive/html/bug-diffutils/2013-03/msg00012.html
+    * NEWS: Document this.
+    * src/dir.c (compare_names): Fall back on file_name_cmp if
+    compare_collated returns 0, unless ignoring file name case.
+    (diff_dirs): Don't bother with the O(N**2) stuff unless ignoring
+    file name case.
+    * tests/Makefile.am (TESTS): Add strcoll-0-names.
+    * tests/strcoll-0-names: New file.
+
+commit 885dfcec001ba7712257e371c4af61914c64133b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Apr 3 07:51:33 2013 -0700
+
+    diff: remove unnecessary decl
+    
+    * src/dir.c (compare_names_for_qsort): Remove declaration.
+    Not needed now that we assume C89.
+
+commit 085417c79b05afc72ef9d0333a5846da53826a8c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Apr 3 07:48:22 2013 -0700
+
+    diff: tune compare_names_for_qsort
+    
+    * src/dir.c (compare_collated): New function.
+    (compare_names): Use it.
+    (compare_names_for_qsort): Use it.  This is a bit more efficient
+    as it can avoid a double invocation of file_name_cmp when
+    file_name_cmp returns zero.
+
+commit 417363e4ce3e0195b539a4170ff0cda91400dbc8
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sat Mar 30 12:50:27 2013 -0700
+
+    doc: mention new option, --no-dereference in 3.3's NEWS
+    
+    * NEWS (New feeatures): Update 3.3's news to mention --no-dereference.
+    Reported by Denis Excoffier.
+    * Makefile.am (old_NEWS_hash): Update, since this modifies old, and
+    normally-immutable NEWS.
+
+commit 283d1b9528e193ac25018b542665ac5c0e53811f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 26 11:39:06 2013 -0700
+
+    tests: port to Solaris 10 /bin/sh
+    
+    * tests/Makefile.am (TESTS_ENVIRONMENT):
+    Use "FOO=val; export FOO" rather than "export FOO=val",
+    as the latter form doesn't work with Solaris /bin/sh.
+    Problem found when trying to run "make check" on Solaris 10.
+
+commit 36671926115bb6cd29876470afbd85cdda33b443
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Mar 24 11:09:13 2013 -0700
+
+    maint: post-release administrivia
+    
+    * NEWS: Add header line for next release.
+    * .prev-version: Record previous version.
+    * cfg.mk (old_NEWS_hash): Auto-update.
+
+commit 4544aa68fda5404835d1e0bfbfda8467d7e0d4a5
+Author: Jim Meyering <meyering@fb.com>
+Date:   Sun Mar 24 11:00:34 2013 -0700
+
+    version 3.3
+    
+    * NEWS: Record release date.
+
+commit 6e68271b694fd8fd75459f613861f66ae7b9573b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Mar 23 00:26:09 2013 -0700
+
+    doc: fix menu typo
+    
+    * doc/diffutils.texi (Comparing Three Files): Fix out-of-order menu.
+    Bug caught by Texinfo 5.0.
+
+commit 0c22f56ed7990cf02cbd2ade738944dd5ea8afd5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Mar 23 00:21:45 2013 -0700
+
+    maint: update build procedure to recent gettext etc.
+    
+    * bootstrap.conf (gnulib_modules): Add vararrays.
+    (needed_gnulib_files, unnecessary_gettext_files): New vars.
+    (bootstrap_post_import_hook): New function, to implement these vars.
+    (excluded_files): Remove; 'bootstrap' no longer supports this.
+    Its function is now performed by unnecessary_gettext_files.
+    (buildreq): Update automake to 1.12.2, to avoid CVE-2012-3386.
+    * configure.ac (AM_GNU_GETTEXT_VERSION): Bump from 0.17 to 0.18.2,
+    to lessen the probability that we'll have outlandishly old files
+    during a build.
+    * m4/vararrays.m4: Remove from repository, as we now use the
+    gnulib version.
+
+commit 90fd310a7865bf4ae695aaab0f21a9ab71f849f8
+Author: Jim Meyering <jim@meyering.net>
+Date:   Fri Mar 22 04:39:25 2013 +0100
+
+    build: update gnulib to latest and adapt; update bootstrap, too
+    
+    Blindly updating to the latest from gnulib, bootstrap would
+    fail due to failure of our local patches to apply.  Hence,
+    these first two updates.
+    * gl/lib/regex_internal.c.diff: Update offsets, so this patch
+    applies to the latest from gnulib.
+    * gl/lib/regex_internal.h.diff: Remove file.  No longer needed.
+    * bootstrap: Update from gnulib.
+
+commit b2f1e4bc555073d43b664c4389569a195ff040e3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Jan 6 08:30:39 2013 -0800
+
+    tests: port to hosts lacking fmt, make -C
+    
+    * tests/Makefile.am (built_programs): Don't assume fmt works.
+    Don't rely on 'make -C', either.
+
+commit 118d732ab2f414f9964377b4663598fa4a3ac3a6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Jan 6 08:25:05 2013 -0800
+
+    maint: update .gitignore for recent gnulib
+    
+    * .gitignore: Add tests/*.trs and several *.h and *.sed files in lib,
+
+commit 45716f1cabffe46278c22b91a6399d7970639fef
+Author: Jim Meyering <jim@meyering.net>
+Date:   Fri Jan 4 11:19:17 2013 +0100
+
+    build: update gnulib submodule to latest
+
+commit a0483cb2fc67ce559033a28e98b310e8ceaa9fd0
+Author: Jim Meyering <jim@meyering.net>
+Date:   Fri Jan 4 11:13:02 2013 +0100
+
+    maint: update all copyright year number ranges
+    
+    Run "make update-copyright".
+
+commit 01d92dba155d9ad87eaf0378876e0c67285c2075
+Author: Eric Blake <eblake@redhat.com>
+Date:   Tue Oct 23 11:06:48 2012 +0200
+
+    build: default to --enable-gcc-warnings in a git tree
+    
+    Anyone building from cloned sources can be assumed to have a new
+    enough environment, such that enabling gcc warnings by default will
+    be useful.  Tarballs still default to no warnings, and the default
+    can still be overridden with --disable-gcc-warnings.
+    * configure.ac (gl_gcc_warnings): Set default based on environment.
+
+commit 42f6244ee028dfbc535934e21028e6aa582256e7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Oct 3 21:57:21 2012 -0700
+
+    * doc/diffutils.texi (cmp Options): Document -l format better.
+
+commit 221383bcb1f9de839727b6ffd1b5a2b725314779
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Sep 10 12:18:59 2012 +0200
+
+    maint: use xasprintf in place of xmalloc+sprintf
+    
+    * bootstrap.conf (gnulib_modules): Add gnulib's xvasprintf module.
+    * src/util.c: Include "xvasprintf.h".
+    (begin_output): Use xasprintf in place of xmalloc+sprintf.
+
+commit e17295dc5529b252c269f12e081184bbde42d575
+Author: Andreas Gruenbacher <agruen@gnu.org>
+Date:   Tue Aug 14 00:30:46 2012 +0200
+
+    diff: encode file names with special characters
+    
+    * src/util.c (c_escape_char): New function.
+    (c_escape): New function.
+    (begin_output): Escape file names when needed.
+    * src/context.c (print_context_header): New names parameter.
+    (print_context_label): New name parameter.
+    * src/diff.h (print_context_header): Change prototype.
+    * tests/filename-quoting: New file.
+    * NEWS: Document this change.
+
+commit baeaa83e31da3a1a36d2a1f76140b67ff76859fe
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Aug 30 07:52:22 2012 -0700
+
+    diff: silence GCC warning instead of slowing down
+    
+    * src/dir.c (find_dir_file_pathname): Use 'IF_LINT (volatile)' to
+    silence the gcc warning, rather than using 'volatile', as the
+    warning appears to be bogus.
+
+commit f6ac439e484731a8a910bcd91e45039a3fa39c59
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Tue Aug 28 09:39:53 2012 +0200
+
+    diff: avoid possible longjmp-triggered misbehavior
+    
+    * src/dir.c (find_dir_file_pathname): gcc 4.8.0 20120825 reported
+    that a local variable's value might be clobbered.  Declare "match"
+    to be volatile.
+
+commit 6c273a4db62c4f7b0667545c31a5ad24b913598a
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Tue Aug 28 08:47:27 2012 +0200
+
+    build: update gnulib, bootstrap and init.sh to latest
+
+commit 5cb0eea638e5db4de66bcf99d9ce4f6fd974e04e
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Tue Aug 28 10:58:48 2012 +0200
+
+    maint: avoid new syntax-check failure due to @xref use
+    
+    * doc/diffutils.texi: Change several "; @xref{..." to ".  @xref{...",
+    since @xref should start a sentence.
+
+commit 1f281b36801627601f8a92f26e8ac6a0a7e36526
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue May 15 14:01:53 2012 -0700
+
+    maint: remove ms subdirectory
+    
+    diffutils is now designed to build with Cygwin or MinGW.
+    The old DJGPP stuff probably doesn't work anyway.
+    * Makefile.am (SUBDIRS): Remove ms.
+    * NEWS: Document this.
+    * configure.ac (AC_CONFIG_FILES): Remove ms/Makefile.
+    * ms/Makefile.am, ms/README, ms/config.bat, ms/config.sed:
+    * ms/config.site: Remove.
+
+commit bca6d67e3f92b9c358e96098d7cd9b841dc16604
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon May 14 23:24:49 2012 -0700
+
+    maint: update bootstrap from gnulib
+    
+    * bootstrap: Update from gnulib.
+
+commit 3549f733b9cd2c7fd5dd1e4a273151e2da01a00b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon May 14 23:07:13 2012 -0700
+
+    main: port subcommands to mingw
+    
+    Problem reported by Eli Zaretskii in
+    <http://lists.gnu.org/archive/html/bug-gnu-utils/2012-05/msg00013.html>.
+    Approach suggested by Bruno Haible as option (4) in
+    <http://lists.gnu.org/archive/html/bug-gnu-utils/2012-05/msg00036.html>.
+    * bootstrap.conf (gnulib_modules): Add system-quote.
+    * src/diff3.c, src/sdiff.c, src/util.c:
+    Include <system-quote.h>, not <sh-quote.h>.
+    * src/diff3.c (read_diff):
+    * src/sdiff.c (main, edit):
+    * src/util.c (begin_output):
+    Use system_quote_argv, for portability to Mingw.
+    * src/sdiff.c (NUM_SIGS, handler_index_of_SIGINT): Now enum
+    values, not macros; this is cleaner and avoids a GCC warning if
+    !HAVE_WORKING_VFORK.
+    * src/util.c (begin_output) [! HAVE_WORKING_FORK]: Do not use -f,
+    for consistency with the HAVE_WORKING_FORK code.
+
+commit de512b8345de9d501b21a5c1bc446e28d50ebf8c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon May 14 22:13:21 2012 -0700
+
+    maint: update bootstrap from gnulib
+    
+    * bootstrap: Update from gnulib.
+
+commit 98985d32063135ab0e584fafb6e9edcf45869ec9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon May 14 22:12:21 2012 -0700
+
+    maint: m4/gnulib-cache.m4 is not under version control
+    
+    This is like what coreutils does, and suppresses 'git status' chatter.
+    * .gitignore: Add /m4/gnulib-cache.m4.
+
+commit e537e2c86632dca0ba3abe2b6e2d7d7cac189b2c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun May 13 19:30:56 2012 -0700
+
+    Use binary mode when testing for binary files.
+    
+    This reverts the 2006-01-05 change and modernizes to the current API.
+    Idea suggested by Eli Zaretskii in:
+    http://lists.gnu.org/archive/html/bug-gnu-utils/2012-05/msg00066.html
+    * src/cmp.c (main):
+    * src/diff.c (main, compare_files):
+    Use set_binary_mode rather than SET_BINARY.
+    * src/diff.c (compare_files): Omit unnecessary use of O_BINARY.
+    * src/io.c (sip): Sample unknown files in binary mode, to see
+    whether they are binary.
+    (read_files): Read binary files in binary mode.
+
+commit aa7a1de25ab798fc7c45a68df41556b1f9f17fb2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon May 14 10:10:21 2012 -0700
+
+    build: update gnulib submodule to latest
+
+commit 5f295d6115179216d13b78a768c97e873f493da9
+Author: Stefano Lattarini <stefano.lattarini@gmail.com>
+Date:   Sun May 13 19:46:30 2012 -0700
+
+    build: omit obsolete AM_PROG_CC_STDC macro
+    
+    The Automake-provided macro 'AM_PROG_CC_STDC' has been superseded by
+    the Autoconf-provided one 'AC_PROG_CC' since October 2002, and will
+    be removed in the next major automake version.
+    * configure.ac (AM_PROG_CC_STDC): Drop it.
+
+commit 3c19ca08b1cf7aaaae72393073affaa082928ae4
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat May 5 15:51:25 2012 +0200
+
+    diff: fix a typo that was always disabling the same_special_file macro
+    
+    * src/system.h (same_special_file): Correct cpp guard expression:
+    s/HAVE_ST_RDEV/HAVE_STRUCT_STAT_ST_RDEV/.  Reported by Eli Zaretskii.
+
+commit 6cb7786fd85a503bfcbe8f28dd34a92902736825
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Jan 26 12:25:27 2012 +0100
+
+    maint: update bootstrap from gnulib
+    
+    * bootstrap: Update from gnulib.
+
+commit 2f108d7405ab121ebbec88ee9865bac8657f7218
+Author: Eric Blake <eblake@redhat.com>
+Date:   Wed Mar 7 09:13:10 2012 -0700
+
+    usage: improve wording of --ignore-matching-lines
+    
+    * src/diff.c (option_help_msgid): Tweak wording.
+
+commit c7560370da8ff0d7b48b75989b8f46cb619fbfd8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Mar 4 13:19:55 2012 -0800
+
+    doc: explain -I RE better in --help output
+    
+    * src/diff.c, src/sdiff.c (option_help_msgid): For -I RE,
+    change "whose lines all match" to "all whose lines match" to avoid
+    unintended interpretation.  Reported by Danijel Tasov in
+    <http://bugs.debian.org/648411>.
+
+commit b2892140d83cbc05881440a2fdbc13bb24b6cd76
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Feb 12 13:08:26 2012 -0800
+
+    sdiff: remove dependency on sigprocmask
+    
+    * bootstrap.conf (gnulib_modules): Remove sigprocmask.
+    * src/sdiff.c (temporary_file): No need to invoke sigprocmask
+    here, since the signal handler merely sets a flag.
+
+commit 7f2f4bb36593c0d2ed3284b3b8be2951fa6d5008
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Feb 4 22:10:40 2012 -0800
+
+    diff: -N, --unidirectional-new-file now compare to "-" too
+    
+    * NEWS: Document this.
+    * doc/diffutils.texi (Comparing Directories): Likewise.
+    Also, document that these options work at the top level.
+    * src/diff.c (compare_files): Treat EBADF like ENOENT, to handle
+    the case where "-" is closed.  Allow the other file to be
+    STDIN_FILENO, in case it's "-".
+    * tests/Makefile.am (TESTS): Add new-file.
+    * tests/new-file: New file.
+
+commit 62ca21c8c1a5aa3488589dcb191a4ef04ae9ed4f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Jan 25 23:46:16 2012 -0800
+
+    maint: quote 'like this' or "like this", not `like this'
+    
+    This is in response to a recent change in the GNU coding standards,
+    which now suggest quoting 'like this' or "like this", instead of
+    `like this' or ``like this''.
+    * HACKING, NEWS, README, README-hacking, TODO, doc/diagmeet.note:
+    * doc/diffutils.texi, ms/config.bat, ms/config.site:
+    * src/analyze.c, src/cmp.c, src/context.c, src/diff.c:
+    * src/diff.h, src/diff3.c, src/dir.c, src/ifdef.c, src/io.c:
+    * src/sdiff.c, src/side.c, src/system.h, src/util.c:
+    * tests/help-version:
+    Quote 'like this' or "like this" in commentary.
+    * cfg.mk (old_NEWS_hash): Adjust to reflect new NEWS quoting.
+    * man/help2man: Update to 1.40.4 version, with quoting fixed as above.
+    * po/en.po: Remove translation involving `, as it's no longer needed.
+    * src/cmp.c (try_help, specify_ignore_initial, usage, main):
+    * src/diff.c (main, try_help, option_help_msgid, specify_value)
+    (compare_files):
+    * src/diff3.c (main, try_help, option_help_msgid, usage)
+    (read_diff):
+    * src/dir.c (compare_names):
+    * src/sdiff.c (try_help, usage, check_child_status, main):
+    * src/util.c (finish_output):
+    * tests/help-version:
+    Quote 'like this' in output.
+
+commit 70eafb8038cb866ca62ef96ff4dda217d408ce7e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Jan 25 16:11:46 2012 -0800
+
+    build: update gnulib submodule to latest
+
+commit 301a23cdbba22ad208e4014d277eb8eb600d2d0e
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Jan 12 13:57:05 2012 +0100
+
+    build: accommodate newer bootstrap from gnulib
+    
+    * bootstrap.conf (gnulib_tool_option_extras): Add both --symlink
+    and --makefile-name=gnulib.mk.  Also remove now-obsolete $bt/ prefix.
+    * bootstrap: Update from gnulib.
+    * tests/init.sh: Update from gnulib.
+    * lib/Makefile.am: Initialize numerous variables, so that
+    generated code in gnulib.mk may use += to append to them.
+
+commit 6e51ccfb4eccfdb6672e69c982723f633fb0f099
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Jan 12 14:04:17 2012 +0100
+
+    maint: avoid new syntax-check failure
+    
+    * src/diff.c (compare_files): Use STREQ, not strcmp.
+
+commit e3324651cc1f9f116754a4713e08bfb0bac50150
+Author: Bruno Haible <bruno@clisp.org>
+Date:   Sat Jan 7 00:57:29 2012 +0100
+
+    New option --no-dereference.
+    
+    * src/diff.h (no_dereference_symlinks): New variable.
+    * src/diff.c: Include xreadlink.h.
+    (longopts): Add --no-dereference option.
+    (main): Accept --no-dereference option.
+    (option_help_msgid): Mention the --no-dereference option.
+    (compare_files): If no_dereference_symlinks is true, use lstat()
+    instead of stat(). Compare symbolic links by comparing their values.
+    * bootstrap.conf (gnulib_modules): Add lstat, stat, xreadlink.
+    * doc/diffutils.texi (Comparing Directories, diff Options): Mention the
+    --no-dereference option.
+    * tests/no-dereference: New file.
+    * tests/Makefile.am (TESTS): Add it.
+
+commit 45110a7927df633cb3235d4fee3d84b0b6d26a96
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Jan 1 09:32:41 2012 +0100
+
+    maint: update all copyright year number ranges
+    
+    Run "make update-copyright".
+
+commit c88c3b6b2ae94bf5d72a04dd4fb797cb386fcb07
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Dec 14 14:28:47 2011 +0100
+
+    build: update to latest gnulib and adapt
+    
+    * tests/binary: Reverse arguments to compare to avoid failure of
+    new syntax-check rule.
+    * configure.ac: Use -Wno-format-nonliteral.
+    Mark functions as pure of const, per recommendations enabled by
+    new gcc -W options.  Use _GL_ATTRIBUTE_PURE and _GL_ATTRIBUTE_CONST.
+    * lib/cmpbuf.h (buffer_lcm, block_compare):
+    Apply pure and/or const attributes.
+    * src/cmp.c (block_compare): Likewise.
+    * src/context.c (find_hunk): Likewise.
+    * src/diff.h (lines_differ): Likewise.
+    * src/diff3.c (skipwhite): Likewise.
+    * src/dir.c (dir_loop): Likewise.
+    * src/util.c (find_change, find_reverse_change): Likewise.
+    (translate_line_number): Likewise.
+
+commit 439286a937c2ae02374e0389ed2ccd91240a8bd8
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Dec 14 14:27:28 2011 +0100
+
+    build: stop distributing gzip'd releases;  xz is enough
+    
+    * configure.ac (AM_INIT_AUTOMAKE): Add no-dist-gzip.
+
+commit 31b43733d40d0a919e0af013f48e271f5824200e
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Tue Nov 29 17:11:59 2011 +0100
+
+    tests: use "compare exp out", not "compare out exp"
+    
+    Likewise, when an empty file is expected, use "compare /dev/null out",
+    not "compare out /dev/null". I.e., specify the expected/desired contents
+    via the first file name.  Prompted by a suggestion from Bruno Haible
+    in http://thread.gmane.org/gmane.comp.gnu.grep.bugs/4020/focus=29154
+    
+    Run these commands:
+    
+      git grep -l -E 'compare [^ ]+ exp' \
+        |xargs perl -pi -e 's/\b(compare) (\S+) (exp\S*)/$1 $3 $2/'
+      git grep -l -E 'compare [^ ]+ /dev/null' \
+        |xargs perl -pi -e 's,\b(compare) (\S+) (/dev/null),$1 $3 $2,'
+    
+    But manually convert this one:
+    
+      -compare out exp-$(echo $opt|tr ' ' _)
+      +compare exp-$(echo $opt|tr ' ' _) out
+    
+    and avoid an inappropriate change to cfg.mk.
+
+commit 5e2baecb26cede9f42456da9593bd0f15af823bb
+Author: Stefano Lattarini <stefano.lattarini@gmail.com>
+Date:   Wed Oct 12 11:11:23 2011 +0200
+
+    tests: use more portable fd redirection in TESTS_ENVIRONMENT
+    
+    * tests/Makefile.am (TESTS_ENVIRONMENT): Redirection with `exec 9>&2'
+    is not portable to various Korn shells, and to (at least) HP-UX 11
+    /bin/sh.  Use a more portable idiom.
+    See http://thread.gmane.org/gmane.comp.gnu.coreutils.bugs/22488 for
+    lots of discussion.
+
+commit 366adeb73d80cbe8ed4b730c46ed7864cf10eb73
+Author: Stefano Lattarini <stefano.lattarini@gmail.com>
+Date:   Mon Oct 10 20:30:21 2011 +0200
+
+    tests: make test runner a script, not a shell function
+    
+    All the test scripts in the diffutils testsuite are shell scripts,
+    so the current definition of TESTS_ENVIRONMENT, which adaptively
+    run tests using either perl or the shell depending on their kind,
+    is an overkill.
+    
+    Moreover, this change is required in order for the testsuite to
+    continue to work with the new testsuite harness that is planned
+    to be introduced in Automake 1.12 (which, as of the writing date,
+    is still under development and in late alpha state).
+    
+    See also related discussion on bug-coreutils:
+     <http://debbugs.gnu.org/cgi/bugreport.cgi?bug=8887>
+    
+    * tests/Makefile.am (TESTS_ENVIRONMENT): Remove definition of the
+    `shell_or_perl_' shell function, which is not required anymore.
+    (LOG_COMPILER): New, define to `$(SHELL)'.
+    * tests/binary: Make executable.
+    * tests/colliding-file-names: Likewise.
+    * tests/excess-slash: Likewise.
+    * tests/no-newline-at-eof: Likewise.
+
+commit 7508234eabe646abcea074baea83612f8115d3b9
+Author: Claudio Bley <claudio.bley@gmail.com>
+Date:   Sun Sep 4 18:01:57 2011 +0200
+
+    portability: use SET_BINARY rather than xfreopen (NULL, ...
+    
+    * src/diff.c: Include binary-io.h, not xfreopen.h.
+    (main): Use SET_BINARY (...) rather than xfreopen (NULL, X, ...),
+    because the latter doesn't work on MinGW and crashes using MSVC.
+    * src/cmp.c (main): Likewise.
+
+commit 11ef88af927a4591aa54bc86814c0ed11b6025be
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Tue Oct 4 13:40:21 2011 +0200
+
+    build: update gnulib submodule to latest
+
+commit 57a09576e8d344c2e694ece0fc3335ca8e058edd
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Sep 2 17:21:07 2011 +0200
+
+    post-release administrivia
+    
+    * NEWS: Add header line for next release.
+    * .prev-version: Record previous version.
+    * cfg.mk (old_NEWS_hash): Auto-update.
+
+commit 8f14bb909569036fe580cd639df08225f5f4e93c
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Sep 2 17:18:34 2011 +0200
+
+    version 3.2
+    
+    * NEWS: Record release date.
+
+commit e2ed9d279b1a9933a4225a1c952aa5c9d50b4c69
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Sep 2 14:16:04 2011 +0200
+
+    build: update bootstrap and tests/init.sh from gnulib
+    
+    * bootstrap: Update from gnulib.
+    * tests/init.sh: Likewise.
+
+commit 783eca9655c2bdcae547b290909493c0a16bf598
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Sep 2 00:36:24 2011 +0200
+
+    build: update gnulib submodule to latest
+
+commit 77bcc326cc252e8c4b453000a0174320dc565cd7
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Sep 1 10:13:26 2011 +0200
+
+    doc: diffutils' texi-derived doc may now be in debian's "main" section
+    
+    * NEWS (Packaging): Mention the "no front/back-cover" change.
+
+commit 320355d6d4a7cbaf15a34341131e506fff8e41c2
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Aug 15 07:27:14 2011 +0200
+
+    maint: avoid new "make sytnax-check" failure.
+    
+    * src/diff.h (find_dir_file_pathname): Mark declaration with "extern"
+    keyword, in order to placate the tight-scope syntax check.
+
+commit 8739d45f721feb3d05d75f5ca0afda4bacea635b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Aug 14 22:08:16 2011 -0700
+
+    * src/io.c (find_and_hash_each_line): Refactor for brevity.
+
+commit 86a40dd6acc84e5633d2fc6b45f9193fe01b23f8
+Author: Roland McGrath <roland@hack.frob.com>
+Date:   Sun Aug 14 14:37:01 2011 -0700
+
+    diff, sdiff: new option --ignore-trailing-space (-Z)
+    
+    Derived from Roland McGrath's patch (dated June 2004!) in:
+    http://lists.gnu.org/archive/html/bug-gnu-utils/2004-07/msg00000.html
+    * NEWS:
+    * doc/diffutils.texi (White Space, Blank Lines)
+    (sdiff Option Summary, diff Options, sdiff Options): Document -Z.
+    * src/diff.h (IGNORE_TRAILING_SPACE)
+    (IGNORE_TAB_EXPANSION_AND_TRAILING_SPACE): New constants, for -Z.
+    * src/diff.c (shortopts, longopts, main, option_help_msgid):
+    * src/sdiff.c (longopts, option_help_msgid, main):
+    * src/io.c (find_and_hash_each_line):
+    * src/util.c (lines_differ, analyze_hunk): Support -Z.
+
+commit efb0557f4cd63628957880ffbf63702b604e0ae2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Aug 13 15:11:19 2011 -0700
+
+    * bootstrap.conf (gnulib_modules): Remove timegm.
+    
+    This fixes a problem noted by Andreas Schwab in:
+    http://lists.gnu.org/archive/html/bug-diffutils/2011-08/msg00035.html
+
+commit 70febebfe5215674079dc1c65ad966f5e404d2a8
+Author: Tim Waugh <twaugh@redhat.com>
+Date:   Sat Aug 13 13:16:32 2011 -0700
+
+    diff: --ignore-file-name-case now applies at top level too
+    
+    Derived from Tim Waugh's patch in:
+    http://lists.gnu.org/archive/html/bug-diffutils/2011-08/msg00034.html
+    * NEWS, doc/diffutils.texi (diff Options): Document this.
+    * src/diff.c (compare_files): Implement this, by using
+    find_dir_file_pathname.
+    * src/diff.h (find_dir_file_pathname): New decl.
+    * src/dir.c: Include filenamecat.h.
+    (find_dir_file_pathname): New function.
+
+commit e3001b775aa8a3e7e30651b0f59d401ac4fe419d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Aug 13 11:28:57 2011 -0700
+
+    * .gitignore: Add lib/unistr, lib/unused-parameter.h.
+
+commit 1e340def247d7b11fe18da3a959bfeabd93d52b4
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Aug 10 12:38:04 2011 +0200
+
+    post-release administrivia
+    
+    * NEWS: Add header line for next release.
+    * .prev-version: Record previous version.
+    * cfg.mk (old_NEWS_hash): Auto-update.
+
+commit 78524ae4ba5a726844d06b9eb24c6844c84a4c52
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Aug 10 12:33:36 2011 +0200
+
+    version 3.1
+    
+    * NEWS: Record release date.
+
+commit 3edb801c061779b8245557f14072e8b5681986f7
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Aug 10 10:20:06 2011 +0200
+
+    build: use largefile module and update to latest gnulib
+    
+    * configure.ac: Remove AC_SYS_LARGEFILE, subsumed by ...
+    * bootstrap.conf (gnulib_modules): ...this.  Use largefile module.
+    * gnulib: Update to latest.
+
+commit 8832cf045d62a4a40e6df948e6cf8b85485653a0
+Author: Santiago Vila <sanvila@unex.es>
+Date:   Mon Aug 8 17:59:46 2011 +0200
+
+    doc: insert comma in --help line for --ignore-space-change (-b)
+    
+    * src/diff.c (option_help_msgid): Insert omitted comma between
+    "-b" and "--ignore-space-change".  (tiny change)
+
+commit 789252980fa8ef3d804372cd347898aa5c2ec7fe
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Aug 4 18:59:29 2011 +0200
+
+    doc: relax restriction on front-cover and back-cover texts
+    
+    * doc/diffutils.texi (copying): Relax restriction on front-cover
+    and back-cover texts (just as m4 did here:
+    http://git.savannah.gnu.org/cgit/m4.git/commit?id=ee1e92ec).
+    Reported by Santiago Vila.  Fix suggested by Eric Blake.
+
+commit c06794dacf66868840ea4818352929eabeec09c2
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Aug 3 18:07:33 2011 +0200
+
+    tests: update init.sh from gnulib
+    
+    * tests/init.sh: Update from gnulib.
+
+commit 1ce0b3604b88aa6ba07b7ff5c0201224465307f1
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Aug 3 14:22:24 2011 +0200
+
+    build: update gnulib submodule to latest
+
+commit 01fc077bbfea22f0759400b45bf6a04b840ee2e4
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Jul 3 22:44:26 2011 +0200
+
+    maint: remove inclusion of unused header, for "make syntax-check"
+    
+    * src/diff3.c: Don't include <inttostr.h>.  Not used.
+    * src/context.c: Likewise.
+
+commit c8b5b09d1393139ba443e7e239cfa6a9c3e92258
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Jun 19 17:15:26 2011 +0200
+
+    build: don't require perl when building from a tarball
+    
+    But do ensure -- in all other circumstances -- that the man/*.1
+    files are rebuilt whenever the version number changes.
+    * configure.ac (SRC_VERSION_C): Define.
+    * man/Makefile.am (dist_man1_MANS): Rename from $(man1_MANS),
+    so that we distribute those pesky man/*.1 files.
+    (EXTRA_DIST): Reflect name change.
+    (MAINTAINERCLEANFILES): Define this, not DISTCLEANFILES,
+    now that these generated files are distributed.
+    ($(dist_man1_MANS)): Depend on $(SRC_VERSION_C), so we get the
+    full dependency when not building from a tarball.
+
+commit e783a23b1944d89405342f5d6a09dba26c192005
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Jun 13 09:17:26 2011 +0200
+
+    doc: do not distribute generated man/*.1 man files
+    
+    * man/help2man: New file.
+    * man/Makefile.am: Use $(srcdir)/help2man.
+    Convert $(dist_man1_MANS) to $(man1_MANS), to tell automake
+    not to distribute the generated man/*.1 files.  Now they're
+    generated at build-from-tarball time.
+    ($(man1_MANS)): Depend on version.c, so that man pages are
+    regenerated whenever the version string changes.
+
+commit 7faccb437cb0c08c52ac061db66e9e028bd690a7
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Jun 12 11:24:57 2011 +0200
+
+    build: ccache works better without embedded version strings
+    
+    * src/Makefile.am: Generate version.c and version.h and put the
+    new symbol in a tiny library to be used by each program.
+    (LDADD): Add the new library.
+    * src/cmp.c (main): Use Version, not PACKAGE_VERSION, so the .o
+    file does not change with each commit-derived version increment.
+    * src/diff.c (main): Likewise.
+    * src/diff3.c (main): Likewise.
+    * src/sdiff.c (main): Likewise.
+    * src/system.h: Include "version.h".
+    * .gitignore: Add version.[ch]
+
+commit 929cf564727acb17435e98b6d05e9d6453f10808
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Jun 12 10:14:22 2011 +0200
+
+    doc: ensure each program has a man/*.x file: add "SEE ALSO" references
+    
+    * man/cmp.x: New file.
+    * man/diff3.x: New file.
+    * man/sdiff.x: New file.
+    * man/diff.x: Add xrefs to the other three programs, and to patch.
+    * man/Makefile.am (EXTRA_DIST): List new files.
+    (cmp.1, diff3.1, sdiff.1): Depend on each .x file.
+
+commit df0a31f6110b14cce7d1b3fa5a48a38d603a4e12
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Jun 11 14:06:10 2011 +0200
+
+    doc: rename diff.texi to diffutils.texi
+    
+    This makes the .texi basename the same as the package name,
+    which is consistent with most other GNU packages.
+    * doc/diffutils.texi: Rename from...
+    * doc/diff.texi: ...removed.
+    * doc/Makefile.am (info_TEXINFOS): Reflect name change.
+    (diffutils_TEXINFOS): Likewise.
+    * cfg.mk (gendocs_options_): Remove this customization.  It is no
+    longer needed, now that the .texi name matches that of the package.
+    * man/Makefile.am ($(dist_man1_MANS)): Remove now-unnecessary sed
+    filter.
+    * README: Update references to diffutils.texi etc. here, too.
+    * .gitignore: Update here, too.
+    Suggested by Karl Berry.
+
+commit a2b10ab0d6f8f11c380fdb1dedd920dfa1359a90
+Author: Karl Berry <karl@freefriends.org>
+Date:   Wed Jun 8 13:00:23 2011 +0000
+
+    cmp, diff, diff3, sdiff: edit and align --help text.
+    
+    * cmp.c (option_help_msgid, usage),
+    * diff.c (option_help_msgid, usage),
+    * diff3.c (option_help_msgid, usage),
+    * sdiff.c (option_help_msgid, usage): align descriptions in the --help
+    output and slightly edit content.
+
+commit de65c25dc103b7f4b18e0c3116c31ff7fc6d4726
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri May 27 23:38:40 2011 -0700
+
+    diff: don't use locales after local-specific sorting fails
+    
+    * src/dir.c (compare_names): Don't invoke strcasecmp if
+    locale-specific sorting fails, because POSIX.1-2008 says strcasecmp
+    has unspecified behavior outside the POSIX locale.  See:
+    http://lists.gnu.org/archive/html/bug-diffutils/2011-05/msg00008.html
+
+commit a3318fdbca6002d524f063ab5e98e7e59295d2a2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri May 27 23:34:08 2011 -0700
+
+    bootstrap: Avoid multithreading.
+    
+    * bootstrap.conf (gnulib_tool_option_extras):
+    Add "--avoid=localename --avoid=lock", because we don't want to
+    bring in the multithreading code that recent gnulib changes would
+    otherwise bring in.
+    (excluded_files): Remove m4/lock.m4; no longer needed, now that
+    we use --avoid=lock.
+
+commit 1850ea03ac1d72a4f686143463af22d2377a9f24
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri May 27 21:32:38 2011 -0700
+
+    build: update gnulib submodule to latest
+
+commit 0b7299f98e9ce4e10cc595414e1505f239022e36
+Author: Karl Berry <karl@gnu.org>
+Date:   Mon May 23 09:41:48 2011 -0700
+
+    maint: update README-hacking
+    
+    * README-hacking: Update a la coreutils for git, etc.
+
+commit 91d850a78b100bf78c9f77abf38c0369b877f597
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon May 23 19:20:05 2011 +0200
+
+    maint: update gnulib to latest with accompanying tight-scope tweaks
+    
+    * cfg.mk: Include $(srcdir)/dist-check.mk using "-include",
+    to accommodate the new sc_tight_scope rule.
+    (_gl_TS_extern): Define, to tell gnulib's tight_scope rule that
+    headers here mark externs with "XTERN".
+    * gnulib: Update to latest.
+
+commit 39213a3bbcfd86c1629c06507bfc4a761f71dbc7
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Apr 29 20:04:14 2011 +0200
+
+    maint: use gnulib's new readme-release module
+    
+    * bootstrap.conf (gnulib_modules): Add readme-release.
+    (bootstrap_epilogue): Add the recommended perl one-liner.
+    * README-release: Remove file; it is now generated from gnulib.
+    * .gitignore: Add it.
+
+commit 167d1e3125e596479dd994ebc29b833e9fd7e825
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed May 18 20:31:36 2011 +0200
+
+    build: update gnulib submodule to latest
+
+commit a531a3cff268a51848b029b3d6ba67b37a8d91ce
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun May 8 22:19:23 2011 +0200
+
+    maint: prepare for the tight-scope check
+    
+    * src/diff.h: Mark function declarations with "extern" in
+    preparation for the tight-scope check.
+    (ignore_white_space): Separate enum decl from declaration
+    of this variable.
+    * src/Makefile.am (diff_SOURCES): Move diff.h from here to ...
+    (noinst_HEADERS): ...here.
+    For convenience, since the tight-scope rule uses $(noinst_HEADERS).
+
+commit 0744f3339d691dbce47e5e0c9ca8652ff8f79f0b
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri May 13 11:12:33 2011 +0200
+
+    maint: don't use now-removed gnulib "exit" module
+    
+    * bootstrap.conf (gnulib_modules): Remove "exit" module.
+    It no longer exists.
+
+commit 7d638238a2f3e419948a92024fb67739c61894ce
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Mar 26 13:45:52 2011 +0100
+
+    build: update gnulib submodule to latest
+
+commit 8a223056984c0153638e33e074cf334a32b3fd97
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Mar 26 13:44:13 2011 +0100
+
+    * .x-sc_space_tab: Remove file.  Instead, ...
+    
+    * cfg.mk (exclude_file_name_regexp--sc_space_tab): ...define this.
+
+commit d9d3cf9f096df7c11c4453b8453f53eda53939fa
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Mar 26 12:46:26 2011 +0100
+
+    maint: fix typo in unused rule
+    
+    * cfg.mk (config-save): Fix typo: add leading "_" in variable name.
+
+commit 23d970ea5f71fc8913d7e2a4d33b575b13b43fb9
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Mar 18 22:38:59 2011 +0100
+
+    doc: add a reference to wdiff(1) from diff.1
+    
+    * man/diff.x: New file, to add "SEE ALSO" reference to wdiff(1).
+    * man/Makefile.am (diff.1): Depend on diff.x.
+    ($(dist_man1_MANS)): Tell help2man to include diff.x.
+    (EXTRA_DIST): Add diff.x.
+    Suggestion from Dan Jacobson in http://bugs.debian.org/613319
+
+commit ffd622a2814e9f9d66ab3077d93107ff2f7266df
+Author: Eric Blake <eblake@redhat.com>
+Date:   Fri Mar 18 15:26:59 2011 -0600
+
+    docs: info should mention -L
+    
+    * doc/diff.texi (diff Options): Document -L.
+
+commit c549fc6c777f025a303c9f980f360a644affd65e
+Author: Eric Blake <eblake@redhat.com>
+Date:   Fri Mar 18 15:19:37 2011 -0600
+
+    docs: diff --help should mention -L
+    
+    * src/diff.c (option_help_msgid): Document -L.
+
+commit 3f2d868741b500a9817a62e3cab12a24c6615a76
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Feb 14 09:39:44 2011 +0100
+
+    doc: speak of the --test (-a) option, not "the -a or --test option"
+    
+    Convert using this command:
+    perl -pi -e \
+      's/(\@option{-.}) or (\@option{--.*?}) option/$2 ($1) option/' \
+      doc/diff.texi
+    Then convert some more with this:
+    perl -pi -e \
+        's/the (\@option{-.}) or (\@option{--.*?})$/the $2 ($1)/' \
+      doc/diff.texi
+    Then convert more manually.
+    
+    Suggested by Dan Jacobson
+
+commit 91da1da696e1d13ab7e288ede04d03fd2d12e79a
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Jan 24 12:27:32 2011 +0100
+
+    maint: remove all uses of vfork: use fork instead
+    
+    Our use of vfork now provokes warnings from gcc-4.6.0.
+    Also, vfork is no longer even specified by POSIX.1-2008.
+    * src/diff3.c (read_diff): Change each use of vfork to "fork".
+    Remove #ifdef'd code.
+    * src/util.c (begin_output, finish_output): Likewise.
+    * src/sdiff.c (cleanup, main, edit): Likewise.
+    (handler_index_of_SIGPIPE): Remove now-unused definition.
+    * src/system.h: Don't include <vfork.h>.
+    (vfork): Remove definition.
+    * ms/config.site: Remove reference to vfork cache variable.
+
+commit 4e0d3664c7a1a7515309b140dbf8ff27538423cf
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Jan 24 16:32:00 2011 +0100
+
+    tests: avoid newer but less-portable tail option syntax
+    
+    * tests/function-line-vs-leading-space: Use sed -n '3,$p' rather than
+    tail -n+3.  Older versions of tail do not accept that newer syntax.
+    Reported by Sudhakara Peram.
+
+commit bf4003c13d75c927f5f616b2c38eef7c3d7e28c4
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Jan 24 13:36:17 2011 +0100
+
+    tests: fix an erroneous test
+    
+    On most systems, like-named files were compared, by luck.
+    However, on others, different-named files would be compared
+    since their names were being treated as equal -- but they had
+    different content, so the test would fail.
+    * tests/colliding-file-names: Use different sets of file names
+    in d1 and d2 so that they cannot accidentally match.
+    Put the same line in each test file.  This is required
+    when files named e.g., abc and ABC are compared.
+    This test was failing on a NixOS 86_64-darwin system.
+
+commit 7e27c1ae467d2b2d611668abcd2e86f650a2d453
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Jan 24 12:34:49 2011 +0100
+
+    build: update gnulib submodule to latest
+
+commit 13b0958f25f67ad1d759105921650243dfbe648c
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Jan 24 12:13:16 2011 +0100
+
+    tests: fix typo that silently disabled all tests
+    
+    * tests/Makefile.am (TESTS): Fix typo: s/jESTS/TESTS/
+
+commit c16c3176840de5a153186aa9f981453cac25451f
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Jan 23 18:58:27 2011 +0100
+
+    build: update gnulib submodule to latest
+
+commit 9de94f53b5b63330b7658f3b63d06021aabfc7c6
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Jan 23 18:57:50 2011 +0100
+
+    maint: avoid new syntax-check failure
+    
+    * src/diff.c (specify_value): Use !STREQ(...), not strcmp(...) != 0.
+    * src/diff3.c (main): Likewise.
+
+commit ce5367b6b3e4df909883f41f3ad6f12981f5a263
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Jan 3 22:08:42 2011 +0100
+
+    maint: update copyright year ranges to include 2011
+    
+    Run "make update-copyright", so "make syntax-check" works in 2011.
+
+commit 7f0be31391ce956341690c85a060a541a02f8480
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Jan 3 22:04:45 2011 +0100
+
+    build: update gnulib submodule to latest
+
+commit 6fc3b9737d71c149b5198d957e993d620632d360
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Dec 16 10:05:21 2010 -0800
+
+    bootstrap: adjust to recent gnulib changes
+    
+    * bootstrap.conf (excluded_files): Do not exclude m4/size_max.m4
+    and m4/xsize.m4 when using an external gettext, since they are
+    now needed by other gnulib modules.
+
+commit 5c65882affa003bab8b21c6f1cdfa038d51b5ca6
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Dec 16 15:20:24 2010 +0100
+
+    doc: add contributor guidelines: HACKING
+    
+    * HACKING: New file, copied 99% from the one in grep's repository.
+
+commit 9026760882adce9e2a000cb9f64d3b2a2de410cc
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Oct 9 15:24:05 2010 +0200
+
+    maint: describe policy on copyright year number ranges
+    
+    * README: Mention coreutils' long-standing policy on use of M-N
+    ranges in copyright year lists.  Requested by Richard Stallman.
+
+commit 361b3b13da25366256745b7cce4ff71231ef24e9
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Sep 4 09:08:08 2010 +0200
+
+    maint: adjust init.sh use to conform
+    
+    * tests/help-version: Use one line: "${srcdir=.}/init.sh"; ...
+    * tests/basic: Likewise.
+    * tests/binary: Likewise.
+    * tests/colliding-file-names: Likewise.
+    * tests/excess-slash: Likewise.
+    * tests/function-line-vs-leading-space: Likewise.
+    * tests/help-version: Likewise.
+    * tests/label-vs-func: Likewise.
+    * tests/no-newline-at-eof: Likewise.
+    * tests/stdin: Likewise.
+
+commit d5d4b828b46628977ec5b75d731649c65f8e1bf2
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Sep 4 09:04:43 2010 +0200
+
+    maint: avoid shadowing warning
+    
+    * src/dir.c (diff_dirs): Rename shadowed local cmp to "c".
+
+commit edf0032df445a519b503f72147fa3f846983df56
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Sep 4 08:55:48 2010 +0200
+
+    build: use gettext-h, not gettext
+    
+    * bootstrap.conf (gnulib_modules): Use gettext-h, not gettext.
+    The latter is overkill for a package that uses
+    AM_GNU_GETTEXT([external]...
+
+commit 0d0c959471b898f18166f65dcb164c7b602a416c
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Sep 4 08:54:18 2010 +0200
+
+    build: update build/test tools from gnulib
+    
+    * bootstrap: Update from gnulib.
+    * tests/init.sh: Likewise.
+
+commit 0ffe188b2bc56ebeb54dcefbb24d64849f20df1b
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Sep 4 08:53:28 2010 +0200
+
+    build: update gnulib submodule to latest
+
+commit 53de393ca335e77f22d3789100734c87868f12b3
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Aug 14 17:13:28 2010 -0500
+
+    diff -r: avoid printing excess slashes in concatenated file names
+    
+    * bootstrap.conf (gnulib_modules): Add filenamecat.
+    * src/diff.c: Include "filenamecat.h".
+    (compare_files): Use file_name_concat, rather than dir_file_pathname.
+    * src/util.c (dir_file_pathname): Remove now-unused function.
+    * src/diff.h: Remove its declaration.
+    * tests/excess-slash: New script to test for this.
+    * tests/Makefile.am (TESTS): Add it.
+    Forwarded by Santiago Vila from <bugs.debian.org/586301a>,
+    reported by Jari Aalto.
+
+commit f2ad578b241713fa81d98b3573fa42397d2ea3f8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Aug 12 17:55:05 2010 -0700
+
+    diff: avoid spurious diffs when two distinct dir entries compare equal
+    
+    Problem reported by Christoph Anton Mitterer in:
+    http://lists.gnu.org/archive/html/bug-diffutils/2010-08/msg00000.html
+    
+    * NEWS: Mention this bug fix.
+    * src/dir.c (compare_names_for_qsort): Fall back on file_name_cmp
+    if two distinct entries in the same directory compare equal.
+    (diff_dirs): Prefer a file_name_cmp match when available.
+    * tests/Makefile.am (TESTS): New test colliding-file-names.
+    * tests/colliding-file-names: New file.
+
+commit a0e9e5e67a6a34e131eb392ddb99569bc973748e
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun May 9 19:09:26 2010 +0200
+
+    build: update gnulib submodule to latest
+
+commit bec2cfcd8f73c81219a0f348718b01766e274621
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun May 9 18:39:39 2010 +0200
+
+    build: don't define macros that gnulib provides
+    
+    * bootstrap.conf (gnulib_modules): Add signal, stdint.
+    * lib/cmpbuf.c (SA_RESTART, SA_INTERRUPT): Remove definitions.
+    (SIZE_MAX, PTRDIFF_MAX): Likewise.
+    Include <stdint.h>.
+    * src/system.h (WEXITSTATUS, WIFEXITED): Remove definitions.
+    (SA_RESTART, SA_INTERRUPT): Likewise.
+
+commit 6ef1f1f7086021b90c81636de26373c3fe472e5c
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun May 9 18:34:09 2010 +0200
+
+    build: rely on gnulib's sigprocmask module
+    
+    * src/sdiff.c: Remove #if-!HAVE_SIGPROCMASK-guarded code.
+    * bootstrap.conf (gnulib_modules): Add sigprocmask.
+
+commit 6cfdf0ab03ce32dad30460e8fd00e7ecc9db5a7b
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Tue May 4 09:55:31 2010 +0200
+
+    doc: README-release: don't mention To:, Cc:, etc announcement headers,
+    
+    now that those are supplied automatically via gnulib's maint.mk.
+    * README-release: sync with coreutils.
+
+commit 40adeecffd03ad56e3ed0054c9ee9f31a86397dd
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon May 3 23:16:56 2010 +0200
+
+    maint: teach web-doc-generating code how to do its job
+    
+    * cfg.mk (gendocs_options): Define, so that gendocs.sh knows
+    the name of our texinfo source file.
+    * gnulib: Update to latest, for new gnu-web-doc-update and maint.mk.
+
+commit e7616f6408417cca7df49c4b030047757b856d88
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon May 3 20:35:06 2010 +0200
+
+    doc: update release procedure
+    
+    * README-release: Rearrange slightly: post the announcement to
+    Savannah first, so you can include a link to that post in the email.
+    Sync a few details from coreutils' README-release.
+
+commit d03317ad6abccf98a0c6fb0f9ffb9509feee1965
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon May 3 18:52:56 2010 +0200
+
+    post-release administrivia
+    
+    * NEWS: Add header line for next release.
+    * .prev-version: Record previous version.
+    * cfg.mk (old_NEWS_hash): Auto-update.
+
+commit 022cd5c5eb647a22a4daa5fe5cbc10af6d5a1112
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon May 3 18:49:55 2010 +0200
+
+    version 3.0
+    
+    * NEWS: Record release date.
+
+commit ee02ef075faaab2feb61a5f4a6120e11517dac8d
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon May 3 08:53:31 2010 +0200
+
+    build: update gnulib submodule to latest
+
+commit 3f027ba48d26ebca62066845832e12062a1ed8b2
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat May 1 08:17:06 2010 +0200
+
+    build: use gnulib's sys_wait module
+    
+    * bootstrap.conf (gnulib_modules): Use gnulib's sys_wait module,
+    now that we assume its presence.
+
+commit 5c63f4d41638b863f5c5a71401af6e1c042d223d
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Apr 30 18:46:27 2010 +0200
+
+    build: update gnulib submodule to latest
+    
+    * bootstrap: Also update from gnulib.
+    * tests/init.sh: Likewise
+
+commit 7ea9bf381b354cbf5e05ab89e0ee2009162bc09a
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Apr 30 18:56:03 2010 +0200
+
+    maint: remove now-useless #if HAVE_HEADER_H guards
+    
+    * src/system.h: Include <sys/wait.h> unconditionally,
+    now that gnulib guarantees its presence.
+    * lib/cmpbuf.c: Likewise for <unistd.h> and <inttypes.h>.
+
+commit 59669066e7771fa01912e4c2081ad80aa78d3f68
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Apr 17 08:21:32 2010 +0200
+
+    tests: use original no-newline-at-eof test, but with -U1, not -U2
+    
+    * tests/no-newline-at-eof: Revert to the smaller test, but with
+    -U1 rather than -U2, since that actually triggers the bug.
+
+commit 4ba438168d7508853e4be9f74ad6d95ac024a20a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 16 22:20:04 2010 -0700
+
+    Followon improvements for the fix for Debian bug 577832.
+    
+    * src/io.c (find_and_hash_each_line): Omit the inserted newline in
+    a simpler way.
+    * tests/no-newline-at-eof: Fix the test case so that it rejects
+    the old, buggy behavior.
+
+commit 16e65488ddd26fe0ad3f8d8ebd30709c9291e6dd
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Apr 16 11:18:10 2010 +0200
+
+    build: update gnulib submodule to latest
+
+commit 6bb3d2900866c23da01a409aa3447ecf68627fc1
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Apr 16 09:14:04 2010 +0200
+
+    tests: test for the no-newline-at-EOF bug
+    
+    * tests/no-newline-at-eof: New file.
+    * tests/Makefile.am (TESTS): Add it.
+
+commit f444711a2639b4974ff3e720c455a1f96f1109e8
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Apr 15 23:26:22 2010 +0200
+
+    diff: fix a regression when at least one input lacks a newline-at-EOF,
+    
+    and the final hunk plus context-length aligns exactly with the end
+    of the newline-lacking file.  Diff would fail to output the required
+    "\ No newline at end of file" line, thus rendering the output invalid.
+    This bug appears to have been introduced by 2006-05-07
+    commit 58d0483b, "(find_identical_ends): Fix huge performance bug...",
+    at least to the extent that reverting that change fixes the bug.
+    Considering the stated effect of that change and lack of metrics,
+    reverting it is not an option, so here we take a more direct approach.
+    
+    Given these inputs,
+    
+        printf '\n1'>a; printf '\n0\n\n1'>b
+    
+    and running diff like this:
+    
+        ./diff -U1 a b
+    
+    for input file "b", the pointer, files[1].linbuf[4][-1], to
+    the last byte on the final line was mistakenly pointing at the
+    sentinel newline at EOF, rather than at the preceding byte.
+    
+      (gdb) p files[1].linbuf[4][-1]
+      $3 = 10 '\n'
+    
+    Thus, this test in the final print_1_line call:
+    
+      if ((!line_flag || line_flag[0]) && limit[-1] != '\n')
+        fprintf (out, "\n\\ %s\n", _("No newline at end of file"));
+    
+    would fail, because limit[-1] (which is files[1].linbuf[4][-1])
+    was mistakenly '\n', rather than the desired '1'.
+    
+    My first thought was simply to adjust the final linbuf[line] setting,
+    at the end of io.c's find_and_hash_each_line function function:
+    
+           if (p == bufend)
+    -       break;
+    +       {
+    +         if (current->missing_newline)
+    +           --linbuf[line];
+    +         break;
+    +       }
+    
+    But that would make diff misbehave with this input
+    (same as above, but with a newline appended to "a"),
+    
+        printf '\n1\n'>a; printf '\n0\n\n1'>b
+        ./diff -U1 a b
+    
+    due to the block (100 lines above) that is triggered in that case
+    (but not in the both-files-missing-newline case):
+    
+          if (p == bufend
+              && current->missing_newline
+              && ROBUST_OUTPUT_STYLE (output_style))
+            {
+              /* This line is incomplete.  If this is significant,
+                 put the line into buckets[-1].  */
+              if (ignore_white_space < IGNORE_SPACE_CHANGE)
+                bucket = &buckets[-1];
+    
+              /* Omit the inserted newline when computing linbuf later.  */
+              p--;
+              bufend = suffix_begin = p;
+            }
+    
+    Note how "p" is decremented and "bufend" adjusted.
+    When that happens, we certainly don't want to decrement
+    "bufend" yet again.
+    
+    Since there is no other way to determine at the end whether "bufend"
+    was already decremented, add a new variable to serve as witness.
+    
+    * NEWS (Bug fixes): Mention it.
+    Reported by Timo Juhani Lindfors in http://bugs.debian.org/577832.
+    Forwarded by Santiago Vila.
+
+commit 648802169a29ea096d6e9813b043b91af9342f8d
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Apr 16 08:47:28 2010 +0200
+
+    tests: update init.sh from gnulib
+    
+    * tests/init.sh: Update from gnulib.
+
+commit 4065b154b0eda7aa100bcd0a905b0f4304fbacfd
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Apr 8 11:04:15 2010 +0200
+
+    build: include cfg.mk and dist-check.mk in the distribution tarball
+    
+    * Makefile.am (EXTRA_DIST): Add cfg.mk and dist-check.mk.
+
+commit 70a02578aebbc3f0fd6edea240d5c1e9e76101e3
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Apr 8 11:02:32 2010 +0200
+
+    maint: update to latest gnulib
+    
+    * cfg.mk (sc_cross_check_PATH_usage_in_tests): Remove rule,
+    now that it's in gnulib's maint.mk.
+    * gnulib: Update to latest.
+
+commit 0c6d7eea33394375e0e794e72c7896508645f426
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Apr 7 11:43:14 2010 +0200
+
+    tests: make new PATH-crosschecking syntax-check tighter
+    
+    * cfg.mk (sc_cross_check_PATH_usage_in_tests): Use grep's -x (match
+    entire line) option with -F.
+
+commit fe2d46d4aaa79e15d2df24ae387c032858982c3f
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Apr 7 10:59:00 2010 +0200
+
+    tests: pull latest help-version from gzip
+    
+    * tests/help-version: Update from gzip.
+    * Makefile.am (TESTS_ENVIRONMENT): Export VERSION,
+    as required for this new help-version script.
+
+commit 46773b6abbfd75432387a6e28579a11c62e897d9
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Apr 7 10:51:19 2010 +0200
+
+    tests: add syntax-check rule to verify that tests use proper PATH
+    
+    * cfg.mk (sc_cross_check_PATH_usage_in_tests): New rule, that is
+    useful only in conjunction with the help-version script.
+
+commit 55cf264a2bac21ed6b8729bc175df421e35facf4
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Apr 7 10:56:06 2010 +0200
+
+    tests: use path_prepend_ consistently; remove unnecessary VERBOSE check
+    
+    * tests/basic: Likewise.
+    * tests/binary: Likewise.
+    * tests/function-line-vs-leading-space: Likewise.
+    * tests/label-vs-func: Likewise.
+    * tests/stdin: Likewise.
+
+commit eb7d0cc49110157fe0a7820f39cb052371af2699
+Author: Eric Blake <eblake@redhat.com>
+Date:   Tue Apr 6 10:11:35 2010 -0600
+
+    maint: ignore generated files
+    
+    * .gitignore: Ignore recent gnulib additions.
+
+commit a7784f93efeb7609159de1217d43231a9f7a7f2f
+Author: Eric Blake <eblake@redhat.com>
+Date:   Tue Apr 6 10:03:29 2010 -0600
+
+    maint: update to latest bootstrap
+    
+    * bootstrap: Copy from gnulib/build-aux.
+
+commit adc5cf557b1f56c8ed1aff907ca3e9abf344ce86
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Apr 5 22:08:58 2010 +0200
+
+    tests: get latest init.sh from gnulib
+    
+    * tests/init.sh: Update from gnulib.
+
+commit c5b10cdca91e438acc819b0cde4ea694ce52d3d2
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Apr 5 21:47:17 2010 +0200
+
+    build: update gnulib submodule to latest; adapt
+    
+    * cfg.mk (local-checks-to-skip): Add new sc_texinfo_acronym, to skip it.
+
+commit eb8258b8c6b3930e06fc20b02456448c43daeff1
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Mar 18 18:10:29 2010 +0100
+
+    diff -F/-p: don't depend on locale-specific white-space definition
+    
+    * src/context.c: Include "c-ctype.h".
+    Use c_isspace, not isspace.
+
+commit f21d1195aef067e6459cca8a1b79a50498a10532
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Mar 18 17:25:50 2010 +0100
+
+    tests: exercise new behavior of -F RE
+    
+    * tests/function-line-vs-leading-space: New file.
+    * tests/Makefile.am (TESTS): Add it.
+
+commit 24cc227fa1900502d167a60a8325af576dfe5552
+Author: Yannick Moy <yannick.moy@adacore.com>
+Date:   Thu Mar 4 14:20:16 2010 +0100
+
+    with -F or -p, emit better function lines: no leading white space
+    
+    * src/diff.c (print_context_function): For languages like Ada
+    that allow local functions and procedures, the plain context
+    function line may start with enough blank characters that the
+    function name does not get completely printed in the 40
+    characters limit.  This patch solves this problem by removing
+    these useless initial blank characters.
+    * NEWS (Changes in behavior): Mention this change.
+
+commit d9c2b10e33c2fd073a10e7770c859c16001592f9
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Mar 17 16:53:17 2010 +0100
+
+    build: don't require a specific version of help2man
+    
+    * bootstrap.conf (buildreq): Bootstrap can't deal with it,
+    perhaps because the command name contains a digit.
+
+commit 61fb56b31483ae1c3d483ce099d3468697d37a75
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Mar 17 15:52:05 2010 +0100
+
+    build: make bootstrap ensure that help2man is available
+    
+    * bootstrap.conf (buildreq): Add help2man.
+
+commit 1afa8038498155d2666c387547dd2c8c44ca718e
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Tue Feb 23 09:39:07 2010 +0100
+
+    tests: test for the "Binary files A and B differ" diagnostic
+    
+    * tests/binary: New script.
+    * tests/Makefile.am (TESTS): Add it.
+
+commit 3f591f4bb5776b4fc91573b940a9d845458cc617
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Feb 18 12:59:29 2010 +0100
+
+    revert 2002 change that removed "Binary " from "files A and B differ"
+    
+    With this change, "printf '\0'|diff - /dev/null" now prints
+    "Binary files - and /dev/null differ" once again.
+    This reverts 2002-06-28 commit a352f0980,
+    "(briefly_report): Don't say "Binary files differ", ...".
+    * src/analyze.c (briefly_report): Do include the "Binary " prefix
+    in the diagnostic, when !brief.
+    * NEWS (Changes in behavior): Mention the diagnostic change.
+    Reported by Andreas Hoenen in http://bugs.debian.org/570064.
+
+commit aa56d5f6d086855785d2fe83d148cf090eabee80
+Author: Juan Manuel Guerrero <juan.guerrero@gmx.de>
+Date:   Sun Feb 14 18:16:25 2010 +0100
+
+    avoid compilation failure on systems lacking both fork and vfork
+    
+    * src/sdiff.c [!HAVE_WORKING_FORK && !HAVE_WORKING_VFORK] (main):
+    Pass the right number of arguments to shell_quote_copy.
+    * src/util.c [!HAVE_WORKING_FORK && !HAVE_WORKING_VFORK] (begin_output):
+    Likewise.
+
+commit 9999d0b8dff45ef3b093e9addebf4ff1b464d9fc
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Feb 11 11:09:01 2010 +0100
+
+    post-release administrivia
+    
+    * NEWS: Add header line for next release.
+    * .prev-version: Record previous version.
+    * cfg.mk (old_NEWS_hash): Auto-update.
+
+commit 66f2f2d60ab2bd66c820e255f2ce8bfdcaca34a9
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Feb 11 10:45:20 2010 +0100
+
+    version 2.9
+    
+    * NEWS: Record release date.
+
+commit fecd0079fe6e15b0f53bf953721d838d9099bf05
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Feb 11 09:06:02 2010 +0100
+
+    doc: document the release procedure
+    
+    * README-release: New file.
+
+commit 9f735dd16ab54550329f2fad357d816f7438e7d0
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Feb 10 11:37:23 2010 +0100
+
+    maint: change use of "|" to more maintainable "||" (no semantic change)
+    
+    * src/analyze.c (diff_2_files): Using the "||" operator happens to
+    be equivalent to using "|" in this case.  It is also clearer and
+    less prone to inadvertent bug introduction, in case the variable,
+    "changes" were ever to take on a value not in {0,1}.
+    Patch by Tim Waugh, via Mike Frysinger.
+
+commit b50a16567acff496bdf3ac0004809b6dcc88c2d6
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Feb 10 09:09:55 2010 +0100
+
+    portability: avoid "diff - ..." failure at least on *BSD and Solaris
+    
+    The new "stdin" test was failing on many types of systems.
+    * src/diff.c (compare_files): Guard use of xfreopen (NULL, "rb", ...
+    also with O_BINARY, so as to avoid this unnecessary call on
+    systems where it's not needed (on some it fails with "Bad address".
+
+commit b22f6671d773e326fdc9c4b096a5c056c6cd0509
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Feb 10 08:55:59 2010 +0100
+
+    tests: honor VERBOSE
+    
+    * tests/basic: Enable "set -x" if $VERBOSE.
+    * tests/help-version: Likewise.
+    * tests/label-vs-func: Likewise.
+    * tests/stdin: Likewise.
+
+commit a1dcb61f03265e69a0ebd4f09deb45af3e1a56b9
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Feb 5 07:46:44 2010 +0100
+
+    build: update gnulib submodule to latest
+
+commit 3c0aac1e7efa0410e913c9a5b936e5759c63901f
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Feb 4 20:02:06 2010 +0100
+
+    sync with gnulib
+    
+    * gl/lib/regcomp.c.diff: Adjust to apply to the latest in gnulib.
+    * gnulib: Update submodule to latest.
+
+commit 6bb67138079e8ef3457ee1fa07cebcb78b6049d6
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Jan 17 11:39:00 2010 +0100
+
+    build: do not override gnulib-provided AM_CFLAGS options
+    
+    Avoid a warning from automake:
+    lib/Makefile.am:23: AM_CFLAGS multiply defined in condition TRUE ...
+    lib/gnulib.mk:30: ... `AM_CFLAGS' previously defined here
+    lib/Makefile.am:18:   `lib/gnulib.mk' included from here
+    
+    * lib/Makefile.am (AM_CFLAGS): Append $(WARN_CFLAGS) and
+    $(WERROR_CFLAGS), i.e., use "+=", not "=".
+    This was introduced via 2009-12-17 commit e58efa5b
+    "build: enable warnings and -Werror.",
+    but fortunately is not a bug, because the definition
+    it would have overridden was always empty.
+
+commit f51320402bf1342d47199f7dfe37add89092ee5b
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Jan 17 11:15:26 2010 +0100
+
+    maint: add to .gitignore
+    
+    * .gitignore: Ignore more.
+
+commit ef2251a3e5fa8bdf667cf38a9d9cbca38db1137b
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Jan 16 08:32:06 2010 +0100
+
+    doc: add to TODO
+    
+    * TODO: Add an item, suggested by Dan Jacobson.
+
+commit 07e844a96ddecc1702b847ce95d956409a75de46
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Jan 13 13:54:13 2010 +0100
+
+    tests: ensure that an argument of "-" is treated as standard input
+    
+    * tests/stdin: New test.
+    * tests/Makefile.am (TESTS): Add it.
+
+commit 2d648ae3fe10d9b554f7c2c5ee8c84371e687392
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Jan 10 11:45:20 2010 +0100
+
+    tests: now "make distcheck" runs more tests, incl. syntax-check
+    
+    * cfg.mk: Include dist-check.mk, from coreutils.
+    * Makefile.am (distcheck-hook): Define rule, to hook to...
+    * dist-check.mk: New file.
+
+commit 617600b42265557a2d3be46e6277697ec47df90d
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Jan 9 11:48:53 2010 +0100
+
+    build: update gnulib to latest, for fixed syntax-check rule
+
+commit a5188c6f727aa4abeb414950179a27da4a2e0142
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Jan 9 11:18:46 2010 +0100
+
+    maint: record updated NEWS hash
+    
+    * cfg.mk (old_NEWS_hash): Update to account for GFDL change.
+
+commit a9d7c6d1a52970f26741f6af4cf873730ad50c2a
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Jan 8 11:35:26 2010 +0100
+
+    build: update gnulib submodule to latest
+
+commit 4e1233f063e4c3e5421cd28245b96f2607a7038b
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Jan 9 11:05:59 2010 +0100
+
+    tests: add a test of basic functionality
+    
+    * tests/basic: Start adding tests.
+    * tests/Makefile.am (TESTS): Add it.
+
+commit cadd497e2759a208c3512b9c8c6c7fb61c5fbb22
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Jan 8 11:34:43 2010 +0100
+
+    maint: udpate GFDL license to 1.3
+    
+    * doc/diff.texi: Update to use GFDL version 1.3.
+
+commit cb251009d3ca44aca9934d87ab3a2af1c0e66f90
+Author: Eric Blake <ebb9@byu.net>
+Date:   Sat Jan 2 10:17:00 2010 -0700
+
+    build: allow compilation on cygwin
+    
+    * src/Makefile.am (cmp_LDADD): Move LIBICONV...
+    (LDADD): ...into global flags, since all programs need it.
+
+commit b20ae152dd435cd10b7bb207a948616d6b6332fd
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Jan 3 18:54:21 2010 +0100
+
+    maint: record update-copyright options for this package
+    
+    * cfg.mk: Next time, just run "make update-copyright".
+
+commit a6b73e6dd7a293316f669a8930198d140df6236b
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Jan 3 18:39:19 2010 +0100
+
+    tests: prepend ../src, not "." to PATH
+    
+    * tests/help-version: Correct PATH.
+
+commit 6a44886e245da5862051080a6c7938dd1f0a3fc3
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Jan 1 16:18:27 2010 +0100
+
+    maint: update all FSF copyright year lists to include 2010
+    
+    Use this command:
+    git ls-files |grep -vE '^(\..*|COPYING|gnulib)$' |xargs \
+    env UPDATE_COPYRIGHT_USE_INTERVALS=1 build-aux/update-copyright
+
+commit 10d11122eaa135104737d462015d48041c304f1d
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Dec 31 17:20:42 2009 +0100
+
+    maint: newer gnulib; don't hard-code my GPG key ID
+    
+    * cfg.mk (gpg_key_ID): Remove definition, now that maint.mk automates it.
+    * gnulib: Update to latest.
+
+commit 9fe26edf840736d3c4d6c89005b3a0c860444d4c
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Nov 28 19:36:01 2009 +0100
+
+    tests: exercise diff -p's function-name matching
+    
+    * tests/label-vs-func: New file.
+    * tests/Makefile.am (TESTS): Add label-vs-func.
+    Reported by Simon Arlott <simon@fire.lp0.eu>
+    http://article.gmane.org/gmane.linux.kernel.janitors/14260
+
+commit e0fc06c5ce4e7c370ae2366b35c5952023c537fe
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Nov 28 19:31:46 2009 +0100
+
+    tests: use gnulib's init.sh
+    
+    * tests/Makefile.am (EXTRA_DIST): Add init.sh.
+    Remove test-lib.sh.
+    * tests/init.sh: New file.
+    * tests/test-lib.sh: Remove file.
+    * tests/help-version: Use init.sh, not test-lib.sh.
+
+commit 37abff282fc5adb392653c7a11e56bb733a672e6
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Nov 28 19:43:28 2009 +0100
+
+    maint: don't let trailing spaces in diffs perturb make syntax-check
+    
+    * .x-sc_space_tab: New file.
+
+commit e58efa5bd2f2fdab0aff6395b9d6c46e0db09fd3
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Nov 21 17:45:33 2009 +0100
+
+    build: enable warnings and -Werror.
+    
+    * src/Makefile.am (AM_CFLAGS): Enable warnings and -Werror.
+    Set to this: $(WARN_CFLAGS) $(WERROR_CFLAGS)
+    * lib/Makefile.am (AM_CFLAGS): Similarly, but use this:
+    $(GNULIB_WARN_CFLAGS) $(WERROR_CFLAGS)
+    * configure.ac (GNULIB_WARN_CFLAGS): Don't turn off -Wuninitialized.
+
+commit 8c3d25a63a2c5912170ef6e13f748f3904e6b5cf
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sun Nov 22 17:06:57 2009 +0100
+
+    build: avoid a warning from gnulib's sh-quote.c
+    
+    * gl/lib/sh-quote.c.diff: New file, to avoid a warning.
+
+commit f4bde95cc1eb6d36629163797a04d698d6e3b483
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Nov 21 18:08:00 2009 +0100
+
+    maint: avoid warnings via patched versions of gnulib's regex functions
+    
+    * gl/lib/regcomp.c.diff: New file.
+    * gl/lib/regex_internal.c.diff: Likewise.
+    * gl/lib/regex_internal.h.diff: Likewise.
+    * gl/lib/regexec.c.diff: Likewise.
+
+commit f8435aeffe78d4090828937f9bedfc8290f1c1e9
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Nov 21 19:33:01 2009 +0100
+
+    build: update gnulib submodule to latest
+
+commit 4c048db1c7f64e937ae58593158714d48545fbb5
+Author: Eric Blake <ebb9@byu.net>
+Date:   Fri Nov 20 14:55:05 2009 -0700
+
+    build: ignore more files
+    
+    * .gitignore: Add config.cache, *.exe.
+    
+    Signed-off-by: Eric Blake <ebb9@byu.net>
+
+commit e5b1ef85fbc034ffc5f3a0c18fa2917fba42ec89
+Author: Eric Blake <ebb9@byu.net>
+Date:   Thu Nov 19 09:15:28 2009 -0700
+
+    build: fix test run on cygwin
+    
+    This, plus a gnulib update for xalloc-die-tests, are necessary
+    for make check to pass on cygwin.
+    
+    * tests/Makefile.am (built_programs): Ignore $(EXEEXT).
+    * src/Makefile.am (paths.h): Add missing dependency.
+
+commit 25742fce0a76d714d6f0669610cff0804ff90895
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Nov 20 22:49:00 2009 +0100
+
+    maint: remove vestiges of nanosleep
+    
+    * src/Makefile.am (LDADD): Remove $(LIB_NANOSLEEP), now
+    that we no longer use the nanosleep module.
+    Spotted by Eric Blake.
+
+commit e90c254a0ebafd26a0ea07e2ec3867c539947f63
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Nov 20 22:30:41 2009 +0100
+
+    maint: don't pull in gnulib's nanosleep unnecessarily
+    
+    * bootstrap.conf (gnulib_modules): Remove nanosleep.  Not needed.
+    Spotted by Eric Blake.
+
+commit 3f7fe0297caa17a2acdc97a30896dd8963b1def4
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Nov 20 17:07:47 2009 +0100
+
+    maint: cfg.mk: remove factored-out ftp host/dir definitions
+    
+    * cfg.mk (gnu_ftp_host-alpha, gnu_ftp_host-beta gnu_ftp_host-stable):
+    (gnu_rel_host, url_dir_list): Remove definitions.  The defaults,
+    now provided by maint.mk, are the same.
+    * gnulib: Update for latest, including those maint.mk additions.
+
+commit 2fe6784a3507be4fc1ae9d78eb5b8c6d6f759ae6
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Nov 20 10:36:54 2009 +0100
+
+    build: link with now-required libraries
+    
+    * src/Makefile.am (LDADD): Add gnulib-required libraries.
+    (cmp_LDADD): Add $(LIBICONV), for cmp's use of proper_name_utf8.
+
+commit 4fe5ec326f4a09060ec30097cef9ba8b547f69d5
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Nov 20 10:26:48 2009 +0100
+
+    maint: lib/xfreopen.c contains translatable strings
+    
+    * po/POTFILES.in: Add lib/xfreopen.c.
+
+commit 788645f184922bce1d9851c4fd2f193458935046
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Nov 20 09:58:45 2009 +0100
+
+    maint: remove hard-coded macro definitions provided by intprops.h
+    
+    * lib/cmpbuf.c: Include "intprops.h" rather than open-coding macros
+    like TYPE_SIGNED and TYPE_MINIMUM.
+
+commit 3b828e32235ebe162ec2093e56e0e0dd778b6e71
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Nov 19 20:35:52 2009 +0100
+
+    maint: add gnulib's announce-gen module
+    
+    * bootstrap.conf (gnulib_modules): Add announce-gen
+
+commit 975a1e0418b41f95f67efa7fa5a5db7c8432632d
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Nov 19 18:51:53 2009 +0100
+
+    build: suppress warnings about bindtextdomain and textdomain
+    
+    * src/system.h (bindtextdomain, textdomain) [!ENABLE_NLS]: Define away.
+
+commit 7ebb24620d87386e5579bef6ff0e50778dff84be
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Nov 19 18:10:56 2009 +0100
+
+    build: use more gnulib modules
+    
+    * bootstrap.conf (gnulib_modules): Add mktime, nanosleep, strptime
+    and timegm.
+
+commit cd10d2c30801df4abf60dd0fb54ddd4a2f9fc02a
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Nov 19 16:09:56 2009 +0100
+
+    use xfreopen rather than freopen
+    
+    * src/cmp.c: Include "xfreopen.h".
+    Use xfreopen in place of freopen.
+    * src/diff.c Likewise, and...
+    (main): Set exit_failure to EXIT_TROUBLE, rather than to 2.
+    * src/diff3.c: Likewise.
+    * bootstrap.conf (gnulib_modules): Add xfreopen.
+
+commit 163f2fa3e873d2dfebce2c41abc8532a9fa370f9
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Nov 19 15:39:47 2009 +0100
+
+    build: enable many warnings
+    
+    * configure.ac: Add support for --enable-gcc-warnings.
+    * bootstrap.conf (gnulib_modules): Add manywarnings.
+    * Makefile.am (AM_CFLAGS): Add $(WARN_CFLAGS) $(WERROR_CFLAGS)
+
+commit 3eee17bbbe3798d91b9e36f5756b0de391eb61d5
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Nov 20 10:20:31 2009 +0100
+
+    build: update gnulib submodule to latest
+
+commit d837c269eac591b4fedf58deba84e00f3c6c334c
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Nov 19 19:43:46 2009 +0100
+
+    maint: add an assertion to suppress clang-detected warning
+    
+    The clang static analyzer reported that a NULL parent could be
+    dereferenced.  However, that cannot happen, because for all callers,
+    the parameter, parent, is always non-NULL at that point.
+    * src/diff.c: Include <assert.h>.
+    Assert that parent is not NULL.
+
+commit 7af115552a637d96a98ddd17353c6e7f94e137b4
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Nov 19 19:40:11 2009 +0100
+
+    maint: remove dead assignment from diff3.c
+    
+    * src/diff3.c (make_3way_diff): Remove dead assignment.
+
+commit 6be63587089728ac8dd140781ae586fb314d9ac4
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 18 07:41:04 2009 +0100
+
+    build: update gnulib submodule to latest
+
+commit 2514ec69733ac7491cd80b9e4710034e6218a134
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Nov 16 21:49:37 2009 +0100
+
+    maint: hide build commands behind $(AM_V_GEN)
+    
+    * src/Makefile.am (paths.h): Use $(AM_V_GEN), and split a long line.
+    * man/Makefile.am ($(dist_man1_MANS)): Use $(AM_V_GEN) here, too.
+
+commit a401664d47f17b1c7497c2a251b073de105cdbec
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Nov 16 21:41:38 2009 +0100
+
+    build: let automake generate better man-installation rules
+    
+    * man/Makefile.am (dist_man1_MANS): Rename from dist_man_MANS,
+    to enable better automake-generated installation rules.
+
+commit 5f93400251fb7be08fa03ef7c2dd78b4850481ba
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Nov 16 17:15:38 2009 +0100
+
+    admin: ignore all of gnulib-tests
+    
+    * .gitignore: Add gnulib-tests
+
+commit 8fbbf26925a6e2183be8211fb82a6eb518229a38
+Author: Eric Blake <ebb9@byu.net>
+Date:   Thu Nov 12 08:17:56 2009 -0700
+
+    build: avoid link failure when libsigsegv is used
+    
+    * src/Makefile.am (LDADD): Link against LIBSIGSEGV.
+
+commit 9b0a630024092f50d6c94d9d033c02dd5bdd6a5b
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Nov 16 09:01:57 2009 +0100
+
+    maint: define/use PROGRAM_NAME and AUTHORS; use propername module
+    
+    * bootstrap.conf (gnulib_modules): Add propername.
+    * src/cmp.c (PROGRAM_NAME, AUTHORS): Define.
+    (main): Use them in use of version_etc.
+    * src/diff.c (PROGRAM_NAME, AUTHORS, main): Likewise.
+    * src/diff3.c (PROGRAM_NAME, AUTHORS, main): Likewise.
+    * src/sdiff.c (PROGRAM_NAME, AUTHORS, main): Likewise.
+    * src/system.h: Include "propername.h".
+
+commit b60091684ac415bcc6efaaedc42d31dedd378a75
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Nov 16 08:58:54 2009 +0100
+
+    maint: no longer define *_FILENO constants
+    
+    * src/system.h (STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO):
+    Remove definitions.  Now guaranteed by gnulib.
+
+commit 3850429db6a8582ae5f1d43fb92dd29ee9af261e
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Nov 16 08:17:35 2009 +0100
+
+    maint: bug-diffutils@gnu.org is the new bug-reporting address
+    
+    * configure.ac (AC_INIT): Use bug-diffutils@..., not bug-gnu-utils
+    as the bug-reporting address.
+    * NEWS (Administrivia): Mention this.
+    * src/cmp.c (usage): Remove hard-coded address.
+    Instead, use gnulib's emit_bug_reporting_address function.
+    * src/diff.c (usage, option_help_msgid): Likewise.
+    * src/diff3.c (usage): Likewise.
+    * src/sdiff.c (usage): Likewise.
+
+commit 943b8a4383375c4eb197b4e984d5bca89790c5b0
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Mon Nov 16 07:38:03 2009 +0100
+
+    sdiff, diff3: exec diff, not $(bindir)/diff
+    
+    * src/Makefile.am (paths.h): Emit a definition of DEFAULT_DIFF_PROGRAM
+    that is simply "diff" (or whatever $(transform) would convert that to,
+    e.g., "gdiff").  This makes it so that tests can work without first
+    installing diff, and so that the binaries do not hard-code $(prefix).
+    * NEWS (Changes in behavior): Mention this.
+
+commit e454c1471aaf8b3e6bead2313838aefebfe97bca
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Sat Nov 14 10:31:41 2009 +0100
+
+    tests: add the first script; hook up gnulib-tests
+    
+    * configure.ac (AC_CONFIG_FILES): Add tests/Makefile and
+    gnulib-tests/Makefile.
+    * tests/help-version: New file, from coreutils.
+    * tests/test-lib.sh: Likewise.
+    * tests/Makefile.am: New file, from gzip.
+    * Makefile.am (SUBDIRS): Add tests and gnulib-tests.
+    * tests/t-local.sh: New, empty(for now) file.
+
+commit 8465a94ddbb1308d0a406280d87dc432f2005e6a
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Nov 13 18:01:24 2009 +0100
+
+    build: require gettext-0.17
+    
+    * configure.ac: Require gettext-0.17; it was released two years ago.
+
+commit 0fb1003a455d9955c683e8f08eec80880c51c1db
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Fri Nov 13 18:00:44 2009 +0100
+
+    build: correct gettext configure-time support
+    
+    * configure.ac: Use AM_GNU_GETTEXT([external], [need-ngettext]),
+    rather than AM_GNU_GETTEXT([external], [need-formatstring-macros]).
+    Reported by Martin Jacobs in
+    http://thread.gmane.org/gmane.comp.parsers.bison.bugs/3181
+
+commit 8c265a45e54a77003ce754fac893eaf292f7cd6d
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Nov 12 09:38:34 2009 +0100
+
+    build: generalize autoheader check
+    
+    * bootstrap: Look for AC_CONFIG_HEADER as well as AC_CONFIG_HEADERS.
+
+commit 8ec1458ae90b7da54a0d2d476fc70456bf3e7816
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Nov 12 08:21:18 2009 +0100
+
+    maint: use a git submodule for gnulib
+    
+    * .gitmodules: New file, to track gnulib.
+    * gnulib: New file, created by running this:
+    git submodule add git://git.sv.gnu.org/gnulib.git gnulib
+
+commit 8356d902509c4df69fd5dcdb4fe112cb3d57dc95
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Thu Nov 12 08:19:53 2009 +0100
+
+    maint: tell git what it can ignore
+    
+    * .gitignore: Ignore generated files.
+
+commit 3504236b28c6d92653675b3d80361dafed381e0d
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 22:24:33 2009 +0100
+
+    build: generate ChangeLog (from git logs) into distribution tarball
+    
+    * Makefile.am (dist-hook, gen-ChangeLog): New rules.
+    (gen_start_date): Define.
+    * bootstrap.conf (gnulib_modules): Add gitlog-to-changelog.
+
+commit 9bfafb33a6fad87d9b3fc41f0d8e97f9eac8f848
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 22:10:24 2009 +0100
+
+    admin: update all copyright notices to include the year 2009
+
+commit 5b6ba5593b9425a5843986ec97af75fd7c60c6e6
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 21:56:27 2009 +0100
+
+    maint/sc: enable the m4 quote check
+    
+    * m4/vararrays.m4 (AC_C_VARARRAYS): Quote AC_DEFINE argument.
+    * cfg.mk (local-checks-to-skip): Add sc_m4_quote_check.
+
+commit 08d9ddae59b92de9568c8efb0e4c8cd495686df9
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 21:28:53 2009 +0100
+
+    build: rely on gnulib's progname module
+    
+    * bootstrap.conf (gnulib_modules): Add progname.
+    * cfg.mk (local-checks-to-skip): Add sc_program_name.
+    * src/cmp.c: Include progname.h.
+    (program_name): Remove declaration.
+    (main): Call set_program_name.
+    * src/diff.c (main): Likewise.
+    * src/diff3.c (main): Likewise.
+    * src/sdiff.c (main): Likewise.
+    * src/diff.h (program_name): Remove extern declaration.
+
+commit 8cbaebf3532d23cf115ecfb733caa2c0536c070d
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 21:22:38 2009 +0100
+
+    maint/sc: enable the space-TAB check
+    
+    * doc/diagmeet.note: Use no TABs.
+    * ms/config.sed: Use TAB-space, not space-TAB in [].
+    * cfg.mk (local-checks-to-skip): Remove sc_space_tab.
+
+commit 0363ae9f0f40e492f1460440cebc5c933b482b95
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 21:12:48 2009 +0100
+
+    build: rely on gnulib's mbrtowc module
+    
+    * bootstrap.conf (gnulib_modules): Add mbrtowc.
+    * src/side.c [!HAVE_MBRTOWC]: Remove now-useless code,
+    since gnulib guarantees working <wchar.h> and mbrtowc.
+    * cfg.mk (local-checks-to-skip): Remove sc_prohibit_HAVE_MBRTOWC.
+
+commit 2b13b2c76a1ca2119c7e79a2b1985c504ee7a5f4
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 21:08:44 2009 +0100
+
+    maint/sc: enable check for unmarked diagnostics
+    
+    * cfg.mk (local-checks-to-skip): Remove sc_unmarked_diagnostics.
+    * src/dir.c (diff_dirs): Mark a diagnostic for translation.
+
+commit 242183ade35ec89c28710574f77037ce8fea84ad
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 21:07:08 2009 +0100
+
+    maint/sc: enable two config.h-checking rules
+    
+    * cfg.mk (local-checks-to-skip): Remove sc_require_config_h and
+    sc_require_config_h_first.
+    (config_h_header): Define.
+
+commit c9893c55535136d90433b4f9abbc5e7c1e6a303e
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 21:01:38 2009 +0100
+
+    maint/sc: enable the po check
+    
+    * cfg.mk (local-checks-to-skip): Add sc_po_check.
+    * po/POTFILES.in: Update.
+
+commit d4bfdc5340505513d702ee7b6f9eb616868662c5
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 20:57:13 2009 +0100
+
+    maint/sc: use STREQ, not strcmp(a,b) == 0
+    
+    Run this command:
+      git grep -l 'strcmp *([^=]*== *0'|xargs \
+        perl -pi -e 's/\bstrcmp( *\(.*?\)) *== *0/STREQ$1/g'
+    and then add the new definition.
+    * src/system.h (STREQ): Define.
+    * src/cmp.c (main): Use STREQ, not strcmp.
+    * src/diff.c (main, compare_files): Likewise.
+    * src/diff3.c (main): Likewise.
+    * src/sdiff.c (expand_name): Likewise.
+    * cfg.mk (local-checks-to-skip): Add sc_prohibit_strcmp.
+
+commit c952719219ef62b8405edd68f47716ad29d7c41d
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 20:50:55 2009 +0100
+
+    maint/sc: enforce "file system" spelling
+    
+    * src/system.h: Spell it as two words, not one.
+    * ms/config.sed: Likewise.
+    * cfg.mk (local-checks-to-skip): Remove sc_file_system.
+
+commit 036f253976af28b3112a7b246069f73345023ded
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 20:48:06 2009 +0100
+
+    maint/sc: enable check for CVS keyword expansion
+    
+    * doc/diff.texi: Remove $Id$.
+    * cfg.mk (local-checks-to-skip): Remove sc_prohibit_cvs_keyword.
+
+commit e5b61431a50c0cf303ec586d139e5e4b95767abe
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 20:44:10 2009 +0100
+
+    maint: record previous version
+    
+    * .prev-version: New file.
+
+commit 21ebf6648ef306f055004f4411331417980d817c
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 20:43:53 2009 +0100
+
+    maint/sc: enable check for duplicate "the"; fix one
+    
+    * NEWS: s/the the/the/.
+    Adjust style to fit what some of the hooks and release tools expect.
+    * cfg.mk (local-checks-to-skip): Remove sc_the_the.
+    (old_NEWS_hash): Update.
+
+commit f54288e8ee642ba16c57abd2252fad07625794e0
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 19:54:28 2009 +0100
+
+    maint/sc: remove cast of xmalloc return value
+    
+    * lib/prepargs.c (prepend_default_options): Remove useless cast.
+    * cfg.mk (local-checks-to-skip): Remove sc_cast_of_x_alloc_return_value.
+
+commit 90ac0e3b3bf7c069c0559c650beb5a0afa4b7614
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 19:41:53 2009 +0100
+
+    maint: rename ChangeLog to ChangeLog-2008
+    
+    * ChangeLog-2008: Rename from ChangeLog.
+    * Makefile.am (EXTRA_DIST): Add ChangeLog-2008.
+    * .gitignore: Ignore ChangeLog.
+
+commit cb0791d7a466db7406b040a2670cbb27dfc184b1
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 19:36:10 2009 +0100
+
+    maint/sc: remove useless if-before-free tests
+    
+    * src/diff.c (compare-files): Remove useless if stmts.
+    * src/dir.c (diff_dirs): Likewise.
+    * cfg.mk (local-checks-to-skip): Remove sc_avoid_if_before_free.
+
+commit 8075840b3938a05d7dc931adcb6d0ca9e90d432d
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 15:18:13 2009 +0100
+
+    maint: require newer automake, new non-major version string, dist-xz
+    
+    * configure.ac: Drop -cvs suffix.  Switch to git-based format.
+    Distribute xz-compressed tarballs, too.
+    Require automake-1.11.
+    Enable automake's --enable-silent-rules option.
+
+commit a9a19e94fbb30fe57846bf94d03d61f8b84f9f9e
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 15:13:54 2009 +0100
+
+    build: update build/release infrastructure
+    
+    * bootstrap: Update from gnulib.
+    * bootstrap.conf (gnulib-modules): Add do-release-commit-and-tag,
+    git-version-gen, gnu-make, gnu-web-doc-update, gnumakefile, gnupload,
+    maintainer-makefile, update-copyright.
+    * gnulib-tests/Makefile.am: New file.
+    * cfg.mk: New file.
+    (local-checks-to-skip): List currently-failing tests,
+    so that "syntax-check" passes initially.
+    (manual_title): Define.
+
+commit 8fd1173dd50ff556a19d046efee0a5bbf6aaf777
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 31 00:45:01 2008 +0000
+
+    * doc/diff.texi: Update Back-Cover text to reflect new GNU wording.
+
+commit f1a0d330653ed34da99313c510fbc6ee7844b523
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 17:49:46 2008 +0000
+
+    * src/side.c [!HAVE_MBRTOWC]: Supply defns for mbstate_t and mbrtowc.
+    
+    Problem reported by Bruno Haible.
+
+commit c3b0f9e45b0660716286fc561f38abdd1019c239
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 00:02:11 2008 +0000
+
+    * src/side.c (print_half_line): Don't convert to unsigned char
+    
+    unnecessarily.
+
+commit 8983b8d9040d3b909e8a7aeda9188affa1585014
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Jan 23 23:56:30 2008 +0000
+
+    Don't mishandle multibyte characters in side-by-side format.
+    
+    Problem reported by Erik Karlsson in
+    <http://lists.gnu.org/archive/html/bug-gnu-utils/2008-01/msg00030.html>.
+    * bootstrap.conf (gnulib_modules): Add wcwidth.
+    * src/side.c: Include <wchar.h>.
+    (print_half_line): Compute number of bytes and print widths of
+    multibyte characters.  Inspired by an alternative solution from
+    Bruno Haible in
+    <http://lists.gnu.org/archive/html/bug-gnu-utils/2008-01/msg00032.html>.
+
+commit e1820a76c057c2c7c5f46f51c6fc37dae8c423c1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Dec 5 07:24:14 2007 +0000
+
+    * NEWS: New diff option --suppress-blank-empty (no longer -u default).
+    
+    * doc/diff.texi (Detailed Unified): Trailing spaces are no longer
+    omitted.
+    (Trailing Blanks): New section.
+    (diff Options) Mention new option.
+    * src/diff.h (suppress_blank_entry): New decl.
+    * src/context.c (pr_unidiff_hunk): Support --suppress-blank-empty.
+    * src/util.c (print_1_line): Likewise.
+    * src/diff.c (longopts, main, option_help_msgid): Likewise.
+    (SUPPRESS_BLANK_EMPTY_OPTION): New constant.
+
+commit d4897fbc006f1c7ff2c1b825fa86c299c46472c8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Dec 5 07:07:22 2007 +0000
+
+    * configure.ac: Invoke gl_USE_SYSTEM_EXTENSIONS after gl_EARLY,
+    
+    since gnulib now requires this order.
+
+commit 99c5b6631d8e766cca9ec5595ae552ec34a58c00
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Dec 5 07:01:49 2007 +0000
+
+    * bootstrap: Import from gnulib.
+
+commit 9c6f0755416965dc426cc2f60c6635f04531e35a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 17 23:37:27 2007 +0000
+
+    Fix typo in previous change; Bruno wrote the code.
+
+commit 0cb3c7ffeff111a4784185c0c791b92dc4ad2d61
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 17 23:35:48 2007 +0000
+
+    Break out diffseq.h into a separate file, so that gettext can use
+    this code.  Idea from Bruno Haible.
+    * bootstrap.conf (gnulib_modules): Add diffseq.
+    * src/analyze.c (xvec, yvec, fdiag, bdiag, too_expensive, SNAKE_LIMIT):
+    (struct partition, diag, compareseq): Remove; now in diffseq.h.
+    (ELEMENT, EQUAL, OFFSET, EXTRA_CONTEXT_FIELDS, NOTE_DELETE, NOTE_INSERT):
+    (USE_HEURISTIC): New macros.
+    Include "diffseq.h".
+    (diff_2_files): Rewrite to use new diffseq.h interface.
+
+commit 53aeb341d52b8d56cd5080d146330a6cb114d4ba
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 17 23:18:56 2007 +0000
+
+    * bootstrap: Import from gnulib.
+
+commit e78fa511978bacb0948eb333a815d66b14bc0782
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Aug 15 19:33:36 2007 +0000
+
+    * doc/diff.texi (Copying This Manual): Adjust to new fdl.texi layout.
+
+commit 28c227c281a947a7ebac93f2784d9f7a0dac3ffc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Aug 15 19:32:22 2007 +0000
+
+    * src/diff.c (compare_files): Use last_component rather than base_name,
+    adjusting to gnulib API change.  This avoids a memory leak.
+    * src/sdiff.c (expand_name): Likewise.
+    * src/util.c (dir_file_pathname): Likewise.
+
+commit 4805ca767a3c9b20deede49b2e4b294e58a28325
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jul 19 18:26:38 2007 +0000
+
+    * doc/diff.texi (White Space): Note that newline always ends a line,
+    so -w doesn't ignore newline-related changes.  Problem reported by
+    David Kastrup.
+
+commit 7e7a52f33be97ba6ae5ffcca4c504f243ecc12eb
+Author: Jim Meyering <meyering@redhat.com>
+Date:   Wed Nov 11 12:35:21 2009 +0100
+
+    remove many files
+    
+    Many are now obtained via bootstrap from gnulib.
+    Others (ms/) were not being maintained.
+
+commit 43e4846f1153b7fc199a46c29f5b73c1cff49757
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jul 19 17:45:29 2007 +0000
+
+    * COPYING: New file.
+    * AUTHORS: Update from GPLv2 to GPLv3.
+    * Makefile.am: Likewise.
+    * NEWS: Likewise.
+    * README: Likewise.
+    * README-hacking: Likewise.
+    * bootstrap: Likewise.
+    * bootstrap.conf: Likewise.
+    * configure.ac: Likewise.
+    * exgettext: Likewise.
+    * doc/Makefile.am: Likewise.
+    * lib/Makefile.am: Likewise.
+    * lib/cmpbuf.c: Likewise.
+    * lib/cmpbuf.h: Likewise.
+    * lib/prepargs.c: Likewise.
+    * m4/vararrays.m4: Likewise.
+    * man/Makefile.am: Likewise.
+    * ms/Makefile.am: Likewise.
+    * ms/README: Likewise.
+    * ms/config.bat: Likewise.
+    * ms/config.sed: Likewise.
+    * ms/config.site: Likewise.
+    * po/POTFILES.in: Likewise.
+    * src/Makefile.am: Likewise.
+    * src/analyze.c: Likewise.
+    * src/cmp.c: Likewise.
+    * src/context.c: Likewise.
+    * src/diff.c: Likewise.
+    * src/diff.h: Likewise.
+    * src/diff3.c: Likewise.
+    * src/dir.c: Likewise.
+    * src/ed.c: Likewise.
+    * src/io.c: Likewise.
+    * src/normal.c: Likewise.
+    * src/sdiff.c: Likewise.
+    * src/system.h: Likewise.
+    * src/util.c: Likewise.
+
+commit 4e45d1d3241f2dbe27d1d434b5e44077457528d6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jul 19 17:19:39 2007 +0000
+
+    * src/ifdef.c: Fix typo: "GNU DIFF General Public License" should be
+    "GNU General Public License".  Reported by Erich Guenther.
+    * src/side.c: Likewise.
+
+commit 2e5425cc4d56407e83e931bcff395d5813ef353b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 18 22:57:12 2007 +0000
+
+    (print_context_label): Use TYPE_IS_INTEGER macro rather than rolling
+    it ourselves.
+
+commit 7f61a0561421a669321c382d79d8e83a08aad21f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 18 22:45:24 2007 +0000
+
+    * bootstrap.conf (gnulib_modules): Add inttypes.
+
+commit 2da851745e00e862d7afa4dda21276fc859d5c7f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 18 22:23:18 2007 +0000
+
+    * src/context.c (print_context_label): Don't assume that time_t
+    fits in long int, since it doesn't in FreeBSD/arm.  Problem
+    reported by Xin Li in
+    <http://lists.gnu.org/archive/html/bug-gnu-utils/2007-06/msg00091.html>.
+
+commit b8c8ac122f2f060c9998d20c94d71883bd3435d7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Jun 6 23:40:16 2007 +0000
+
+    * NEWS:  Mention new sdiff aliases 1 and 2 for l and r.
+    * doc/diff.texi (Merge Commands): Likewise.
+    * src/sdiff.c (give_help): Give help for them.
+    (edit): Support them.
+
+commit cbadd508f38bca085f94fa704b551fdca9097a6f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Apr 12 00:15:15 2007 +0000
+
+    * doc/diff.texi (Detailed diff3 Normal): "range is a singleton" ->
+    "there is only one line", for clarity.  Suggested by Jerry Peek.
+
+commit f9179e0514ce957641d6ba61225e9275d0f74c03
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Apr 4 22:11:27 2007 +0000
+
+    * TODO: Mention possible sdiff improvement.
+
+commit c7f95e3605303a49dec2dc5a4f96b5b1c7c87518
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Apr 4 22:08:14 2007 +0000
+
+    * bootstrap: Sync from gnulib.
+    * src/cmp.c: Don't include exit.h; no longer needed.
+    * src/diff.c: Likewise.
+    * src/sdiff.c: Likewise.
+    * src/dir.c: Don't include strcase.h; no longer needed.
+    * README-alpha: Remove, replacing with:
+    * README-hacking: New file, taken from coreutils with some changes.
+    The rename is required by the change to 'bootstrap'.
+
+commit 2f9d531901f2126e6157aed6d23df18d3509b308
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 15 09:25:48 2006 +0000
+
+    * src/analyze.c (build_reverse_script): Fix typo in comment.
+    Problem and fix reported by Daniel Hipschman.
+
+commit 2a324549cee6cb97de866694218354186922ac9a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Nov 14 22:53:59 2006 +0000
+
+    * src/sdiff.c (sigprocmask): Don't dump core if O is null.
+
+commit 1795be71fb9db24aaa5d3ef2fd71f0f952ccb72f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Nov 14 20:22:12 2006 +0000
+
+    Don't assume SIGPIPE exists, and that sigblock and sigsetmask
+    exist if sigprocmask does not.  Problem reported by Paul Edwards
+    for MVS 3.8.
+    * configure.ac (sigblock): Check whether this function is
+    available, if sigprocmask is not.
+    * src/sdiff.c (sigs): Omit SIGPIPE if it's not defined.
+    Put SIGINT last; all uses changed.
+    (handler_index_of_SIGPIPE): Omit if SIGPIPE is not defined.
+    (sigblock, sigsetmask) [!HAVE_SIGBLOCK]: New macros.
+
+commit 6bd6999fed54d8c9e1f95308304141663202db73
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 5 00:57:34 2006 +0000
+
+    * src/sdiff.c (sigprocmask) [! HAVE_SIGPROCMASK]: Cast 2nd arg to
+    sigset_t *, since it might be a literal 0.  Problem reported by
+    Paul Edwards for MVS 3.8.
+
+commit 10892a2dccbd79676e1da06801006e35e05e0830
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Sep 5 23:02:32 2006 +0000
+
+    * NEWS: diff -u no longer outputs trailing white space unless the
+    input data has it.
+
+commit 2daf7bfa36f4f44692330e1102ebe004198bbc0f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Sep 5 22:57:29 2006 +0000
+
+    Modernize bootstrap procedure to match current gnulib.
+    * bootstrap: Sync with coreutils bootstrap, except check that
+    the directory build-aux exists before trying to copy to it.
+    * bootstrap.conf: New file.
+    (gnulib_modules): Add config-h, dup2, extensions, fcntl, fdl,
+    stat-macros, unistd.
+    * configure.ac: Invoke gl_EARLY and gl_INIT rather than
+    GNULIB_AUTOCONF_SNIPPET.
+    (AC_CONFIG_HEADER): Rename config.h to lib/config.h.
+    (AC_CHECK_HEADERS_ONCE): Don't check for fcntl.h, locale.h,
+    sys/file.h, unistd.h.  We now use the fcntl and unistd modules,
+    and locale.h can be assumed for any C89 compiler.
+    (DIFFUTILS_PREREQUISITES): Remove.  No longer needed now that
+    we use the stdint module.
+    (AC_CHECK_FUNCS_ONCE): Remove dup2, which is no longer needed
+    now that we use the dup2 module.
+    (AM_GNU_GETTEXT): Use need-formatstring-macros, and ...
+    (AM_GNU_GETTEXT_VERSION): specify version 0.15 instead of 0.14.5,
+    to be consistent with coreutils.
+    * lib/Makefile.am (noinst_LIBRARIES):
+    (lib_SOURCES, libdiffutils_a_LIBADD):
+    (libdiffutils_a_DEPENDENCIES, BUILT_SOURCES, EXTRA_DIST):
+    (MOSTLYCLEANFILES): Remove; now computed automatically.
+    (noinst_HEADERS, libdiffutils_a_SOURCES): Just append
+    our special files now.
+    * lib/cmpbuf.c: Include config.h unconditionally, since we
+    no longer define HAVE_CONFIG_H.
+    * lib/prepargs.c: Likewise.
+    * src/Makefile.am (LDADD): Use $(LIBINTL), not @LIBINTL@.
+    (diff_LDADD): Use $(LIB_CLOCK_GETTIME), not @LIB_CLOCK_GETTIME@.
+    * src/dir.c (dir_read): Use _D_EXACT_NAMLEN, not NAMELEN.
+    * src/system.h (volatile): Remove, since we assume C89 or better.
+    Include stat-macros.h.
+    (S_IRWXU, S_IRWXG, S_IRWXO, S_IRUSR, S_IWUSR):
+    Remove, since we now use stat-macros.h.
+    (SEEK_SET, SEEK_CUR): Remove, since we assume C89 or better.
+    Include unistd.h unconditionally, since we use unistd.
+    Likewise for fcntl.h.
+    (dup2): Remove, since we now use dup2.
+    (O_RDONLY, O_RWDR, O_BINARY): Remove, since we now use
+    fcntl.
+    Include dirent.h unconditionally.
+    (NAMLEN): Remove, replacing with....
+    (_D_EXACT_NAMLEN): New macro.
+    Include inttypes.h unconditionally.
+    (PTRDIFF_MAX, SIZE_MAX, UINTMAX_MAX, strtoumax): Remove, since
+    we now use inttypes.
+    Include locale.h unconditionally.
+    (setlocale): Remove, since we now assume locale.h.
+
+commit a204b37fb2d871df551d9bf6fb722d8f269a0754
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Sep 5 22:57:09 2006 +0000
+
+    * doc/diff.texi (Detailed Unified): Don't output trailing white
+    space unless the input data has it.
+    * src/context.c (pr_unidiff_hunk): Likewise.
+
+commit 19397f6b83f488de0e54c7ea4972e86515677752
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Sep 5 14:04:57 2006 +0000
+
+    * src/context.c (print_context_function): Do not print
+    trailing white space in a context header.
+
+commit 32625c50259a94e480ab8184a9b6af674e854076
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Jul 26 06:20:59 2006 +0000
+
+    (cmp Options): -l also outputs the EOF message.
+
+commit 67d3afe06ae68b181de2be258099c62400bc3b81
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue May 9 22:57:20 2006 +0000
+
+    * src/cmp.c (cmp): The previous fix wasn't quite right either, as
+    it mishandled 'cmp A B >/dev/null' when A is shorter than B and
+    differs before A's end-of-file, by outputting a bogus EOF message.
+    Also, it was inefficient if A and B were large.
+
+commit f0098c7f4f1c88f7f24af9b3d0ac56bee63ace82
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon May 8 07:21:34 2006 +0000
+
+    Use Jim's wording in ChangeLog entry, mostly.
+
+commit f74bf8344446af160009ddd6f9a1bfde43092adc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon May 8 07:17:54 2006 +0000
+
+    Correct authorship of previous patch.
+
+commit 69aaf732ab2fbed74b3b19d9e3e0adc6b0ff372e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon May 8 01:41:04 2006 +0000
+
+    * src/cmp.c (cmp): Fix bug introduced in 2006-03-09 change.
+    For example, "cmp <(echo b) <(echo a) > /dev/null" incorrectly
+    succeeded.  Problem reported by Jim Meyering.
+
+commit 96e1fbe4c727ac843a4760859148378c22d52b66
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun May 7 08:16:19 2006 +0000
+
+    * src/context.c (pr_context_hunk, pr_unidiff_hunk):
+    Prefer fputs or fputc to fprintf, since it's a tad more efficient
+    with unlocked-IO on glibc.  Long ago we avoided fputs to
+    work around an ancient SunOS bug, but that's no longer relevant.
+    * src/diff3.c (output_diff3, dotlines, undotlines):
+    (output_diff3_edscript, output_diff3_merge): Likewise.
+    This also avoids a gcc -Wformat-security warning reported
+    by Jim Meyering.
+    * src/ed.c (print_ed_hunk, print_forward_ed_hunk, print_rcs_hunk):
+    Likewise.
+    * src/normal.c (print_normal_hunk): Likewise.
+
+commit e0842123160e781efcc0ddbf854dae53b7f674e2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun May 7 04:07:58 2006 +0000
+
+    find_identical_ends and doc/diff.texi fixes
+
+commit 58d0483b621792959a485876aee05d799b6470de
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun May 7 04:07:41 2006 +0000
+
+    (find_identical_ends): Fix huge performance bug that I
+    introduced in the 2001-11-25 change: the code to remove the
+    identical suffix also looked at the trailing sentinel, which meant
+    the common suffix length was always incorrectly calculated to be
+    zero.  Problem and fix reported by Daniel Hipschman.  Instead of
+    his fix, revert to the (nearly-equivalent) pre-2001 code.
+
+commit bcfeb9cb38452c38234b2b783fff51c0ba529a12
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun May 7 04:06:50 2006 +0000
+
+    Switch from GFDL 1.1 to 1.2.
+
+commit 4c0c7c59d6728975d7b18dd3ca3f76c8cecd8ce8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 13 19:11:17 2006 +0000
+
+    * src/system.h (PARAMS, PROTOTYPES): Remove; no longer needed.
+    (IF_LINT): New macro, to pacify GCC.
+    * src/analyze.c (diag, compareseq): Use IF_LINT.
+    * src/cmp.c (cmp): Likewise.
+    * src/diff3.c (process_diff): Likewise.  Also, prefer NULL to 0.
+    * src/ifdef.c (do_printf_spec, scan_char_literal): Likewise.
+    * src/sdiff.c (edit): Likewise.
+
+commit a3dd61b474f62af16f8638679c8ade0ab34978cf
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Mar 9 20:57:25 2006 +0000
+
+    Update code comment to match previous patch.
+
+commit dab9c7e59b283db312c08ac765ac41e2338cdaf7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Mar 9 20:54:39 2006 +0000
+
+    (main): Avoid an unnecessary system call introduced in previous patch.
+
+commit 708ba31420d0bf4dfaa37fafa566727312ecb966
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Mar 9 20:38:11 2006 +0000
+
+    * src/cmp.c (type_no_stdout): New constant.
+    (main): Use it to avoid bug when the "EOF on foo" message is
+    generated and stdout is /dev/null.
+
+commit 57253a174c8645f56d1dbe7032b8c0128ec4a68c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 5 07:33:42 2006 +0000
+
+    Handle gettext.m4 like glibc21.m4.  Don't remove po/en.po.
+
+commit f5c76109838cdf542958a88020bd34e2f54f97a4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 5 07:23:55 2006 +0000
+
+    Update FSF address.
+
+commit e781e2df7cbe7794165e267a627417c906e4adbd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 5 07:15:26 2006 +0000
+
+    Describe CVS access better, using the README-alpha from GNU tar.
+
+commit 91b8605708cf2d7c49679a46a80b4039167da2cd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 5 07:08:23 2006 +0000
+
+    * src/cmp.c: Don't include <setmode.h>.
+    (specify_ignore_initial): Reword to avoid gcc -W warnings.
+    (main): Use freopen instead of setmode, since freopen is in POSIX.
+    * src/context.c: Revert most 2004-09-01 changes.  Then:
+    (TIMESPEC_NS): Remove.  All uses replaced by
+    get_stat_mtime_ns.
+    Include stat-time.h, strftime.h.
+    (nstrtime): Remove decl.
+    * src/diff.c: Revert most 2004-09-01 changes.  Then:
+    Don't include <posixver.h>, <quotesys.h>, <setmode.h>.
+    Include <sh-quote.h>, <stat-time.h>, <timespec.h>.
+    All uses of quotesys replaced by sh-quote.
+    (main, compare_files):
+    Use freopen instead of setmode, since freopen is in POSIX.
+    (main): Don't complain about "diff -NUM'.
+    (main, set_mtime_to_now):
+    Adjust to stat-time.h macros when accessing nanoseconds.
+    * src/diff3.c: Include sh-quote.h rather than quotesys.  All uses
+    changed.
+    * src/dir.c (dir_read): excluded_filename renamed to
+    excluded_file_name.
+    * src/io.c: Don't include <setmode.h>.
+    (sip, read_files): Remove binary file stuff, leaving a FIXME behind.
+    A DOS expert needs to look at this.
+    * src/diff.c: Include sh-quote.h rather than quotesys.h.
+    All uses changed.
+    * src/system.h: Include verify.h.
+    (verify): Remove.  All uses changed to verify.h version.
+    Include <intprops.h>.
+    (TYPE_SIGNED, TYPE_MINIMUM, TYPE_MAXIMUM): Remove.  Now uses
+    intprops.h versions.
+    (O_BINARY): New defns, taken from coreutils.
+    * src/util.c: Include sh-quote.h rather than quotesys.h.
+    All uses changed.
+
+commit 174ab8396535806d77708990568f9817d11d5bb3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 1 15:06:09 2004 +0000
+
+    (recursive, new_file, unidirectional_new_file,
+    report_identical_files): Move into struct diffopt.  All uses changed.
+    (exclude_options, compare_files, specify_style, check_stdout):
+    New arg OPT.  All uses changed.
+    (GDIFF_MAIN): Remove.  All uses removed.
+    (function_regexp_list, ignore_regexp_list): No longer static; now
+    locals in 'main'.
+    (main): Set opt.function_regexp, opt.ignore_regexp if using regexps;
+    all other code now tests these pointers rather than inspecting fastmap
+    internals.
+    New local OPT to hold former statics; initialize it.
+    (init_regexp_list): New function, used by main.
+    (summarize_regexp_list): Now returns struct re_pattern_buffer *, and
+    assumes reglist->regexps is not NULL.  All uses changed.
+
+commit 203069b84a21bd917b6d971705fcf0480579e718
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 1 14:50:42 2004 +0000
+
+    (find_function_last_search): Move into struct diffopt.
+    All uses changed.
+    (pr_context_label, pr_context_header,
+    print_context_script, find_function, find_hunk, mark_ignorable,
+    pr_context_hunk, pr_unidiff_hunk): New arg OPT.  All uses changed.
+    (print_context_number_range,
+    print_unidiff_number_range): New arg OUT.  All uses changed.
+
+commit 3b8636727556fc88f4517e57bb65ef60ea78c8e9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 1 14:37:55 2004 +0000
+
+    Add AC_C_INLINE.
+
+commit 0d349232b335031c4ef8d8d07e2c712cf1f9ba3d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Jul 21 08:58:38 2004 +0000
+
+    (print_ed_hunk): Optimize the case where an insert's
+    last line is a single-dot line.
+
+commit 61d0b7e9bd56a3999d0697a5fa2e87c4a2d170d2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Jul 21 08:58:12 2004 +0000
+
+    Initial revision
+
+commit ce64bdaf0ec7aa164b1a36bbd9ec79124f08386f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Jun 30 17:49:57 2004 +0000
+
+    Don't include <stdbool.h>, since setmode.h now does this.
+    Include setmode.h first, to catch interface errors.
+    Assume HAVE_SETMODE_DOS is defined.
+
+commit 4f8fa6adc36c096088803a9bf2654ce1a4f8b5a8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Jun 30 17:46:07 2004 +0000
+
+    Include stdbool.h.
+
+commit 316aba17275e68e7be4d5c16ee26ca1f61a1068c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 26 18:04:04 2004 +0000
+
+    Don't remove po/en.po.
+
+commit 9080cf851154c54bef83895133f11ffcdff837a3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Apr 13 22:39:49 2004 +0000
+
+    Don't generate a temporary file, as this runs afoul of "make distcheck"
+    which operates with read-only directories.
+
+commit 6a7b42e65a6f57eca1747f2571fb871d90c86431
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Apr 13 06:56:38 2004 +0000
+
+    (EXTRA_DIST): Add bootstrap.
+    Remove config/config.rpath as it is deduced automatically these days.
+
+commit 4a1de90b3c191e6854a5f91360b50d5f9ef8e859
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Apr 13 06:56:18 2004 +0000
+
+    Version 2.8.7.
+
+commit a76094697e04ec706d37cc5a8b7ad73048fecfef
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Apr 13 06:55:43 2004 +0000
+
+    (AM_GNU_GETTEXT_VERSION): Add.
+    (XGETTEXT): Restore from pre-2004-04-12 version.  This fixes
+    a bug that lost many msgids in doc/diffutils.pot.
+    (AC_INIT): Version 2.8.7.
+
+commit 45cc4e0358a8dc81675edf3c6c17ad0386bd4627
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Apr 13 06:47:34 2004 +0000
+
+    Initial revision
+
+commit fefbcf76e6e9097c97b73c387db27b852c57909e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 23:07:15 2004 +0000
+
+    (AC_CONFIG_COMMANDS): Remove.
+
+commit 74bdeeafed854701b934062d66ac2363016b5f1e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 20:45:50 2004 +0000
+
+    (EXTRA_DIST): Add setmode.h.
+
+commit 2e225054695624e563061098b6ca6e03dc619d47
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 20:30:57 2004 +0000
+
+    Use inttostr module, so we needn't worry about specifying it ourself.
+
+commit a74be8d413ed08f1fd2e73499f73e453be2f6e39
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    * configure.ac: Quote various arguments better.
+    (AC_CONFIG_MACRO_DIR): Add call, specifying "m4".
+    (AC_CONFIG_HEADER): Replaces AM_CONFIG_HEADER.
+    (gl_USE_SYSTEM_EXTENSIONS): Replaces AC_GNU_SOURCE.
+    (AC_ISC_POSIX): Remove; nobody ports to ancient ISC any more.
+    (AC_PROG_CPP, AC_PROG_INSTALL, AC_C_INLINE,
+    AC_HEADER_STDBOOL, AC_HEADER_STDC, AM_GNU_GETTEXT, XGETTEXT,
+    AC_HEADER_STAT, AC_FUNC_VPRINTF, jm_FUNC_GLIBC_UNLOCKED_IO,
+    jm_FUNC_GNU_STRFTIME, jm_FUNC_MALLOC, jm_FUNC_REALLOC,
+    jm_PREREQ_C_STACK, jm_PREREQ_ERROR, jm_PREREQ_HARD_LOCALE,
+    jm_PREREQ_QUOTEARG, jm_PREREQ_REGEX, AC_FUNC_FNMATCH_GNU, jm_AC_DOS):
+    Remove; not needed here, as our files don't use them directly
+    or we rely on gnulib modules.
+    (AC_C_CONST): Remove; we assume C89 now.
+    (AC_CHECK_HEADERS): Remove libintl.h, limits.h, stdlib.h, string.h,
+    time.h.
+    (AC_CHECK_TYPE): Remove ptrdiff_t, ssize_t.
+    (AC_CHECK_FUNCS): Remove diraccess, strchr, strerror, tmpnam).
+    (AC_REPLACE_FUNCS): Remove memchr, mkstemp, strcasecmp.
+    (GNULIB_AUTOCONF_SNIPPET): Add call.  This replaces much of
+    the above.
+    (AC_CONFIG_FILES): Remove lib/posix/Makefile.
+
+commit 2ea441f7e2238c3cb0b31bf1e8f9cf308f9d4c21
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    Initial revision
+
+commit b3f6204729da36e1b91222a3a37ae1b5b6183db4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    Move copyright notice to end.  Defer to "configure
+    --help" for special "configure" options.  Suggest latest libiconv.	Update version numbers of Autoconf etc. to current.
+
+commit 477cd3074a36e5f5f6ea9d986f0772cf3f27cfbe
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    Add news for 2.8.4, 2.8.6.
+
+commit 3f0830fef57d62a48bbfdaa868698038b7b085f7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    Do not include regex.h, as diff.h does this now.
+    (lines_differ): Don't convert char * to unsigned char *;
+    just leave pointers as char *.  This lessens the number of
+    potentially-dangerous casts.
+
+commit 43adfd44c5edd962d042abb1976ad0710748d7d5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    (S_IRWXU, S_IRWXG, S_IRWXO): Define if not defined.
+    (S_IXUSR, S_IXGRP, S_IXOTH): Remove.
+    Include <time.h> unconditionally, since we can assume C89 now.
+    Likewise for <stdlib.h>, <string.h>.
+    (getenv, EXIT_SUCCESS, EXIT_FAILURE, SSIZE_MAX, strchr, strrchr,
+    memcmp, memcpy): Remove decl; no longer needed.
+    (strcasecoll, strcasecmp): Define if not built in.
+    (CTYPE_DOMAIN, ISPRINT, ISSPACE, TOLOWER, _tolower, errno): Remove;
+    we now assume C89 or better.  All uses changed.
+    Include <stdbool.h> unconditionally now, since gnulib supports it
+    if the C compiler doesn't.  All boolean uses of 0 and 1 now
+    changed to false and true.
+    (lin_is_printable_as_long_int): Renamed from lin_is_printable_as_long.
+
+commit 5af1582ab885a37805191cb2a76026eb67560b1e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    minor cleanups for bool, etc
+
+commit c151c4194b162bcee131693aa82359da2b196650
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    (usage): Mention exit status.
+    (main): Adjust to latest gnulib c_stack_action calling conventions.
+    Adjust to latest version_etc calling conventions.
+    Include <unlocked-io.h>, <exit.h>.
+    (check_child_status): Renamed from ck_editor_status, and
+    accept a new arg MAX_OK_STATUS.  All callers changed.
+    Handle status 126/127 as per POSIX.
+    (edit): Likewise.
+    (main): Likewise.  Fix getopt typo: -E wasn't supported.
+
+commit 4cdc5fbf2b6e1dd5a38ea4b7d83e3a085ea5c549
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    Do not include regex.h, as diff.h does this now.
+    (find_and_hash_each_line): Don't convert char *
+    to unsigned char *; just leave pointers as char *.  This
+    lessens the number of potentially-dangerous casts.
+
+commit fbe4a6f698f834461143df0b2868e6545ee45702
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    (next_line): Remove; replace with...
+    (next_line0, next_line1): New vars.
+    (print_ifdef_script, print_ifdef_hunk):
+    Use them to fix line-number computation bug.
+
+commit b4a6ac7a09084fc340be083ad45fb8c40c959545
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    int -> long int
+
+commit ede07ddb4d1ca04aab16088671cfae01752e83b9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    Include <strcase.h>.
+    (failed_locale_specific_sorting): Renamed from failed_strcoll.
+    All uses changed.
+    (compare_names): Don't invoke strcasecmp first thing when
+    ignore_file_name_case; if locale_specific_sorting, we should
+    just use that.
+
+commit d5b0491a3196315c14597f5542234a57472dd547
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    (usage): Mention exit status.
+    (main): Adjust to latest gnulib c_stack_action calling conventions.
+    Adjust to latest version_etc calling conventions.
+    Include unlocked-io.h.
+    (strip_trailing_cr): New var.
+    (STRIP_TRAILING_CR_OPTION): New enum.
+    (longopts, main, option_help_msgid, read_diff):
+    Add --strip-trailing-cr support.
+    (read_diff): Exit with status 126 (not 127) if errno != ENOENT
+    after failed execvp in child.  Report this in parent.
+
+commit 70a8b49b0fb78ea910a4e3fa1fc3846227d7fc42
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    Include regex.h, unlocked-io.h.
+    (struct file_data.changed): Now char *, not bool *, to save
+    space on hosts where bool takes more space than char.
+    All uses changed.
+
+commit 0b52cc41fc62fec5c6b1920930a20bf26382dfcd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    Do not include regex.h, as diff.h does this now.
+    (option_help_msgid): Mention exit status.
+    (main): Adjust to latest gnulib c_stack_action calling conventions.
+    Adjust to latest version_etc calling conventions.
+    Include <exit.h>.
+    (binary): Define to true if not declared.
+    (longopts): Set tabsize flag to 1.
+    (main): Don't output nanoseconds if platform lacks them.
+    Don't treat files as binary if !binary.
+    (set_mtime_to_now): Use 0, not NULL.
+    (compare_files): Mark files as nonexistent if it looks like
+    'patch' created inaccessible regular empty files to denote
+    nonexistent backups.  Don't compare such files.
+    Clear st_* members of status of	nonexistent file.
+    Remove now-unnecessary tests.
+
+commit fae8239911a876b179c0c57ace09f837aaa6541a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    Do not include regex.h, as diff.h does this now.
+
+commit 61d1ff8d5006c448ed7f257b021e48c5c2afac42
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    Sort includes.  Include <exit.h>, <unlocked-io.h>.
+    (specify_comparison_type): Don't report an error if the comparison
+    type has already been specified the same way as this one.
+    (usage): Mention exit status.
+    (main): Adjust to latest gnulib c_stack_action calling conventions.
+    (main): Adjust to latest version_etc calling conventions.
+
+commit 0ebd95fcbdec9f353f89378dad84e2cdb4e3c1fd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    (SUBDIRS): Remove.
+    (EXTRA_DIST, noinst_HEADERS): Remove most entries.
+    (libdiffutils_a_SOURCES): Now just lib_SOURCES.
+    (lib_SOURCES): New macro.
+    (DISTCLEANFILES, MOSTLYCLEANFILES): Set to empty now.
+    (gnulib.mk): Include: this does most of the work eliminated
+    by the above changes.
+
+commit 59500c52b299db1bd589517dbc3b781cb576dcdc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    (set_binary_mode): Return true, not 1.
+
+commit 6fc04adf128379f0efac92966a52865fb5f87e29
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    (__attribute__): New macro.
+    (set_binary_mode): Define only if HAVE_SETMODE_DOS.
+    Otherwise define a dummy static char, as C89 requires
+    that we define something.
+
+commit 6243e2580a0a84026f75edb2a54edfc39d39825e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 12 07:44:35 2004 +0000
+
+    (dircategory): Change to "Text creation and
+    manipulation" from "GNU packages".
+    (Translations): New node.
+    (Overview): Improve quality of algorithm citations.
+    (Binary): -q doesn't exactly cause diff to assume files are binary.
+    (Normal): Place after Side by Side, since it's less important.
+    (Detailed Context, Detailed Unified, Detailed ed,
+    Detailed if-then-else, diff3 Hunks, Detailed diff3 Normal):
+    Place at end of menu.
+    (Detailed Unified): Mention that fractional timestamps are
+    omitted on hosts that don't support them.
+    Mention what happens when hunks contain just one line.
+    (Line Group Formats, Reject Names): Fix duplicate-word typos.
+    (Comparing Directories): Trailing white space and empty lines are
+    ignored in the -X file.
+    (diff Options): Add --strip-trailing-cr.
+    (Projects): gnu -> gvc@gnu.org.
+
+commit 16b4efacf9235515793fcc0a3e827a98219a80f9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Mar 12 04:39:09 2004 +0000
+
+    (diag): Return void, not lin, since the return
+    value wasn't needed.  All callers changed.
+    (diag, diff_2_files):
+    Use 'true' and 'false' instead of '1' and '0', when appropriate.
+    (compareseq): Use lin const * local variables instead of lin *.
+    Don't bother checking diag's return value.
+    (shift_boundaries, build_reverse_script, build_script, diff_2_files):
+    Use char arrays, not bool arrays, since
+    sizeof (bool) might be greater than 1.
+
+commit 4ed49df5e498c76b610fc1cb86c5411efb65c090
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 8 00:03:44 2004 +0000
+
+    (Makefile.am): Don't use $<, as it doesn't work with Solaris make.
+
+commit da9e16ed92a74144ed0798aa6d7d4e2e6ad921c7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Feb 9 08:29:40 2004 +0000
+
+    (AC_FUNC_SETMODE_DOS): AC_LIBOBJ(setmode) if true.
+
+commit a6c2999cb2757182945881bc269110468be086ba
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jan 12 20:52:38 2004 +0000
+
+    coreutils 5.2.0
+
+commit 55865b500d9c55b7395a89a968eed0c1583120c6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jul 28 00:57:07 2003 +0000
+
+    Use a single locale for both British and American English,
+    since we don't need to use '-ise' in Britain, says the OED.
+
+commit 74e3ee8f1939d6b2dc32410c38a103a8b906af1d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Oct 15 03:57:20 2002 +0000
+
+    (diff3.$(OBJEXT), diff.$(OBJEXT), sdiff.$(OBJEXT)):
+    Rename from (misspelled) diff3.$(OBJECT), diff.$(OBJECT), sdiff.$(OBJECT).
+    Patch by Paul D. Smith in
+    <http://mail.gnu.org/pipermail/bug-gnu-utils/2002-October/003251.html>.
+    Bug reported by Chris Bainbridge.
+
+commit b6a7784af676924f577b305b5c15978f1e7847e1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 14 04:40:20 2002 +0000
+
+    (MOSTLYCLEANFILES): Add paths.ht.
+    (paths.h): Send output to paths.ht first, and then rename to
+    paths.h at the end.  This avoids problems if the disk is full.
+    It also works around what appears to be a bug with GNU make -j
+    (3.79.1); see <http://bugs.gentoo.org/show_bug.cgi?id=8934>.
+
+commit 2b39a9397d67262ebee902483fb5bdbcfce5c2e6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 22 07:52:26 2002 +0000
+
+    (TYPE_SIGNED): Remove.
+    (INT_STRLEN_BOUND): Don't use TYPE_SIGNED; that way, the macro works
+    for either a type or an object.
+
+commit d8c6a49f1a250041d54b8551f904c91b7a2eec61
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Aug 12 07:38:20 2002 +0000
+
+    (jm_FUNC_REALLOC): Define HAVE_REALLOC if realloc works.
+
+commit cf8a358fdf17330bd49ff8e1e0d0be74fba7e162
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Aug 12 07:34:43 2002 +0000
+
+    (jm_FUNC_MALLOC): Define HAVE_MALLOC if malloc works.
+
+commit f7a75bc37a8d5a027f3c2a4519a4db42b5fab7d9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Aug 7 09:10:36 2002 +0000
+
+    Snapshot before syncing with gnulib again.
+
+commit eb2b167bece3a06cdfea7d956796a89931e5813c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Aug 4 11:15:53 2002 +0000
+
+    Switch to GPL.
+
+commit da7959d1e0cba81ac77d545a12c328d358f490f9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jul 1 14:19:20 2002 +0000
+
+    Include sys/time.h; from Volker Borchert.
+
+commit 6d38b808b9b4ab7d5d0685d6d21885af60c51038
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Jun 28 07:00:15 2002 +0000
+
+    (AC_INIT): Version 2.8.4.
+
+commit a352f09806a8606b4bbec07048da6762ce7d9afa
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Jun 28 06:58:59 2002 +0000
+
+    (briefly_report): Don't say "Binary files differ", since one
+    of the files may not be a binary file.
+    Bug reported by Dan Jacobson.
+
+commit f8d4015e3620ad843e0a73649b2ba0cb91c2c5e5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Jun 22 13:29:17 2002 +0000
+
+    (segv_handler, c_stack_action) [! defined SA_SIGINFO]:
+    Do not assume SA_SIGINFO behavior.
+    Bug reported by Jim Meyering on NetBSD 1.5.2.
+
+commit 932176da4ca083c0b07a60bd20d830b14a058a86
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 07:19:01 2002 +0000
+
+    Version 2.8.3.
+
+commit ee74fb1947e525b09250821aec95c0fdca5efae2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 07:15:20 2002 +0000
+
+    Add en_US.
+
+commit 5ac585d8c000be958b4c2a78f8c39d4aed769ee7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 07:03:37 2002 +0000
+
+    Translate "Torbjorn".
+
+commit 00ec5e4806c0645feb6c33c38e06bc58f32fcac2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 07:03:37 2002 +0000
+
+    Initial revision
+
+commit 886c533f81c3058448260622ab3bfbe494ce3978
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 06:45:46 2002 +0000
+
+    Include version-etc.h, not freesoft.h.
+    (copyright_notice): Remove.
+    (main): Use version_etc to print version.
+    (version_string): Remove decl.
+
+commit d6a560a408345cd86e74fe70b52aaff2dfef985f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 06:31:13 2002 +0000
+
+    Remove lib/freesoft.c.
+    Add lib/file-type.c, lib/version-etc.c, lib/xmalloc.c.
+
+commit 12e1995d935c1d981042eb5927bc7906f4addfdd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 05:55:42 2002 +0000
+
+    (version_string): Remove decl.
+
+commit e69f844815d144855bcb1e3d72f4aa7510d2ecd3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 05:55:42 2002 +0000
+
+    Include version-etc.h, not freesoft.h.
+    (copyright_notice): Remove.
+    (main): Use version_etc to print version.
+
+commit b4b207d09d13f30957aa3febf82a9d0da06f5ad9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 05:55:42 2002 +0000
+
+    (cmp_SOURCES, diff3_SOURCES, sdiff_SOURCES, diff_SOURCES):
+    Remove version.c.
+    (MAINTAINERCLEANFILES, $(srcdir)/version.c): Remove.
+
+commit 4ead5e11465e00e3d5bdedaccb921abbb1354974
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 05:55:42 2002 +0000
+
+    (noinst_HEADERS): Remove freesoft.h.
+    Add version-etc.h.
+    (libdiffutils_a_SOURCES): Remove freesoft.c.  Add version-etc.c.
+
+commit b0ec6101bdde2c10f43c65da03539c878345892d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 05:55:42 2002 +0000
+
+    (version_etc): Remove package and version args.
+    (version_etc_copyright): Remove.
+
+commit cb95fdb5a348237bb84846202ce6d213f7d46327
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 05:55:42 2002 +0000
+
+    (version_etc): Remove package and version args.
+    (version_etc_copyright): Remove.
+    Do not include unlocked-io.h; no longer needed.
+    Include gettext.h rather than libinto.h.
+    (_): Define unconditionally.
+    (version_etc): Adjust wording to match current GNU coding standards.
+    Translate "(C)" if possible.
+
+commit 0c3f74704f4525d9a6e55b27c791688e312573c7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 05:55:42 2002 +0000
+
+    (Special Files): Document behavior of symlink loops.
+
+commit 588fadc48e9ab796859ac6d41928cbbc982465b1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 05:52:49 2002 +0000
+
+    (AC_INIT): Version 2.8.3.
+
+commit 54b2d5d20f17f17dbd7f3198fd7940573355623e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 17 05:52:49 2002 +0000
+
+    Update to automake 1.6.2.
+
+commit edd7dd52ff64c0bbb05198a7fb6cc8cd9b164ad4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Jun 12 06:06:47 2002 +0000
+
+    (WIDE_CHAR_SUPPORT): New macro.  Use it uniformly instead of
+    (defined HAVE_WCTYPE_H && defined HAVE_WCHAR_H).  It also depends
+    on HAVE_BTOWC.
+
+commit 4b89533a437ec6309014174b534c28a9178a2777
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 12:13:01 2002 +0000
+
+    (readnum): Fix autoincrement typo.
+
+commit d327549393709d88696313ba55aece1c29861549
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 11:59:47 2002 +0000
+
+    Check for HAVE_SIGALTSTACK and HAVE_GETCONTEXT, too.
+
+commit faf225b9c68c5a42b6958f712336255fabfa1316
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 11:56:33 2002 +0000
+
+    Don't assume uintmax_t.  Check for getcontext and sigaltstack existence,
+    too.
+
+commit 536f11749bab2eee07d0e2c635ca9e6195663bee
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 11:22:20 2002 +0000
+
+    Don't invoke AC_FUNC_FNMATCH_GNU with an argument.
+
+commit 94bad85d38ad8570928cc6d609871a2de1c26e27
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 11:20:13 2002 +0000
+
+    Trim trailing white space.
+
+commit 65dbacedda1323bda3b04326110c08bed4756627
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 11:18:52 2002 +0000
+
+    Fix trailing white space.
+
+commit 1886715b4b613d1f049a298e6e0b808b49bc6845
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 11:15:03 2002 +0000
+
+    Translate (C).
+
+commit 1027af18b661bf6e24a9153dcfe5395db98351e9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    (finish_output): Check for ENOEXEC.
+    (lines_differ, output_1_line): New option --tabsize=COLUMNS.
+    (analyze_hunk): If -b or -w is also specified, -B now considers
+    lines to be empty if they contain only white space.
+
+commit 4ddc54cbc5ad3e54dceaa5b53b83467a24ec2254
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    *** empty log message ***
+
+commit 0a49c9797c2f508e62fbd06541ea7664cafc7efc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    (tab_from_to, print_half_line, print_1sdiff_line):
+    New option --tabsize=COLUMNS.
+
+commit d11594d81392ef8f68131fe9c6c846c106b22036
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    Include <file-type.h>.
+    Include paths.h.
+    (copyright_notice): Renamed from copyright_string.
+    Now a msgid, so that copyright symbol can be translated.
+    All uses changed.
+    (catchsig, signal_handler, initial_action): Signal handlers return void,
+    not RETSIGTYPE, since we no longer support K&R.
+    (TABSIZE_OPTION): New constant.
+    (longopts, usage, main): New option --tabsize=COLUMNS.
+    (cleanup): New arg signo.  All uses changed.
+    (ck_editor_status, main, edit): Don't worry about ENOEXEC.
+
+commit 22efb75195447a35bcdcd7c48b08edc679b55340
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    Include <file-type.h>.
+    (find_and_hash_each_line): New option --tabsize=COLUMNS.
+
+commit 1572db90e55550ce98478386da6293db999c7991
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    Include <file-type.h>.
+    Include paths.h.
+    (copyright_notice): Renamed from copyright_string.
+    Now a msgid, so that copyright symbol can be translated.
+    All uses changed.
+    (skipwhite, readnum): New functions.
+    (process_diff_control): Use them.
+    (SKIPWHITE, READNUM): Remove.
+    (read_diff): Don't worry about errno == ENOEXEC.
+
+commit b4d2d2b865f4562f3c47114a7e750939802a805d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    (TAB_WIDTH): Remove.
+    (tabsize): New decl.
+    (sdiff_half_width, sdiff_column2_offset): Now size_t rather than
+    unsigned int.
+
+commit 208896a9c327459761e27170ae0f293550981dbf
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    Include <file-type.h>.
+    Include paths.h.
+    (copyright_notice): Renamed from copyright_string.
+    Now a msgid, so that copyright symbol can be translated.
+    All uses changed.
+    Include posixver.h.
+    (TABSIZE_OPTION): New constant.
+    (main): Allow widths up to SIZE_MAX.
+    (filetype): Move to lib/file-type.c and rename to file_type.
+    All uses changed.
+    (longopts, main, usage): New option --tabsize=COLUMNS.
+
+commit b2b34cb3be44f7e2f2a41aa890619b94cca85a78
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    Include <file-type.h>.
+    Include paths.h.
+    (copyright_notice): Renamed from copyright_string.
+    Now a msgid, so that copyright symbol can be translated.
+    All uses changed.
+
+commit 2aab82acbe56ab6fad747994b6ee7231dd3d6ce5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    Include <file-type.h>.
+
+commit a1ef5140b61e798296a87b60a0a0461e8989f462
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    (noinst_HEADERS): Remove diff.h.
+    (DEFS): Remove.
+    (diff_sources): Add diff.h.
+    (MOSTLYCLEANFILES): New macro.
+    (cmp.$(OBJEXT) diff3.$(OBJECT) diff.$(OBJECT) sdiff.$(OBJECT)): Depend
+    on paths.h.
+    (paths.h): New rule.
+
+commit 5b713e8dd605e2c2b7ddc2629305009e3c755a38
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    Add hu, pt_BR.
+
+commit 0d1e55b956643e0554d2fc4f075497e03b82a80d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    (AC_HEADER_STDBOOL): Do not cast pointer to
+    bool in integer constant expression; C99 does not allow it.
+
+commit 70c7ef8c86d183076f9dcd80f3ddf41df8d97f25
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    (jm_PREREQ_QUOTEARG): AC_MBSTATE_T -> AC_TYPE_MBSTATE_T.
+
+commit 6756cc93587506482ff6c85d4ee22cf6b3702b77
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    Update to latest Autoconf CVS for AC_GNU_SOURCE
+    (renamed from AC__GNU_SOURCE).
+
+commit f4468d980da9386fd8866b038f98eaecf02d8513
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    (jm_PREREQ_C_STACK): Do not AC_REQUIRE jm_AC_TYPE_UINTMAX_T.
+    Check for sys/resource.h, uccontext.h.
+    Check for decls of getcontext, sigaltstack.
+    Check for stack_t.
+
+commit aa5475b6b4e5d4e4b50c7c90c524b06b03ff9272
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    Include posixver.h.
+
+commit bf641a954266b8b01c44aec876777867efa49e9d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 06:06:32 2002 +0000
+
+    (struct patternlist.str): Size 1, not 0, as C89 requires this.
+    (NEW_PATTERN): Use offsetof, not sizeof, since str now has size 1.
+
+commit 229fb658714487a3e8de3535274dadc86bb4cde4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 05:53:54 2002 +0000
+
+    (AC_INIT): Version 2.8.2.
+    (AC_GNU_SOURCE): Move up, so that it affects later compilations properly.
+    (DEFAULT_DIFF_PROGRAM, AC_TYPE_SIGNAL): Remove.
+    (jm_AC_TYPE_INTMAX_T): Add.
+    (AC_FUNC_FNMATCH_GNU): Use this, instead of AC_FUNC_FNMATCH.
+    (AC_CONFIG_LINKS): regex.hin renamed from regex_.h.
+
+commit 8578be467d873454a08ba86e3c840f0dda48ae90
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 05:53:54 2002 +0000
+
+    Incorporate contents from INSTALLME.  Upgrade to help2man 1.28.
+
+commit d67b77f4306960b8233ef75ee32f95d92eb29801
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 05:53:54 2002 +0000
+
+    Version 2.8.2.
+
+commit 1fe83a59f8a6c6c48cd842ead12dc70663067998
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 05:53:54 2002 +0000
+
+    (EXTRA_DIST): Remove INSTALLME.
+
+commit bb9cc01d988adfbf8928d040fbd29d6b953fe158
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 05:53:54 2002 +0000
+
+    (EXTRA_DIST): Add fnmatch_loop.c.
+    (noinst_HEADERS): fnmatch_.h renamed from fnmatch.hin.
+    regex_.h renamed from regex.hin.
+    Add file-type.h.
+    (libdiffutils_a_SOURCES): Add file-type.c.
+    (DISTCLEANFILES): Remove fnmatch.hno, regex.hno.
+
+commit 9e4cdf9d2ceac4e2599c50523c14f544e0015a6d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 05:53:54 2002 +0000
+
+    (__const): Do not define to empty, as this breaks
+    Sun cc.  The code doesn't work with K&R anyway.
+
+commit 871e480cf6d7be4c0ffa60703cb8e558b55e5944
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 05:53:54 2002 +0000
+
+    (alloca, __builtin_expect): Define for non-GCC hosts.
+    <strings.h>: Include only if HAVE_STRINGS_H.
+    <stddef.h>: Include if we include stdlib.h.
+    Do not comment out all code if ! HAVE_FNMATCH_GNU.
+    (getenv): Do not declare if HAVE_DECL_GETENV.
+    (__strchrnul, __wcschrnul): Remove; not used.
+    (MEMPCPY): Use mempcpy if not _LIBC; use memcpy if neither _LIBC
+    nor HAVE_MEMPCPY.
+    (FOLD) [HANDLE_MULTIBYTE]: Do not pass wide char to ISUPPER.
+    (STRLEN, STRCAT, MEMPCPY) [HANDLE_MULTIBYTE && !defined _LIBC]:
+    Use wcslen rather than __wcslen, and likewise for wcscat, wmempcpy.
+    (MEMPCPY) [HANDLE_MULTIBYTE]: Use wmempcpy if not _LIBC; use wmemcpy
+    if neither _LIBC nor HAVE_WMEMPCPY.
+
+commit a9a0f5a47ba0a86cbdbaccb17951a7b612741bf5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 05:53:54 2002 +0000
+
+    (siginfo_t, c_stack_die): Remove decl.
+
+commit 88ead7550596dfef16049c68f65b5e70bd1395cd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 05:53:54 2002 +0000
+
+    (__attribute__): New macro.
+    (EOVERFLOW): Define if not defined.(stack_t): Define to struct sigaltstack if not defined or declared.
+    Include <sys/resource.h>, <ucontext.h> if available.
+    Include <stdio.h> if DEBUG.
+    Do not include <inttypes.h> or <stdint.h>.
+    (c_stack_die): Remove info and context args.  All uses changed.
+    (segv_action): Likewise.
+    (alternate_signal_stack): Change uintmax_t to long, to ease porting.
+    (get_stack_location, min_address_from_argv, max_address_from_argv,
+    null_action): New functions.
+    (stack_base, stack_size): New vars.
+    (segv_handler): context arg may not be used.
+    Use global stack_base, stack_size if
+    ! HAVE_XSI_STACK_OVERFLOW_HEURISTIC.
+    Add debug code.
+    Invoke die (rather than segv_action) to exit.
+    (c_stack_action): Accept new argv arg, and simpler handler arg.
+    All uses changed.  Move code into new functions above.
+    Allow null action.
+    [! (defined SA_ONSTACK && defined _SC_PAGESIZE)]: Assume all segvs
+    are stack overflows.
+    (main) [DEBUG]: Describe what output should be like.
+
+commit 6cce27301e62cc6ce0aa6896ffcc1fba43a10b39
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jun 11 05:53:54 2002 +0000
+
+    Reword "@option{-f} and @option{--foo}" to "@option{-f} or @option{--foo}".
+    Use @acronym instead of @sc where appropriate.
+    (Specified Lines): Renamed from Specified Folding.
+    (Comparison, Blank Lines):
+    Clarify wordings for Blank Lines and Specified Lines nodes.
+    (Binary): Mention --verbose and --print-bytes.
+    (Tabs, sdiff Option Summary, diff Options):
+    New option --tabsize=COLUMNS.
+
+commit 3c8ae4bdc186ef5ee25ebe47d2718c8e7227d008
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jun 10 08:04:33 2002 +0000
+
+    Convert to new autoconf.
+
+commit 735b377bbdb5385c533fbd910359b9b5fbb8ba9b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat May 25 10:34:07 2002 +0000
+
+    (jm_PREREQ_EXCLUDE): Use AC_FUNC_FNMATCH_GNU.
+    (jm_PREREQ_QUOTEARG): AM_C_PROTOTYPES -> AC_C_PROTOTYPES.
+
+commit a1fdcabe77b73cf3131c7c9372755c6dd280b20e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri May 10 11:20:06 2002 +0000
+
+    Initial revision
+
+commit e2e1c72458808505888bfd037e030be0c6a1fc64
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Apr 25 21:55:16 2002 +0000
+
+    Check for false and true values in preprocessor expressions.
+
+commit b68181fadb5995369e4eb5258f11dcc263ebd8c7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Apr 21 04:35:32 2002 +0000
+
+    Update to Automake 1.6.1.
+
+commit 3977399600bd39600c19f76410ac485eade0ab04
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Apr 9 17:55:36 2002 +0000
+
+    Initial revision
+
+commit 384ece6125c1d7f941c9afdc5420c1e0f8c5eb3d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 8 18:56:39 2002 +0000
+
+    (__restrict_arr): Define for GCC 3.1 and up.
+
+commit 23447f11cd30a9146194535cd24dbfd326702ea6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    (AC_INIT): Version 2.8.1.
+    (AC_HEADER_STDBOOL): Add.
+    (AC_CHECK_HEADERS): Remove stdbool.h.
+
+commit 52dd0175b9162ac5de7fb0f7743982b586800d41
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    Add Ulrich Drepper.
+
+commit 4921a4ab37be351e7b0e6b6f8fa95692a0394e5e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    Doc fixes in 2.8.1.
+
+commit a07c16a6f30ee48431a3d983cbb76cbd7faac2c5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    (SSIZE_MAX): Define if limits.h doesn't.
+
+commit 869386e545a4569fec82ea14efceefe1976d097c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    Include cmpbuf.h.
+    (read_diff): Use block_read instead of read, to work around Tru64 5.1 bug.
+
+commit e3c53fd2ffd9ce6038a435af784da55b785ffae6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    (cmp): Use block_read instead of read, to work around Tru64 5.1 bug.
+
+commit 4f9d18c728e3c5161ffa3f34c91e3dc12f12229b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    Assign PTRDIFF_MAX - 1 to a size_t variable, just in case there's a problem
+    with ptrdiff_t versus size_t.
+
+commit 0be3e22c88468137b418c833b1ef6a31fa9290b3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    (datadir, INCLUDES): Remove.
+    (AM_CPPFLAGS): New macro.
+
+commit bea637acb3fd1df8bb51634bd05c0c3cae1e3d8a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    Initial revision
+
+commit c7448142e8cfbc6c458b9f70b6bad67b097a49ad
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    (jm_PREREQ_EXCLUDE): Use AC_HEADER_STDBOOL rather than AC_CHECK_HEADERS(stdbool.h).
+    (jm_PREREQ_HASH): Likewise.
+
+commit a758e82c032307554e827eae4d017113cab4b1f7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    (errno): Remove declaration; K&R C is obsolete.
+    Include limits.h.
+    (SIZE_MAX, SSIZE_MAX): Define if standard headers don't.
+    (MIN): New macro.
+    (block_read): Do not attempt to read more than SSIZE_MAX bytes, as the
+    resulting behavior is implementation-defined.  Work around bug in
+    Tru64 5.1, which can't read more than INT_MAX bytes at a time.
+
+commit e21807a095fb6db7ce208b43e54f7d6cc8762247
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    Use new @copying directive.  Work around incompatibility with Debian
+    install-info.
+    Put @contents first, not last, since Texinfo now suggests this.
+    Fix bug in -w documentation noted by Karl Berry.
+    Mention links for speedup.
+    New node "Speedups" for future speedups.
+    Just say "Index", not "Concept Index".
+
+commit 9ca86332609254e0ad957e7524d25b442ff60ec2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 5 20:37:31 2002 +0000
+
+    Mention GNU texinfo.
+
+commit 8074c424b524873712e3cce26a1ca302b7927f9e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 25 04:58:36 2002 +0000
+
+    (sip): Do not mishandle buffered count when reverting to text mode.
+
+commit 79a1780c886394cf7a423606ff1230fa04bdc1ca
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Mar 24 07:50:25 2002 +0000
+
+    Upgrade the description of `patch' to GNU patch 2.5.4, and revamp
+    the documentation accordingly.
+
+commit a888728c15b0d5b1a9edb63c281ead02938542cc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Mar 24 07:48:39 2002 +0000
+
+    (AC_INIT): Version 2.8.
+    (AC_PREREQ): 2.53.
+
+commit a9d6b567a0d30c144d003a93321891f736bdef31
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Mar 24 07:46:58 2002 +0000
+
+    Diffutils 2.8.
+
+commit d3a786ee18774379e976c3c8fde2fd1cadf472ca
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Mar 24 07:40:52 2002 +0000
+
+    Upgrade to gettext 0.11.1 and help2man 1.27.
+
+commit 78899f4efb372cba80dca7f970c6744b1eb4f4c4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Mar 24 07:36:37 2002 +0000
+
+    (c_stack_die) [!HAVE_SIGINFO_T]: Don't use info.
+    Bug reported by Eli Zaretskii.
+
+commit f581b40bf9c058223186ed2bb554ae8d5ad87a35
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Mar 24 07:35:28 2002 +0000
+
+    (main): Fix typo that prevented diff -y from working.  Bug reported by
+    Mitsuru Chinen.
+
+commit 855c8786ae73c5078b5248f7c26c97d816f944ed
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Mar 15 22:07:58 2002 +0000
+
+    Tweak editing of install-info-am target.
+
+commit 10baaae888f0f9e70ef7e7665ea33c20591e1617
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 12 13:08:22 2002 +0000
+
+    (cmp): Fix typos in previous change.
+
+commit 7bbd6de9bca5f9be4122984dbc6ccc6754c91765
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 12 13:03:58 2002 +0000
+
+    Use "byte" rather than "char" if a translation for "byte" is available.
+
+commit 3115963776ec53e46ba6da6a1fd8f7df01a8e039
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 12 07:17:13 2002 +0000
+
+    Bring back --horizon-lines.
+
+commit 89b6f2d6e560f2cf3e16c1dbc1c7fdbe0700f33d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 12 07:16:19 2002 +0000
+
+    cmp -l -s and cmp -s -l are not allowed.  Use cmp -s or cmp -l instead.
+    Deprecate diff -h, -H, -L, -P, --inhibit-hunk-merge.
+
+commit c19f0389186ef8990657d3fb253e72641c9ea2d3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 12 07:14:31 2002 +0000
+
+    (option_help_msgid): Bring back --horizon-lines documentation.
+
+commit fa03d1fdfbcb50aa07445b5df7cdbb14b496f342
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 12 06:50:10 2002 +0000
+
+    (AC_INIT): Version 2.7.10.
+    (jm_PREREQ_HARD_LOCALE): Add.
+
+commit d950765db33214a06f0a9512396e5f8cf532f2f8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 12 06:34:28 2002 +0000
+
+    -L -> --label
+
+commit d8a86d88b2d0777d3d13e4bf76e52202974b4f48
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 12 06:34:28 2002 +0000
+
+    (option_help_msgid): Do not document -L, -P, --horizon-lines,
+    --inhibit-hunk-merge, -H.
+
+commit 9f0dae504667a7369cfdb1d8bcfd69bbeec78659
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 12 06:34:28 2002 +0000
+
+    (specify_comparison_type): New function.
+    (check_stdout): "indices and codes" -> "byte numbers and values"
+    (main): Use specify_comparison_type to detect option clashes.
+
+commit 1d63e8c4d1574ceddfd86ded8da35fca45af577d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 12 06:34:28 2002 +0000
+
+    (jm_PREREQ): Add jm_PREREQ_HARD_LOCALE.
+    (jm_PREREQ_HARD_LOCALE): New macro.
+
+commit 0d3dcc25e737e4429adcc663b39b3a876f84657e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 12 06:34:28 2002 +0000
+
+    (alloca): Remove.
+    Include stdlib.h if available, for malloc.
+    (hard_locale): Use malloc, not alloca.  Test for storage allocation failure.
+
+commit 8fe985d9880461be41f90f60672daea5eed736cf
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Mar 12 06:34:28 2002 +0000
+
+    (Overview): byte != character.
+    (Detailed Context, Detailed Unified, Alternate Names, diff Options): Do not document diff -L.
+    (Comparing Directories): Do not document diff -P.
+    (Making Patches, diff Options): Likewise.
+    (diff Performance, sdiff Option Summary, diff Options, sdiff Options): Do not document diff -H.
+    (diff Performance, diff Options): Do not document --horizon-lines.
+    (cmp Options): Prefer -b to -c.
+    (cmp Options, diff Options, diff3 Options, sdiff Options): Put short
+    options next to the similar long options.
+    Document --help, and use the same wording for --verbose on all commands.
+    (diff3 Options): Fix typo in description of -E, which used wrongly used
+    "-e" instead of "-E".
+    (patch Options): Put short options next to the similar long options.
+
+commit 2839f50782cc5757a03caa671bb82028edb0a0f2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 08:37:01 2002 +0000
+
+    Do not distribute shar file.
+
+commit db6505cbe52329d36717f52d1ba013dbf30dd61b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 08:23:30 2002 +0000
+
+    Initial revision
+
+commit 91bee6760695a602ba855ffd3e1339f6056e7865
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 08:00:47 2002 +0000
+
+    (option_help_msgid, usage): Reword for help2man.
+
+commit 68f96e5cd777642bec7b1d9e0fd5345796c95586
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 08:00:47 2002 +0000
+
+    Remove trailing white space.
+
+commit 4f981362a7a3074f1216cfb8060075b256b1cda1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 08:00:47 2002 +0000
+
+    (option_help_msgid): Reword for help2man.
+
+commit d001fbedbe556f6ad3139d86350a502ab3dee29b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 08:00:47 2002 +0000
+
+    (usage): Reword for help2man.
+
+commit dbea9821b7e9fe612becb6ce2041e7f7720e2c05
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 08:00:47 2002 +0000
+
+    (AUTOMAKE_OPTIONS): Remove.
+
+commit 796ad2bc350bb9d5c6d57870e2450d0a37d694b5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 08:00:47 2002 +0000
+
+    Add zh_TW.
+
+commit b3dabc957103be5a3ec304696bd558ec940fd670
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 08:00:47 2002 +0000
+
+    (AUTOMAKE_OPTIONS): Remove gnits.
+
+commit 6d9d2036a21790ec48b34948a1099c8b20718e24
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 08:00:47 2002 +0000
+
+    (AC_SYS_XSI_STACK_OVERFLOW_HEURISTIC): Change wording of message.
+    Do not check for stdbool.h or ucontext.h, or for ucontext_t or
+    sigaction or sigaltstack.
+
+commit 1e15bf9664e3d40ced7875a46fc00bd3a35b6296
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 08:00:47 2002 +0000
+
+    Include <errno.h>
+    (ENOTSUP): Define if errno.h doesn't.
+    (SA_NODEFER, SA_ONSTACK, SA_RESETHAND, SA_SIGINFO, SIGSTKSZ, _SC_PAGESIZE,
+    ALTERNATE_STACK_SIZE, stack_t, sigaltstack): Remove; we now assume them
+    all when HAVE_XSI_STACK_OVERFLOW_HEURISTIC, so we don't need substitutes.
+    (<ucontext.h>): Include only if HAVE_XSI_STACK_OVERFLOW_HEURISTIC.
+    (alternate_signal_stack): Now of size SIGSTKSZ, not ALTERNATE_STACK_SIZE.
+    (segv_handler): Simplify, under the assumption that
+    HAVE_XSI_STACK_OVERFLOW_HEURISTIC is nonzero.
+    (c_stack_action): Likewise.
+    (exit_failure) [DEBUG]: Initialize to 0, not 1.
+    (recurse, main) [DEBUG]: Remove main args.
+
+commit 1ada67d90b1f55e10dfe2f4ea646855b963a9274
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 07:09:22 2002 +0000
+
+    (AC_INIT): Change package name from diff to diffutils.  Bump version
+    to 2.7.9.
+    (AM_INIT_AUTOMAKE): Use new form, with options gnits dist-shar,
+    rather than old from that duplicated AC_INIT.
+    (AM_MISSING_PROG): Add help2man.
+    (REGEX_MALLOC): Define.
+    (AC_CONFIG_FILES): Add man/Makefile.
+
+commit f88dc3e8ed068be29a0f96c1213f143ead9c61e8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 07:08:45 2002 +0000
+
+    Add man pages.
+
+commit 3ec1124c9faf779d7bf99dac29aa09f88ec98417
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 07:07:05 2002 +0000
+
+    (AUTOMAKE_OPTIONS): Remove.
+    (SUBDIRS): Add man.
+
+commit f28f42d6d6f29b5835cdb7c4c91701cfb6e56f62
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Mar 11 07:07:05 2002 +0000
+
+    Update to autoconf 2.53, automake 1.6, help2man 1.25 with patch.
+     .
+
+commit b89a1f4f2cba1a0f1d5357fd7fb11666b35f9eed
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Mar 2 11:56:17 2002 +0000
+
+    Tweak editing of install-info-am and
+    uninstall-info-am targets, to include 8+3-butchered names of Info
+    files.
+
+commit a0303415a5f3500f2246f5fb36748fe2eeb5f50c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Mar 1 19:46:11 2002 +0000
+
+    Remove trailing white space
+
+commit 6e1f365f51d8d682047721b5041d362ce0914563
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Mar 1 07:42:20 2002 +0000
+
+    Initial revision
+
+commit be90df3756ef94bb38b8256078fd9fb99303bf78
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 08:05:12 2002 +0000
+
+    Include <xalloc.h>.
+
+commit 56e47cdf45fd4cfe528d9bb802d7535fd895493f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 08:05:12 2002 +0000
+
+    (LONG_OPTION, GROUP_FORMAT_OPTION, LINE_FORMAT_OPTION): Remove.
+    (longopts): Revert to prevision version.
+
+commit 145637ede6ef151716c0ed602f17ed6f3b02f994
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 07:35:36 2002 +0000
+
+    Reword to put POSIX first.
+
+commit aa3a3c3a118c8869416a3c39ab4851bb9881e030
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 07:26:14 2002 +0000
+
+    diff -NUM is now deprecated.
+    diff now takes the maximum of the specified contexts.
+    Conflicting options now cause an error again.
+    "Microsoft OSes" -> DGJPP
+
+commit 2fb91b7373594ad082b9362944e34249f20bfe82
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 06:32:34 2002 +0000
+
+    (AC_INIT, AM_INIT_AUTOMAKE): Version 2.7.8
+    (AC__GNU_SOURCE): Add this, replacing AH_VERBATIM of _GNU_SOURCE.
+    (AM_GNU_GETTEXT): Add external arg, from gettext 0.11.
+    (tempname): Use AC_LIBOBJS, not LIBOBJS=, as now required by autoconf.
+    (jm_PREREQ_C_STACK): Add.
+    (AC_CONFIG_FILES): Remove intl/Makefile.
+
+commit de95c16082c62034ac0b034e71684b43ddc499f7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 05:22:26 2002 +0000
+
+    2 -> EXIT_TROUBLE.
+    Adopt POSIX convention for ENOEXEC and exit status 126.
+    unsigned -> unsigned int
+
+commit 52fbd2fdd450db3285b5df0754a537e81f16e057
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 05:22:26 2002 +0000
+
+    Don't use alloca or include <alloca.h>.
+    unsigned -> unsigned int
+    (EXIT_SUCCESS, EXIT_FAILURE, EXIT_TROUBLE): Define if not defined.
+    Include signal.h.
+    (SA_RESTART): Define if not defined.
+    (SIGCHLD): Likewise.
+
+commit 3064374e471e327d5e298176f9606fcbd9197b73
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 05:22:26 2002 +0000
+
+    unsigned -> unsigned int.
+
+commit 0d7a3eb7ac6f51ac0e4484f9c4fce89d008905ec
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 05:22:26 2002 +0000
+
+    Include c-stack.h, exitfail.h.  Do not include signal.h.
+    0 -> EXIT_SUCCESS, 1 -> EXIT_FAILURE, 2 -> EXIT_TROUBLE.
+    (ck_editor_status): New function.
+    (main): Check for stack overflow.
+    Adopt POSIX convention for subsidiary programs not found.
+    (diffarg): Check for integer overflow to avoid core dumps.
+    (trapsigs): Remove SA_INTERRUPT special case; now done by header.
+    (SIGCHLD): Likewise.
+    (edit): Adopt POSIX convention for subsidiary programs not found.
+
+commit 4179042755cc919ce8d9b8043cd7e60515f36b30
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 05:03:41 2002 +0000
+
+    (sip): Avoid integer overflow and core dumps if buffer alignments are
+    preposterously incompatible.
+    (slurp): Do not dump core if the file is growing as we read it.
+    If a regular file grows, keep reading until we catch up with its EOF.
+    (find_and_hash_each_line): Check for integer overflow to avoid core dumps.
+    (GUESS_LINES): Remove.
+    (guess_lines): New function.  Avoid integer overflow.
+    (find_identical_ends): Use it.
+    Avoid integer overflow and possible core dumps.
+
+commit 9d39ee103c4ba56fc584ee877a800e3a57312183
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 05:03:41 2002 +0000
+
+    (format_group, print_ifdef_lines): Avoid core dumps with
+    bad formats.
+    (do_printf_spec): Avoid alloca.
+
+commit 1ae253c28bd45fb808e3ba5d5a27d7a7781fdf86
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 05:03:41 2002 +0000
+
+    (dir_read): Ignore st_size of directories: POSIX says it's garbage.
+    Check for integer overflow to avoid core dumps.
+    (diff_dirs): 0 -> EXIT_SUCCESS, 2 -> EXIT_TROUBLE.
+
+commit 309c90b06bd95d1b1a9dc3f418d60b0c01ad8dd8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 05:03:41 2002 +0000
+
+    Include c-stack.h, exitfail.h.
+    (ALLOCATE): Remove.  All uses changed to xmalloc, or to xmalloc plus
+    an overflow check.
+    (myread): Remove.
+    (main): Check for stack overflow.
+    0 -> EXIT_SUCCESS, 1 -> EXIT_FAIULRE, 2 -> EXIT_TROUBLE.
+    (try_help): Likewise.
+    (process_diff): Check for integer overflow, to avoid core dumps.
+    2 -> EXIT_TROUBLE.
+    (read_diff): Exit with status 126 if the file is not executable,
+    for compatibility with POSIX 1003.1-2001.
+    Accommodate ancient AIX hosts that set errno to EINTR after uncaught
+    SIGCONT.
+    Check for integer overflow to avoid core dumps.
+    (fatal, perror_with_exit): 2 -> EXIT_TROUBLE.
+
+commit 8a8172ed6d1018777adcf0a4d8e542c89b62a2db
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 05:03:41 2002 +0000
+
+    Include c-stack.h, exitfail.h.
+    Do not include signal.h.
+    (specify_style, specify_value): Bring these routines back, as POSIX
+    requires that the order of options not matter.
+    (shortopts): New constant.
+    (group_format_option, line_format_option): New constants.
+    (LONG_OPTION, GROUP_FORMAT_OPTION, LINE_FORMAT_OPTION): New macros.
+    (longopts): Use them.
+    (main): 0 -> EXIT_SUCCESS, 1 -> EXIT_FAILURE, 2 -> EXIT_TROUBLE.
+    Ensure that order of options does not matter.
+    Check for stack overflow.
+    If contexts overflow, substitute LIN_MAX, as that's good enough.
+    If multiple contexts are specified, use their maximum.
+    -c is equivalent to -C 3 now, instead of having an implicit context;
+    likewise for -u and -U 3.
+    Use specify_style and specify_value.
+    (SIGCHLD): Do not define; now done in a header.
+    Use new style time stamp format for -u / -U.
+    Reject numeric-string options if operating in POSIX 1003.1-2001 mode.
+    Avoid overflow problems with tab width.
+    Simplify from-file and to-file code.
+    (usage): Do not mention obsolete options.
+    (filetype): Do not mention whether a file is executable.
+    Add typed memory objects.
+    (compare_files): 0 -> EXIT_SUCCESS, 1 -> EXIT_FAILURE, 2 -> EXIT_TROUBLE.
+
+commit c959ef623200eb155fd7b3922b45d6a05473d627
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:48:46 2002 +0000
+
+    (pr_context_hunk): Do not dump core if an enormous context causes an
+    arithmetic overflow.
+    (pr_unidiff_hunk): Likewise.
+    (find_hunk): Likewise.
+
+commit 4aae6ffeaf06ddbe087ab7240f004a21d29053ff
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:48:46 2002 +0000
+
+    Include c-stack.h, exitfail.h.
+    (hard_locale_LC_MESSAGES): Depend on ENABLE_NLS.
+    (try_help, check_stdout, main, cmp): 2 -> EXIT_TROUBLE.
+    (main): Check for stack overflow.
+    0 -> EXIT_SUCCESS.
+    1 -> EXIT_FAILURE.
+    (cmp): Likewise.
+    Accommodate ancient AIX hosts that set errno to
+    EINTR after uncaught SIGCONT.
+
+commit e53339d2dc48207afa94f48d24c3d2aba979b467
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    (diff_2_files): Avoid arithmetic overflow in buffer size calculation.
+
+commit 1035ed370de10d17eb8740297c7e5f869bba309b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    (datadir): @DATADIRNAME@ -> share.
+    (INCLUDES): Remove intl.
+    (LDADD): Change INTLLIBS to LIBINTL.  No need to link libdiffutils.a twice.
+
+commit e7d9579f6a33b24bab7b5f4c797d116968534448
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    Add lib/c-stack.c, src/dir.c.
+
+commit 58166227e9ce53b408123ec4a56603df61a0de6b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    Add cs, ja.
+
+commit 07c7dac163b39bdfc849c3c44e503548f7e1ca0e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    (AC_FUNC_SETMODE_DOS): Check for fcntl.h and unistd.h unconditionally.
+
+commit 570f74da59f3403ea25d43e9d8413a240da40a98
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    (jm_PREREQ): Add jm_PREREQ_POSIXVER.
+    (jm_PREREQ_POSIXVER): New macro.
+
+commit 9f0eff52c22275bc86d26a562a679812c5dd7cdb
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    Initial revision
+
+commit 8d9e3b29bf92b6c9d622475e3eb000e2c62d42cd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    (buffer_lcm): New arg LCM_MAX.
+
+commit 47b633e3cfc658faf4c0e5ab0aa9990c14c64e87
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    Include errno.h.
+    (errno): Declare if !STDC_HEADERS.
+    Include signal.h.
+    (SA_RESTART): Define if not already defined.
+    Include <inttypes.h>.
+    (PTRDIFF_MAX): Define if not already defined.
+    (TYPE_SIGNED, TYPE_MINIMUM, TYPE_MAXIMUM): Likewise.
+    (block_read): Accommodate ancient AIX hosts that set errno to EINTR
+    after uncaught SIGCONT.
+    (buffer_lcm): Return a reasonable size if the multiple is too large.
+    New arg LCM_MAX.  All callers changed.
+
+commit a44befd50b332e152c4beae97fdac417cd214ffa
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    (noinst_HEADERS): Add c-stack.h, exitfail.h.
+    (libdiffutils_a_SOURCES): Add c-stack.c, exitfail.c, quotesys.c.
+    (INCLUDES): Remove.
+
+commit 2e507ad1c092735de058e7e7b7066ecac50269a4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    Include exitfail.h.
+    (xalloc_exit_failure): Remove; subsumed by exit_failure.
+    All uses changed.
+
+commit b89fe19666dfdbf512fb5c9d24db924fd31b468c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    (xalloc_exit_failure): Remove; subsumed by exit_failure.
+
+commit 8eb1bae7000c49615c8ccde9bab35c50070396f9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    Include "hard-locale.h".
+    (hard_locale): Ignore ENABLE_NLS, since we want to operate on
+    locales other than LC_MESSAGES.
+
+commit 3561657de9831ea2750619b86935d18430a27065
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:28:07 2002 +0000
+
+    Add vr index.
+    Update copyright to 2002.
+    (Standards conformance): New chapter.
+    (Binary): Differing binary files are trouble unless the user asked for
+    brief output.
+    (Detailed Context): Prefer new time stamp format in discussion.
+    (Less Context): Likewise.  (Also use short option).
+    (Detailed Unified): Likewise.
+    (Alternate Names): Separate option from arg.
+    (Pagination): Prefer new time stamp format in discussion.
+    (Making Patches): Mention -U 2.
+    (diff Options): Deprecate -LINES, as POSIX 1003.1-2001 does not allow it.
+
+commit 5fcad7569e7edea859fe050d60ca8f1bac5607bb
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:18:53 2002 +0000
+
+    (SUBDIRS): Remove intl.
+
+commit 9fefe1c55909e3aef526522c29d9646812523a4a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Feb 28 04:18:53 2002 +0000
+
+    Update advice for Solaris installation problems.
+    We no longer use a test version of gettext.
+    Autoconf test version updated from  2.52f to 2.52h.
+    POSIX 1003.1-2001 patch for Automake.
+
+commit 38231fc04f4ed6581db50bbd68d22f45a7d7c91d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Feb 16 05:30:19 2002 +0000
+
+    Initial revision
+
+commit 3121d568e22a84e44e7508f3b116185bed77e38c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:48:10 2002 +0000
+
+    Warn about libiconv problems.
+
+commit 0f9e8c67e1c082c4b3a284002796cb0f5da8e15d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:40:17 2002 +0000
+
+    DIFF -> Diffutils
+
+commit 9c2cd387c77c5499932c7c4111dd4dee50d0d1cf
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:35:06 2002 +0000
+
+    Don't say "illegal".  Fix headers to match recent gettext standards.
+
+commit 2d27ca42cda7c727cba1a70c58ff9d9c7422a0b3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    (AC_INIT, AM_INIT_AUTOMAKE): Version 2.7.7.
+    (AC_INIT): Use new 3-arg form.
+    (AC_CONFIG_SRCDIR): Specify src/diff.c here, not in AC_INIT.
+    (ALL_LINGUAS): Remove: now in po/LINGUAS as per Gettext 0.11.
+    (AC_CONFIG_AUX_DIR): New macro invocation.
+
+commit 4b67faa4adaf9b8471caed288dcbbf43cecd5d2e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    Mention INSTALLME.
+
+commit ffaecd082cbb558dc496f5583f53a5e14aab716e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    (AC_INIT, AM_INIT_AUTOMAKE): Version 2.7.7.
+    Reformat for imminent 2.8 release.
+
+commit 6f653ba4711ea25106bdfce5946c4ee2d131a198
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    (EXTRA_DIST): Add config/config.rpath, INSTALLME.
+    (DISTCLEANFILES): Remove.
+
+commit 788366578a517c465ff131c4690e7bef0149d850
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    (finish_output): Ensure that werrno is initialized.
+    (lines_differ): Have an explicit do-nothing case for
+    IGNORE_NO_WHITE_SPACE, to pacify gcc -Wall.
+
+commit 17832e035de3e3a6b59ed901d87d36d156cc80a4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    (UINTMAX_MAX): New macro.
+    Include gettext.h, not libgettext.h.
+    (N_): Do not wrap arg in parentheses.  Fix from Bruno Haible.
+
+commit f8b1a9f4e4b845c5bab4b016213e40eace32215a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    (copyright_string): Update to 2002.
+    (usage): Reformat messages to ease translation.
+    (handler_index_of_SIGINT, handler_index_of_SIGPIPE):
+    New macros.
+    (main): Do not confuse signal numbers with their indices.
+    Bug reported by Bruno Haible.
+    (edit): Cat lin to long before printing with %ld, since lin might
+    be narrow than long.
+
+commit ec7bf151d0ae5b8a92be3354f6783353adb0afd9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    (file_block_read): Use SIZE_MAX instead of (size_t) -1,
+    to avoid warnings on some compilers.
+
+commit 8d25777b1af7332dfb556095d26e5c7c4724796d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    Include <setjmp.h>
+    (struct dirdata): New member nnames.
+    (locale_specific_sorting, failed_strcoll): New vars.
+    (dir_read): Renamed from dir_sort.  Don't sort the dir.
+    Set new nnames member of struct dirdata.  All callers changed.
+    (compare_names): Don't check for errno after strcasecmp.
+    Use strcoll only if locale_specific_sorting is nonzero.
+    If strcoll fails, longjmp out rather than returning a value
+    that might result in an invalid comparison function that might
+    make qsort dump core.
+    (diff_dirs): Sort the directory ourselves.  Use setjmp to recover
+    from strcoll failure, falling back on native byte comparison.
+    Make local variables volatile if they need to preserve their value
+    after setjmp/longjmp.
+
+commit a76d0e1130b4d06d00ec29b237cf1f9a82bd6193
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    (copyright_string): Update to 2002.
+    (usage): Reformat messages to ease translation.
+    (main): Remove unused variable.
+
+commit 89d3f55dd661b9df807fd93617c7ba4f42fa3da3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    (copyright_string): Update to 2002.
+    (bytes, parse_ignore_initial, cmp): Use UINTMAX_MAX
+    instead of (uintmax_t) -1, to avoid warnings on some compilers.
+    (usage): Reformat messages to ease translation.
+
+commit 5289afd403a0c0309eaa0c2ca6cd256facd2b438
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    Include <string.h>.  Reported by Bruno Haible.
+
+commit eadc9ce7d6afaee9bbdcbabde146e6a7536040a1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    Fix comment.
+
+commit 75cd3e885faf8d8ab4f69b884eed11533d94abd4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    (noinst_HEADERS): Add gettext.h.
+
+commit 65da723237e469bfccaf8920355d5f413a1dd044
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    Move most of contents to INSTALLME.
+
+commit 39a4929c852dd49bd4bdd4c438a13cca95022868
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 20:16:38 2002 +0000
+
+    Initial revision
+
+commit 6580226bf62049ab531501429f2ed3d52acf8d59
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 24 02:10:11 2002 +0000
+
+    Initial revision
+
+commit 3f4addd972269b5f93567ed569f3cdf862485713
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Jan 16 12:19:34 2002 +0000
+
+    Initial revision
+
+commit c30fa59166501a8529845b1b5664878cea335112
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Jan 5 21:13:09 2002 +0000
+
+    Initial revision
+
+commit 879669e496b3749942de106860a1d738bfc35ad3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 31 23:05:35 2001 +0000
+
+    (interact): After extracting rlen from the editor command, test for a
+    terminating null character, not for a newline.
+
+commit 2bc51c81cb21b206b57e9466d49e84f2ed7ae5dc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 31 23:05:01 2001 +0000
+
+    Fix AC_CONFIG_LINKS for when symlinks are unavailable.
+
+commit c6228a86aff93d1374085be36f0051240afd5ece
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 31 23:04:26 2001 +0000
+
+    Allow longer source directory names without
+    overflowing the line length limits.  Create the cache in the
+    build directory, not in the source directory
+
+commit 5b9b018b29a6d76ac8c5a1d07d168618898a761f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 24 02:03:34 2001 +0000
+
+    * New diff3 and sdiff option: --diff-program=PROGRAM.
+    * The test-version environment variables DIFF_OPTIONS and DIFF_PROGRAM
+      have been withdrawn, as they caused compatibility problems.
+      You can use aliases or shell script wrappers instead.
+
+commit c3809af86cf16612f01b01f27bb30d7b44db97a0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 24 01:59:05 2001 +0000
+
+    (begin_output): Have child exit with status 127 rather than reporting
+    failure on its own.  Set errno to 0 before invoking popen.
+    (finish_output): Report errno on pclose failure.
+    Distinguish between subsidiary program not found, and failure.
+
+commit 1f7b77fe80d868007776e8e33d3be2bd19cae399
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 24 01:55:59 2001 +0000
+
+    (not_found, execdiff): Remove.
+    (DIFF_PROGRAM_OPTION): New constant.
+    (longopts, option_help_msgid, main): Add --diff-program=PROGRAM.
+    (check_stdout): New function.
+    (main): Remove DIFF_PROGRAM support.  Check stdout after printing version.
+    Use check_stdout after printing help.  Use execvp/perror_fatail rather
+    than execdiff.  Set errno to 0 before invoking popen.
+    Check for pclose failure properly.
+    (main, edit): If child exec fails, exit with 127 rather than trying to
+    print diagnostic.
+    Distinguish between subsidiary program failing and not being found.
+    (edit): Handle signals the same way, regardless of whether we're using
+    system or fork+exec.  Check for system returning -1.
+
+commit c3a98cfc023bb1cd00875a77f2ae35e78967c218
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 24 01:48:07 2001 +0000
+
+    (DIFF_PROGRAM_OPTION, HELP_OPTION): New constants.
+    (longopts, main): Use them.
+    (longopts, main, option_help_msgid): New option --diff-option=PROGRAM.
+    (main): Remove DIFF_PROGRAM support.
+    Check stdout after printing version.
+    (check_stdout): Report errno info if fclose fails.
+    (read_diff): Have child exit with status 127 when program is not found,
+    rather than trying to have the child report failure.  CHeck for
+    pclose returning -1.
+
+commit f16be0e2b03914a24479e5b4587dd31ccfbb3fdf
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 24 01:44:21 2001 +0000
+
+    (DEFAULT_WIDTH): Remove.
+    (main): Use 130 instead of DEFAULT_WIDTH, since it's not really
+    builder-settable.  Do not prepend DIFF_OPTIONS.
+    (check-stdout): If fclose (stdout) fails, print errno info.
+    (option_help_msgid): Default context is 3, not 2.
+    (usage): Work even if ptrdiff_t is wider than int.
+
+commit aa71c5d0fd39a210285416856a782657c7be6945
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 24 00:53:12 2001 +0000
+
+    (diff Options): Remove DIFF_OPTIONS.
+    (Invoking diff3, Invoking sdiff): Remove DIFF_PROGRAM.
+    (diff3 Options, sdiff Options): Add --diff-program.
+
+commit 5400b5e9051392e46fd4438fbc5e022e63e922c9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 24 00:11:59 2001 +0000
+
+    (valid_suffixes): Add '0', to support suffixes like "MB" and "MiB".
+    (check_stdout): Don't assume that the translations of "write failed"
+    and of "standard output" lack '%'.
+    (main): Check stdout after printing version.
+
+commit e053f8c49d1a14ab45ec697502f0f3ceaa85790d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 24 00:09:16 2001 +0000
+
+    [HAVE_FCNTL_H && HAVE_SETMODE_DOS]: Include <fcntl.h>.
+    [!HAVE_SETMODE_DOS]: Do not include <unistd.h>.
+    (set_binary_mode): Return mode (not 1) if fd is a tty.
+    Do not assume that O_TEXT is zero.
+
+commit 2eb762252f7faef3208c90fffef44edf5fb07102
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 24 00:06:54 2001 +0000
+
+    (cmp Options): In byte counts, a plain suffix (without any integer)
+    is assumed to modify the integer 1.  Index terms like "kibibyte".
+    Document plain "k".
+    
+    (Reporting Bugs): Mention bug-report archive and test version
+    location.  Ask for "diff --version" in bug reports.
+
+commit ed5c8a4d3f69d096a02d850331f610c6daf1dd64
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 24 00:03:09 2001 +0000
+
+    (ALL_LINGUAS): Add tr.
+
+commit 26b18e2062458fb970aa7956e16840c7ee41ccc6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Dec 22 01:48:53 2001 +0000
+
+    Latest version from self.
+
+commit f4501e2ec54a1a01572d275c33148107a64d76f8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Dec 13 19:30:37 2001 +0000
+
+    Fix typos.
+
+commit 25dfb088db254b39ddb21457473b76299d985999
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Dec 13 19:26:46 2001 +0000
+
+    Fix comment.
+
+commit 08562bb5c3ac0748d5c6474d89399a73588f0fbc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Dec 13 19:26:46 2001 +0000
+
+    Remove the split prevention of config.status.
+    Fix Sed commands for converting absolute file names into op_srcdir-relative ones.
+
+commit 510ff6559ed90ad984f5c442ff0ee054823c0325
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Dec 13 19:26:46 2001 +0000
+
+    Initial revision
+
+commit c47d95a0840d2f0e48d0bb64e8f40d8860f674ab
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Dec 12 00:40:53 2001 +0000
+
+    Remove jm-glibc-io.m4
+
+commit b272bbb9bb27e469a99b8930e91d87ce15f161af
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 09:19:39 2001 +0000
+
+    Add --no-ignore-file-name-case.
+    File name case sensitivity now affects file name exclusion.
+    Fix typos.
+
+commit f1db1aefd227cf1e9d0717d72f959eca5c52e116
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 09:19:12 2001 +0000
+
+    diffutils 2.7.5
+
+commit c4b00134ca02faac16f6b321be5287df8558d18b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 09:14:20 2001 +0000
+
+    Include dirname.h.
+    (dir_file_pathname): Use base_name rather than file_name_lastdirchar.
+
+commit 05264956fc8fc4b2428e495becfdfe70b2e1652f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 09:13:35 2001 +0000
+
+    (S_IXUSR, S_IXGRP, S_IXOTH): New macros.
+    Include <libgettext.h> rather than rolling it ourselves.
+    (file_name_lastdirchar, HAVE_SETMODE, set_binary_mode): Remove.
+
+commit 33e8ec0f79d0de7582d315cb938fcee6d2d4a446
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 09:12:22 2001 +0000
+
+    Include <dirname.h>.
+    (expand_name): Use base_name rather than file_name_lastdirchar, for
+    portability to DOS.
+    (main): Initialize xalloc_exit_failure before possibly invoking any memory
+    allocator.
+
+commit 994ba2db42d306251ad663d42a702e3c7cec3c03
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 09:10:47 2001 +0000
+
+    Include setmode.h.
+
+commit e8398dcf9a5254d63732ff5710df7bda0cf33470
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 09:10:14 2001 +0000
+
+    (main): Initialize xalloc_exit_failure before possibly invoking any memory
+    allocator.
+
+commit e3b1ff596cdbafce7eebce8c5976cd005bed8ab4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 08:30:46 2001 +0000
+
+    Include dirname.h, setmode.h.
+    
+    (main): Later values and/or styles now silently override earlier.
+    (specify_value, specify_style): Likewise.  All callers changed.  Remove.
+    
+    (binary, main, option_help_msgid, compare_files):
+    HAVE_SETMODE -> HAVE_SETMODE_DOS.
+    (NO_IGNORE_FILE_NAME_CASE_OPTION): New constant.
+    (longopts, main, option_help_msgid): Support it.
+    (exclude_options): New function.
+    (main): Use it. Initialize xalloc_exit_failure before potentially
+    allocating memory.
+    
+    (filetype): Distinguish executable files from others, as POSIX suggests.
+    
+    (compare_files): Use base_name instead of file_name_lastdirchar.
+
+commit fe7c8fb737386c5032c08a082e8f1a6a189aecec
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 08:20:24 2001 +0000
+
+    Include <hard-locale.h>, <setmode.h>.
+    (hard_locale_LC_MESSAGES): New macro.
+    (sprintc): Remove int width arg; it's now the caller's responsibility to pad.
+    All callers changed.
+    (stat_buf): New static var; was formerly a local var in 'main'.
+    (valid_suffixes): Add 'K', for 'KiB'.
+    (option_help_msgid): Don't confuse bytes with characters.
+    (main): Set xalloc_exit_failure before invoking anything that might
+    allocate memory.  Fix bug: -n was incorrectly ignored when optimizing
+    the case of regular files with different lengths.
+    (cmp): Use an index column wide enough to store this comparison's indexes.
+    In locales other than the POSIX locale, say "byte" rather than "char".
+
+commit d788533d5f17bd403c6d87e77f32a241905879ca
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 08:12:21 2001 +0000
+
+    pc -> ms
+
+commit d104e14d8e39ca9fc7381c448da64de088b45dc2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 08:11:35 2001 +0000
+
+    Initial revision
+
+commit 412c4f34362c26ceb5305d8504b1e5766e4c9220
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 08:09:04 2001 +0000
+
+    (noinst_HEADERS): Add dirname.h, setmode.h.
+    (libdiffutils_a_SOURCES): Add basename.c, setmode.c.
+
+commit 380d97d7b99670c6fdb7c2f8cd0df8e8af524c66
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 08:07:59 2001 +0000
+
+    (AM_INIT_AUTOMAKE): Version 2.7.5.
+    (PR_PROGRAM): Use AC_DEFINE_UNQUOTED, so that $PR_PROGRAM is expanded by sh.
+    (ptrdiff_t, ssize_t): Use AC_CHECK_TYPE with a default of int,
+    not AC_CHECK_TYPES.
+    (jm_AC_DOS, AC_FUNC_SETMODE_DOS): New macros.
+    (AC_CONFIG_FILES): Add ms/Makefile.
+
+commit 277dbf811b8cd5300445328436282849faa477c6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 11 08:03:58 2001 +0000
+
+    (SUBDIRS): Add ms.
+
+commit 39ac13e2120e473ef5e0c35dce345e5a73b14d17
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 14:05:54 2001 +0000
+
+    Fix copyright notice.
+
+commit 0ac2866bd3c157a355a3aa1bd82cfef8f38a2b9b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:56:28 2001 +0000
+
+    diffutils 2.7.7
+
+commit 0b98d9a71f7c825c3052aa675d9029511d80f51b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:44:47 2001 +0000
+
+    (direntry, Overview, Comparison, Binary, Invoking cmp): Use "byte"
+    rather than "character" when talking about cmp, since it compares
+    bytes, not character.
+    (Invoking cmp): New trailing operands FROM-SKIP and TO-SKIP.
+    -i or --ignore-initial now accepts FROM-SKIP:TO-SKIP.
+    New option -n or --bytes.
+    Count operands now may be in octal or hex, and may be followed by a
+    size multiplier.
+
+commit c33d179ab620a88209cad033c8d6cdd6f6d09f82
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:39:54 2001 +0000
+
+    (usage): Clarify.
+
+commit d7f6b143d910dd2177be966fc485e599e0a8e31a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:39:35 2001 +0000
+
+    (AM_INIT_AUTOMAKE): version 2.7.4.
+    (DEFAULT_DIFF_PROGRAM): Define to "diff", not "$bindir/diff"
+    (which didn't work anyway).
+    (AC_CHECK_MEMBERS): Add struct stat.st_blksize, struct stat.st_rdev.
+    (AC_STRUCT_ST_BLKSIZE, AC_STRUCT_ST_RDEV): Remove; obsolescent.
+    (AC_FUNC_FORK): Use this, instead of obsolescent AC_FUNC_VFORK.
+    (AC_CONFIG_FILES, AC_CONFIG_COMMANDS): Add.
+    (AC_OUTPUT): Remove args; they were obsolescent.
+
+commit a6def20a05ca209c84a26015f2a1f3fbfd2ac19b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:37:07 2001 +0000
+
+    Test version 2.7.4.
+
+commit 129a699834531edf968287ffd74798e5b0f827dd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:22:49 2001 +0000
+
+    (setup_output, begin_output, finish_output): HAVE_FORK ->
+    HAVE_WORKING_FORK || HAVE_WORKING_VFORK.
+
+commit ca059f5bfd498ae64fb81c7446cf7a2c1bca6eed
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:20:30 2001 +0000
+
+    (STAT_BLOCKSIZE): Use HAVE_STRUCT_STAT_ST_BLKSIZE, not HAVE_ST_BLKSIZE.
+    (vfork): New macro.
+    (HAVE_FORK): Remove.
+    (set_binary_mode): New macro.
+
+commit 44e0be8f0f88fc57c67ff11b15353a4fc0a21ac6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:18:51 2001 +0000
+
+    (diffpid, cleanup, main, edit): HAVE_FORK -> HAVE_WORKING_FORK ||
+    HAVE_WORKING_VFORK.
+    (main): HAVE_VFORK -> HAVE_WORKING_VFORK.
+    (edit): Reopen the temporary file after the editor has run, in case
+    the editor operates by unlinking the old file and linking a new one.
+    (P_tmpdir): Rename from PVT_tmpdir; this fixes a typo.  All uses changed.
+
+commit 5ea1938003be6f5fd5d54c9a2ef9238815aad411
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:16:21 2001 +0000
+
+    (sip, read_files): Remove tests for HAVE_SETMODE; use set_binary_mode
+    instead of setmode.
+    (sip): Fix typo in backward lseek when reverting to text mode.
+
+commit f95e035eda1ac8ff79ea16e4c8b07aa33b1ec6ef
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:14:44 2001 +0000
+
+    (read_diff): HAVE_FORK -> HAVE_WORKING_FORK || HAVE_WORKING_VFORK.
+
+commit 5f0e17299fb53cd6ce420320037cc0fdeed6cba0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:13:04 2001 +0000
+
+    Initial revision
+
+commit 75ea63a2d7ffde984977953d5d604e7ce73386f0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:12:06 2001 +0000
+
+    (EXTRA_DIST): Add xstrtol.c.
+    (noinst_HEADERS): Add xstrtol.h.
+    (libdiffutils_a_SOURCES): Add xstrtoumax.c.
+
+commit 98d914fc6c4fc046cd93aaa97c27faa09983c102
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 13:11:04 2001 +0000
+
+    <xstrtol.h>: Include.
+    (ignore_initial): Now an array with 2 elements.  All uses changed.
+    (bytes): New var.
+    (HELP_OPTION): New constant.
+    (long_options, main): Use it.
+    (long_options, option_help_msgid, main, cmp): Add support for -n or --bytes.
+    (parse_ignore_initial): New function.
+    (option_help_msgid, main): Add -i M:N.
+    (usage, main): Add two optional trailing operands, a la BSD.
+    (main): setmode -> set_binary_mode.
+    (cmp): Report byte number of what we've seen, not of the entire file.
+    This is to be consistent with the line number, which is always relative
+    with what we've seen.
+
+commit 32164584130dc9e2bd1dd5ade4df6ef9ea4fabe2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 07:43:59 2001 +0000
+
+    (main, compare_files): setmode -> set_binary_mode.
+
+commit c99680457cfd3e1c05b85593120dc3615fac8512
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 06:23:58 2001 +0000
+
+    (__xstrtol): Don't accept 'Ki'; require 'KiB'.
+
+commit cc58a4f8063c010a61ca2aedcc0e5a12d89c863c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 3 05:33:58 2001 +0000
+
+    (__xstrtol): Add support for IEC 60027-2.
+
+commit 770d68dc364ebbb35a1fde71766efec8c7c9792d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 15:13:04 2001 +0000
+
+    autoconf/lib/autoconf/functions.m4
+
+commit 91a8ea4b54c8f53be5394d6380f632434ad79c53
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 08:06:19 2001 +0000
+
+    (INCLUDES): Add -I../lib, for regex.h.
+
+commit 23689a884bbf814bb7fca5fff4952109f3fa00fa
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 07:48:26 2001 +0000
+
+    Don't set LIB_CLOCK_GETTIME to 'none required'; set it to
+    the empty string instead.
+
+commit 9b53dc875732f3df331505769fc1b414591a62d7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 07:36:42 2001 +0000
+
+    (EXTRA_DIST): Add strtoimax.c, strtol.c.
+
+commit 10d66dc46d700293ee9484e6da522ebe278b5ee0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 07:30:11 2001 +0000
+
+    (SUBDIRS): Put intl before lib, so that libintl.h exists.
+
+commit 7577cc7fb6cdf08f3b6344a5ae5351b66f8ab974
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 07:25:31 2001 +0000
+
+    (noinst_HEADERS): Add unlocked-io.h.
+
+commit 258ce5d07b536306e19f1efda97243df66966544
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 07:25:09 2001 +0000
+
+    (__EXTENSIONS__): New define, for the unlocked macros.
+
+commit a443fa483a1738694bf3b677bb60355a7e151e06
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 06:51:21 2001 +0000
+
+    Add copyright notice.
+    Remove stuff that doesn't apply any more.
+
+commit 6c994721a7274e8cd5964fb2b65341ac3d6777cd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 06:33:50 2001 +0000
+
+    2.7.3 news
+
+commit 96db06389fc69f0108beeffbff22770e4fc00dd4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 06:32:33 2001 +0000
+
+    Initial revision
+
+commit f1d11746cab0d2175dd6136249050801adb13946
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 06:31:33 2001 +0000
+
+    offsets -> indices for cmp
+
+commit 814c36a2c8e714f3aae096e0cc47f57ed5cb8d4c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 06:31:04 2001 +0000
+
+    (option_help_msgid): offsets -> indices
+
+commit 7160e82d562025f3e95aa37ca40ab56a63a2c183
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 06:28:48 2001 +0000
+
+    (option_help_msgid): Don't mention --binary on POSIX hosts.
+
+commit eefb9adae1642dcb0e2ac523c79998f466e94e77
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 06:28:17 2001 +0000
+
+    (STRIP_TRAILING_CR_OPTION): New constant.
+    (longopts, option_help_msgid, main): Add -E, --ignore-tab-expansion,
+    --strip-trailing-cr.
+
+commit bcb8f7f3527717c5c8cd2848a8c443bb442b0be2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 05:54:30 2001 +0000
+
+    Change direcategory from Utilities to GNU Packages.
+    Add individual utilities.
+    Switch to Free Documentation License.
+    @code -> @command
+    @samp -> @option
+    GNU -> @sc{gnu}
+    GNU patch version is 2.5.4.
+    Expand tabs to spaces, except when in an example that actually uses tabs.
+    Prefer @node with just one arg.
+    Document -E or --ignore-tab-expansion, --strip-trailing-cr, --ignore-file-name-case.
+    Regular expressions are now grep style, not Emacs style.
+    cmp's -c or --print-chars option is now -b or --print-bytes.
+    Time stamps now depend on LC_TIME.
+    -p now implies ^[[:alpha:]$_].
+    Flags now include ' and 0.
+    cmp -i is an alias for --ignore-initial
+    Document --from-file, --to-file.
+    Document DIFF_OPTIONS.
+
+commit 49e3b25b41c934ca6945d94de98d747fa5cc9922
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 00:22:19 2001 +0000
+
+    (AC_CHECK_FUNCS): Add gettimeofday, clock_gettime.
+    (LIB_CLOCK_GETTIME): New subst.
+
+commit b6092f7a19c7b78a5c002a3fd80d0b8b61c3ea61
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 00:21:28 2001 +0000
+
+    Assume C89 or better.
+    (_GNU_SOURCE): Remove; config.h now defines it.
+    (alloca): Declare like coreutils does it.
+    (verify, TYPE_SIGNED, TYPE_MINIMUM, TYPE_MAXIMUM, O_RDWR, S_IRUSR, S_IWUSR):
+    New macros.
+    (STAT_BLOCKSIZE): Parenthesize definiens.
+    <inttypes.h>: Include if HAVE_INTTYPES_H.
+    (CHAR_MAX, INT_MAX): Remove.
+    (PTRDIFF_MAX, SIZE_MAX): New macros.
+    (strtoumax): New decl.
+    Include stddef.h.
+    (bzero): Remove.
+    (bindtextdomain, textdomain, N_): New macros.
+    (ISPRINT, ISSPACE): Remove ifndef wrappers.
+    (ISUPPER, ISDIGIT): Remove.
+    (TOLOWER): New macro.
+    (MIN): Renamed from min; all callers changed.
+    (MAX): Likewise, from max.
+    (lin): New type.
+    (LIN_MAX): New macro.
+    (file_name_cmp): Renamed from filename_cmp.  All callers changed.
+    (file_name_lastdirchar): Renamed from file_name_lastdirchar.
+    All callers changed.
+    (could_be_mvfs_stat_bug, could_be_nfs_stat_bug, dev_may_have_duplicate_ino):
+    Remove.
+    (HAVE_SETMODE, NULL_DEVICE): New macros.
+    (same_file): Do not check attributes.
+    (same_file_attributes): New macro.
+
+commit 7cc1ca84b34554f4c4c20c69d8bba80f9cb63fa7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 25 00:11:23 2001 +0000
+
+    Assume C89 or better.
+    int -> bool for booleans.
+    int -> lin for line numbers.
+    int -> size_t for sizes.
+    Use angle-brackets when including quotesys.h.
+    Include error.h, regex.h, xalloc.h.
+    (message5): sizeof -> offsetof
+    (begin_output): Invoke pr without -f.
+    (lines_differ): Renamed from line_cmp, and return bool not 3-way int.
+    All callers changed.
+    Add support for IGNORE_TAB_EXPANSION.
+    (change_letter): Now an array rather than a function.  All callers changed.
+    (translate_range): Translate line numbers to long, not lin, for convenience
+    with printf.
+    (analyze_hunk): Return enum changes instead of a count of inserts and deletes.
+    All callers changed.
+    (zalloc): New function.
+
+commit babd4445b7551da0b2eb132cbb59794a80caf229
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 23:59:13 2001 +0000
+
+    Assume C89 or better.
+    int -> bool for booleans.
+    int -> lin for line numbers.
+
+commit f7ea233c667071964270b985ad52f2efa53a5eb3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 23:56:49 2001 +0000
+
+    Assume C89 or better.
+    int -> bool for booleans.
+    int -> lin for line numbers.
+    Use angle-brackets when including getopt.h, quotesys.h.
+    Include error.h, freesoft.h, stdio.h, xalloc.h.
+    (copyright_string): Use only most recent year.
+    (authorship_msgid, option_help_msgid): Wrap in N_().
+    
+    (tmpname): Now volatile.
+    (tmpmade): Remove.
+    (tmp): New var.
+    (private_tempnam, exists, letters): Remove.
+    (temporary_file): New function.
+    (edit): Use it.
+    (interact): Use strtoumax, not atoi.
+
+commit 7a9851bed3ee069c6d78e0526c3edf6c85315dea
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 23:46:37 2001 +0000
+
+    Assume C89 or better.
+    int -> lin for line numbers.
+
+commit 420373575c3761cc50e762084400056affb968a0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 23:44:22 2001 +0000
+
+    Assume C89 or better.
+    int -> bool for booleans.
+    int -> lin for line numbers.
+    int -> size_t for sizes.
+    Use angle-brackets when including cmpbuf.h.
+    Include regex.h, xalloc.h.
+    (word): Remove; now done in system.h.
+    (hash_value): New type; use it instead of 'unsigned' for hash values.
+    (file_block_read): New function.
+    (sip, slurp): Use it.  Now static.
+    (sip): Ensure block size is a multiple of word size.  Clear eof flag.
+    (slurp): Use xalloc_die to report memory exhaustion.
+    (find_and_hash_each_line): Use TOLOWER instead of _tolower.
+    Add support for IGNORE_TAB_EXPANSION.
+    (prepare_text_end): Strip trailing CR if requested.
+    (find_identical_ends): Prepare the text only once, if they're duplicates.
+    Let the compiler take advantage more of the fact that the buffers are
+    word-aligned.
+    (primes): Remove.
+    (prime_offset): New var.
+    (read_var): Use prime_offset instead of primes.
+    Use zalloc instead of xmalloc + bzero.
+
+commit 9afb404ccb9b04b4a488008cb04dd262db71b52f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 20:16:15 2001 +0000
+
+    Assume C89 or better.
+    int -> lin for line numbers.
+    (format_group): Use strtoumax to parse line numbers.
+    (format_group, print_ifdef_lines): Use do_printf_spec to handle printf specs.
+    (groups_letter_value): Don't use _tolower; it's locale-dependent.
+    (do_printf_spec): Renamed from scan_printf_spec; now does the printing.
+
+commit 36b388a33f2cb41d622680b81d9bf0142f542424
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 20:10:42 2001 +0000
+
+    Assume C89 or better.
+    int -> lin for line numbers (or 'long' when that's more convenient).
+    (print_ed_hunk): Fix bug when handling double-dot inserts.
+
+commit 1c2ed8ea5b7561400ef64ce60c71181d5a1f4649
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 20:08:03 2001 +0000
+
+    Assume C89 or better.
+    int -> bool for booleans.
+    Include error.h, exclude.h, xalloc.h.
+    
+    (dir_sort): Return 0 on error, 1 on success.  All callers changed.
+    compare_names -> compare_names_for_qsort.
+    
+    (compare_names): Try strcasecmp if ignore_file_name_case.  Then try
+    strcoll.  Use file_name_cmp only as a last resort.  Warn about
+    strcasecmp or strcoll failure.
+    (compare_names_for_qsort): New function.
+    
+    (diff_dirs): Use compare_names rather than filename_cmp.
+
+commit a54f0db411e5cc633bf739f9e644c9d8d7da9b18
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 19:56:07 2001 +0000
+
+    Assume C89 or better.
+    int -> bool for booleans.
+    int -> lin for line numbers.
+    Use angle-brackets when including getopt.h, quotesys.h.
+    Include error.h, freesoft.h, inttostr.h, xalloc.h.
+    (copyright_string): Use only most recent year.
+    (authorship_msgid, option_help_msgid): Wrap in N_().
+    
+    Rename the following variables for consistency with user-visible
+    option spellings.  All uses changed.
+    (text): Renamed from always_text.
+    (initial_tab): Renamed from tab_align_flag.
+    
+    (horizon_lines): Remove.  Remove all uses.
+    
+    (main): Invoke bindtextdomain and textdomain after setlocale.
+    Rename "DIFF" to "DIFF_PROGRAM".
+    
+    Try to compare file0 to file1, because this is where changes are
+    expected to come from.  Diffing between these pairs of files is more
+    likely to avoid phantom changes from file0 to file1.
+    However, use file2 as the common file if this is a 3-way diff,
+    for backward compatibility.
+    
+    (create_diff3_block): Use xcalloc instead of malloc + bzero.
+    
+    (INT_STRLEN_BOUND): Remove; now in system.h.
+    
+    (read_diff): Always use --horizon-lines=100 rather than trying to guess it.
+    Do not pass --inhibit-hunk-merge.
+    Minimum chunk size is 1, not 8KiB.
+    Use xalloc_die to report memory exhaustion.
+    (undotlines): Use long for start, not int.
+
+commit 2efe295eb51b9c02594a473d0d55b0ea8fe599c0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 19:29:55 2001 +0000
+
+    Assume C89 or better.
+    int -> bool for booleans.
+    int -> lin for line numbers.
+    Don't include regex.h.
+    (enum changes): New enum.
+    (enum line_class): Remove; subsumed by enum changes.
+    (enum output_style): New constant OUTPUT_UNSPECIFIED.
+    
+    (ignore_space_change_flag, ignore_all_space_flag): Remove.
+    (ignore_white_space): New decl, subsuming the above two.  All uses changed.
+    
+    Rename the following decls for consistency with user-visible
+    option spellings.  All uses changed.
+    (text): Renamed from always_text_flag.
+    (ignore_blank_lines): Renamed from ignore_blank_lines_flag.
+    (ignore_case): Renamed from ignore_case_flag.
+    (brief): Renamed from no_details_flag.
+    (initial_tab): Renamed from tab_align_flag.
+    (expand_tabs): Renamed from tab_expand_flag.
+    (starting_file): Renamed from dir_start_file.
+    (paginate): Renamed from paginate_flag.
+    (sdiff_merge_assist): Renamed from sdiff_help_sdiff.
+    (left_column): Renamed from sdiff_left_only.
+    (suppress_common_lines): Renamed from sdiff_skip_common_lines.
+    (speed_large_files): Renamed from heuristic.
+    (minimal): Renamed from no_discards.
+    
+    (inhibit_hunk_merge): Remove.
+    
+    (strip_trailing_cr, excluded, time_format): New decls.
+    
+    (files_can_be_treated_as_binary): Renamed from ignore_some_changes.
+    
+    (group_format, line_format): Now char const *[], not char *[].
+    
+    (struct file_data): Buffer is now word*, not char*, as it's always
+    aligned and this can help the compiler.  buffered_chars -> buffered
+    (since it's a byte count, not a char count).  All uses changed.
+    New member `eof'.
+    
+    (FILE_BUFFER): New macro.
+    
+    (excluded_filename, error, free_software_msgid): Remove decls; now in
+    other .h files.
+    
+    (sip, slurp): Remove decls.
+    (file_block_read): New decl.
+    (change_letter): Now an array, not a function.
+    (lines_differ): Renamed from line_cmp.
+    (analyze_hunk): Now returns enum changes rather than two change counts.
+
+commit d7f8501f5336632c5213b4bab9a44c26523b1b11
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 19:12:49 2001 +0000
+
+    (diff_LDADD): New symbol.
+
+commit 2e8641a5e5c62be99544041e777c1a73dc34a16f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 19:10:43 2001 +0000
+
+    Assume C89 or better.
+    int -> bool for booleans.
+    long -> off_t for line numbers.
+    Use angle-brackets when including getopt.h, fnmatch.h, quotesys.h.
+    Include error.h, exclude.h, freesoft.h, hard-locale.h, prepargs.h,
+    regex.h, signal.h, xalloc.h.
+    (copyright_string): Use only most recent year.
+    (authorship_msgid, option_help_msgid): Wrap in N_().
+    
+    Rename the following variables for consistency with user-visible
+    option spellings.  All uses changed.
+    (binary): Renamed from binary_flag.
+    (new_file): Renamed from entire_new_file_flag.
+    (unidirectional_new_file): Renamed from unidirectional_new_file_flag.
+    (report_identical_files): Renamed from print_file_same_flag.
+    
+    (numeric_arg): Remove.
+    
+    (exclude, exclude_alloc, exclude_count, excluded_filename, add_exclude,
+    add_exclude_file):
+    Remove; now done by exclude.h.
+    
+    (BINARY_OPTION, FROM_FILE_OPTION, HELP_OPTION, HORIZON_LINES_OPTION,
+    IGNORE_FILE_NAME_CASE_OPTION, INHIBIT_HUNK_MERGE_OPTION,
+    LEFT_COLUMN_OPTION, LINE_FORMAT_OPTION, NORMAL_OPTION,
+    SDIFF_MERGE_ASSIST_OPTION, STRIP_TRAILING_CR_OPTION,
+    SUPPRESS_COMMON_LINES_OPTION, TO_FILE_OPTION,
+    UNCHANGED_LINE_FORMAT_OPTION, OLD_LINE_FORMAT_OPTION,
+    NEW_LINE_FORMAT_OPTION, UNCHANGED_GROUP_FORMAT_OPTION,
+    OLD_GROUP_FORMAT_OPTION, NEW_GROUP_FORMAT_OPTION,
+    CHANGED_GROUP_FORMAT_OPTION): New constants.
+    (longopts, main): Use them.
+    
+    (longopts, main, option_help_msgid): Add -E, --from-file, --to-file.
+    
+    (main): Invoke bindtextdomain and textdomain after setlocale.
+    Use grep syntax, not Emacs, for regular expressions.
+    Use exclude.h, not our own functions.
+    Use ISO 8601 time format in hard locales.
+    Prepend DIFF_OPTIONS.
+    Don't update ignore_some_changes.
+    Use strtoumax instead of numeric_arg.
+    Use specify_value when appropriate.
+    error -> try_help when appropriate.
+    -p now means ^[[:alpha:]$_], not ^[_a-zA-Z$].
+    Ignore --inhibit-hunk-merge.
+    Prefer changed group formats to unchanged ones.
+    Remove now-unnecessary casts.
+    Set files_can_be_treated_as_binary.
+    
+    (specify_value): Renamed from specify_format.  All uses changed.
+    
+    (specify_style): Default is now unspecified, not normal.  All uses changed.
+    
+    (set_mtime_to_now): New function.
+    (compare_files): Use it.  Use memset, not bzero.
+    Set stdin mtime to current time even when stdin is not a regular file.
+    Check for same file attributes, as well as for same file.
+    Use files_can_be_treated_as_binary.
+    "write failed" -> "standard output on output failure.
+
+commit d96c04ee417716da551c9af5ff9da185536d4557
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 14:34:53 2001 +0000
+
+    Assume C89 or better.
+    int -> lin for line numbers.
+    Include inttostr.h, regex.h.
+    (TIMESPEC_NS): New macro.
+    (nstrftime): New decl.
+    (print_context_label): Use nstrftime and time_format to format times.
+    Print numeric time stamp value if localtime fails.
+    (print_context_function): New function.
+    (pr_context_hunk, pr_unidiff_hunk): Use it.
+    (find_function): Use size_t for sizes, not int.
+
+commit 4de1d68d32189b44d363b3c43d77eef81b184df5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 14:16:12 2001 +0000
+
+    Assume C89 or better.
+    int -> bool for booleans.
+    long -> off_t for line numbers.
+    Use angle-brackets when including cmpbuf.h, getopt.h.
+    Include error.h, freesoft.h, inttostr.h, xalloc.h.
+    (copyright_string): Use only most recent year.
+    (authorship_msgid): Wrap in N_().
+    (buffer): Now word*, not char*.  All uses changed.
+    (word): Remove macro; now in system.h.
+    (long_options, option_help_msgid, main): -c --print-chars -> -b --print-bytes
+    (check_stdout): "write failed" -> "standard output"
+    (option_help_msgid): Wrap in N_().
+    (main): Invoke bindtextdomain and textdomain after setlocale.
+    Use strtoumax instead of doing the work ourselves.
+    Check for same_file_attributes as well as same_file.
+    (cmp): Use ssize_t for read returns, not size_t.
+    Do not assume that size_t is not narrower than int.
+    Do not assume that line numbers fit in 'long'.
+    (block_compare_and_count, block_compare):
+    Compiler now checks that buffers are word-aligned.
+    (block_compare_and_count): Count sizes with size_t, not long.
+    (sprintc): byte arg is unsigned char, not unsigned.
+
+commit dd1268672597e935cdd910f1adf731dc4bd3e6f1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Nov 24 13:51:07 2001 +0000
+
+    Assume C89 or better.
+    int -> lin for line numbers.
+    int -> bool for booleans.
+    unsigned int -> size_t for sizes.
+    Use angle-brackets when including cmpbuf.h.
+    Include error.h, regex.h, xalloc.h.
+    (discard_confusing_lines, diff_2_files): Use zalloc rather than xalloc+bzero.
+    (discard_confusing_lines): unsigned int -> lin for values that are really
+    line numbers.
+    (shift_boundaries): Do not inhibit hunk merges.
+    (build_reverse_script, build_script, diff_2_files): Use |, not ||, for speed.
+    (diff_2_files): no_details_flag & ~ignore_some_changes ->
+    files_can_be_treated_as_binary.  Esure that buffer size is a multiple
+    of sizeof (word).  Use file_block_read to read buffers.
+    (diff_2_files): Abort if output style is not one of the expected styles.
+
+commit a821b5602b040227ab71a2638dca2253fb6da5c1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Nov 23 18:44:41 2001 +0000
+
+    Initial revision
+
+commit f78da6466e7b2d77de2a4214fe83985ee5b7e6e1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Nov 23 13:28:32 2001 +0000
+
+    Initial revision
+
+commit 22af62a5678ea705380884bef4ec43e82e65db63
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Nov 23 13:25:01 2001 +0000
+
+    (jm_PREREQ_READUTMP): Remove, as it gives autoheader the willies.
+
+commit cd1a913b43413da87860f557a094c398744a9e2c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Nov 23 13:04:25 2001 +0000
+
+    Include config.h, freesoft.h rather than diff.h.
+    (free_software_msgid): Wrap contents in N_.
+
+commit e28790892e335a412aff01934a37a3a2768c1dbb
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Nov 23 13:02:42 2001 +0000
+
+    Use prototypes instead of old-style functions.
+
+commit 33d72d80bc0ccc713ba39768ef102c6dc7904074
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Nov 23 13:02:08 2001 +0000
+
+    Don't include system.h; instead, include config.h, unistd.h.
+    Use prototypes instead of old-style functions.
+    (block_read): Don't assume that int is no wider than size_t.
+
+commit e48d1026c5f76e1795ebec078167a6c651f0fa16
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Nov 23 08:05:29 2001 +0000
+
+    Initial revision
+
+commit 8b1cfebb78c02f55f91d229ecceef4284957f6db
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Nov 23 07:54:35 2001 +0000
+
+    Define filename_cmp as an object-like macro, not as a function-like
+    macro.
+
+commit da34f9fc343796c6025e60a8f5726604d9a34b74
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Nov 23 07:52:27 2001 +0000
+
+    Always operate in the C locale.
+    Set AWK using a method that works even with broken shells.
+
+commit abb43c1f76f48e45fcabe330a503a62eaa117db7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Nov 23 07:46:59 2001 +0000
+
+    (AC_INIT): Use src/diff.c, not diff.h, as the source files got removed.
+    (AM_CONFIG_HEADER): Switch from AC_CONFIG_HEADER.
+    (AC_ARG_PROGRAM, AC_MINIX): Remove.
+    
+    (AC_PREREQ, AM_INIT_AUTOMAKE, ALL_LINGUAS, AC_PROG_AWK,
+    AM_PROG_CC_STDC, AC_PROG_RANLIB, AC_C_INLINE, AC_C_VARARRAYS,
+    DEFAULT_DIFF_PROGRAM, DEFAULT_EDITOR_PROGRAM, AC_STRUCT_ST_MTIM_NSEC): Add.
+    
+    (PR_PROGRAM): AC_DEFINE.
+    
+    (AC_SYS_LARGEFILE): Use instead of our homebrew version.
+    
+    (_GNU_SOURCE): Define if not defined.
+    
+    (AC_CHECK_HEADERS): Add stdbool.h, unistd.h.
+    (AC_CHECK_TYPES): Add ptrdiff_t, uintmax_t.
+    (AM_GNU_GETTEXT, XGETTEXT): Add.
+    
+    (WITH_MVFS_STAT_BUG, WITH_NFS_STAT_BUG): Remove.
+    (HAVE_MEMCHR): Remove.
+    (AC_CHECK_FUNCS): Add diraccess.
+    (AC_REPLACE_FUNCS): Add memchr, waitpid.
+    (jm_FUNC_GLIBC_UNLOCKED_IO, jm_FUNC_GNU_STRFTIME, jm_FUNC_MALLOC,
+     jm_FUNC_REALLOC, jm_PREREQ_ERROR, jm_PREREQ_QUOTEARG, jm_PREREQ_REGEX,
+     jm_PREREQ_TEMPNAME, jm_AC_PREREQ_XSTRTOUMAX, AC_FUNC_FNMATCH): Add.
+    (fnmatch.h, regex.h): Do not create these files unless we're using
+    our own fnmatch and regex.
+    (AC_OUTPUT): Add doc/Makefile, intl/Makefile, lib/Makefile, lib/posix/Makefile,
+    m4/Makefile, po/Makefile.in, src/Makefile.
+
+commit 851e78757601f74100d920fa8d1861e150309cd6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Nov 23 07:12:27 2001 +0000
+
+    Don't translate "program" to "programme".
+
+commit 64c1b907e37d9f2eb9af94e5c2a4fec4ed1be624
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Nov 20 19:05:44 2001 +0000
+
+    Initial revision
+
+commit 0b795bef12137f5ea8d0a7771581bf7eda28f314
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Nov 20 05:34:44 2001 +0000
+
+    Initial revision
+
+commit 8e78630e376e1d8ed311a2bd11be0a7215efde0d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 4 01:21:33 2001 +0000
+
+    Initial revision
+
+commit 8a650ddd00a9c5130a0b67199d5578b845fee1e4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 27 00:37:40 2001 +0000
+
+    Initial revision
+
+commit ce4ac3d8f5bcfcc73e260bb5754b56ec56a1b313
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 22 08:00:19 2001 +0000
+
+    Initial revision
+
+commit 5e0ab37d1b54802075c6919eb0183a18cf3817d9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 29 01:15:42 2001 +0000
+
+    Initial revision
+
+commit 37788019c290ff31f902f64fdb6b405ea0f95408
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Aug 23 17:25:08 2001 +0000
+
+    Initial revision
+
+commit 8a81b851d53c92e845961a2881ed3d8a725064d6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Aug 12 17:11:46 2001 +0000
+
+    Initial revision
+
+commit ecad5d7b24b4bcc21f3275d2d1bb011727cfb3b6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Jul 15 14:31:54 2001 +0000
+
+    Initial revision
+
+commit 688ab06db171f210dbe73dbef43bb2148e5de15f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Jul 7 04:55:38 2001 +0000
+
+    Initial revision
+
+commit 42bf2924b081cda528bca0aba18d49aa983e9ed5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Jul 6 04:44:39 2001 +0000
+
+    Initial revision
+
+commit 7109958ae4875dd0534e4de888a885114cc4e270
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Apr 2 08:26:15 2001 +0000
+
+    Initial revision
+
+commit 4dcf610052023fc1b821cf6850a76327e44874cd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Jan 26 11:13:28 2001 +0000
+
+    Initial revision
+
+commit eb477ba9451eef62e9344ca64c0c6f072e83bc3f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Oct 31 07:09:56 2000 +0000
+
+    Initial revision
+
+commit 0090fd30f97f695e18708ddd6c3a34c9f8e6837b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Aug 7 15:48:18 2000 +0000
+
+    Initial revision
+
+commit 9825e0bef52904997b438ba9aac33848071574b9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Feb 6 06:57:20 2000 +0000
+
+    From GCC repository
+
+commit 39a0766fcd5481d35e2caf3e779618353ed63469
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Dec 12 02:27:20 1998 +0000
+
+    (lf_snarf): Fix bug when help line wrapped around the input buffer.
+
+commit 4ecee655a20f0db1be9477096f22786959b6578e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Sep 15 22:34:53 1998 +0000
+
+    Add dircategory.
+
+commit 5c5dfca096877631f67a2a06f324beaf52b36939
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 07:27:17 1998 +0000
+
+    Include <config.h> before using "const".
+
+commit df0836e08976e3e58f6aa8420efec13d48433cca
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:59:43 1998 +0000
+
+    ($D.tar.gz): Don't use ln to create distribution; it doesn't
+    work with symlinks.
+
+commit 19db0feae5268084abeabb97a96f8b3a6d102dba
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    (AC_PATH_PROG): Add PR_PROGRAM.
+    If available, prefer support for large files unless the user specified
+    one of the CPPFLAGS, LDFLAGS, or LIBS variables.
+    (AC_STRUCT_ST_RDEV): Add.
+    (HAVE_ST_FSTYPE_STRING): Add.
+    (--with-mvfs-stat-bug, --with-nfs-stat-bug): New options.
+    (HAVE_MEMCHR): New macro.
+    (AC_CHECK_FUNCS): Add sicprocmask.
+
+commit eb6efbf9c67a01ee7317df4ebe2db3a139920ea4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    Add --with-mvfs-stat-bug, --with-nfs-stat-bug.
+
+commit 88507c4fc146befc67d9909e1b6b2c2c00dba635
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    (quotesys.h): Include.
+    (PR_PROGRAM): New macro.
+    (pfatal_with_name): Abort if error returns.
+    (fatal): Likewise.
+    (print_message_queue): Free message chain after printing.
+    (currently_recursive): Renamed from current_depth, and now a boolean.
+    (begin_output): Report error if fflush does.
+    Avoid stdio and gettext in child.
+
+commit bc79aedec85808753e4d51323e2385fb1c13d7d0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    (__attribute__): New macro.
+    (getenv): Don't declare if HAVE_STDLIB_H.
+    (CHAR_MAX): New macro.
+    (<locale.h>): New include.
+    (<locale.h>): Include before <libintl.h>.
+    (could_be_mvfs_stat_bug, could_be_nfs_stat_bug, dev_may_have_duplicate_ino,
+    same_special_file): New macros.
+    (same_file): Use them.
+
+commit 65e8fe11693ff0748df573053a1270e97ed09a8a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    (print_half_line): Add brackets to pacify GCC -Wall.
+
+commit e72388acbd0fc8f3619e56cca431984fa571d01f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    (quotesys.h): Include.
+    (DIFF_PROGRAM, DEFAULT_EDITOR_PROGRAM): Remove.
+    (free_software_msgid, editor_program, not_found): New vars.
+    (diffbin, edbin): Remove.
+    (editor_program): Renamed from edbin.
+    (edit, interact): Now take extra string arg.
+    (exiterr, fatal, perror_fatal, try_help): Add noreturn attribute.
+    (sigset_t, sigemptyset, sigmask, sigaddset, SIG_BLOCK, SIG_SETMASK):
+    (sigprocmask): New macros, if !HAVE_SIGPROCMASK.
+    (error): Now has printf attribute.
+    (longopts, main): Don't assume ASCII.
+    (try_help): New operand arg.
+    (usage): Conform to new GNU standards.
+    (main): Set static vars for editor and diff program.
+    Compare getopt_long result to -1, not EOF.
+    -v conforms to new GNU standard.
+    Complain better about extra and missing operands.
+    If HAVE_VFORK, block SIGINT and SIGPIPE in the parent, since when
+    the child munges its handlers it may somp on the parent.
+    Pass rname to intract.
+    Translate not-found message before forking.
+    (give_help): Just output it all at once.
+    (edit): New args lname, lline, rname, rline.
+    (edit): New command 'd'.
+    (interact): New args lname, rname.
+
+commit f00d3f0a665703921f746d541d909446f1a4160e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    Update FSF address.
+
+commit d81d5f9e6cb8931c2afc616fad19d0df85721b90
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    (cmpbuf.h): Include.
+    (slurp): Check for arithmetic overflow when computing buffer size.
+
+commit a1bec6ce6450cc45f4ff44b66ecb463c1a4352b4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    Remove `#if 0'ed code.
+
+commit f2ca3a82c2205ac873d4413badad64db9bf36589
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    (diff_dirs): Check for recursive directory loop.
+    Arg is now struct comparison const *.
+    (dir_loop): New function
+
+commit fd90a378218ee0687187ba44800af2ad76373d2e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    (quotesys.h): Include.
+    (free_software_msgid): New decl.
+    (RANGE_START, RANGE_END): Renamed from START and END.
+    (fatal, perror_with_exit, try_help): Add noreturn attribute.
+    (error): Add printf attribute.
+    (diff_program): Now a ptr, not an array.  Initialize to DEFAULT_DIFF_PROGRAM
+    instead of DIFF_PROGRAM.
+    (longopts, main): Don't assume ASCII.
+    (main): Use DIFF environment var to specify name of diff program.
+    Compare getopt_long result to -1, not EOF.
+    -v now reports version according to new GNU standard.
+    Report spelling of extra operand, or last operand before missing one.
+    (try_help): Now takes operand arg.
+    (option_help_ms): Fix typo: missing comma.
+    (usage): Update as per current GNU standards.
+    (environ): Remove decl.
+    (read_diff): Invoke diff with --inhibit-hunk-merge.
+    Translate `not found' message before forking.
+    Quote name of diff program.
+    Pass horizon lines.
+    `memory exhausted' -> `Memory exhausted'
+
+commit bad331bf32f5a812007ef5400b675f19507fc03a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    (XTERN): Renamed from EXTERN.
+    (struct filedata): Remove dir_p arg.
+    (struct comparison): New type.
+    (diff_2_files, diff_dirs)" Ise ot/
+    (error): Add printf attribute if applicable.
+    (free_software_msgid): New decl.
+    (pr_program): New decl.
+    (fatal): Add noreturn attribute.
+    (pfatal_with_name): Likewise.
+
+commit b2bbf871e71760e99cdf6cb2d50a274840ad5930
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    (authorship_msgid): New var.
+    (quotesys.h): Include.
+    (ck_atoi): Remove.
+    (function_regexp_list, ignore_regexp_list): Now static.
+    (binary_flag): Renamed from binary_I_O.
+    (entire_new_file_flag, unidirectional_new_file_flag, print_file_same_flag):
+    Now static.
+    (numeric_arg): Renamed from ck_atoi.
+    New argument specifying the argument type.
+    (longopts, main): Don't assume ASCII.
+    (longopts): Remove old aliases --file-label, --entire-new-file, --ascii,
+    --print.
+    (main): Check for -1, not EOF, when calling getopt_long.
+    Use numeric_arg to report errors.
+    Report error if -l specified but pagination is not supported.
+    Report error if -S is specified twice with conflicting values.
+    Have --version conform to the new GNU standards.
+    Add new --from-file, --to-file, --inhibit-hun,-merge options.
+    Make the horizon at least as large as the context.
+    Add casts to pacify gcc -Wall.
+    (try_help): Add operand arg.
+    (option_help_msgid): Doc fix to match above.
+    (usage): Indent option_help_msgid.
+    (compare_files): Now takes struct comparison
+    instead of two directory names and a depth.
+    (NONEXISTENT, UNOPENED, ERRNO_ENCODE, ERRNO_DECODE):
+    New macros.
+    (DIR_P): New macro.
+    Report error if fflush does.
+
+commit cd804a4efe27ad94e18a34b50d3cde70e1c0b4c0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    Fix spacing.
+
+commit 563686fcd98c79e3c73d729e87da072ec9ad7fa7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    (authorship_msgid): New var.
+    (free_software_msgid): New decl.
+    (error): Now has printf attribute.
+    (try_help): Likewise.
+    (long_options): Don't assume ASCII.
+    (try_help): Now accepts operand arg.
+    (main): Check for -1, not EOF, when calling getopt_long.
+    Report --ignore-initial value when complaining about it.
+    Output copyright and free software info with -v.
+    Don't assume ASCII.
+    Report last operand when one is missing.
+    Report text of extra operand.
+    Move block_read into cmpbuf.c.
+
+commit f1c356747f2a2969055ef6770d5c9bbbbed99291
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    Document recent changes.
+    The patch doc still corresponds to patch 2.2, unfortunately.
+    Update GNU bug reporting address.  Omit Larry Wall's address;
+    it's obsolete and he's busy with perl.
+
+commit ddbaec7810f5ca4b230e5708d54d4514ab712273
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    Fix copyright.
+
+commit ee7817ee7f07dcf291f05f9797df7bd292c02b32
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 06:13:10 1998 +0000
+
+    (DEFAULT_DIFF_PROGRAM): Renamed from DIFF_PROGRAM.
+    (PR_PROGRAM): All `configure' to define it.
+    (srcs): Add $(diffutils_srcs), freesoft.c, quotearg.c instead of quote.c,
+    quotearg.h.
+    (distfiles): Add acconfig.h, message/*.
+    (all): Depend on $(destfiles), not info.
+    (version.c): Parenthesize `GNU diffutils'.
+    (common_o): Add freesoft.o
+    (diff_o): quote.o -> quotearg.o
+    (diff3_o, sdiff_o): Likewise.
+    (diff.dvi): Depend on version.texi.
+    (diff.o diff3.o quotearg.o sdiff.o util.o): New dependency on quotearg.h
+    (diff3.o): DIFF_PROGRAM -> DEFAULT_DIFF_PROGRAM.
+    (sdiff.o): Likewise.
+    (messages.po): Remove.
+    (message/msgid.po, message/template.po): New rules.
+    (maintainer-clean): Renamed from realclean.
+    (install): Install from source directory, if applicable.
+    Invoke install-info if needed.
+    (install-strip): New rule.
+    (check): Set DIFF.
+    (stamp-h.in): Don't put the date into the timestamp.
+    (D_dirs): Add $D/message.
+    ($D.tar.gz): Compress with gzip -9.
+    (srcs, distfiles, diff_o, diff3_o, sdiff_o): Rename quotearg.c to
+    quotesys.c and quotearg.h to quotesys.h.
+
+commit 8a60489fa41523137624aeef82c6bd353a8a4ea9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 00:34:04 1998 +0000
+
+    (same_file): Add.
+
+commit 40a2ed14d8c92b5859472b0034a31bbe0bec7a5c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 00:34:04 1998 +0000
+
+    Don't alter PROGRAMS.
+
+commit 7a3d2137801b5848c56cc36fa151393342b0faf8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 00:34:04 1998 +0000
+
+    Update FSF address.
+    (quote_system_arg): Renamed from system_quote_arg.
+
+commit ddf93d23968097487ae48fa72c3bb87e250afdc7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 00:34:04 1998 +0000
+
+    (DEFAULT_DIFF_PROGRAM): Renamed from DIFF_PROGRAM.
+    When editing mkinstalldirs rule, look for exec_prefix and prefix.
+    Add .exe when installing files.
+
+commit 822edd195b0e0d752a032c171ea17fb949a25953
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 00:34:04 1998 +0000
+
+    (%.exe): Remove.
+    (pc-clean): Remove *.exe
+
+commit 03bd647315af7369818dbdc533e5e7ad2f71d8b4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 00:34:04 1998 +0000
+
+    (same_file): Remove.
+
+commit 6e9a130189c23ea1f75fd1cfe52be084e9d6957f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 00:26:54 1998 +0000
+
+    Initial revision
+
+commit 877cbd3f3a05e5f29cc0934a5cb57e14cd20279a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 00:25:27 1998 +0000
+
+    Add copyright date and update FSF address.
+
+commit 9703835363fa00fe91fbda23a565c6dd57e03a77
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 14 00:22:05 1998 +0000
+
+    (diff_dirs): Check for recursive directory loop.
+    Arg is now struct comparison const *.
+    (dir_loop): New function
+
+commit 15cb246458767a925a974aa2292ec3a41eecf469
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 23:17:39 1998 +0000
+
+    Initial revision
+
+commit 064482a2366d06a1b299c26cb6f1dd7001e1d7d5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    Add --with-mvfs-stat-bug, --with-nfs-stat-bug.
+
+commit 27d11e852fec1a55420b928e75ba2cc3012ab5f1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    (quotearg.h): Include.
+    (PR_PROGRAM): New macro.
+    (pfatal_with_name): Abort if error returns.
+    (fatal): Likewise.
+    (print_message_queue): Free message chain after printing.
+    (currently_recursive): Renamed from current_depth, and now a boolean.
+    (begin_output): Report error if fflush does.
+    Avoid stdio and gettext in child.
+
+commit 79532e867d0bd3f4653600485cd24b00eeed99a1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    (__attribute__): New macro.
+    (getenv): Don't declare if HAVE_STDLIB_H.
+    (CHAR_MAX): New macro.
+    (<locale.h>): New include.
+    (<locale.h>): Include before <libintl.h>.
+    (could_be_mvfs_stat_bug, could_be_nfs_stat_bug, dev_may_have_duplicate_ino,
+    same_special_file): New macros.
+    (same_file): Use them.
+
+commit 7571701a555b3cf0865f496ba5c46b5a09dc12c6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    (print_half_line): Add brackets to pacify GCC -Wall.
+
+commit 8e6e1bd3ac438d54c8ee50f34674e051f676fa82
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    (quotearg.h): Include.
+    (DIFF_PROGRAM, DEFAULT_EDITOR_PROGRAM): Remove.
+    (free_software_msgid, editor_program, not_found): New vars.
+    (diffbin, edbin): Remove.
+    (editor_program): Renamed from edbin.
+    (edit, interact): Now take extra string arg.
+    (exiterr, fatal, perror_fatal, try_help): Add noreturn attribute.
+    (sigset_t, sigemptyset, sigmask, sigaddset, SIG_BLOCK, SIG_SETMASK):
+    (sigprocmask): New macros, if !HAVE_SIGPROCMASK.
+    (error): Now has printf attribute.
+    (longopts, main): Don't assume ASCII.
+    (try_help): New operand arg.
+    (usage): Conform to new GNU standards.
+    (main): Set static vars for editor and diff program.
+    Compare getopt_long result to -1, not EOF.
+    -v conforms to new GNU standard.
+    Complain better about extra and missing operands.
+    If HAVE_VFORK, block SIGINT and SIGPIPE in the parent, since when
+    the child munges its handlers it may somp on the parent.
+    Pass rname to intract.
+    Translate not-found message before forking.
+    (give_help): Just output it all at once.
+    (edit): New args lname, lline, rname, rline.
+    (edit): New command 'd'.
+    (interact): New args lname, rname.
+
+commit aa33c53a5189298c2a8472dc6ccf9bab1ff0b5bc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    Update FSF address.
+
+commit c275147038536345976081c670b095fb030e86c5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    (cmpbuf.h): Include.
+    (slurp): Check for arithmetic overflow when computing buffer size.
+
+commit a3349dc5c0641e7057981f35ae49e321f157e4ca
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    Remove `#if 0'ed code.
+
+commit 0972f1796deefe04b688322397f930f9216adbe8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    (quotearg.h): Include.
+    (free_software_msgid): New decl.
+    (RANGE_START, RANGE_END): Renamed from START and END.
+    (fatal, perror_with_exit, try_help): Add noreturn attribute.
+    (error): Add printf attribute.
+    (diff_program): Now a ptr, not an array.  Initialize to DEFAULT_DIFF_PROGRAM
+    instead of DIFF_PROGRAM.
+    (longopts, main): Don't assume ASCII.
+    (main): Use DIFF environment var to specify name of diff program.
+    Compare getopt_long result to -1, not EOF.
+    -v now reports version according to new GNU standard.
+    Report spelling of extra operand, or last operand before missing one.
+    (try_help): Now takes operand arg.
+    (option_help_ms): Fix typo: missing comma.
+    (usage): Update as per current GNU standards.
+    (environ): Remove decl.
+    (read_diff): Invoke diff with --inhibit-hunk-merge.
+    Translate `not found' message before forking.
+    Quote name of diff program.
+    Pass horizon lines.
+    `memory exhausted' -> `Memory exhausted'
+
+commit 812d24c69ab194c30ca7d41eba95a06398217be1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    (XTERN): Renamed from EXTERN.
+    (struct filedata): Remove dir_p arg.
+    (struct comparison): New type.
+    (diff_2_files, diff_dirs)" Ise ot/
+    (error): Add printf attribute if applicable.
+    (free_software_msgid): New decl.
+    (pr_program): New decl.
+    (fatal): Add noreturn attribute.
+    (pfatal_with_name): Likewise.
+
+commit 9a57dd54d693952dc3f63ed8baaf99f2fb695132
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    (authorship_msgid): New var.
+    (quotearg.h): Include.
+    (ck_atoi): Remove.
+    (function_regexp_list, ignore_regexp_list): Now static.
+    (binary_flag): Renamed from binary_I_O.
+    (entire_new_file_flag, unidirectional_new_file_flag, print_file_same_flag):
+    Now static.
+    (numeric_arg): Renamed from ck_atoi.
+    New argument specifying the argument type.
+    (longopts, main): Don't assume ASCII.
+    (longopts): Remove old aliases --file-label, --entire-new-file, --ascii,
+    --print.
+    (main): Check for -1, not EOF, when calling getopt_long.
+    Use numeric_arg to report errors.
+    Report error if -l specified but pagination is not supported.
+    Report error if -S is specified twice with conflicting values.
+    Have --version conform to the new GNU standards.
+    Add new --from-file, --to-file, --inhibit-hun,-merge options.
+    Make the horizon at least as large as the context.
+    Add casts to pacify gcc -Wall.
+    (try_help): Add operand arg.
+    (option_help_msgid): Doc fix to match above.
+    (usage): Indent option_help_msgid.
+    (compare_files): Now takes struct comparison
+    instead of two directory names and a depth.
+    (NONEXISTENT, UNOPENED, ERRNO_ENCODE, ERRNO_DECODE):
+    New macros.
+    (DIR_P): New macro.
+    Report error if fflush does.
+
+commit 1a50d285b938342ab331b10f7f05bd22f6502982
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    Fix spacing.
+
+commit 0aa5e6a1bc202f333432c3a4ec2d2b65e1b01a29
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    (authorship_msgid): New var.
+    (free_software_msgid): New decl.
+    (error): Now has printf attribute.
+    (try_help): Likewise.
+    (long_options): Don't assume ASCII.
+    (try_help): Now accepts operand arg.
+    (main): Check for -1, not EOF, when calling getopt_long.
+    Report --ignore-initial value when complaining about it.
+    Output copyright and free software info with -v.
+    Don't assume ASCII.
+    Report last operand when one is missing.
+    Report text of extra operand.
+    Move block_read into cmpbuf.c.
+
+commit fe73cbbe5d4520bc1c6b7e0d177c5911ff91b00c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    (no_discards): Remove.
+    (inhibit): Remove.
+    (shift_boundaries): Don't inhibit.  If inhibit_hunk_merge is nonzero,
+    don't merge hunks.
+    (briefly_report): Now returns 2 if trouble, CHANGES otherwise.
+    (diff_2_files): Now takes struct comparison.  If briefly_report reports
+    trouble, pass it on to caller.
+
+commit f618b639bd9d535a8c38a471b8cea0e7a52f91e0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    (block_read): New decl.
+
+commit c8cc5a397c65806860a5043d55373d58db7ae9e4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    (block_read): Moved here from cmp.c.
+
+commit 227301f86a65a121bd18437a610955db7480888b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:33:07 1998 +0000
+
+    Document recent changes.
+    patch is still only patch 2.2, unfortuantely.
+
+commit 28adfd739abc97634b84ef6f74575e8deac2dc06
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:18:48 1998 +0000
+
+    Mention --from-file=FILE, --to-file=FILE, ed.
+
+commit dcb0b57294bac8d23515770abdee4b3e00b92103
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:18:48 1998 +0000
+
+    (DEFAULT_DIFF_PROGRAM): Renamed from DIFF_PROGRAM.
+    (PR_PROGRAM): All `configure' to define it.
+    (srcs): Add $(diffutils_srcs), freesoft.c, quotearg.c instead of quote.c,
+    quotearg.h.
+    (distfiles): Add acconfig.h, message/*.
+    (all): Depend on $(destfiles), not info.
+    (version.c): Parenthesize `GNU diffutils'.
+    (common_o): Add freesoft.o
+    (diff_o): quote.o -> quotearg.o
+    (diff3_o, sdiff_o): Likewise.
+    (diff.dvi): Depend on version.texi.
+    (diff.o diff3.o quotearg.o sdiff.o util.o): New dependency on quotearg.h
+    (diff3.o): DIFF_PROGRAM -> DEFAULT_DIFF_PROGRAM.
+    (sdiff.o): Likewise.
+    (messages.po): Remove.
+    (message/msgid.po, message/template.po): New rules.
+    (maintainer-clean): Renamed from realclean.
+    (install): Install from source directory, if applicable.
+    Invoke install-info if needed.
+    (install-strip): New rule.
+    (check): Set DIFF.
+    (stamp-h.in): Don't put the date into the timestamp.
+    (D_dirs): Add $D/message.
+    ($D.tar.gz): Compress with gzip -9.
+
+commit 78a974475e68eda02deab1e542c1561c23966a23
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 13 05:18:48 1998 +0000
+
+    Initial revision
+
+commit bf49f4aa398f198b2715a17ac2f7a90a8e13c575
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jan 3 18:53:37 1995 +0000
+
+    Define filename_cmp to stricmp (again).
+
+commit 19aa2d3c918d10bd29d80d01c8dff75d314fb84a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Dec 10 16:46:49 1994 +0000
+
+    Adjust to emx 0.9a.
+    A few compiler options have changed, and gnuregex.dll should have been
+    stripped.
+
+commit 2fb829677f3540677513e3a86b95709147cbc52c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Dec 10 16:42:51 1994 +0000
+
+    Adjust to emx 0.9a.
+
+commit aa8b128119182543a724dfe62c3f44aa5f47ad33
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 27 06:30:14 1994 +0000
+
+    Adjust to latest patch from eliz.
+
+commit c0a49f9f369d12183c53336dece8496422d17205
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 06:24:09 1994 +0000
+
+    (PACKAGE, VERSION, diffutils_srcs, D): New vars.
+    (version.c, version.texi, messages.po): New files.
+    messages.po is built automatically from source files and `getmsgids'.
+    Each function and macro whose first parameter is a gettext msgid
+    has had its first parameter's name changed so it ends in `msgid'.
+    All arrays of msgids have had their names changed to end in `msgid'.
+    `getmsgids' uses this to determine which strings are msgids.
+    All strings that are messages are passed through gettext once before
+    being used, so that they can be localized.
+    Several diagnostics have been changed slightly, to make them more consistent
+    and easier to translate.
+    (distfiles): Add them, pc/*, and getmsgids.
+    (diff.info): Now depends on version.texi.
+    (realclean): Clean messages.po, version.*.
+    (dist): Just build $D.tar.gz.
+    ($D.tar.gz): New file, takes over old `dist' function.
+    Don't assume $(distfiles) are all in same directory.
+
+commit 45db00459e6f2963a02ca721c7ade0393d2c7a90
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:25:53 1994 +0000
+
+    Clean messages.po, too.
+
+commit a6bbb288b23575ef0d0334d78761e63f7f94b5b2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:10:56 1994 +0000
+
+    (AC_CHECK_HEADERS): Add libintl.h, locale.h.
+    (AC_CHECK_LIB): Check for -lintl.
+
+commit 5ce0e7349f49068f794c064023324fed1292442a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:10:56 1994 +0000
+
+    2.7.1 alpha news
+
+commit 993d9f48b184bc387fc3df2a0034d10cc77aaaa9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:10:56 1994 +0000
+
+    (struct msg, message5, print_message_queue): Allocate just one block of memory
+    to save a messsage.
+
+commit 74674f3e03eaeb72158692b229d8ed49416d55dc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:10:56 1994 +0000
+
+    (gettext): Declare; use a stub if ! HAVE_LIBINTL_H.
+    (setlocale): Declare; use a stub if ! HAVE_LOCALE_H.
+
+commit caf01e2fb9559d2643a43f279e4d66bab0deb553
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:10:56 1994 +0000
+
+    (version_string): Fix typo in declaration: `const' was missing.
+    (option_help_msgid, help_msgid): New constant.
+    (usage, give_help): Use them, so message is translated one option at a time.
+    (main): Invoke setlocale first thing, to tell library we're internationalized.
+    (trapsigs): Ignore sigaction failure, to be compatible with `signal'.
+
+commit a0d1e40b965340856a1a07e3adceeeae380d4cd9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:10:56 1994 +0000
+
+    (main): Invoke setlocale first thing, to tell library we're internationalized.
+    (option_help_msgid): New constant.
+    (usage): Use it, so message is translated one option at a time.
+
+commit 893aeeb7e0234f11f9153b365f785fcadfc271d8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:10:56 1994 +0000
+
+    (main): Invoke setlocale first thing, to tell library we're internationalized.
+    -D FOO now outputs `/* ! FOO */ instead of `/* not FOO */'.
+    (option_help_msgid): New constant.
+    (usage): Use it, so message is translated one option at a time.
+    (compare_files): For label, use file_label if set.
+
+commit 4f5769d660ddc9c16421ec97fb0d612b44cb2aa6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:10:56 1994 +0000
+
+    (main): Invoke setlocale first thing, to tell library we're internationalized.
+    (option_help_msgid): New constant.
+    (usage): Use it, so message is translated one option at a time.
+    (sprintc): Renamed from `printc'.  Now outputs to a buffer instead of stdout.
+    (cmp): Use new sprintc semantics.
+
+commit 3da1b0cc6a4f847d4ca8a70444fd7141f0a15290
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:10:56 1994 +0000
+
+    (briefly_report): Rewrite `message (A?"B":"C")' as
+    `if (A) message ("B") : message ("C")'; this is for getmsgids.
+    (briefly_report, diff_2_files): For label, use file_label if set.
+
+commit 204c39de358b8675209e67045ee718e460832bd8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:10:56 1994 +0000
+
+    Use version.texi.
+    -D FOO now outputs `/* ! FOO */ instead of `/* not FOO */'.
+
+commit 629b424629fa32d92e4cd64c36cc87071b4ff2b0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:10:56 1994 +0000
+
+    Initial revision
+
+commit e386d1b4b1a344260d02ac9f573cf7114fe97b29
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 14 05:10:56 1994 +0000
+
+    (PACKAGE, VERSION, diffutils_srcs, D): New vars.
+    (version.c, version.texi, messages.po): New files.
+    messages.po is built automatically from source files and `getmsgids'.
+    Each function and macro whose first parameter is a gettext msgid
+    has had its first parameter's name changed so it ends in `msgid'.
+    All arrays of msgids have had their names changed to end in `msgid'.
+    `getmsgids' uses this to determine which strings are msgids.
+    All strings that are messages are passed through gettext once before
+    being used, so that they can be localized.
+    Several diagnostics have been changed slightly, to make them more consistent
+    and easier to translate.
+    (distfiles): Add them, pc/*, and getmsgids.
+    (diff.info): Now depends on version.texi.
+    (realclean): Clean version.*.
+    (dist): Just build $D.tar.gz.
+    ($D.tar.gz): New file, takes over old `dist' function.
+    Don't assume $(distfiles) are all in same directory.
+
+commit 8c445c7c3aeee3eaed656d65d6a3958d4e5450b1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Nov 13 20:59:45 1994 +0000
+
+    Add HAVE_LIBINTL_H, HAVE_LOCALE_H, HAVE_LIBINTL.
+
+commit 9826645f369ae45dcae53502731b30a9762a050f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 9 17:42:44 1994 +0000
+
+    (trapsigs): Don't check signal return value, since it's bogus under djgpp.
+
+commit 49a8fa06517d91e798bf13c34bd446d55b1d401b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 9 17:22:07 1994 +0000
+
+    Include <sys/emxload.h>.  Define _REGEX_RE_COMP.
+
+commit 7e13cd4cb189a8c1903c81018f20a671eaeedace
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 9 17:22:07 1994 +0000
+
+    Remove quote.o.
+
+commit a8a1d53a240395260d8bd1be3567aa5513b1acdf
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 17:04:40 1994 +0000
+
+    Fix to match autoconf 2.0 outline.
+
+commit 919d9efa7dac5ba8448c1703a8b3e4259b33c43d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    (pr_program): New var.
+    (begin_output): Use system_quote_arg to compute command.
+    (analyze_hunk): ignore_regexp_list -> ignore_regexp.fastmap
+    Fix off-by-1 line length bug.
+    Match with one big regexp instead of a list of regexps.
+    Use new `trivial_length' local instead of comparing line's first byte to `\n'.
+    Help the compiler with linbuf local vars.
+
+commit 47acc0b36a848b347b06303f5a2e07e5c5f1a405
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    (system_quote_arg): New function; replaces SYSTEM_QUOTE_ARG macro.
+
+commit c421d599f88317290e4b321ea44bef3230bc8ae5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    (main): Use system_quote_arg to compute command.
+
+commit f1fe427f312e5fbadf22c83c785d78915aea6490
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    (find_identical_ends): function_regexp_list -> function_regexp.fastmap
+
+commit 2e6f3b4f2528bdaee622ef8da7119917fb986e22
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    (read_diff): Quote arguments with system_quote_arg.
+
+commit d3f8acca914ce995591af64dbc291defd2ac3606
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    (function_regexp, ignore_regexp): Replace lists of compiled regexps with
+    these single compiled regexps.
+    (regexp_list, function_regexp_list, ignore_regexp_list): Moved to diff.c.
+
+commit 0bde792586cd647051d4dcb31362a09022cca9e9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    (option_list): Quote options with system_quote_arg.
+    (add_regexp): Build one big regexp instead of a list of regexps.
+    (summarize_regexp_list): New function.
+    (regexp_list): Redesigned struct; moved here from diff.h.
+    (function_regexp_list, ignore_regexp_list): Likewise, for vars.
+
+commit 5b6f6d8841181216494161371b434a2e35462125
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    (find_function): Simplify interface: don't return size of function line.
+    All callers changed.  function_regexp_list -> function_regexp
+    (print_context_script, pr_context_hunk, pr_unidiff_hunk):
+    ignore_regexp_list -> ignore_regexp.fastmap
+    (print_context_script, find_function): INT_MAX now denotes no previous match;
+
+commit 4d0d153b38abed7ee9c4ca5bbf461a03ad1e626e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    Fix comment.
+
+commit 55ffd9714e96495ca0c309eb4b5d0d027839d9cb
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    (diff_2_files): ignore_regexp_list -> ignore_regexp.fastmap
+
+commit c451a2003646e9b05a649b4d86f7a09ca2364a62
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    \ -> /
+
+commit 0d75a4d1e5c382ae7dd866adcca6e92470f955ab
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    Remove __GNU_LIBRARY__, SYSTEM_QUOTE_ARG, system_quote_arg.
+
+commit 24bcded990501669da1107c79bfa065d36e58517
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    (system_quote_arg): Compute size if first arg is 0.
+
+commit bb9307fe16533d834ef2a1181760eff97b5262f4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    Quote CFLAGS= for djgpp GNU make.
+    Clean *.bat, fname.
+    Move dist to different directory.
+
+commit dbc2dc8d0c2dddbfe9ae97d1d0c9bb4103990f5b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    Update version number, remove `only' typo.
+
+commit 9d37018f319b9912e6566c3a9e85172385d88023
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 31 07:27:27 1994 +0000
+
+    (srcs, diff_o, diff3_o, sdiff_o): New files quote.c, quote.o.
+
+commit 0c5e4918da08819eed4a360b28e67df68b971205
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 15 20:09:12 1994 +0000
+
+    (perror_with_name, fatal): Use GNU `error'.
+    (error): Remove.
+    (line_cmp): tolower -> _tolower
+    (xmalloc, xrealloc): Remove.
+
+commit 4ce826fb34d8011e8c021eeb14a283ccc920cec5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 15 20:09:12 1994 +0000
+
+    (_tolower): Define if not already defined.
+    (malloc, realloc): Remove unused declarations.
+
+commit 2f95916004c9c67345c8e9298d0a8a8394ff58aa
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 15 20:09:12 1994 +0000
+
+    (xmalloc): Remove.
+    (diffarg): Take advantage of cleaner xrealloc semantics.
+
+commit f431aa8c700cb727f1b9b065d0f1d25c8a68f378
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 15 20:09:12 1994 +0000
+
+    (ROL): Use sizeof to make it more generic.
+    (slurp): Align buffer size to word size, in case malloc cares.
+    (find_and_hash_each_line): Don't invoke line_cmp if the length
+    differs and -i is in force.  tolower -> _tolower; this speeds
+    up diff -i considerably under some hosts (e.g. Solaris 2.3).
+    Don't assume ISSPACE ('\n') is nonzero.
+
+commit ce8a482bf4c3e4ad1ea70e55a74b96a43c8b0e7a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 15 20:09:12 1994 +0000
+
+    (groups_letter_value): tolower -> _tolower
+
+commit 1fbe4c853ce4b9fda8167ca4751b49b598492f11
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 15 20:09:12 1994 +0000
+
+    (main): Use strerror (EISDIR) instead of "Is a directory".
+    (xmalloc, xrealloc): Remove.
+    (fatal, perror_with_exit): Use `error'.
+
+commit 5b1cad81664d06f45e309032e914e3f743df3ff0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 15 20:09:12 1994 +0000
+
+    (ignore_some_line_changes): Removed.  All users changed.
+    (error): Change to GNU library standard.  All callers changed.
+    (xmalloc_exit_failure): New variable.  xmalloc and xrealloc are now taken
+    from GNU library.  All `main' programs set this variable at the start.
+
+commit 67e172c7653a143ac67d7d1fdeeee9a548206424
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 15 20:09:12 1994 +0000
+
+    (add_exclude): Can now assume xrealloc (0, ...) works.
+    (add_regexp): Free storage on failure.  Allocate storage all at one go.
+
+commit ff04d4a6b8586b52b7266bfcaa31420b99cd5a52
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 15 20:09:12 1994 +0000
+
+    (main): Align buffer size to word size, in case malloc cares.
+
+commit 9f40dabd6b4732fa4c39e4ed97d1cf3c8b9fc252
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 15 20:09:12 1994 +0000
+
+    error caller changed
+
+commit ea3d57c64052bd50583c58ec9341fa4985c2ac12
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 15 20:09:12 1994 +0000
+
+    (common_o): New variable.  Link error.o and xmalloc.o into all programs.
+    (check): Depend on $(PROGRAMS).
+
+commit ae76071a49d024000e07435d703b2d527e22b616
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Wed Oct 12 21:04:35 1994 +0000
+
+    (main): Set xmalloc_exit_failure.
+
+commit 67feaeb0f0dc56b39eb5323710b6a53322ab39de
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 3 08:00:09 1994 +0000
+
+    ENV -> env
+
+commit a37fd034dd1bfb4f6e09990209f8c992f9865eeb
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 3 08:00:09 1994 +0000
+
+    ENV -> env.  Remove makefile rules.  Read pc/makefile.
+
+commit e13374d8246c1237bc4a4b09228636cba0b2e9df
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 3 08:00:09 1994 +0000
+
+    Simplify the instructions by building a makefile.
+
+commit ac58035dd2b9f19b73316a91b1af4c53d71dd6ba
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 3 08:00:09 1994 +0000
+
+    Simplify the instructions.
+
+commit fd736c91704211b015c294d4095ecaefeeae3a5a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 3 06:52:06 1994 +0000
+
+    / -> \
+
+commit 5cd6116e856f71b079262ff542728239c285840c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 3 06:51:30 1994 +0000
+
+    / -> \.  65536, not 64*1024, in case somebody has a small int compiler.
+
+commit 6879b8f6f99fd5011f3dc6554630ccce66cb5804
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Oct 2 21:25:49 1994 +0000
+
+    Limit to only emx-specific stuff.
+
+commit ab1150bcb901777c73ad616bb02185f438bade88
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Oct 2 21:25:49 1994 +0000
+
+    Initial revision
+
+commit 1330271d767986819db277aa63fe5c9989dcded7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Oct 2 21:25:49 1994 +0000
+
+    Limit to only djgpp-specific stuff.
+
+commit 6c746d1930205bb57496235eee9023141d183175
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Oct 2 21:25:49 1994 +0000
+
+    Remove initialize_main.
+
+commit b092c9884a1cf2a55f13ab26845e7c23d80715ff
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Oct 2 21:25:49 1994 +0000
+
+    Generalize to dgcpp.
+
+commit b85f4c403ed4e705bbf85664e240979f1ec67949
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Oct 2 21:25:49 1994 +0000
+
+    Update for djgpp.
+
+commit 4e44a14836a44835c63c0534b5895ac47d632759
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 1 17:19:37 1994 +0000
+
+    diffutils 2.7 news
+
+commit 7a2d60ee66481b4fcb77274cb2dd0ef53854a759
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 1 05:24:19 1994 +0000
+
+    Update to version 2.7
+
+commit a2290f8c7f41e5e0a1b1cf564427b50ab6751078
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 1 05:14:15 1994 +0000
+
+    (AC_HEADER_SYS_WAIT): Add.
+    (AC_CHECK_HEADERS): Remove sys/wait.h.
+    (AC_CHECK_FUNCS): Add tmpnam.
+
+commit babad6e9ab0e7d3ff46f154307a473e2924dd8b0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 1 05:14:15 1994 +0000
+
+    (dir_file_pathname): Use filename_lastdirchar instead of strrchr.
+
+commit 57e35b2fe52c8727730fb758eeb17ad1fbd28e66
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 1 05:14:15 1994 +0000
+
+    (<sys/wait.h>, WEXITSTATUS): Use simpler scheme now that HAVE_SYS_WAIT_H
+    is turned off on hosts that are incompatible with Posix applications.
+
+commit 6159ec6f1a9cd96a128da3e3fd4486cdd2d3b646
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 1 05:14:15 1994 +0000
+
+    (private_tempnam): Use tmpnam if HAVE_TMPNAM; this simplifies porting.
+    (exists, letters): Omit if HAVE_TMPNAM.
+    (expand_name): Use filename_lastdirchar instead of strrchr.
+
+commit 51ee538828055feaae3ea5d6b06b5128c1df2954
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 1 05:14:15 1994 +0000
+
+    (read_diff): If STAT_BLOCKSIZE yields zero, adjust it to a more reasonable
+    value.
+
+commit 07ed0ecefeca9be0536797cec89ed07e6446d898
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 25 01:21:32 1994 +0000
+
+    Initial revision
+
+commit bf5a7b416679853f17a4b9067df5c32d176054cb
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 24 20:36:40 1994 +0000
+
+    (exists, private_tempname): Adopt latest GNU libc algorithm.
+    (private_tempnam): Specialize for sdiff to avoid portability problems.
+
+commit 7189dccfb05cf4d5c6a76b6cfadf4aa1c97dd9e1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 24 05:55:49 1994 +0000
+
+    Add rules for `default:' and `.SUFFIXES:'.
+
+commit 4a676345371383b8ba54148f0293d493e12b2b4b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 24 05:55:49 1994 +0000
+
+    Add io.h.
+
+commit 7e3fa69d9216db89af49fee2e36a63c88c611589
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    (AC_ARG_PROGRAM): Added.
+    (AC_OUTPUT): Add [date > stamp-h].
+
+commit 7124caf284e39d75650ebe9088f26d240abbbbeb
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    isspace -> ISSPACE, etc.
+    (PR_PROGRAM): Moved here from diff.h (old name was PR_FILE_NAME).
+    (begin_output): Use SYSTEM_QUOTE_ARG.
+
+commit 87791d0033ba440a562dd110c916e69c14a09929
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    <string.h>: Include if HAVE_STRING_H, too.
+    (CTYPE_DOMAIN, ISDIGIT, ISPRINT, ISSPACE, ISUPPER): New macros that
+    work around common <ctype.h> problems.
+    (O_BINARY): Remove.
+    (SYSTEM_QUOTE_ARG): New macros.
+
+commit 56ebd036789ec66bd34447b959126c4f71485543
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    isprint -> ISPRINT
+
+commit 20bb7b34b24e09a2229ce5f414d3e554ec506046
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    isspace -> ISSPACE, etc.
+    <ctype.h> now included by system.h.
+    (DEFAULT_EDITOR_PROGRAM): Renamed from DEFAULT_EDITOR for consistency.
+    (TMPDIR_ENV): New macro.
+    (expand_name): Change `isdir' to `is_dir' to avoid theoretical ctype
+    namespace contamination.
+    (main): Use SYSTEM_QUOTE_ARG.
+    (private_tempnam): Don't access "/tmp" directly; access it via PVT_tmpdir.
+
+commit 908dadc7b9c64bdbe7f9e22aeb8d0ccdad66f205
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    isspace -> ISSPACE, etc.
+    (word): Don't define if already defined.
+    (read_files): Set mode to binary before returning 1.
+
+commit 9ea02bc7c5da7ec118bed0d7a4614fa3fb2f13f6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    isdigit -> ISDIGIT, etc.
+
+commit 321868dd1585e35b2292d23bfe69f2ad69b53eab
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    <ctype.h> now included by system.h.
+    (main): Give proper diagnostic if too many labels were given.
+    (read_diff): Use SYSTEM_QUOTE_ARG.
+
+commit 272b19fed95dac834234343f2be96966be004a64
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    <ctype.h> now included by system.h.
+    (PR_FILE_NAME): Rename to PR_PROGRAM and move to Makefile.in, util.c.
+
+commit 4c5217c90efc4f69a7bed6022fe09da968e977a3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    Add comment.
+
+commit b53ee8d668cf8834a6a8b82db45368b5a0dd8355
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    (word): Don't define if already defined.
+    (main): Use setmode, not open(..., O_BINARY); this hits stdin too.
+    Use NULL_DEVICE instead of "/dev/null".
+    (cmp): Use %lu instead of %ld when it is more likely to give correct output.
+
+commit 2b982bf06e9a2d3b9d7676a9c77eda2a4f709701
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    Initial revision
+
+commit dcbd46bfa35db430751e6504f6212a60e3857be0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    Broaden name.
+
+commit 03d25aa193d61d08b384cde510238b2ee92d882d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    Rewrite from scratch.
+
+commit 654e86283e81c14a294bf88fc4c3945130742ab4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    Make it more like ../config.hin.
+
+commit 21a8299b8eb5607b386ed2c9c8351cd8be905290
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    Revamp for more Unix-like approach.
+
+commit d970a9641829918a7e7ee822b5cb2ce16a50aef0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 22 16:47:00 1994 +0000
+
+    (DEFAULT_EDITOR_PROGRAM, DIFF_PROGRAM, LIBOBJS, NULL_DEVICE, PR_PROGRAM,
+    PROGRAMS): New variables.
+    (check, stamp-h.in, cmp.o, util.o): New targets.
+    
+    (edit_program_name): New variable; replaces old binprefix method.
+    (install, uninstall): Use it.
+    (binprefix): Removed.
+    
+    (distfiles): Add stamp-h.in.
+    (clean): Remove stamp-h.
+    (config.hin, config.h): Use time stamp files to see whether they're up to date.
+    
+    (cmp_o): Add $(LIBOBJS).
+    
+    (install): Install info files from srcdir if they're not in `.'.
+
+commit 8e031e750eaa8342e5f7c9bef35fa365d7ab6607
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 18 00:28:22 1994 +0000
+
+    Patches from Kai Uwe Rommel
+
+commit 72cc814aef0a183c56b291f20e8d61df4f71078c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Sep 16 21:31:04 1994 +0000
+
+    Patches from Kai Uwe Rommel
+
+commit bc5201049a73639af8aa8248ccc8d981c6e5c304
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 15 17:58:49 1994 +0000
+
+    remove CR
+
+commit a279fecaaa46bbe8705f709cb663eb5a03ef0754
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 15 17:58:49 1994 +0000
+
+    Remove CR and usage.  Improve / \ : detection.
+
+commit dd79db47919506ab46cdd663564077f8355ec4d9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 15 17:58:49 1994 +0000
+
+    Make it look mre like config.hin and system.h.
+    Add HAVE_SETMODE.  Remove quote_char.  Define same_file to -1.
+
+commit 9f01c902c5ca320d417cd1f88d618b6b2e62cf36
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 15 17:58:49 1994 +0000
+
+    Initial revision
+
+commit a268b2bd9e798f6488337f65f944a76c18026225
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 15 17:49:34 1994 +0000
+
+    (program_name): Renamed from `program', for consistency.
+
+commit f19358db7aaa40289485bc06d371a51758d33a13
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 15 17:49:34 1994 +0000
+
+    (printc): Don't quote C if isprint(C).
+
+commit 110ed53bfe349fe7bf9563917867a6b1f8dd28b0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 15 04:25:50 1994 +0000
+
+    Initial revision
+
+commit 675bab82c354f325d81e642493282fb306087383
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 14 15:04:41 1994 +0000
+
+    entered into RCS
+
+commit 262be8ba548bb57e81deb3efee6db5fe57de9d63
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Sep 13 18:46:43 1994 +0000
+
+    (AC_FUNC_MEMCHR): Remove.  Autoconf didn't adopt this, since we need not
+    worry about an old experimental library where memchr didn't work.
+    (AC_FUNC_MEMCMP): Not needed, since we only test for equality.
+    (AC_REPLACE_FUNCS): Add test for memchr.
+    (AC_CHECK_FUNCS): Check for memchr, not memcpy, since it'll be cached.
+    (AC_CHECK_HEADERS): Add string.h; regex.c uses on some old hosts.
+
+commit ea404e8bfb25c662a13f2754496527127babd986
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Sep 13 18:46:43 1994 +0000
+
+    (memcmp): Define in terms of bcmp.
+    Use HAVE_MEMCHR to test for all mem* routines.
+
+commit 9bb6665825b1d7f807400fd4fe08f6997fe06fdc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Sep 13 18:46:43 1994 +0000
+
+    (srcs): Remove memcmp.c.  We use bcmp if memcmp doesn't work, since
+    we only test for equality.
+
+commit 2f93e7ee108f1f13c923edb19fa57ef45df61b67
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 12 15:52:22 1994 +0000
+
+    (line_cmp): Now takes just two arguments, and no longer optimizes
+    for common case of exact equality; the caller does that optimization now.
+    Optimize for the common case of mostly exact equality.
+    Use isupper/tolower instead of islower/toupper, for consistency.
+    (line_cmp, print_line): Use '\n' instead of line_end_char.
+
+commit d11c579336b08ac6fae564d9c08edaaf49227657
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 12 15:52:22 1994 +0000
+
+    Use more modern autoconf approach to standard C headers.
+
+commit f51c8e0cddd964748e70cac48347cc3e80c8dd1e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 12 15:52:22 1994 +0000
+
+    Fix copyright notice.
+
+commit db138267996a9c496249d25d67dc0cf7eaa52f3b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 12 15:52:22 1994 +0000
+
+    (binary_file_p): Assume non-broken memchr.
+    (find_and_hash_each_line): Revamp to fix some inconsistencies with -b -w -i
+    and incomplete lines.  Incomplete lines are now put into their own bucket.
+    This means line_cmp no longer needs line length arguments,
+    and equivalence classes' line length no longer need to include \n.
+    Invoke line_cmp only if memcmp fails and if ignore_some_line_changes.
+    (prepare_text_end): -B no lonter ignores missing newlines.
+    (read_files): Allocate another bucket for incomplete lines.
+
+commit 55429168429dce9d0e88798656cc3ee871e6e1d2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 12 15:52:22 1994 +0000
+
+    (ignore_some_line_changes): New variable; replaces `length_varies'.
+    (line_end_char): Removed; it wasn't being used consistently.
+    (line_cmp): Now takes just pointers to two lines.
+
+commit b86bc30b1bcfcec54b7baf97ae53121711cc1e5d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 12 15:52:22 1994 +0000
+
+    (main): Use '\n', not line_end_char.
+    (ignore_some_line_changes): New variable; replaces `length_varies'.
+
+commit 2113dba0f38db53564ebfc6de3bdee4b6a62c9ec
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 12 15:52:22 1994 +0000
+
+    entered into RCS
+
+commit f7d04f3e12be3c299d7f19de309e56f6b9f3e958
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 12 15:52:22 1994 +0000
+
+    (CPPFLAGS, DEFS, CFLAGS, LDFLAGS, prefix, exec_prefix): Default to
+    autoconf-specified strings.
+    (COMPILE): Use the defaults.
+    (srcs): Add memcmp.c.
+    (distfiles): Rename config.h.in to config.hin and install.sh to install-sh.
+    (Makefile, config.h, config.hin, config.status): Rework for compatibility
+    with Autoconf 2.
+
+commit e85eb8cb146fba69cee6d3febd3ce3fb2b42c8bb
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 8 08:23:15 1994 +0000
+
+    Add memchr.c, waitpid.c, install.sh
+
+commit 1bc9633710949deb5fc6a273f6132298f1f49d9c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 8 08:08:03 1994 +0000
+
+    (srcs): Add memchr.c, waitpid.c
+
+commit 3fd81d5f8c566232232b48e3be861dd1ea90cbf2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 8 07:23:11 1994 +0000
+
+    Revamp for Autoconf 2.
+
+commit f098afa7d2a130cf2d0a9806d7a3ee4ea26d083c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 8 07:23:11 1994 +0000
+
+    (memchr, waitpid): Remove; use new substitutes instead.
+
+commit 3dfe2ea421249d9d7aa11e0ad37e6783648439ad
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 8 07:23:11 1994 +0000
+
+    Use Autoconf 2 style HAVE_DIRENT_H etc. macros for directories.
+
+commit 17fa709c6bbfbed7c8111fff02d08d1f2011764d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 8 07:23:11 1994 +0000
+
+    (try_help): New function.
+    (usage): Just print usage; let caller worry about exiting.
+    (memchr, waitpid): Remove; use new substitutes instead.
+
+commit 350a6ba55235b740d03afc84562a8df2212fa389
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 8 07:23:11 1994 +0000
+
+    (dir_sort): Prefer NAMLEN (p) to strlen (p->d_name).
+    Change VOID_CLOSEDIR to CLOSEDIR_VOID for Autoconf 2.
+
+commit 66bbc88b540532674c1f3d3ef26bbb5df765fea8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 8 07:23:11 1994 +0000
+
+    (try_help, check_stdout): New functions.
+    (usage): Just print usage; let caller worry about exiting.
+    (read_diff): Use new waitpid substitute.
+
+commit a9a3e02a8eb2398b96ee79158e57879425d79356
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 8 07:23:11 1994 +0000
+
+    (try_help, check_stdout): New functions.
+    (usage): Just print usage; let caller worry about exiting.
+    (option_help): New variable.
+    (filetype): Add Posix.1b file types.
+
+commit 4fdea93974738df7a4b6441094475a533b596b29
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 8 07:23:11 1994 +0000
+
+    (try_help, check_stdout): New functions.
+    (usage): Just print usage; let caller worry about exiting.
+
+commit 6d47c45cbfb6acbe46683411298a929b84751ba6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 8 07:23:11 1994 +0000
+
+    *** empty log message ***
+
+commit 23141bbc07269c4d06fbe064b14661ab1ea61bd7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 8 07:23:11 1994 +0000
+
+    (diff_o, diff3_o, sdiff_o): Add $(LIBOBJS).
+
+commit 3e4d9d4cac16150f748a35c6487174267c06de87
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 3 16:43:25 1994 +0000
+
+    *** empty log message ***
+
+commit 2d876bd5c4ff0401e0bdc6ea0b18d4753a122c0d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 3 16:37:31 1994 +0000
+
+    (distfiles): Add install.sh.
+
+commit 78d1350a8f30594109ab24a089ab0d8e38fb0d85
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 3 16:12:53 1994 +0000
+
+    Switch to new autoconf naming convention.  Add test for sys/file.h.
+
+commit 3b57b651310db7feae5bbe3b28ea80327a9b296d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Sep 2 16:01:49 1994 +0000
+
+    (main): Call initialize_main first.
+    If we'll have children, make sure SIGCHLD isn't ignored.
+    (read_diff): Use popen+pclose if !HAVE_FORK.
+    (DIFF_CHUNK_SIZE): Removed.  We now get initial chunk size from STAT_BLOCKSIZE.
+    (INT_STRLEN_BOUND): New macro.
+
+commit 14cae612e4f2f21e1ba9e9f7ab35c834a2fd82ca
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Sep 2 15:46:39 1994 +0000
+
+    (ck_fdopen): Function removed.
+    (cleanup, main, waitpid): Use popen+pclose if !HAVE_FORK.
+    (edit): Use system if !HAVE_FORK.
+    (main): Call initialize_main first.
+    (execdiff): Now assumes caller has pushed all args, plus trailing 0.
+    All callers changed.
+    (trapsigs): If we'll have children, make sure SIGCHLD isn't ignored.
+    (private_tempnam): Try TMP if TMPDIR isn't defined.
+    Fit temporary filenames into 8.3 limit.
+
+commit 160c4a9fb615e713855f6f7668967b3ce46366d9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Sep 2 15:36:53 1994 +0000
+
+    Include <sys/file.h> only if HAVE_SYS_FILE_H.
+    (S_IXGRP, S_IXOTH, S_IXUSR): Remove unused macros.
+    (STAT_BLOCKSIZE): Don't define if already defined.
+    (min, max): Undef if already defined.
+    (filename_cmp, filename_lastdirchar, HAVE_FORK, HAVE_SETMODE, initialize_main
+    O_BINARY, same_file): New macros, for porting to non-Posix systems like DOS.
+
+commit 4f042426fe9d274466b6e3d163907d0ddd60fa16
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Sep 2 15:32:35 1994 +0000
+
+    (binary_I_O): New variable for --binary option.
+    (main, usage, compare_files): Support --binary option.
+    (main): Call initialize_main first.
+    If we'll have children, make sure SIGCHLD isn't ignored.
+    (compare_files): Use filename_cmp to compare file names.
+    Use filename_lastdirchar to find last directory char in a file name.
+    Use same_file to determine whether two files are the same.
+
+commit 5656c2c6e7a5ab0445b429d3362060b91046c853
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Sep 2 06:09:57 1994 +0000
+
+    (begin_output): Use popen+pclose if !HAVE_FORK.  Check fdopen status.
+
+commit 0e014790ed7103a777f6c6b8ff5beecd98bf1060
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Sep 2 05:14:12 1994 +0000
+
+    (sip): If HAVE_SETMODE, always test for binary files using binary mode.
+
+commit 1ec43a06812d6f7b40909f5052c5be09834f8b40
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Sep 2 05:12:08 1994 +0000
+
+    (print_context_label): Check whether (broken) ctime yields 0.
+
+commit 883e61c62b6cb8d5bb756b938190f1e6674e781d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 1 17:01:31 1994 +0000
+
+    *** empty log message ***
+
+commit 15535d055503d8b86b917c203ceffb13523d5c7e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 1 17:00:47 1994 +0000
+
+    (distclean): Clean config.cache, config.log (for new autoconf).
+
+commit 8c3fba9345221724d146a265a40729bc3e910d11
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 1 17:00:41 1994 +0000
+
+    (main): Call initialize_main first.
+    Use filename_cmp to compare file names.
+    Use same_file to determine whether two files are the same.
+
+commit d32dfccb104b0b7d008244c546e07db940903225
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 1 17:00:28 1994 +0000
+
+    (compare_names, diff_dirs): Use filename_cmp to compare file names.
+
+commit d987d052d321fe4bc6a6056a1022f7fe7af42d53
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 1 17:00:17 1994 +0000
+
+    (format_group, groups_letter_value): Use * instead of [] in prototypes.
+
+commit 7dce49b3b5a94ced9368316d26e63f04b1e896d5
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Fri Jun 17 15:23:43 1994 +0000
+
+    (info, dvi, diff.dvi): New targets.
+    (clean): Remove TeX output files.
+
+commit 474d970822b10b7038c48706dd4569b82a469890
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Jun 17 05:37:52 1994 +0000
+
+    (word): Change from typedef to #define, to avoid collision with
+    Unicos 8.0 <sys/types.h>, which also typedefs `word'.
+
+commit bc6bec73a8d99b7ffd663d9e39e89d048a2cfc1d
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 15 00:53:01 1994 +0000
+
+    (print_number_range): Don't rely on promotion to make the old-style parameter
+    type agree with the prototype parameter type; this doesn't work on
+    Apollos running bsd4.3.
+
+commit 41a3344a4213e3f722216665139ecead47fa6298
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 15 00:53:01 1994 +0000
+
+    (scan_diff_line): Don't rely on promotion to make the old-style parameter
+    type agree with the prototype parameter type; this doesn't work on
+    Apollos running bsd4.3.
+
+commit 91df35595e5c48238c7f6c916101c0c3e3bcb1f8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 15 00:50:09 1994 +0000
+
+    *** empty log message ***
+
+commit ea61d22f5b1f5852ca31d662d5755da6ae4faeec
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Jan 3 02:05:51 1994 +0000
+
+    (LDFLAGS): Remove -g.  All users changed to use $(CFLAGS) as well
+    as $(LDFLAGS).
+
+commit 5a1a95bc796eb762fbb4f56e20dd0ef7a974d4c4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Dec 13 12:22:58 1993 +0000
+
+    diffutils 2.6
+
+commit 72db0aa2f2ba7fe24a4c6ae5d1dffdeaec81d1a4
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Dec 3 21:07:48 1993 +0000
+
+    (main): allow -p -u.
+
+commit d80108a9e2d9195c0d2aa9c735cbe8cb9e2f75a9
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Dec 3 21:07:09 1993 +0000
+
+    *** empty log message ***
+
+commit 74651693b2a7e01cf61b3fd8545fc47c65555282
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Nov 23 03:51:08 1993 +0000
+
+    (distclean): Remove config.h.
+
+commit c9673423c1166eb994cb3f99d646e50a14fbd631
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 10 08:28:27 1993 +0000
+
+    (AC_HAVE_HEADERS): Add unistd.h; remove AC_UNISTD_H.
+
+commit 5b318f266f7881ea5ebe765c5347716f2543adc3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 10 08:28:27 1993 +0000
+
+    *** empty log message ***
+
+commit 3a23f3eb8afec20ffaf28cd1bfc05661316e7474
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 10 08:28:27 1993 +0000
+
+    (xmalloc, xrealloc): "virtual memory" -> "memory"
+
+commit 0ddcbc909912ca7369813cc4f5bd7e17a278466a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 10 08:28:27 1993 +0000
+
+    (usage): Send usage to stdout, not stderr.
+    (long_options, main, usage): Add `--help'.
+    (main): Send version number to stdout, not stderr.  Exit afterwards.
+
+commit d81ae65145818897ea26e6c11e1528c53afbf3f6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 10 08:28:27 1993 +0000
+
+    (word): Change to `int'; it makes a big difference on x86.
+    (sip, slurp): Put off allocating room to hold the whole file until we
+    have to read the whole file.  This wins if the file turns out
+    to be binary.
+    (primes): Omit large primes if INT_MAX is small.
+
+commit d963c582c1078b9d26243874e14ca5fb82447a6f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 10 08:28:27 1993 +0000
+
+    (usage): Send usage to stdout, not stderr.
+    (long_options, main, usage): Add `--help'.
+    (read_diff): Detect integer overflow in buffer size calculations.
+
+commit ecbe3d8f04cd6006f6f9a64b21fecdeb87281696
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 10 08:28:27 1993 +0000
+
+    (long_options, main, usage): Add `--help'.
+    (main): Send version number to stdout, not stderr.
+    (usage): Send usage to stdout, not stderr.
+    (compare_files): Initialize `inf' properly.
+
+commit 0f8c0d885e8f59efe3a9d2d2cfb2f731b0cd4ebd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 10 08:28:27 1993 +0000
+
+    (word): New type.  All uses of `long' for word-at-a-time comparisons
+    changed to `word'.
+    (long_options, main, usage): Add `--help'.
+    (usage): Send usage to stdout, not stderr.
+    (main): Add `-v'.  Send version number to stdout, not stderr.
+
+commit 4b1a69ee970f3016cb7d1b7a6424673beee6a5f7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 10 08:28:27 1993 +0000
+
+    (too_expensive): New variable, for heuristic to limit the worst-case
+    cost to O(N**1.5 log N) at the price of producing suboptimal output for
+    large inputs with many differences.
+    (diff_2_files): Initialize it.
+    (struct partition): New type.
+    (SNAKE_LIMIT): New macro; merely documents already-used number 20.
+    (diag): New `minimal' arg; all callers changed.  Put results into
+    struct partition.  Apply `too_expensive' heuristic.  Tune.
+    (compareseq): New `minimal' arg; all callers changed.  Tune.
+    (shift_boundaries): Improve heuristic to also coalesce adjacent runs
+    of changes more often.
+
+commit be52c66d5ef8e0f74e555d4cbf5b22ef5ef3e62f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 10 08:28:27 1993 +0000
+
+    Initial revision
+
+commit 7aeb973641eeae48c4d6abd1ce477858f6f90147
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 10 08:28:27 1993 +0000
+
+    GNU diffutils 2.6
+
+commit d3079e2f6bbd367cb4e1744653d94adcf49aa0fb
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 27 07:20:24 1993 +0000
+
+    (memchr): Make first arg char const *
+    to match standard.
+    (xmalloc, xrealloc): Cast malloc, realloc
+    to (VOID *) to suppress bogus warnings on some nonstandard hosts.
+
+commit 3a90d1af5a2b3b57af324ea3791de3a19dc3bc81
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 27 07:20:24 1993 +0000
+
+    (malloc, realloc): Declare only if !HAVE_STDLIB_H.
+    (memchr): Declare only if !HAVE_MEMCHR.  These changes are
+    needed to keep some nonstandard hosts happy.
+
+commit 00c73e284b4f194f44a8ef81822486dff1859924
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 27 07:20:24 1993 +0000
+
+    (xmalloc, xrealloc): Cast malloc, realloc
+    to (VOID *) to suppress bogus warnings on some nonstandard hosts.
+    (lf_copy, lf_skip, lf_snarf): Cast memchr to (char *)
+    to suppress bogus warnings on some nonstandard hosts.
+    (memchr): Make first arg char const *
+    to match standard.
+
+commit 1dcec128c62cd5fbb461cf28251a5d56210c9784
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 27 07:20:24 1993 +0000
+
+    (xmalloc, xrealloc): Cast malloc, realloc
+    to (VOID *) to suppress bogus warnings on some nonstandard hosts.
+
+commit 70b4740f3f25b4e50470d937ce9afb503423c169
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 27 07:20:24 1993 +0000
+
+    (add_exclude_file): Cast memchr to (char *)
+    to suppress bogus warnings on some nonstandard hosts.
+
+commit 38681c3055dcadafca0970ab40378c64ec99421f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 27 07:20:24 1993 +0000
+
+    (main, usage, version_string): Add --version option.
+
+commit fef4518ddad8ac816bbac963cdb45869249a22bc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 27 07:20:24 1993 +0000
+
+    (diff_2_files): Work around memcmp bug with size=0.
+
+commit d6a38aed737d9a647806d35b677507f1c1c7c516
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 27 06:30:18 1993 +0000
+
+    Initial revision
+
+commit c1a57a783bb54b12c1369632b89a42d960b3321c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 27 06:18:21 1993 +0000
+
+    GNU diffutils 2.6
+
+commit 36af5432bf4be21c0ba680d7baf483fcae5492ee
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 18 01:33:07 1993 +0000
+
+    (AC_STAT_MACROS_BROKEN): Add.
+
+commit 9f03341c093a30e7bc3c95e2876a30254a4790d1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 18 01:33:07 1993 +0000
+
+    (output_1_line): Use isprint, since some hosts lack isgraph.
+    Ensure that its argument isn't negative.
+    (xmalloc, xrealloc): Remove needless casts.
+
+commit 818c6c7ee66e1ce028f8e232737b1a384fb194ef
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 18 01:33:07 1993 +0000
+
+    (volatile, const): Define these before including any system headers,
+    so that they're used consistently in all system includes.
+    (S_IS{BLK,CHR,DIR,FIFO,REG,SOCK}): Fix defns if STAT_MACROS_BROKEN.
+    (getenv, malloc, realloc): Declare even if HAVE_STDLIB_H, since some
+    <stdlib.h>s don't declare them.
+    (memchr): Likewise for <string.h>.
+
+commit 96d6bc969fd6ab47cb134631fd496e3432e270d6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 18 01:33:07 1993 +0000
+
+    Include "system.h" first.
+    (xmalloc): Make defn static, like declaration.
+
+commit 0398a96fe634295de3bea52ef325f88c72267eff
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 18 01:33:07 1993 +0000
+
+    Include "system.h" first.
+    (xmalloc): Now static.
+    (xmalloc, realloc): Remove needless casts.
+    (READNUM): Ensure isdigit argument isn't negative.
+
+commit 1bfc4514b097f261b98d0b1f875edfbdc5a94091
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 18 01:33:07 1993 +0000
+
+    Remove redundant "system.h" inclusion.
+
+commit bec40df88a702f41d5cc565a785f038e1ebead42
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 18 01:33:07 1993 +0000
+
+    Include "system.h" first.
+
+commit 015dc4c028bd7dd30ec001604f4676949f2d339a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 18 01:33:07 1993 +0000
+
+    (discard_confusing_lines): Make defn static, like declaration.
+
+commit a6a9150a06232636a2b7888a1d71b011811aabdc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Sep 18 01:33:07 1993 +0000
+
+    (diff3, sdiff, cmp): Do not link $(ALLOCA).
+
+commit 03ca0426698728f388ea7c13bebb4bf7d5aca397
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Sep 17 19:27:09 1993 +0000
+
+    GNU diffutils 2.6
+
+commit a3866fa3b80f9f78d2b43823411c07ee38592a7a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Sep 17 06:29:10 1993 +0000
+
+    GNU diffutils 2.6
+
+commit d23d2f2b18b5ce325181ebebce40c9d92d12edde
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Sep 17 05:26:45 1993 +0000
+
+    GNU diffutils 2.6
+
+commit 5f6bfb84c7738caafd8b36660d1a8ab4b65aeda7
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 15 23:34:31 1993 +0000
+
+    #include <config.h>, not "config.h", to allow
+    configuring in a separate directory when the source directory has
+    already been configured.
+
+commit f4cd92b6ac57e931c5bf52dc13671bec6eb5152e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 15 23:34:31 1993 +0000
+
+    (scan_char_literal): New function, for new %c'x' and
+    %c'\ooo' format specs.
+    (format_group, print_ifdef_lines): Use it.  Remove %0 format spec.
+
+commit 35aad47ae3f3310672963918c1944d339f22680c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 15 23:34:31 1993 +0000
+
+    (cmp): Don't try to read past end of file; this doesn't
+    work on ttys.
+
+commit f9461e59e19b9fd2c458dc2f9ff536d233edf98f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 15 23:34:31 1993 +0000
+
+    (COMPILE): New defn, with proper -I options so that
+    `#include <config.h>' works.
+
+commit a2b82541fef2ca5e61dab7fc67bdf0100a3f6b6a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 13 14:22:57 1993 +0000
+
+    Configure HAVE_LIMITS_H, HAVE_STDLIB_H.
+
+commit c98340644e55179d1a71a77af131970e1e17b87b
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 13 14:22:57 1993 +0000
+
+    (line_cmp): bcmp -> memcmp
+
+commit 24f285cec459b4f7771f4dec30da370086a58442
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 13 14:22:57 1993 +0000
+
+    (PARAMS, VOID): Define earlier so that malloc decl can use VOID.
+    (STAT_BLOCKSIZE): Simplify ersatz defn; just use 8K.
+    (dirent): Renamed from direct; dirent makes the code more standard.
+    <limits.h>, <stdlib.h>, <string.h>: Include only if corresponding HAVE_*_H.
+    (memcmp, memcpy, strchr, strrchr): Prefer these standard names to
+    traditional names.
+
+commit d03c8525fd2672121669f2b947e3850bdd49b4d1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 13 14:22:57 1993 +0000
+
+    (expand_name): rindex -> strrchr
+    (expand_name, lf_snarf): bcopy -> memcpy
+    (interact): index -> strchr
+
+commit fe1e2e9de6edad046b24aa0eb52a266f7c49d458
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 13 14:22:57 1993 +0000
+
+    (struct group): New struct.
+    (print_ifdef_lines): Use it to simplify argument passing.  Remove the
+    convention that last arg -1 signifies that the lines from file 2 are
+    the same as the lines from file 1; this convention no longer works,
+    now that line numbers might be printed out, since the line's numbers
+    may differ.  Add first FILE * argument to output to.  All callers changed.
+    Use a faster test for the single-fwrite optimization.
+    Add support for %?c, %(A=B?T:E), PRINTF_SPECn formats.
+    (format_group, scan_printf_spec, groups_letter_value): New functions.
+    (format_ifdef): 1st arg is no longer const pointer.
+
+commit e491a3556f24e7478887877eb78195748a02a7dd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 13 14:22:57 1993 +0000
+
+    (copy_stringlist, compare_line_list): bcmp -> memcmp
+
+commit 158d33010d26a6bcfa19f1df320a9d4c9975b69e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 13 14:22:57 1993 +0000
+
+    (group_format, line_format): No longer const pointers.
+
+commit 75d628023000dc17fbfde46799261a2c723a8707
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 13 14:22:57 1993 +0000
+
+    (main, longopts): Add --line-format=FORMAT option.
+    (specify_format): Args no longer const pointers.  All callers changed.
+    (compare_files): rindex -> strrchr.
+
+commit ecf2d45950b4fd7967f6b30df8aeebe5ace5376c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 13 14:22:57 1993 +0000
+
+    (diff_2_files): Use memcmp instead of bcmp.
+
+commit 10d3e0ad7bd824b5a3d6cf5f541451d5fb4c87d0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 13 00:27:28 1993 +0000
+
+    GNU diffutils 2.6
+
+commit 1a71453b7bc68d2cfb9aa4d737e0c9ffb47ce5df
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Sep 3 00:21:02 1993 +0000
+
+    (compare_files): Two files with the same name must be the same file;
+    avoid a needless `stat' in that case.
+
+commit 9ca9006ee016868d47d9e203e352f3d7274885eb
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 19:13:20 1993 +0000
+
+    (srcs, objs, distfiles, cmp): New files cmpbuf.[ch].
+    (distfiles): New files config.h.in, mkinstalldirs.
+    (.c.o): Add -DHAVE_CONFIG_H.
+
+commit 42326d264796c8802247ff929a9561b1d688cbdc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Configure HAVE_SIGACTION, RETSIGTYPE, HAVE_VPRINTF.
+    Configure into config.h.
+
+commit 6f0c43bd7b450fe37bf6fd6d0138153183699c3c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.  Use `const' to pacify `gcc'.
+    Use size_t, not int, when needed.  Use STD{IN,OUT,ERR}_FILENO instead of [012].
+    (struct msg, msg_chain, msg_chain_end): Moved here from diff.h.
+    (message5): New function.
+    (pr_pid): New var.
+    (begin_output): Allocate `name' more precisely.
+    Put child pid into pr_pid, so that we can wait for it later.
+    Don't check execl's return value, since any return must be an error.
+    (finish_output): Detect and report output errors.
+    Use waitpid if available.  Check pr exit status.
+    (line_cmp): Use locale's definition of white space
+    instead of using one hardwired defn for -b and another for -w.
+    (analyze_cmp): Avoid double negation with `! nontrivial'.
+    Pacify `gcc -Wall' be rewriting for-loop into do-while-loop.
+    (dir_file_pathname): New function.
+
+commit c8209e8e34843819287c1f5b1b10a7c3a7de6c98
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    (S_IXOTH, S_IXGRP, S_IXUSR,
+    SEEK_SET, SEEK_CUR,
+    STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO):
+    New macros, if system doesn't define them.
+    (volatile): Don't define if already defined.
+    (PARAMS): New macro.
+    (VOID): Move here from diff.h.
+
+commit 63170f223c8ef30650240171f171c1259a7b366f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.  Use `const' to pacify `gcc'.
+
+commit bc7d55d1f848fb5faff8a6d3662c483eec54beb0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.  Use size_t, not int, when needed.
+    Use `const' to pacify `gcc'.  Use STD{IN,OUT,ERR}_FILENO instead of [012].
+    (SEEK_SET): Move to system.h.
+    (version_string): Now char[], not char*.
+    (private_tempnam): Remove hardcoded limit on temporary file names.
+    (exiterr, perror_fatal, main): When exiting because of a signal,
+    exit with that signal's status.
+    (lf_refill, main, skip_white, edit, interact): Check for signal.
+    (ignore_SIGINT): Renamed from `ignore_signals'.
+    (NUM_SIGS, initial_handler): New macros.
+    (initial_action, signal_received, sigs_trapped): New vars.
+    (catchsig, trapsigs): Use sigaction if possible, since this closes the
+    windows of vulnerability that `signal' has.  Use RETSIGTYPE not void.
+    When a signal comes in, just set a global variable; this is safer.
+    (checksigs, untrapsig): New functions.
+    (edit): Pacify `gcc -Wall' with a useless assignment.
+    Respond to each empty line with help, not to every other empty line.
+    (private_tempnam): Remove hardcoded limit on temporary file name length.
+    Don't assume sizeof (pid_t) <= sizeof (int).
+
+commit f2b587677b4cb5d1ae5a9596df8d2efa90384843
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.
+    (change_letter, print_number_range, find_change): Move decls to diff.h.
+    (print_normal_hunk): Now static.
+
+commit d002fe98187824364679e45b69e2104f18512284
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.  Use size_t, not int, when needed.
+    (line_cmp): Move declaration to diff.h.
+    (textchar): Remove.
+    (find_and_hash_each_line): Use locale's definition of white space
+    instead of using one hardwired defn for -b and another for -w.
+
+commit 46775cfbd9a47eea0c51c74935bbeac8b2e185e1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.
+
+commit 2bb476a6039ce1ae3715bfc13f59ed23ff4eaa8c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.  Use size_t, not int, when needed.
+    Use `const' when needed to pacify gcc.
+    (struct dirdata): Rename `files' to `names' to avoid confusion
+    with external struct file_data `files'.
+
+commit 96a2e40dd0d57c2f845943fb246ecfdda29349bb
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.  Use size_t, not int, when needed.
+    Use `const' when needed to pacify gcc.
+    Use STD{IN,OUT,ERR}_FILENO instead of [012].
+    (VOID): Move to system.h.
+    (version_string): Now char[].
+    (usage): Sort options.
+    (process_diff): Pacify `gcc -Wall' with a useless assignment.
+    (read_diff): pid is of type pid_t, not int.  Use waitpid if available.
+    (output_diff3): Simplify test for `\ No newline at end of file' message.
+
+commit 86596683e8c1b41a8ac9e5c2b4e497ef2fd8fb7c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.  Use size_t, not int, when needed.
+    Use `const' when needed to pacify gcc.
+    (Is_space, textchar): Remove.
+    (struct msg, msg_chain, msg_chain_end): Move to util.c.
+    (VOID): Move to system.h.
+    (line_cmp, version_string, change_letter, print_number_range,
+    find_change): New decls.
+
+commit 1c96aecf2aab2b5225373e4e41bb94b80914638e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.  Use size_t, not int, when needed.
+    Use `const' when needed to pacify gcc.
+    Use STD{IN,OUT,ERR}_FILENO instead of [012].
+    (usage): Sort options.
+    (filetype): New function.
+    (compare_files): Set stdin's st_mtime to be the current time.
+    Leave its name "-" instead of changing it to "Standard Input";
+    to test whether a file is stdin, we must compare its name to "-" instead
+    of its desc to 0, since if it's closed other file descs may be 0.
+    When comparing standard input to a file, and using a shortcut (e.g.
+    looking at file sizes or inode numbers), take the lseek offset into
+    account before deciding whether the files are identical.
+    Pretend that nonexistent files have the same filetype as existing files.
+    Rename `errorcount' to `failed', since it's boolean.
+    In directory comparisons, if a file is neither a regular file nor a
+    directory, just print its type and the other file's type.
+
+commit 92b99a4ef582665c45a17e15f8b3fc96bae740e5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.  Use size_t, not int, when needed.
+    Use `const' when needed to pacify gcc.
+    (print_context_label): Standard input's st_mtime is no longer a special case
+    here, since `compare_files' now sets it to the current time.
+
+commit e8095a8ed1b3cc3fe41e2f09da655917c4845fbf
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.  Use size_t, not int, when needed.
+    Use `const' when needed to pacify gcc.  Use 0, not NULL, for portability.
+    Make globals static when possible.
+    
+    (file): Now a 2-element array; replaces `file1' and `file2'.
+    (file_desc, buffer): Likewise, for file[12]_desc and buf[12].
+    (main): Likewise, for stat_buf[12].  Index these variables with `i'.
+    
+    (ignore_initial): New var.
+    (long_options): Now const.  Add `--ignore-initial'.
+    (usage): Sort options and add `--ignore-initial'.
+    (main, cmp): Add `--ignore-initial' support.
+    
+    (main): `cmp - -' now succeeds.  Use STD{IN,OUT,ERR}_FILENO instead of [012].
+    When comparing standard input to a file, and using a shortcut (e.g.
+    looking at file sizes or inode numbers), take the lseek offset into
+    account before deciding whether the files are identical.
+    Avoid mentioning `dev_t', `ino_t' for portability to nonstandard hosts.
+    Use l.c.m. of files' buffer sizes, not 8 * 1024.
+    ferror (stdout) does not imply errno has a useful value.
+    If 2nd file is "-", treat it first, in case stdin is closed.
+    
+    (cmp): Always compute `char_number', `smaller' for speed and simplicity.
+    Say `cmp: EOF on input', not `/usr/gnu/bin/cmp: EOF on input',
+    as per Posix.2.
+    
+    (block_compare_and_count): Increment line_number argument.
+    Remove end_char argument; it's always '\n'.  All callers changed.
+    Do not assume sizeof(long) == 4; this isn't true on some 64-bit hosts.
+    (block_compare): Minimize differences with block_compare_and_count.
+    
+    (block_read): Coalesce `bp += nread's.
+    
+    (printc): Remove `FILE *' arg; output to stdout.  All callers changed.
+
+commit 3b9709d3f4b322a0a64ec9d33cbf9bbfd170f02c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Add prototypes to function declarations.  Use size_t, not int, when needed.
+    (diag): Pacify `gcc -Wall' with a useless assignment.
+    (diff_2_files): Use l.c.m., not max, of files' buffer sizes.
+
+commit a9dde9e085845faef1566af34651dfe0410be1fc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Aug 27 17:30:26 1993 +0000
+
+    Initial revision
+
+commit 3e492ee56afd89ed6216e00148b6378026f50473
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Aug 23 05:44:15 1993 +0000
+
+    GNU diffutils 2.7
+
+commit 495c25447365aabb888d317a7934403dd08feaf8
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Fri Jul 30 00:44:17 1993 +0000
+
+    	* Makefile.in (config.status): Run config.status --recheck, not
+    	configure, to get the right args passed.
+
+commit 3a50fa0f0210e037d0b5583ccb7c12d52066f9e6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jul 22 10:46:30 1993 +0000
+
+    (dist): Replace `if [ ! TEST ]; then ACTION; fi' with `[ TEST ] ||
+    ACTION || exit' so that the command exits with proper status for `make'.
+
+commit bd8d4cc978484a29f6782808a36bfa95bc679278
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Thu Jul 8 23:47:51 1993 +0000
+
+    new targets
+
+commit 308a124880a6cdce4dfc1b895e767adb2fbdfb79
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Jul 4 00:00:00 1993 +0000
+
+    Attempt to do a better job with three two-way diffs.
+    This was a file labeled diff3.c.new-notdone,
+    dated 1992-04-27, with user name `randy'.
+
+commit 72e9b3762de6101d10eb7378a7f996ad8643e4f5
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Jun 5 23:10:40 1993 +0000
+
+    (dist): Switch from .z to .gz.
+
+commit 7efcf6d1879dea4682d57ed29b75b5727be04a53
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed May 26 17:16:02 1993 +0000
+
+    Change NULL to 0.
+
+commit 47b8d868a96ed6ab769c5b144c6b6faf5bd3d634
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed May 26 17:16:02 1993 +0000
+
+    (print_sdiff_common_lines_print_sdiff_hunk): Cast args to pointer types, for traditional C.
+
+commit 9c0b359b91b2411a8bbdb8589768fb42361e195a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed May 26 17:16:02 1993 +0000
+
+    (longopts, private_tempnam): Change NULL to 0.
+
+commit 50a3709b577ada7869b303b0ccb92628e7187b5c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed May 26 17:16:02 1993 +0000
+
+    (longopts): Change NULL to 0.
+
+commit f0c10d063072e6f9238808348a5a404ffd256864
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed May 26 17:16:02 1993 +0000
+
+    (main): Cast args to compare_files, for traditional C.
+
+commit 73e929cbb6eb24bf3e64238c1484c872d34d5369
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed May 26 17:16:02 1993 +0000
+
+    (diff_2_files): Change NULL to 0.
+
+commit 9a8361c3c5e613a32811e630c2d1a33687fc6d58
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue May 25 15:36:38 1993 +0000
+
+    (compare_files): Don't use the file size shortcut if
+    ignore_some_changes is nonzero, since the file size may differ
+    merely due to ignored changes.
+    (briefly_report): New function.
+    (main):  Set ignore_some_changes if we might ignore some changes.
+    Remove unsystematic assignment of 0 to static vars.
+
+commit 6e652af429e2d422531cd323b7165d7ccb75be43
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue May 25 14:54:05 1993 +0000
+
+    (tab_align_flag): New variable, for new -T option.
+    (main, usage, output_diff3): Add support for -T.
+
+commit c0d57c083342e7ab4cb795aa4f4129082b33d9da
+Author: Richard M. Stallman <rms@gnu.org>
+Date:   Sun May 23 19:25:41 1993 +0000
+
+    entered into RCS
+
+commit 1f60a522de41a36a8dd546ec5f75d2bc08b9e3d6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat May 22 22:15:29 1993 +0000
+
+    (read_files): New argument PRETEND_BINARY says whether to
+    pretend the files are binary.
+
+commit da390dd91151a90327bfd1272b85cadf712a81bc
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat May 22 22:15:29 1993 +0000
+
+    (ignore_some_changes): New variable.
+
+commit 63455a47c89f1ba65ba7d41f84c6ad1a304b2cec
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat May 22 22:15:29 1993 +0000
+
+    (diff_2_files):  With -q, do not report that files differ
+    if all their differences are ignored.
+
+commit 78ec03a882b95cd29d36835ee428f88a48b3736e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat May 22 19:33:55 1993 +0000
+
+    entered into RCS
+
+commit 706124a32837bc01a160b73bb0271b9a041fb0d1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri May 21 20:38:19 1993 +0000
+
+    entered into RCS
+
+commit e86eac7b5fae39d4fb8243af9c25ebac661a4b2e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 23 17:18:44 1993 +0000
+
+    entered into RCS
+
+commit 8a5351c2de9e0f6464a981b2fb1973e03aa93e2f
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Apr 23 17:18:44 1993 +0000
+
+    *** empty log message ***
+
+commit 3319a943fbae0182341e75dc65721333a96dfc90
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Apr 4 21:25:20 1993 +0000
+
+    Initial revision
+
+commit da717e72f7cc581ea23937ee7aface42e9857834
+Author: Roland McGrath <roland@gnu.org>
+Date:   Mon Mar 22 21:16:22 1993 +0000
+
+    *** empty log message ***
+
+commit 8aaab4f3e19e7bc4a92ded306ce665eca48cb776
+Author: Richard M. Stallman <rms@gnu.org>
+Date:   Fri Mar 5 05:20:07 1993 +0000
+
+    *** empty log message ***
+
+commit 4aaf705f814fac541e8789c4092b77371f8c6cf2
+Author: Roland McGrath <roland@gnu.org>
+Date:   Thu Feb 25 20:27:03 1993 +0000
+
+    *** empty log message ***
+
+commit 6ddf7e686bb00d6da06aa438a8106f8a8b635266
+Author: Richard M. Stallman <rms@gnu.org>
+Date:   Mon Feb 22 20:04:42 1993 +0000
+
+    *** empty log message ***
+
+commit ad75085c057c58ec6756f98fc5c086ae1cd7c477
+Author: Roland McGrath <roland@gnu.org>
+Date:   Mon Feb 22 17:56:35 1993 +0000
+
+    *** empty log message ***
+
+commit 1818943fac21d52fa810717c8f174ef137677b90
+Author: Richard M. Stallman <rms@gnu.org>
+Date:   Sun Feb 21 00:18:53 1993 +0000
+
+    *** empty log message ***
+
+commit 4cea33c405f2d9c1d0e91ab16c5b93fa17073526
+Author: Roland McGrath <roland@gnu.org>
+Date:   Fri Feb 19 22:39:37 1993 +0000
+
+    *** empty log message ***
+
+commit d1157d9215cb261635f663eba9c98b6434646fd2
+Author: Richard M. Stallman <rms@gnu.org>
+Date:   Thu Feb 11 18:48:31 1993 +0000
+
+    *** empty log message ***
+
+commit 6734c1e0ffd9014fe623192f651beb5543af6229
+Author: Richard M. Stallman <rms@gnu.org>
+Date:   Thu Feb 11 08:39:43 1993 +0000
+
+    entered into RCS
+
+commit 00e5d088e3627870d9574824de59a2272e50f4c7
+Author: Richard M. Stallman <rms@gnu.org>
+Date:   Thu Feb 11 08:36:08 1993 +0000
+
+    *** empty log message ***
+
+commit e5fb154b0cc6e9d24a7cdb62ff405eb497b823a8
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Jan 31 02:49:15 1993 +0000
+
+    entered into RCS
+
+commit 0448e625aeec1f3f5f1268411db0c1d20d204315
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Fri Jan 8 22:31:41 1993 +0000
+
+    *** empty log message ***
+
+commit a7544e448c174339ede7c11a70a3185ad5e0ee39
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 23 18:44:33 1992 +0000
+
+    *** empty log message ***
+
+commit 0689ff7f2b83e20fced9dbba9837d9478423f9ce
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Nov 18 20:40:28 1992 +0000
+
+    *** empty log message ***
+
+commit be75ee024b368eb6cc359d64a0766baa2f5bad82
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Nov 17 20:10:49 1992 +0000
+
+    *** empty log message ***
+
+commit a07432e950d609619697805aaebe5434e673c779
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Nov 12 16:02:18 1992 +0000
+
+    entered into RCS
+
+commit 95ed3464570329da521604082b082e3bf832239e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Nov 12 16:02:18 1992 +0000
+
+    *** empty log message ***
+
+commit 8f4db99c5fe1b1bc0f9cb522e10289592acec0e0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Nov 9 03:59:56 1992 +0000
+
+    *** empty log message ***
+
+commit ea33d3b33abaf4c10f0e8d49ac566ae92aa3e409
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 19 04:33:05 1992 +0000
+
+    entered into RCS
+
+commit 98b3abbdf5ba0b7e016209bb304eef5d1f6976c0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sat Oct 10 01:53:56 1992 +0000
+
+    Initial revision
+
+commit f1e137e3dc5256b19dce9bc8492c841e1aaefacf
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Oct 5 05:18:46 1992 +0000
+
+    *** empty log message ***
+
+commit b98227d8eb71c53f9d3e12537e8410ebde0bf86e
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 30 09:21:59 1992 +0000
+
+    entered into RCS
+
+commit 0bc4206adad21d679d7cadb7a578402b0e2b0a0a
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Wed Sep 30 09:21:59 1992 +0000
+
+    *** empty log message ***
+
+commit 22548858bc47c5851f4d0c44ec7d8c6e8f281300
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Mon Sep 28 04:51:42 1992 +0000
+
+    *** empty log message ***
+
+commit bba40d01965c3af009b5bf033013f8cb529346bd
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 27 05:38:13 1992 +0000
+
+    *** empty log message ***
+
+commit 5e96cefa2872848f2076694db7d77293eae56a14
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 24 15:18:07 1992 +0000
+
+    *** empty log message ***
+
+commit c8780b481ad26b919f3630079fc67d745edc8ce3
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Sep 24 05:54:14 1992 +0000
+
+    *** empty log message ***
+
+commit eecd1662a18c7b69f5521534c68d81652af33517
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue Sep 15 03:59:44 1992 +0000
+
+    entered into RCS
+
+commit 9113c022e956cbee58d980f862cf265cfe031610
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue Sep 15 03:15:49 1992 +0000
+
+    *** empty log message ***
+
+commit 639733d782e6cf581728ab4a924829eafc414cab
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Sat Sep 12 05:32:31 1992 +0000
+
+    *** empty log message ***
+
+commit 1ef94913174bad28ddbd4be07605bf7efd5e54a0
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 6 23:00:36 1992 +0000
+
+    *** empty log message ***
+
+commit de7b7cb54a75a0331fb3edffbc4f07d085fc8ab1
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 6 07:19:49 1992 +0000
+
+    *** empty log message ***
+
+commit 096465ae0dfe8bbc04e072a5503aee95896342ef
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 6 04:35:52 1992 +0000
+
+    *** empty log message ***
+
+commit 8ab03a75052de0f5b80d8f7d72160ff80eb0e453
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Sun Sep 6 04:35:52 1992 +0000
+
+    entered into RCS
+
+commit 01bd70f34606d248b4499dc7a081fff728874cd8
+Author: Richard M. Stallman <rms@gnu.org>
+Date:   Fri Sep 4 19:32:07 1992 +0000
+
+    *** empty log message ***
+
+commit 5f9f2a0445fe5059066ec49c15eb93ea057e1dfe
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Thu Sep 3 19:30:55 1992 +0000
+
+    *** empty log message ***
+
+commit 8f5a93cad7aab2a3a95c972546ae6eb778991048
+Author: Richard M. Stallman <rms@gnu.org>
+Date:   Fri Aug 14 07:38:17 1992 +0000
+
+    *** empty log message ***
+
+commit 3c488d0cb20eea79acf3c540b78a0f5399a8372f
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Thu Jul 16 20:56:16 1992 +0000
+
+    Initial revision
+
+commit 9a623661c76da444685f1c3ca8bb4580f013cfc3
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Wed Jul 8 19:58:07 1992 +0000
+
+    entered into RCS
+
+commit 44b481aaa297582491bda6e5a1596715c25ddeb8
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Wed Jul 8 19:46:10 1992 +0000
+
+    *** empty log message ***
+
+commit b2f3f8fcaa081c862a2255843f0b76d5fe7b71fb
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Wed Jul 8 19:21:40 1992 +0000
+
+    Initial revision
+
+commit 6456bbcb000f5ed63d292784735927c30cd8b072
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue Jul 7 23:00:18 1992 +0000
+
+    *** empty log message ***
+
+commit df1eb75645ab62efff57fec5a9cac6c560f3f702
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue Jul 7 22:44:43 1992 +0000
+
+    Initial revision
+
+commit 2e9d141071cb6b33d62fdd978377c6498300656b
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue Jul 7 20:24:37 1992 +0000
+
+    Initial revision
+
+commit 8691ced4aabd114cdb74367161da732387ff9af7
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue Jul 7 20:23:47 1992 +0000
+
+    *** empty log message ***
+
+commit 4ca6ed131399d3d74f0d95041ff66ece1e416938
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue Jul 7 19:18:10 1992 +0000
+
+    *** empty log message ***
+
+commit d36834de48b7c513f2a5849e2a4aee275985744b
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue Jul 7 19:13:19 1992 +0000
+
+    Initial revision
+
+commit ab6c5254736e07241596fbd56b41ea5ad32d1f7e
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue Jul 7 07:33:49 1992 +0000
+
+    Initial revision
+
+commit aecd57a13df471e11e3f6abba9bfdbfa84cb47e2
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue Jul 7 07:32:29 1992 +0000
+
+    *** empty log message ***
+
+commit 1e9c0c48752ccc530417c730f8ebd432ffd6ecd4
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue Jul 7 07:23:07 1992 +0000
+
+    entered into RCS
+
+commit f11aa4bd8771b99b8ca3d37384eaa8349e54c561
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Fri Jul 3 18:31:18 1992 +0000
+
+    Initial revision
+
+commit 615c30008ee878beffa91d5181f8efeb5f756cd3
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue May 12 00:09:43 1992 +0000
+
+    Initial revision
+
+commit c8e2427fa22e3ecd5410358af1f343b168cb211c
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Thu Jan 2 17:45:34 1992 +0000
+
+    Initial revision
+
+commit e9274e2af61de3ff67404a19e1b4e585b7709d8b
+Author: David MacKenzie <djm@djmnet.org>
+Date:   Tue Dec 24 05:09:33 1991 +0000
+
+    Initial revision
+
+commit b3c1e930b846248e3d1d0961547202c7b5d65bb2
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Dec 17 19:33:18 1991 +0000
+
+    Initial revision
+
+commit f9d66e6012b57e77bafd7b034a16c422cf454ab6
+Author: Paul Eggert <eggert@cs.ucla.edu>
+Date:   Tue Jul 26 15:24:24 1988 +0000
+
+    Initial revision
diff --git a/quote-3.0-patch.txt b/quote-3.0-patch.txt
new file mode 100644
index 0000000..658f89f
--- /dev/null
+++ b/quote-3.0-patch.txt
@@ -0,0 +1,326 @@
+diff --git a/src/cmp.c b/src/cmp.c
+index 2455dc4..e19f013 100644
+--- a/src/cmp.c
++++ b/src/cmp.c
+@@ -115,7 +115,7 @@ try_help (char const *reason_msgid, char const *operand)
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+   error (EXIT_TROUBLE, 0,
+-	 _("Try `%s --help' for more information."), program_name);
++	 _("Try '%s --help' for more information."), program_name);
+   abort ();
+ }
+ 
+@@ -134,7 +134,7 @@ specify_ignore_initial (int f, char **argptr, char delimiter)
+   if (! (e == LONGINT_OK
+ 	 || (e == LONGINT_INVALID_SUFFIX_CHAR && **argptr == delimiter))
+       || TYPE_MAXIMUM (off_t) < val)
+-    try_help ("invalid --ignore-initial value `%s'", arg);
++    try_help ("invalid --ignore-initial value '%s'", arg);
+   if (ignore_initial[f] < val)
+     ignore_initial[f] = val;
+ }
+@@ -185,7 +185,7 @@ usage (void)
+ 	  _("SKIP values may be followed by the following multiplicative suffixes:\n\
+ kB 1000, K 1024, MB 1,000,000, M 1,048,576,\n\
+ GB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y."),
+-	  _("If a FILE is `-' or missing, read standard input."),
++	  _("If a FILE is '-' or missing, read standard input."),
+ 	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+   emit_bug_reporting_address ();
+ }
+@@ -231,7 +231,7 @@ main (int argc, char **argv)
+ 	{
+ 	  uintmax_t n;
+ 	  if (xstrtoumax (optarg, 0, 0, &n, valid_suffixes) != LONGINT_OK)
+-	    try_help ("invalid --bytes value `%s'", optarg);
++	    try_help ("invalid --bytes value '%s'", optarg);
+ 	  if (n < bytes)
+ 	    bytes = n;
+ 	}
+@@ -257,7 +257,7 @@ main (int argc, char **argv)
+       }
+ 
+   if (optind == argc)
+-    try_help ("missing operand after `%s'", argv[argc - 1]);
++    try_help ("missing operand after '%s'", argv[argc - 1]);
+ 
+   file[0] = argv[optind++];
+   file[1] = optind < argc ? argv[optind++] : "-";
+@@ -269,7 +269,7 @@ main (int argc, char **argv)
+     }
+ 
+   if (optind < argc)
+-    try_help ("extra operand `%s'", argv[optind]);
++    try_help ("extra operand '%s'", argv[optind]);
+ 
+   for (f = 0; f < 2; f++)
+     {
+diff --git a/src/diff.c b/src/diff.c
+index cc1b611..256a984 100644
+--- a/src/diff.c
++++ b/src/diff.c
+@@ -330,7 +330,7 @@ main (int argc, char **argv)
+ 	      {
+ 		numval = strtoumax (optarg, &numend, 10);
+ 		if (*numend)
+-		  try_help ("invalid context length `%s'", optarg);
++		  try_help ("invalid context length '%s'", optarg);
+ 		if (LIN_MAX < numval)
+ 		  numval = LIN_MAX;
+ 	      }
+@@ -505,7 +505,7 @@ main (int argc, char **argv)
+ 	case 'W':
+ 	  numval = strtoumax (optarg, &numend, 10);
+ 	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+-	    try_help ("invalid width `%s'", optarg);
++	    try_help ("invalid width '%s'", optarg);
+ 	  if (width != numval)
+ 	    {
+ 	      if (width)
+@@ -534,7 +534,7 @@ main (int argc, char **argv)
+ 	case HORIZON_LINES_OPTION:
+ 	  numval = strtoumax (optarg, &numend, 10);
+ 	  if (*numend)
+-	    try_help ("invalid horizon length `%s'", optarg);
++	    try_help ("invalid horizon length '%s'", optarg);
+ 	  horizon_lines = MAX (horizon_lines, MIN (numval, LIN_MAX));
+ 	  break;
+ 
+@@ -585,7 +585,7 @@ main (int argc, char **argv)
+ 	case TABSIZE_OPTION:
+ 	  numval = strtoumax (optarg, &numend, 10);
+ 	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+-	    try_help ("invalid tabsize `%s'", optarg);
++	    try_help ("invalid tabsize '%s'", optarg);
+ 	  if (tabsize != numval)
+ 	    {
+ 	      if (tabsize)
+@@ -744,9 +744,9 @@ main (int argc, char **argv)
+ 	  if (argc - optind != 2)
+ 	    {
+ 	      if (argc - optind < 2)
+-		try_help ("missing operand after `%s'", argv[argc - 1]);
++		try_help ("missing operand after '%s'", argv[argc - 1]);
+ 	      else
+-		try_help ("extra operand `%s'", argv[optind + 2]);
++		try_help ("extra operand '%s'", argv[optind + 2]);
+ 	    }
+ 
+ 	  exit_status = compare_files (NULL, argv[optind], argv[optind + 1]);
+@@ -826,7 +826,7 @@ try_help (char const *reason_msgid, char const *operand)
+ {
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+-  error (EXIT_TROUBLE, 0, _("Try `%s --help' for more information."),
++  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+ 	 program_name);
+   abort ();
+ }
+@@ -870,11 +870,11 @@ static char const * const option_help_msgid[] = {
+   -W NUM  --width=NUM  Output at most NUM (default 130) print columns.\n\
+   --left-column  Output only the left column of common lines.\n\
+   --suppress-common-lines  Do not output common lines."),
+-  N_("-D NAME  --ifdef=NAME  Output merged file to show `#ifdef NAME' diffs."),
++  N_("-D NAME  --ifdef=NAME  Output merged file to show '#ifdef NAME' diffs."),
+   N_("--GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT."),
+   N_("--line-format=LFMT  Similar, but format all input lines with LFMT."),
+   N_("--LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT."),
+-  N_("  LTYPE is `old', `new', or `unchanged'.  GTYPE is LTYPE or `changed'."),
++  N_("  LTYPE is 'old', 'new', or 'unchanged'.  GTYPE is LTYPE or 'changed'."),
+   N_("  GFMT may contain:\n\
+     %<  lines from FILE1\n\
+     %>  lines from FILE2\n\
+@@ -895,7 +895,7 @@ static char const * const option_help_msgid[] = {
+     %c'C'  the single character C\n\
+     %c'\\OOO'  the character with octal code OOO"),
+   "",
+-  N_("-l  --paginate  Pass the output through `pr' to paginate it."),
++  N_("-l  --paginate  Pass the output through 'pr' to paginate it."),
+   N_("-t  --expand-tabs  Expand tabs to spaces in output."),
+   N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+   N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
+@@ -918,9 +918,9 @@ static char const * const option_help_msgid[] = {
+   N_("-v  --version  Output version info."),
+   N_("--help  Output this help."),
+   "",
+-  N_("FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE...' or `FILE... DIR'."),
++  N_("FILES are 'FILE1 FILE2' or 'DIR1 DIR2' or 'DIR FILE...' or 'FILE... DIR'."),
+   N_("If --from-file or --to-file is given, there are no restrictions on FILES."),
+-  N_("If a FILE is `-', read standard input."),
++  N_("If a FILE is '-', read standard input."),
+   N_("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."),
+   0
+ };
+@@ -960,7 +960,7 @@ specify_value (char const **var, char const *value, char const *option)
+ {
+   if (*var && strcmp (*var, value) != 0)
+     {
+-      error (0, 0, _("conflicting %s option value `%s'"), option, value);
++      error (0, 0, _("conflicting %s option value '%s'"), option, value);
+       try_help (NULL, NULL);
+     }
+   *var = value;
+@@ -1159,7 +1159,7 @@ compare_files (struct comparison const *parent,
+ 	= dir_file_pathname (dir, last_component (fnm));
+ 
+       if (STREQ (fnm, "-"))
+-	fatal ("cannot compare `-' to a directory");
++	fatal ("cannot compare '-' to a directory");
+ 
+       if (stat (filename, &cmp.file[dir_arg].stat) != 0)
+ 	{
+diff --git a/src/diff3.c b/src/diff3.c
+index 0f11fdc..fbfb28b 100644
+--- a/src/diff3.c
++++ b/src/diff3.c
+@@ -316,9 +316,9 @@ main (int argc, char **argv)
+   if (argc - optind != 3)
+     {
+       if (argc - optind < 3)
+-	try_help ("missing operand after `%s'", argv[argc - 1]);
++	try_help ("missing operand after '%s'", argv[argc - 1]);
+       else
+-	try_help ("extra operand `%s'", argv[optind + 3]);
++	try_help ("extra operand '%s'", argv[optind + 3]);
+     }
+ 
+   file = &argv[optind];
+@@ -351,7 +351,7 @@ main (int argc, char **argv)
+ 	 file instead.  */
+       common = 3 - common;
+       if (STREQ (file[0], "-") || STREQ (file[common], "-"))
+-	fatal ("`-' specified for more than one input file");
++	fatal ("'-' specified for more than one input file");
+     }
+ 
+   mapping[0] = 0;
+@@ -412,7 +412,7 @@ try_help (char const *reason_msgid, char const *operand)
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+   error (EXIT_TROUBLE, 0,
+-	 _("Try `%s --help' for more information."), program_name);
++	 _("Try '%s --help' for more information."), program_name);
+   abort ();
+ }
+ 
+@@ -435,7 +435,7 @@ static char const * const option_help_msgid[] = {
+   "",
+   N_("-m  --merge  Output merged file instead of ed script (default -A)."),
+   N_("-L LABEL  --label=LABEL  Use LABEL instead of file name."),
+-  N_("-i  Append `w' and `q' commands to ed scripts."),
++  N_("-i  Append 'w' and 'q' commands to ed scripts."),
+   N_("-a  --text  Treat all files as text."),
+   N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+   N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+@@ -460,7 +460,7 @@ usage (void)
+     else
+       putchar ('\n');
+   printf ("\n%s\n%s\n",
+-	  _("If a FILE is `-', read standard input."),
++	  _("If a FILE is '-', read standard input."),
+ 	  _("Exit status is 0 if successful, 1 if conflicts, 2 if trouble."));
+   emit_bug_reporting_address ();
+ }
+@@ -1275,12 +1275,12 @@ read_diff (char const *filea,
+   if (EXIT_TROUBLE <= status)
+     error (EXIT_TROUBLE, werrno,
+ 	   _(status == 126
+-	     ? "subsidiary program `%s' could not be invoked"
++	     ? "subsidiary program '%s' could not be invoked"
+ 	     : status == 127
+-	     ? "subsidiary program `%s' not found"
++	     ? "subsidiary program '%s' not found"
+ 	     : status == INT_MAX
+-	     ? "subsidiary program `%s' failed"
+-	     : "subsidiary program `%s' failed (exit status %d)"),
++	     ? "subsidiary program '%s' failed"
++	     : "subsidiary program '%s' failed (exit status %d)"),
+ 	   diff_program, status);
+ 
+   return diff_result + total;
+diff --git a/src/dir.c b/src/dir.c
+index 5b4eaec..5e08318 100644
+--- a/src/dir.c
++++ b/src/dir.c
+@@ -154,7 +154,7 @@ compare_names (char const *name1, char const *name2)
+ 	r = strcoll (name1, name2);
+       if (errno)
+ 	{
+-	  error (0, errno, _("cannot compare file names `%s' and `%s'"),
++	  error (0, errno, _("cannot compare file names '%s' and '%s'"),
+ 		 name1, name2);
+ 	  longjmp (failed_locale_specific_sorting, 1);
+ 	}
+diff --git a/src/sdiff.c b/src/sdiff.c
+index 4344e8d..5bbecd8 100644
+--- a/src/sdiff.c
++++ b/src/sdiff.c
+@@ -175,7 +175,7 @@ try_help (char const *reason_msgid, char const *operand)
+ {
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+-  error (EXIT_TROUBLE, 0, _("Try `%s --help' for more information."),
++  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+ 	 program_name);
+   abort ();
+ }
+@@ -230,7 +230,7 @@ usage (void)
+     else
+       putchar ('\n');
+   printf ("\n%s\n%s\n",
+-	  _("If a FILE is `-', read standard input."),
++	  _("If a FILE is '-', read standard input."),
+ 	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+   emit_bug_reporting_address ();
+ }
+@@ -286,12 +286,12 @@ check_child_status (int werrno, int wstatus, int max_ok_status,
+     {
+       error (0, werrno,
+ 	     _(status == 126
+-	       ? "subsidiary program `%s' could not be invoked"
++	       ? "subsidiary program '%s' could not be invoked"
+ 	       : status == 127
+-	       ? "subsidiary program `%s' not found"
++	       ? "subsidiary program '%s' not found"
+ 	       : status == INT_MAX
+-	       ? "subsidiary program `%s' failed"
+-	       : "subsidiary program `%s' failed (exit status %d)"),
++	       ? "subsidiary program '%s' failed"
++	       : "subsidiary program '%s' failed (exit status %d)"),
+ 	     subsidiary_program, status);
+       exiterr ();
+     }
+@@ -572,9 +572,9 @@ main (int argc, char *argv[])
+   if (argc - optind != 2)
+     {
+       if (argc - optind < 2)
+-	try_help ("missing operand after `%s'", argv[argc - 1]);
++	try_help ("missing operand after '%s'", argv[argc - 1]);
+       else
+-	try_help ("extra operand `%s'", argv[optind + 2]);
++	try_help ("extra operand '%s'", argv[optind + 2]);
+     }
+ 
+   if (! output)
+diff --git a/src/util.c b/src/util.c
+index 3be03e9..d18bf38 100644
+--- a/src/util.c
++++ b/src/util.c
+@@ -298,12 +298,12 @@ finish_output (void)
+       if (status)
+ 	error (EXIT_TROUBLE, werrno,
+ 	       _(status == 126
+-		 ? "subsidiary program `%s' could not be invoked"
++		 ? "subsidiary program '%s' could not be invoked"
+ 		 : status == 127
+-		 ? "subsidiary program `%s' not found"
++		 ? "subsidiary program '%s' not found"
+ 		 : status == INT_MAX
+-		 ? "subsidiary program `%s' failed"
+-		 : "subsidiary program `%s' failed (exit status %d)"),
++		 ? "subsidiary program '%s' failed"
++		 : "subsidiary program '%s' failed (exit status %d)"),
+ 	       pr_program, status);
+     }
+ 
diff --git a/src/cmp.c b/src/cmp.c
index 2455dc4..e19f013 100644
--- a/src/cmp.c
+++ b/src/cmp.c
@@ -115,7 +115,7 @@ try_help (char const *reason_msgid, char const *operand)
   if (reason_msgid)
     error (0, 0, _(reason_msgid), operand);
   error (EXIT_TROUBLE, 0,
-	 _("Try `%s --help' for more information."), program_name);
+	 _("Try '%s --help' for more information."), program_name);
   abort ();
 }
 
@@ -134,7 +134,7 @@ specify_ignore_initial (int f, char **argptr, char delimiter)
   if (! (e == LONGINT_OK
 	 || (e == LONGINT_INVALID_SUFFIX_CHAR && **argptr == delimiter))
       || TYPE_MAXIMUM (off_t) < val)
-    try_help ("invalid --ignore-initial value `%s'", arg);
+    try_help ("invalid --ignore-initial value '%s'", arg);
   if (ignore_initial[f] < val)
     ignore_initial[f] = val;
 }
@@ -185,7 +185,7 @@ usage (void)
 	  _("SKIP values may be followed by the following multiplicative suffixes:\n\
 kB 1000, K 1024, MB 1,000,000, M 1,048,576,\n\
 GB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y."),
-	  _("If a FILE is `-' or missing, read standard input."),
+	  _("If a FILE is '-' or missing, read standard input."),
 	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
   emit_bug_reporting_address ();
 }
@@ -231,7 +231,7 @@ main (int argc, char **argv)
 	{
 	  uintmax_t n;
 	  if (xstrtoumax (optarg, 0, 0, &n, valid_suffixes) != LONGINT_OK)
-	    try_help ("invalid --bytes value `%s'", optarg);
+	    try_help ("invalid --bytes value '%s'", optarg);
 	  if (n < bytes)
 	    bytes = n;
 	}
@@ -257,7 +257,7 @@ main (int argc, char **argv)
       }
 
   if (optind == argc)
-    try_help ("missing operand after `%s'", argv[argc - 1]);
+    try_help ("missing operand after '%s'", argv[argc - 1]);
 
   file[0] = argv[optind++];
   file[1] = optind < argc ? argv[optind++] : "-";
@@ -269,7 +269,7 @@ main (int argc, char **argv)
     }
 
   if (optind < argc)
-    try_help ("extra operand `%s'", argv[optind]);
+    try_help ("extra operand '%s'", argv[optind]);
 
   for (f = 0; f < 2; f++)
     {
diff --git a/src/cmp.c.orig b/src/cmp.c.orig
new file mode 100644
index 0000000..e19f013
--- /dev/null
+++ b/src/cmp.c.orig
@@ -0,0 +1,685 @@
+/* cmp - compare two files byte by byte
+
+   Copyright (C) 1990-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2010 Free
+   Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+
+#include <c-stack.h>
+#include <cmpbuf.h>
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <hard-locale.h>
+#include <inttostr.h>
+#include <progname.h>
+#include <unlocked-io.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <xfreopen.h>
+#include <xstrtol.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "cmp"
+
+#define AUTHORS \
+  proper_name_utf8 ("Torbjorn Granlund", "Torbj\303\266rn Granlund"), \
+  proper_name ("David MacKenzie")
+
+#if defined LC_MESSAGES && ENABLE_NLS
+# define hard_locale_LC_MESSAGES hard_locale (LC_MESSAGES)
+#else
+# define hard_locale_LC_MESSAGES 0
+#endif
+
+static int cmp (void);
+static off_t file_position (int);
+static size_t block_compare (word const *, word const *);
+static size_t block_compare_and_count (word const *, word const *, off_t *);
+static void sprintc (char *, unsigned char);
+
+/* Filenames of the compared files.  */
+static char const *file[2];
+
+/* File descriptors of the files.  */
+static int file_desc[2];
+
+/* Status of the files.  */
+static struct stat stat_buf[2];
+
+/* Read buffers for the files.  */
+static word *buffer[2];
+
+/* Optimal block size for the files.  */
+static size_t buf_size;
+
+/* Initial prefix to ignore for each file.  */
+static off_t ignore_initial[2];
+
+/* Number of bytes to compare.  */
+static uintmax_t bytes = UINTMAX_MAX;
+
+/* Output format.  */
+static enum comparison_type
+  {
+    type_first_diff,	/* Print the first difference.  */
+    type_all_diffs,	/* Print all differences.  */
+    type_no_stdout,	/* Do not output to stdout; only stderr.  */
+    type_status		/* Exit status only.  */
+  } comparison_type;
+
+/* If nonzero, print values of bytes quoted like cat -t does. */
+static bool opt_print_bytes;
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  HELP_OPTION = CHAR_MAX + 1
+};
+
+static struct option const long_options[] =
+{
+  {"print-bytes", 0, 0, 'b'},
+  {"print-chars", 0, 0, 'c'}, /* obsolescent as of diffutils 2.7.3 */
+  {"ignore-initial", 1, 0, 'i'},
+  {"verbose", 0, 0, 'l'},
+  {"bytes", 1, 0, 'n'},
+  {"silent", 0, 0, 's'},
+  {"quiet", 0, 0, 's'},
+  {"version", 0, 0, 'v'},
+  {"help", 0, 0, HELP_OPTION},
+  {0, 0, 0, 0}
+};
+
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0,
+	 _("Try '%s --help' for more information."), program_name);
+  abort ();
+}
+
+static char const valid_suffixes[] = "kKMGTPEZY0";
+
+/* Update ignore_initial[F] according to the result of parsing an
+   *operand ARGPTR of --ignore-initial, updating *ARGPTR to point
+   *after the operand.  If DELIMITER is nonzero, the operand may be
+   *followed by DELIMITER; otherwise it must be null-terminated.  */
+static void
+specify_ignore_initial (int f, char **argptr, char delimiter)
+{
+  uintmax_t val;
+  char const *arg = *argptr;
+  strtol_error e = xstrtoumax (arg, argptr, 0, &val, valid_suffixes);
+  if (! (e == LONGINT_OK
+	 || (e == LONGINT_INVALID_SUFFIX_CHAR && **argptr == delimiter))
+      || TYPE_MAXIMUM (off_t) < val)
+    try_help ("invalid --ignore-initial value '%s'", arg);
+  if (ignore_initial[f] < val)
+    ignore_initial[f] = val;
+}
+
+/* Specify the output format.  */
+static void
+specify_comparison_type (enum comparison_type t)
+{
+  if (comparison_type && comparison_type != t)
+    try_help ("options -l and -s are incompatible", 0);
+  comparison_type = t;
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    error (EXIT_TROUBLE, 0, "%s", _("write failed"));
+  else if (fclose (stdout) != 0)
+    error (EXIT_TROUBLE, errno, "%s", _("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-b  --print-bytes  Print differing bytes."),
+  N_("-i SKIP  --ignore-initial=SKIP  Skip the first SKIP bytes of input."),
+  N_("-i SKIP1:SKIP2  --ignore-initial=SKIP1:SKIP2"),
+  N_("  Skip the first SKIP1 bytes of FILE1 and the first SKIP2 bytes of FILE2."),
+  N_("-l  --verbose  Output byte numbers and values of all differing bytes."),
+  N_("-n LIMIT  --bytes=LIMIT  Compare at most LIMIT bytes."),
+  N_("-s  --quiet  --silent  Output nothing; yield exit status only."),
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILE1 [FILE2 [SKIP1 [SKIP2]]]\n"),
+	  program_name);
+  printf ("%s\n\n", _("Compare two files byte by byte."));
+  for (p = option_help_msgid;  *p;  p++)
+    printf ("  %s\n", _(*p));
+  printf ("\n%s\n%s\n\n%s\n%s\n",
+	  _("SKIP1 and SKIP2 are the number of bytes to skip in each file."),
+	  _("SKIP values may be followed by the following multiplicative suffixes:\n\
+kB 1000, K 1024, MB 1,000,000, M 1,048,576,\n\
+GB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y."),
+	  _("If a FILE is '-' or missing, read standard input."),
+	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+int
+main (int argc, char **argv)
+{
+  int c, f, exit_status;
+  size_t words_per_buffer;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+
+  /* Parse command line options.  */
+
+  while ((c = getopt_long (argc, argv, "bci:ln:sv", long_options, 0))
+	 != -1)
+    switch (c)
+      {
+      case 'b':
+      case 'c': /* 'c' is obsolescent as of diffutils 2.7.3 */
+	opt_print_bytes = true;
+	break;
+
+      case 'i':
+	specify_ignore_initial (0, &optarg, ':');
+	if (*optarg++ == ':')
+	  specify_ignore_initial (1, &optarg, 0);
+	else if (ignore_initial[1] < ignore_initial[0])
+	  ignore_initial[1] = ignore_initial[0];
+	break;
+
+      case 'l':
+	specify_comparison_type (type_all_diffs);
+	break;
+
+      case 'n':
+	{
+	  uintmax_t n;
+	  if (xstrtoumax (optarg, 0, 0, &n, valid_suffixes) != LONGINT_OK)
+	    try_help ("invalid --bytes value '%s'", optarg);
+	  if (n < bytes)
+	    bytes = n;
+	}
+	break;
+
+      case 's':
+	specify_comparison_type (type_status);
+	break;
+
+      case 'v':
+	version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		     AUTHORS, (char *) NULL);
+	check_stdout ();
+	return EXIT_SUCCESS;
+
+      case HELP_OPTION:
+	usage ();
+	check_stdout ();
+	return EXIT_SUCCESS;
+
+      default:
+	try_help (0, 0);
+      }
+
+  if (optind == argc)
+    try_help ("missing operand after '%s'", argv[argc - 1]);
+
+  file[0] = argv[optind++];
+  file[1] = optind < argc ? argv[optind++] : "-";
+
+  for (f = 0; f < 2 && optind < argc; f++)
+    {
+      char *arg = argv[optind++];
+      specify_ignore_initial (f, &arg, 0);
+    }
+
+  if (optind < argc)
+    try_help ("extra operand '%s'", argv[optind]);
+
+  for (f = 0; f < 2; f++)
+    {
+      /* If file[1] is "-", treat it first; this avoids a misdiagnostic if
+	 stdin is closed and opening file[0] yields file descriptor 0.  */
+      int f1 = f ^ (STREQ (file[1], "-"));
+
+      /* Two files with the same name and offset are identical.
+	 But wait until we open the file once, for proper diagnostics.  */
+      if (f && ignore_initial[0] == ignore_initial[1]
+	  && file_name_cmp (file[0], file[1]) == 0)
+	return EXIT_SUCCESS;
+
+      if (STREQ (file[f1], "-"))
+	{
+	  file_desc[f1] = STDIN_FILENO;
+	  if (O_BINARY && ! isatty (STDIN_FILENO))
+	    xfreopen (NULL, "rb", stdin);
+	}
+      else
+	file_desc[f1] = open (file[f1], O_RDONLY | O_BINARY, 0);
+
+      if (file_desc[f1] < 0 || fstat (file_desc[f1], stat_buf + f1) != 0)
+	{
+	  if (file_desc[f1] < 0 && comparison_type == type_status)
+	    exit (EXIT_TROUBLE);
+	  else
+	    error (EXIT_TROUBLE, errno, "%s", file[f1]);
+	}
+    }
+
+  /* If the files are links to the same inode and have the same file position,
+     they are identical.  */
+
+  if (0 < same_file (&stat_buf[0], &stat_buf[1])
+      && same_file_attributes (&stat_buf[0], &stat_buf[1])
+      && file_position (0) == file_position (1))
+    return EXIT_SUCCESS;
+
+  /* If output is redirected to the null device, we can avoid some of
+     the work.  */
+
+  if (comparison_type != type_status)
+    {
+      struct stat outstat, nullstat;
+
+      if (fstat (STDOUT_FILENO, &outstat) == 0
+	  && stat (NULL_DEVICE, &nullstat) == 0
+	  && 0 < same_file (&outstat, &nullstat))
+	comparison_type = type_no_stdout;
+    }
+
+  /* If only a return code is needed,
+     and if both input descriptors are associated with plain files,
+     conclude that the files differ if they have different sizes
+     and if more bytes will be compared than are in the smaller file.  */
+
+  if (comparison_type == type_status
+      && S_ISREG (stat_buf[0].st_mode)
+      && S_ISREG (stat_buf[1].st_mode))
+    {
+      off_t s0 = stat_buf[0].st_size - file_position (0);
+      off_t s1 = stat_buf[1].st_size - file_position (1);
+      if (s0 < 0)
+	s0 = 0;
+      if (s1 < 0)
+	s1 = 0;
+      if (s0 != s1 && MIN (s0, s1) < bytes)
+	exit (EXIT_FAILURE);
+    }
+
+  /* Get the optimal block size of the files.  */
+
+  buf_size = buffer_lcm (STAT_BLOCKSIZE (stat_buf[0]),
+			 STAT_BLOCKSIZE (stat_buf[1]),
+			 PTRDIFF_MAX - sizeof (word));
+
+  /* Allocate word-aligned buffers, with space for sentinels at the end.  */
+
+  words_per_buffer = (buf_size + 2 * sizeof (word) - 1) / sizeof (word);
+  buffer[0] = xmalloc (2 * sizeof (word) * words_per_buffer);
+  buffer[1] = buffer[0] + words_per_buffer;
+
+  exit_status = cmp ();
+
+  for (f = 0; f < 2; f++)
+    if (close (file_desc[f]) != 0)
+      error (EXIT_TROUBLE, errno, "%s", file[f]);
+  if (exit_status != EXIT_SUCCESS && comparison_type < type_no_stdout)
+    check_stdout ();
+  exit (exit_status);
+  return exit_status;
+}
+
+/* Compare the two files already open on `file_desc[0]' and `file_desc[1]',
+   using `buffer[0]' and `buffer[1]'.
+   Return EXIT_SUCCESS if identical, EXIT_FAILURE if different,
+   >1 if error.  */
+
+static int
+cmp (void)
+{
+  off_t line_number = 1;	/* Line number (1...) of difference. */
+  off_t byte_number = 1;	/* Byte number (1...) of difference. */
+  uintmax_t remaining = bytes;	/* Remaining number of bytes to compare.  */
+  size_t read0, read1;		/* Number of bytes read from each file. */
+  size_t first_diff;		/* Offset (0...) in buffers of 1st diff. */
+  size_t smaller;		/* The lesser of `read0' and `read1'. */
+  word *buffer0 = buffer[0];
+  word *buffer1 = buffer[1];
+  char *buf0 = (char *) buffer0;
+  char *buf1 = (char *) buffer1;
+  int differing = 0;
+  int f;
+  int offset_width IF_LINT (= 0);
+
+  if (comparison_type == type_all_diffs)
+    {
+      off_t byte_number_max = MIN (bytes, TYPE_MAXIMUM (off_t));
+
+      for (f = 0; f < 2; f++)
+	if (S_ISREG (stat_buf[f].st_mode))
+	  {
+	    off_t file_bytes = stat_buf[f].st_size - file_position (f);
+	    if (file_bytes < byte_number_max)
+	      byte_number_max = file_bytes;
+	  }
+
+      for (offset_width = 1; (byte_number_max /= 10) != 0; offset_width++)
+	continue;
+    }
+
+  for (f = 0; f < 2; f++)
+    {
+      off_t ig = ignore_initial[f];
+      if (ig && file_position (f) == -1)
+	{
+	  /* lseek failed; read and discard the ignored initial prefix.  */
+	  do
+	    {
+	      size_t bytes_to_read = MIN (ig, buf_size);
+	      size_t r = block_read (file_desc[f], buf0, bytes_to_read);
+	      if (r != bytes_to_read)
+		{
+		  if (r == SIZE_MAX)
+		    error (EXIT_TROUBLE, errno, "%s", file[f]);
+		  break;
+		}
+	      ig -= r;
+	    }
+	  while (ig);
+	}
+    }
+
+  do
+    {
+      size_t bytes_to_read = buf_size;
+
+      if (remaining != UINTMAX_MAX)
+	{
+	  if (remaining < bytes_to_read)
+	    bytes_to_read = remaining;
+	  remaining -= bytes_to_read;
+	}
+
+      read0 = block_read (file_desc[0], buf0, bytes_to_read);
+      if (read0 == SIZE_MAX)
+	error (EXIT_TROUBLE, errno, "%s", file[0]);
+      read1 = block_read (file_desc[1], buf1, bytes_to_read);
+      if (read1 == SIZE_MAX)
+	error (EXIT_TROUBLE, errno, "%s", file[1]);
+
+      /* Insert sentinels for the block compare.  */
+
+      buf0[read0] = ~buf1[read0];
+      buf1[read1] = ~buf0[read1];
+
+      /* If the line number should be written for differing files,
+	 compare the blocks and count the number of newlines
+	 simultaneously.  */
+      first_diff = (comparison_type == type_first_diff
+		    ? block_compare_and_count (buffer0, buffer1, &line_number)
+		    : block_compare (buffer0, buffer1));
+
+      byte_number += first_diff;
+      smaller = MIN (read0, read1);
+
+      if (first_diff < smaller)
+	{
+	  switch (comparison_type)
+	    {
+	    case type_first_diff:
+	      {
+		char byte_buf[INT_BUFSIZE_BOUND (off_t)];
+		char line_buf[INT_BUFSIZE_BOUND (off_t)];
+		char const *byte_num = offtostr (byte_number, byte_buf);
+		char const *line_num = offtostr (line_number, line_buf);
+		if (!opt_print_bytes)
+		  {
+		    /* See POSIX 1003.1-2001 for this format.  This
+		       message is used only in the POSIX locale, so it
+		       need not be translated.  */
+		    static char const char_message[] =
+		      "%s %s differ: char %s, line %s\n";
+
+		    /* The POSIX rationale recommends using the word
+		       "byte" outside the POSIX locale.  Some gettext
+		       implementations translate even in the POSIX
+		       locale if certain other environment variables
+		       are set, so use "byte" if a translation is
+		       available, or if outside the POSIX locale.  */
+		    static char const byte_msgid[] =
+		      N_("%s %s differ: byte %s, line %s\n");
+		    char const *byte_message = _(byte_msgid);
+		    bool use_byte_message = (byte_message != byte_msgid
+					     || hard_locale_LC_MESSAGES);
+
+		    printf (use_byte_message ? byte_message : char_message,
+			    file[0], file[1], byte_num, line_num);
+		  }
+		else
+		  {
+		    unsigned char c0 = buf0[first_diff];
+		    unsigned char c1 = buf1[first_diff];
+		    char s0[5];
+		    char s1[5];
+		    sprintc (s0, c0);
+		    sprintc (s1, c1);
+		    printf (_("%s %s differ: byte %s, line %s is %3o %s %3o %s\n"),
+			    file[0], file[1], byte_num, line_num,
+			    c0, s0, c1, s1);
+		}
+	      }
+	      /* Fall through.  */
+	    case type_status:
+	      return EXIT_FAILURE;
+
+	    case type_all_diffs:
+	      do
+		{
+		  unsigned char c0 = buf0[first_diff];
+		  unsigned char c1 = buf1[first_diff];
+		  if (c0 != c1)
+		    {
+		      char byte_buf[INT_BUFSIZE_BOUND (off_t)];
+		      char const *byte_num = offtostr (byte_number, byte_buf);
+		      if (!opt_print_bytes)
+			{
+			  /* See POSIX 1003.1-2001 for this format.  */
+			  printf ("%*s %3o %3o\n",
+				  offset_width, byte_num, c0, c1);
+			}
+		      else
+			{
+			  char s0[5];
+			  char s1[5];
+			  sprintc (s0, c0);
+			  sprintc (s1, c1);
+			  printf ("%*s %3o %-4s %3o %s\n",
+				  offset_width, byte_num, c0, s0, c1, s1);
+			}
+		    }
+		  byte_number++;
+		  first_diff++;
+		}
+	      while (first_diff < smaller);
+	      differing = -1;
+	      break;
+
+	    case type_no_stdout:
+	      differing = 1;
+	      break;
+	    }
+	}
+
+      if (read0 != read1)
+	{
+	  if (differing <= 0 && comparison_type != type_status)
+	    {
+	      /* See POSIX 1003.1-2001 for this format.  */
+	      fprintf (stderr, _("cmp: EOF on %s\n"), file[read1 < read0]);
+	    }
+
+	  return EXIT_FAILURE;
+	}
+    }
+  while (differing <= 0 && read0 == buf_size);
+
+  return differing == 0 ? EXIT_SUCCESS : EXIT_FAILURE;
+}
+
+/* Compare two blocks of memory P0 and P1 until they differ,
+   and count the number of '\n' occurrences in the common
+   part of P0 and P1.
+   If the blocks are not guaranteed to be different, put sentinels at the ends
+   of the blocks before calling this function.
+
+   Return the offset of the first byte that differs.
+   Increment *COUNT by the count of '\n' occurrences.  */
+
+static size_t
+block_compare_and_count (word const *p0, word const *p1, off_t *count)
+{
+  word l;		/* One word from first buffer. */
+  word const *l0, *l1;	/* Pointers into each buffer. */
+  char const *c0, *c1;	/* Pointers for finding exact address. */
+  size_t cnt = 0;	/* Number of '\n' occurrences. */
+  word nnnn;		/* Newline, sizeof (word) times.  */
+  int i;
+
+  nnnn = 0;
+  for (i = 0; i < sizeof nnnn; i++)
+    nnnn = (nnnn << CHAR_BIT) | '\n';
+
+  /* Find the rough position of the first difference by reading words,
+     not bytes.  */
+
+  for (l0 = p0, l1 = p1;  (l = *l0) == *l1;  l0++, l1++)
+    {
+      l ^= nnnn;
+      for (i = 0; i < sizeof l; i++)
+	{
+	  unsigned char uc = l;
+	  cnt += ! uc;
+	  l >>= CHAR_BIT;
+	}
+    }
+
+  /* Find the exact differing position (endianness independent).  */
+
+  for (c0 = (char const *) l0, c1 = (char const *) l1;
+       *c0 == *c1;
+       c0++, c1++)
+    cnt += *c0 == '\n';
+
+  *count += cnt;
+  return c0 - (char const *) p0;
+}
+
+/* Compare two blocks of memory P0 and P1 until they differ.
+   If the blocks are not guaranteed to be different, put sentinels at the ends
+   of the blocks before calling this function.
+
+   Return the offset of the first byte that differs.  */
+
+static size_t
+block_compare (word const *p0, word const *p1)
+{
+  word const *l0, *l1;
+  char const *c0, *c1;
+
+  /* Find the rough position of the first difference by reading words,
+     not bytes.  */
+
+  for (l0 = p0, l1 = p1;  *l0 == *l1;  l0++, l1++)
+    continue;
+
+  /* Find the exact differing position (endianness independent).  */
+
+  for (c0 = (char const *) l0, c1 = (char const *) l1;
+       *c0 == *c1;
+       c0++, c1++)
+    continue;
+
+  return c0 - (char const *) p0;
+}
+
+/* Put into BUF the unsigned char C, making unprintable bytes
+   visible by quoting like cat -t does.  */
+
+static void
+sprintc (char *buf, unsigned char c)
+{
+  if (! isprint (c))
+    {
+      if (c >= 128)
+	{
+	  *buf++ = 'M';
+	  *buf++ = '-';
+	  c -= 128;
+	}
+      if (c < 32)
+	{
+	  *buf++ = '^';
+	  c += 64;
+	}
+      else if (c == 127)
+	{
+	  *buf++ = '^';
+	  c = '?';
+	}
+    }
+
+  *buf++ = c;
+  *buf = 0;
+}
+
+/* Position file F to ignore_initial[F] bytes from its initial position,
+   and yield its new position.  Don't try more than once.  */
+
+static off_t
+file_position (int f)
+{
+  static bool positioned[2];
+  static off_t position[2];
+
+  if (! positioned[f])
+    {
+      positioned[f] = true;
+      position[f] = lseek (file_desc[f], ignore_initial[f], SEEK_CUR);
+    }
+  return position[f];
+}
diff --git a/src/cmp.c.rej b/src/cmp.c.rej
new file mode 100644
index 0000000..cef625b
--- /dev/null
+++ b/src/cmp.c.rej
@@ -0,0 +1,56 @@
+--- src/cmp.c
++++ src/cmp.c
+@@ -115,7 +115,7 @@
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+   error (EXIT_TROUBLE, 0,
+-	 _("Try `%s --help' for more information."), program_name);
++	 _("Try '%s --help' for more information."), program_name);
+   abort ();
+ }
+ 
+@@ -134,7 +134,7 @@
+   if (! (e == LONGINT_OK
+ 	 || (e == LONGINT_INVALID_SUFFIX_CHAR && **argptr == delimiter))
+       || TYPE_MAXIMUM (off_t) < val)
+-    try_help ("invalid --ignore-initial value `%s'", arg);
++    try_help ("invalid --ignore-initial value '%s'", arg);
+   if (ignore_initial[f] < val)
+     ignore_initial[f] = val;
+ }
+@@ -185,7 +185,7 @@
+ 	  _("SKIP values may be followed by the following multiplicative suffixes:\n\
+ kB 1000, K 1024, MB 1,000,000, M 1,048,576,\n\
+ GB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y."),
+-	  _("If a FILE is `-' or missing, read standard input."),
++	  _("If a FILE is '-' or missing, read standard input."),
+ 	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+   emit_bug_reporting_address ();
+ }
+@@ -231,7 +231,7 @@
+ 	{
+ 	  uintmax_t n;
+ 	  if (xstrtoumax (optarg, 0, 0, &n, valid_suffixes) != LONGINT_OK)
+-	    try_help ("invalid --bytes value `%s'", optarg);
++	    try_help ("invalid --bytes value '%s'", optarg);
+ 	  if (n < bytes)
+ 	    bytes = n;
+ 	}
+@@ -257,7 +257,7 @@
+       }
+ 
+   if (optind == argc)
+-    try_help ("missing operand after `%s'", argv[argc - 1]);
++    try_help ("missing operand after '%s'", argv[argc - 1]);
+ 
+   file[0] = argv[optind++];
+   file[1] = optind < argc ? argv[optind++] : "-";
+@@ -269,7 +269,7 @@
+     }
+ 
+   if (optind < argc)
+-    try_help ("extra operand `%s'", argv[optind]);
++    try_help ("extra operand '%s'", argv[optind]);
+ 
+   for (f = 0; f < 2; f++)
+     {
diff --git a/src/diff.c b/src/diff.c
index cc1b611..256a984 100644
--- a/src/diff.c
+++ b/src/diff.c
@@ -330,7 +330,7 @@ main (int argc, char **argv)
 	      {
 		numval = strtoumax (optarg, &numend, 10);
 		if (*numend)
-		  try_help ("invalid context length `%s'", optarg);
+		  try_help ("invalid context length '%s'", optarg);
 		if (LIN_MAX < numval)
 		  numval = LIN_MAX;
 	      }
@@ -505,7 +505,7 @@ main (int argc, char **argv)
 	case 'W':
 	  numval = strtoumax (optarg, &numend, 10);
 	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
-	    try_help ("invalid width `%s'", optarg);
+	    try_help ("invalid width '%s'", optarg);
 	  if (width != numval)
 	    {
 	      if (width)
@@ -534,7 +534,7 @@ main (int argc, char **argv)
 	case HORIZON_LINES_OPTION:
 	  numval = strtoumax (optarg, &numend, 10);
 	  if (*numend)
-	    try_help ("invalid horizon length `%s'", optarg);
+	    try_help ("invalid horizon length '%s'", optarg);
 	  horizon_lines = MAX (horizon_lines, MIN (numval, LIN_MAX));
 	  break;
 
@@ -585,7 +585,7 @@ main (int argc, char **argv)
 	case TABSIZE_OPTION:
 	  numval = strtoumax (optarg, &numend, 10);
 	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
-	    try_help ("invalid tabsize `%s'", optarg);
+	    try_help ("invalid tabsize '%s'", optarg);
 	  if (tabsize != numval)
 	    {
 	      if (tabsize)
@@ -744,9 +744,9 @@ main (int argc, char **argv)
 	  if (argc - optind != 2)
 	    {
 	      if (argc - optind < 2)
-		try_help ("missing operand after `%s'", argv[argc - 1]);
+		try_help ("missing operand after '%s'", argv[argc - 1]);
 	      else
-		try_help ("extra operand `%s'", argv[optind + 2]);
+		try_help ("extra operand '%s'", argv[optind + 2]);
 	    }
 
 	  exit_status = compare_files (NULL, argv[optind], argv[optind + 1]);
@@ -826,7 +826,7 @@ try_help (char const *reason_msgid, char const *operand)
 {
   if (reason_msgid)
     error (0, 0, _(reason_msgid), operand);
-  error (EXIT_TROUBLE, 0, _("Try `%s --help' for more information."),
+  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
 	 program_name);
   abort ();
 }
@@ -870,11 +870,11 @@ static char const * const option_help_msgid[] = {
   -W NUM  --width=NUM  Output at most NUM (default 130) print columns.\n\
   --left-column  Output only the left column of common lines.\n\
   --suppress-common-lines  Do not output common lines."),
-  N_("-D NAME  --ifdef=NAME  Output merged file to show `#ifdef NAME' diffs."),
+  N_("-D NAME  --ifdef=NAME  Output merged file to show '#ifdef NAME' diffs."),
   N_("--GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT."),
   N_("--line-format=LFMT  Similar, but format all input lines with LFMT."),
   N_("--LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT."),
-  N_("  LTYPE is `old', `new', or `unchanged'.  GTYPE is LTYPE or `changed'."),
+  N_("  LTYPE is 'old', 'new', or 'unchanged'.  GTYPE is LTYPE or 'changed'."),
   N_("  GFMT may contain:\n\
     %<  lines from FILE1\n\
     %>  lines from FILE2\n\
@@ -895,7 +895,7 @@ static char const * const option_help_msgid[] = {
     %c'C'  the single character C\n\
     %c'\\OOO'  the character with octal code OOO"),
   "",
-  N_("-l  --paginate  Pass the output through `pr' to paginate it."),
+  N_("-l  --paginate  Pass the output through 'pr' to paginate it."),
   N_("-t  --expand-tabs  Expand tabs to spaces in output."),
   N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
   N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
@@ -918,9 +918,9 @@ static char const * const option_help_msgid[] = {
   N_("-v  --version  Output version info."),
   N_("--help  Output this help."),
   "",
-  N_("FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE...' or `FILE... DIR'."),
+  N_("FILES are 'FILE1 FILE2' or 'DIR1 DIR2' or 'DIR FILE...' or 'FILE... DIR'."),
   N_("If --from-file or --to-file is given, there are no restrictions on FILES."),
-  N_("If a FILE is `-', read standard input."),
+  N_("If a FILE is '-', read standard input."),
   N_("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."),
   0
 };
@@ -960,7 +960,7 @@ specify_value (char const **var, char const *value, char const *option)
 {
   if (*var && strcmp (*var, value) != 0)
     {
-      error (0, 0, _("conflicting %s option value `%s'"), option, value);
+      error (0, 0, _("conflicting %s option value '%s'"), option, value);
       try_help (NULL, NULL);
     }
   *var = value;
@@ -1159,7 +1159,7 @@ compare_files (struct comparison const *parent,
 	= dir_file_pathname (dir, last_component (fnm));
 
       if (STREQ (fnm, "-"))
-	fatal ("cannot compare `-' to a directory");
+	fatal ("cannot compare '-' to a directory");
 
       if (stat (filename, &cmp.file[dir_arg].stat) != 0)
 	{
diff --git a/src/diff.c.orig b/src/diff.c.orig
new file mode 100644
index 0000000..256a984
--- /dev/null
+++ b/src/diff.c.orig
@@ -0,0 +1,1330 @@
+/* diff - compare files line by line
+
+   Copyright (C) 1988-1989, 1992-1994, 1996, 1998, 2001-2002, 2004, 2006-2007,
+   2009-2010 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#define GDIFF_MAIN
+#include "diff.h"
+#include <assert.h>
+#include "paths.h"
+#include <c-stack.h>
+#include <dirname.h>
+#include <error.h>
+#include <exclude.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <fnmatch.h>
+#include <getopt.h>
+#include <hard-locale.h>
+#include <prepargs.h>
+#include <progname.h>
+#include <sh-quote.h>
+#include <stat-time.h>
+#include <timespec.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <xfreopen.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "diff"
+
+#define AUTHORS \
+  proper_name ("Paul Eggert"), \
+  proper_name ("Mike Haertel"), \
+  proper_name ("David Hayes"), \
+  proper_name ("Richard Stallman"), \
+  proper_name ("Len Tower")
+
+#ifndef GUTTER_WIDTH_MINIMUM
+# define GUTTER_WIDTH_MINIMUM 3
+#endif
+
+struct regexp_list
+{
+  char *regexps;	/* chars representing disjunction of the regexps */
+  size_t len;		/* chars used in `regexps' */
+  size_t size;		/* size malloc'ed for `regexps'; 0 if not malloc'ed */
+  bool multiple_regexps;/* Does `regexps' represent a disjunction?  */
+  struct re_pattern_buffer *buf;
+};
+
+static int compare_files (struct comparison const *, char const *, char const *);
+static void add_regexp (struct regexp_list *, char const *);
+static void summarize_regexp_list (struct regexp_list *);
+static void specify_style (enum output_style);
+static void specify_value (char const **, char const *, char const *);
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void check_stdout (void);
+static void usage (void);
+
+/* If comparing directories, compare their common subdirectories
+   recursively.  */
+static bool recursive;
+
+/* In context diffs, show previous lines that match these regexps.  */
+static struct regexp_list function_regexp_list;
+
+/* Ignore changes affecting only lines that match these regexps.  */
+static struct regexp_list ignore_regexp_list;
+
+#if O_BINARY
+/* Use binary I/O when reading and writing data (--binary).
+   On POSIX hosts, this has no effect.  */
+static bool binary;
+#else
+enum { binary = true };
+#endif
+
+/* When comparing directories, if a file appears only in one
+   directory, treat it as present but empty in the other (-N).
+   Then `patch' would create the file with appropriate contents.  */
+static bool new_file;
+
+/* When comparing directories, if a file appears only in the second
+   directory of the two, treat it as present but empty in the other
+   (--unidirectional-new-file).
+   Then `patch' would create the file with appropriate contents.  */
+static bool unidirectional_new_file;
+
+/* Report files compared that are the same (-s).
+   Normally nothing is output when that happens.  */
+static bool report_identical_files;
+
+static char const shortopts[] =
+"0123456789abBcC:dD:eEfF:hHiI:lL:nNpPqrsS:tTuU:vwW:x:X:y";
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  BINARY_OPTION = CHAR_MAX + 1,
+  FROM_FILE_OPTION,
+  HELP_OPTION,
+  HORIZON_LINES_OPTION,
+  IGNORE_FILE_NAME_CASE_OPTION,
+  INHIBIT_HUNK_MERGE_OPTION,
+  LEFT_COLUMN_OPTION,
+  LINE_FORMAT_OPTION,
+  NO_IGNORE_FILE_NAME_CASE_OPTION,
+  NORMAL_OPTION,
+  SDIFF_MERGE_ASSIST_OPTION,
+  STRIP_TRAILING_CR_OPTION,
+  SUPPRESS_BLANK_EMPTY_OPTION,
+  SUPPRESS_COMMON_LINES_OPTION,
+  TABSIZE_OPTION,
+  TO_FILE_OPTION,
+
+  /* These options must be in sequence.  */
+  UNCHANGED_LINE_FORMAT_OPTION,
+  OLD_LINE_FORMAT_OPTION,
+  NEW_LINE_FORMAT_OPTION,
+
+  /* These options must be in sequence.  */
+  UNCHANGED_GROUP_FORMAT_OPTION,
+  OLD_GROUP_FORMAT_OPTION,
+  NEW_GROUP_FORMAT_OPTION,
+  CHANGED_GROUP_FORMAT_OPTION
+};
+
+static char const group_format_option[][sizeof "--unchanged-group-format"] =
+  {
+    "--unchanged-group-format",
+    "--old-group-format",
+    "--new-group-format",
+    "--changed-group-format"
+  };
+
+static char const line_format_option[][sizeof "--unchanged-line-format"] =
+  {
+    "--unchanged-line-format",
+    "--old-line-format",
+    "--new-line-format"
+  };
+
+static struct option const longopts[] =
+{
+  {"binary", 0, 0, BINARY_OPTION},
+  {"brief", 0, 0, 'q'},
+  {"changed-group-format", 1, 0, CHANGED_GROUP_FORMAT_OPTION},
+  {"context", 2, 0, 'C'},
+  {"ed", 0, 0, 'e'},
+  {"exclude", 1, 0, 'x'},
+  {"exclude-from", 1, 0, 'X'},
+  {"expand-tabs", 0, 0, 't'},
+  {"forward-ed", 0, 0, 'f'},
+  {"from-file", 1, 0, FROM_FILE_OPTION},
+  {"help", 0, 0, HELP_OPTION},
+  {"horizon-lines", 1, 0, HORIZON_LINES_OPTION},
+  {"ifdef", 1, 0, 'D'},
+  {"ignore-all-space", 0, 0, 'w'},
+  {"ignore-blank-lines", 0, 0, 'B'},
+  {"ignore-case", 0, 0, 'i'},
+  {"ignore-file-name-case", 0, 0, IGNORE_FILE_NAME_CASE_OPTION},
+  {"ignore-matching-lines", 1, 0, 'I'},
+  {"ignore-space-change", 0, 0, 'b'},
+  {"ignore-tab-expansion", 0, 0, 'E'},
+  {"inhibit-hunk-merge", 0, 0, INHIBIT_HUNK_MERGE_OPTION},
+  {"initial-tab", 0, 0, 'T'},
+  {"label", 1, 0, 'L'},
+  {"left-column", 0, 0, LEFT_COLUMN_OPTION},
+  {"line-format", 1, 0, LINE_FORMAT_OPTION},
+  {"minimal", 0, 0, 'd'},
+  {"new-file", 0, 0, 'N'},
+  {"new-group-format", 1, 0, NEW_GROUP_FORMAT_OPTION},
+  {"new-line-format", 1, 0, NEW_LINE_FORMAT_OPTION},
+  {"no-ignore-file-name-case", 0, 0, NO_IGNORE_FILE_NAME_CASE_OPTION},
+  {"normal", 0, 0, NORMAL_OPTION},
+  {"old-group-format", 1, 0, OLD_GROUP_FORMAT_OPTION},
+  {"old-line-format", 1, 0, OLD_LINE_FORMAT_OPTION},
+  {"paginate", 0, 0, 'l'},
+  {"rcs", 0, 0, 'n'},
+  {"recursive", 0, 0, 'r'},
+  {"report-identical-files", 0, 0, 's'},
+  {"sdiff-merge-assist", 0, 0, SDIFF_MERGE_ASSIST_OPTION},
+  {"show-c-function", 0, 0, 'p'},
+  {"show-function-line", 1, 0, 'F'},
+  {"side-by-side", 0, 0, 'y'},
+  {"speed-large-files", 0, 0, 'H'},
+  {"starting-file", 1, 0, 'S'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"suppress-blank-empty", 0, 0, SUPPRESS_BLANK_EMPTY_OPTION},
+  {"suppress-common-lines", 0, 0, SUPPRESS_COMMON_LINES_OPTION},
+  {"tabsize", 1, 0, TABSIZE_OPTION},
+  {"text", 0, 0, 'a'},
+  {"to-file", 1, 0, TO_FILE_OPTION},
+  {"unchanged-group-format", 1, 0, UNCHANGED_GROUP_FORMAT_OPTION},
+  {"unchanged-line-format", 1, 0, UNCHANGED_LINE_FORMAT_OPTION},
+  {"unidirectional-new-file", 0, 0, 'P'},
+  {"unified", 2, 0, 'U'},
+  {"version", 0, 0, 'v'},
+  {"width", 1, 0, 'W'},
+  {0, 0, 0, 0}
+};
+
+/* Return a string containing the command options with which diff was invoked.
+   Spaces appear between what were separate ARGV-elements.
+   There is a space at the beginning but none at the end.
+   If there were no options, the result is an empty string.
+
+   Arguments: OPTIONVEC, a vector containing separate ARGV-elements, and COUNT,
+   the length of that vector.  */
+
+static char *
+option_list (char **optionvec, int count)
+{
+  int i;
+  size_t size = 1;
+  char *result;
+  char *p;
+
+  for (i = 0; i < count; i++)
+    size += 1 + shell_quote_length (optionvec[i]);
+
+  p = result = xmalloc (size);
+
+  for (i = 0; i < count; i++)
+    {
+      *p++ = ' ';
+      p = shell_quote_copy (p, optionvec[i]);
+    }
+
+  *p = '\0';
+  return result;
+}
+
+
+/* Return an option value suitable for add_exclude.  */
+
+static int
+exclude_options (void)
+{
+  return EXCLUDE_WILDCARDS | (ignore_file_name_case ? FNM_CASEFOLD : 0);
+}
+
+int
+main (int argc, char **argv)
+{
+  int exit_status = EXIT_SUCCESS;
+  int c;
+  int i;
+  int prev = -1;
+  lin ocontext = -1;
+  bool explicit_context = false;
+  size_t width = 0;
+  bool show_c_function = false;
+  char const *from_file = NULL;
+  char const *to_file = NULL;
+  uintmax_t numval;
+  char *numend;
+
+  /* Do our initializations.  */
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+  function_regexp_list.buf = &function_regexp;
+  ignore_regexp_list.buf = &ignore_regexp;
+  re_set_syntax (RE_SYNTAX_GREP | RE_NO_POSIX_BACKTRACKING);
+  excluded = new_exclude ();
+
+  /* Decode the options.  */
+
+  while ((c = getopt_long (argc, argv, shortopts, longopts, NULL)) != -1)
+    {
+      switch (c)
+	{
+	case 0:
+	  break;
+
+	case '0':
+	case '1':
+	case '2':
+	case '3':
+	case '4':
+	case '5':
+	case '6':
+	case '7':
+	case '8':
+	case '9':
+	  if (! ISDIGIT (prev))
+	    ocontext = c - '0';
+	  else if (LIN_MAX / 10 < ocontext
+		   || ((ocontext = 10 * ocontext + c - '0') < 0))
+	    ocontext = LIN_MAX;
+	  break;
+
+	case 'a':
+	  text = true;
+	  break;
+
+	case 'b':
+	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
+	    ignore_white_space = IGNORE_SPACE_CHANGE;
+	  break;
+
+	case 'B':
+	  ignore_blank_lines = true;
+	  break;
+
+	case 'C':
+	case 'U':
+	  {
+	    if (optarg)
+	      {
+		numval = strtoumax (optarg, &numend, 10);
+		if (*numend)
+		  try_help ("invalid context length '%s'", optarg);
+		if (LIN_MAX < numval)
+		  numval = LIN_MAX;
+	      }
+	    else
+	      numval = 3;
+
+	    specify_style (c == 'U' ? OUTPUT_UNIFIED : OUTPUT_CONTEXT);
+	    if (context < numval)
+	      context = numval;
+	    explicit_context = true;
+	  }
+	  break;
+
+	case 'c':
+	  specify_style (OUTPUT_CONTEXT);
+	  if (context < 3)
+	    context = 3;
+	  break;
+
+	case 'd':
+	  minimal = true;
+	  break;
+
+	case 'D':
+	  specify_style (OUTPUT_IFDEF);
+	  {
+	    static char const C_ifdef_group_formats[] =
+	      "%%=%c#ifndef %s\n%%<#endif /* ! %s */\n%c#ifdef %s\n%%>#endif /* %s */\n%c#ifndef %s\n%%<#else /* %s */\n%%>#endif /* %s */\n";
+	    char *b = xmalloc (sizeof C_ifdef_group_formats
+			       + 7 * strlen (optarg) - 14 /* 7*"%s" */
+			       - 8 /* 5*"%%" + 3*"%c" */);
+	    sprintf (b, C_ifdef_group_formats,
+		     0,
+		     optarg, optarg, 0,
+		     optarg, optarg, 0,
+		     optarg, optarg, optarg);
+	    for (i = 0; i < sizeof group_format / sizeof group_format[0]; i++)
+	      {
+		specify_value (&group_format[i], b, "-D");
+		b += strlen (b) + 1;
+	      }
+	  }
+	  break;
+
+	case 'e':
+	  specify_style (OUTPUT_ED);
+	  break;
+
+	case 'E':
+	  if (ignore_white_space < IGNORE_TAB_EXPANSION)
+	    ignore_white_space = IGNORE_TAB_EXPANSION;
+	  break;
+
+	case 'f':
+	  specify_style (OUTPUT_FORWARD_ED);
+	  break;
+
+	case 'F':
+	  add_regexp (&function_regexp_list, optarg);
+	  break;
+
+	case 'h':
+	  /* Split the files into chunks for faster processing.
+	     Usually does not change the result.
+
+	     This currently has no effect.  */
+	  break;
+
+	case 'H':
+	  speed_large_files = true;
+	  break;
+
+	case 'i':
+	  ignore_case = true;
+	  break;
+
+	case 'I':
+	  add_regexp (&ignore_regexp_list, optarg);
+	  break;
+
+	case 'l':
+	  if (!pr_program[0])
+	    try_help ("pagination not supported on this host", NULL);
+	  paginate = true;
+#ifdef SIGCHLD
+	  /* Pagination requires forking and waiting, and
+	     System V fork+wait does not work if SIGCHLD is ignored.  */
+	  signal (SIGCHLD, SIG_DFL);
+#endif
+	  break;
+
+	case 'L':
+	  if (!file_label[0])
+	    file_label[0] = optarg;
+	  else if (!file_label[1])
+	    file_label[1] = optarg;
+	  else
+	    fatal ("too many file label options");
+	  break;
+
+	case 'n':
+	  specify_style (OUTPUT_RCS);
+	  break;
+
+	case 'N':
+	  new_file = true;
+	  break;
+
+	case 'p':
+	  show_c_function = true;
+	  add_regexp (&function_regexp_list, "^[[:alpha:]$_]");
+	  break;
+
+	case 'P':
+	  unidirectional_new_file = true;
+	  break;
+
+	case 'q':
+	  brief = true;
+	  break;
+
+	case 'r':
+	  recursive = true;
+	  break;
+
+	case 's':
+	  report_identical_files = true;
+	  break;
+
+	case 'S':
+	  specify_value (&starting_file, optarg, "-S");
+	  break;
+
+	case 't':
+	  expand_tabs = true;
+	  break;
+
+	case 'T':
+	  initial_tab = true;
+	  break;
+
+	case 'u':
+	  specify_style (OUTPUT_UNIFIED);
+	  if (context < 3)
+	    context = 3;
+	  break;
+
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case 'w':
+	  ignore_white_space = IGNORE_ALL_SPACE;
+	  break;
+
+	case 'x':
+	  add_exclude (excluded, optarg, exclude_options ());
+	  break;
+
+	case 'X':
+	  if (add_exclude_file (add_exclude, excluded, optarg,
+				exclude_options (), '\n'))
+	    pfatal_with_name (optarg);
+	  break;
+
+	case 'y':
+	  specify_style (OUTPUT_SDIFF);
+	  break;
+
+	case 'W':
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+	    try_help ("invalid width '%s'", optarg);
+	  if (width != numval)
+	    {
+	      if (width)
+		fatal ("conflicting width options");
+	      width = numval;
+	    }
+	  break;
+
+	case BINARY_OPTION:
+#if O_BINARY
+	  binary = true;
+	  if (! isatty (STDOUT_FILENO))
+	    xfreopen (NULL, "wb", stdout);
+#endif
+	  break;
+
+	case FROM_FILE_OPTION:
+	  specify_value (&from_file, optarg, "--from-file");
+	  break;
+
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case HORIZON_LINES_OPTION:
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (*numend)
+	    try_help ("invalid horizon length '%s'", optarg);
+	  horizon_lines = MAX (horizon_lines, MIN (numval, LIN_MAX));
+	  break;
+
+	case IGNORE_FILE_NAME_CASE_OPTION:
+	  ignore_file_name_case = true;
+	  break;
+
+	case INHIBIT_HUNK_MERGE_OPTION:
+	  /* This option is obsolete, but accept it for backward
+             compatibility.  */
+	  break;
+
+	case LEFT_COLUMN_OPTION:
+	  left_column = true;
+	  break;
+
+	case LINE_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  for (i = 0; i < sizeof line_format / sizeof line_format[0]; i++)
+	    specify_value (&line_format[i], optarg, "--line-format");
+	  break;
+
+	case NO_IGNORE_FILE_NAME_CASE_OPTION:
+	  ignore_file_name_case = false;
+	  break;
+
+	case NORMAL_OPTION:
+	  specify_style (OUTPUT_NORMAL);
+	  break;
+
+	case SDIFF_MERGE_ASSIST_OPTION:
+	  specify_style (OUTPUT_SDIFF);
+	  sdiff_merge_assist = true;
+	  break;
+
+	case STRIP_TRAILING_CR_OPTION:
+	  strip_trailing_cr = true;
+	  break;
+
+	case SUPPRESS_BLANK_EMPTY_OPTION:
+	  suppress_blank_empty = true;
+	  break;
+
+	case SUPPRESS_COMMON_LINES_OPTION:
+	  suppress_common_lines = true;
+	  break;
+
+	case TABSIZE_OPTION:
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+	    try_help ("invalid tabsize '%s'", optarg);
+	  if (tabsize != numval)
+	    {
+	      if (tabsize)
+		fatal ("conflicting tabsize options");
+	      tabsize = numval;
+	    }
+	  break;
+
+	case TO_FILE_OPTION:
+	  specify_value (&to_file, optarg, "--to-file");
+	  break;
+
+	case UNCHANGED_LINE_FORMAT_OPTION:
+	case OLD_LINE_FORMAT_OPTION:
+	case NEW_LINE_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  c -= UNCHANGED_LINE_FORMAT_OPTION;
+	  specify_value (&line_format[c], optarg, line_format_option[c]);
+	  break;
+
+	case UNCHANGED_GROUP_FORMAT_OPTION:
+	case OLD_GROUP_FORMAT_OPTION:
+	case NEW_GROUP_FORMAT_OPTION:
+	case CHANGED_GROUP_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  c -= UNCHANGED_GROUP_FORMAT_OPTION;
+	  specify_value (&group_format[c], optarg, group_format_option[c]);
+	  break;
+
+	default:
+	  try_help (NULL, NULL);
+	}
+      prev = c;
+    }
+
+  if (output_style == OUTPUT_UNSPECIFIED)
+    {
+      if (show_c_function)
+	{
+	  specify_style (OUTPUT_CONTEXT);
+	  if (ocontext < 0)
+	    context = 3;
+	}
+      else
+	specify_style (OUTPUT_NORMAL);
+    }
+
+  if (output_style != OUTPUT_CONTEXT || hard_locale (LC_TIME))
+    {
+#if (defined STAT_TIMESPEC || defined STAT_TIMESPEC_NS \
+     || defined HAVE_STRUCT_STAT_ST_SPARE1)
+      time_format = "%Y-%m-%d %H:%M:%S.%N %z";
+#else
+      time_format = "%Y-%m-%d %H:%M:%S %z";
+#endif
+    }
+  else
+    {
+      /* See POSIX 1003.1-2001 for this format.  */
+      time_format = "%a %b %e %T %Y";
+    }
+
+  if (0 <= ocontext
+      && (output_style == OUTPUT_CONTEXT
+	  || output_style == OUTPUT_UNIFIED)
+      && (context < ocontext
+	  || (ocontext < context && ! explicit_context)))
+    context = ocontext;
+
+  if (! tabsize)
+    tabsize = 8;
+  if (! width)
+    width = 130;
+
+  {
+    /* Maximize first the half line width, and then the gutter width,
+       according to the following constraints:
+
+	1.  Two half lines plus a gutter must fit in a line.
+	2.  If the half line width is nonzero:
+	    a.  The gutter width is at least GUTTER_WIDTH_MINIMUM.
+	    b.  If tabs are not expanded to spaces,
+		a half line plus a gutter is an integral number of tabs,
+		so that tabs in the right column line up.  */
+
+    intmax_t t = expand_tabs ? 1 : tabsize;
+    intmax_t w = width;
+    intmax_t off = (w + t + GUTTER_WIDTH_MINIMUM) / (2 * t)  *  t;
+    sdiff_half_width = MAX (0, MIN (off - GUTTER_WIDTH_MINIMUM, w - off)),
+    sdiff_column2_offset = sdiff_half_width ? off : w;
+  }
+
+  /* Make the horizon at least as large as the context, so that
+     shift_boundaries has more freedom to shift the first and last hunks.  */
+  if (horizon_lines < context)
+    horizon_lines = context;
+
+  summarize_regexp_list (&function_regexp_list);
+  summarize_regexp_list (&ignore_regexp_list);
+
+  if (output_style == OUTPUT_IFDEF)
+    {
+      for (i = 0; i < sizeof line_format / sizeof line_format[0]; i++)
+	if (!line_format[i])
+	  line_format[i] = "%l\n";
+      if (!group_format[OLD])
+	group_format[OLD]
+	  = group_format[CHANGED] ? group_format[CHANGED] : "%<";
+      if (!group_format[NEW])
+	group_format[NEW]
+	  = group_format[CHANGED] ? group_format[CHANGED] : "%>";
+      if (!group_format[UNCHANGED])
+	group_format[UNCHANGED] = "%=";
+      if (!group_format[CHANGED])
+	group_format[CHANGED] = concat (group_format[OLD],
+					group_format[NEW], "");
+    }
+
+  no_diff_means_no_output =
+    (output_style == OUTPUT_IFDEF ?
+      (!*group_format[UNCHANGED]
+       || (STREQ (group_format[UNCHANGED], "%=")
+	   && !*line_format[UNCHANGED]))
+     : (output_style != OUTPUT_SDIFF) | suppress_common_lines);
+
+  files_can_be_treated_as_binary =
+    (brief & binary
+     & ~ (ignore_blank_lines | ignore_case | strip_trailing_cr
+	  | (ignore_regexp_list.regexps || ignore_white_space)));
+
+  switch_string = option_list (argv + 1, optind - 1);
+
+  if (from_file)
+    {
+      if (to_file)
+	fatal ("--from-file and --to-file both specified");
+      else
+	for (; optind < argc; optind++)
+	  {
+	    int status = compare_files (NULL, from_file, argv[optind]);
+	    if (exit_status < status)
+	      exit_status = status;
+	  }
+    }
+  else
+    {
+      if (to_file)
+	for (; optind < argc; optind++)
+	  {
+	    int status = compare_files (NULL, argv[optind], to_file);
+	    if (exit_status < status)
+	      exit_status = status;
+	  }
+      else
+	{
+	  if (argc - optind != 2)
+	    {
+	      if (argc - optind < 2)
+		try_help ("missing operand after '%s'", argv[argc - 1]);
+	      else
+		try_help ("extra operand '%s'", argv[optind + 2]);
+	    }
+
+	  exit_status = compare_files (NULL, argv[optind], argv[optind + 1]);
+	}
+    }
+
+  /* Print any messages that were saved up for last.  */
+  print_message_queue ();
+
+  check_stdout ();
+  exit (exit_status);
+  return exit_status;
+}
+
+/* Append to REGLIST the regexp PATTERN.  */
+
+static void
+add_regexp (struct regexp_list *reglist, char const *pattern)
+{
+  size_t patlen = strlen (pattern);
+  char const *m = re_compile_pattern (pattern, patlen, reglist->buf);
+
+  if (m != 0)
+    error (0, 0, "%s: %s", pattern, m);
+  else
+    {
+      char *regexps = reglist->regexps;
+      size_t len = reglist->len;
+      bool multiple_regexps = reglist->multiple_regexps = regexps != 0;
+      size_t newlen = reglist->len = len + 2 * multiple_regexps + patlen;
+      size_t size = reglist->size;
+
+      if (size <= newlen)
+	{
+	  if (!size)
+	    size = 1;
+
+	  do size *= 2;
+	  while (size <= newlen);
+
+	  reglist->size = size;
+	  reglist->regexps = regexps = xrealloc (regexps, size);
+	}
+      if (multiple_regexps)
+	{
+	  regexps[len++] = '\\';
+	  regexps[len++] = '|';
+	}
+      memcpy (regexps + len, pattern, patlen + 1);
+    }
+}
+
+/* Ensure that REGLIST represents the disjunction of its regexps.
+   This is done here, rather than earlier, to avoid O(N^2) behavior.  */
+
+static void
+summarize_regexp_list (struct regexp_list *reglist)
+{
+  if (reglist->regexps)
+    {
+      /* At least one regexp was specified.  Allocate a fastmap for it.  */
+      reglist->buf->fastmap = xmalloc (1 << CHAR_BIT);
+      if (reglist->multiple_regexps)
+	{
+	  /* Compile the disjunction of the regexps.
+	     (If just one regexp was specified, it is already compiled.)  */
+	  char const *m = re_compile_pattern (reglist->regexps, reglist->len,
+					      reglist->buf);
+	  if (m)
+	    error (EXIT_TROUBLE, 0, "%s: %s", reglist->regexps, m);
+	}
+    }
+}
+
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+	 program_name);
+  abort ();
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    pfatal_with_name (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("Compare files line by line."),
+  "",
+  N_("-i  --ignore-case  Ignore case differences in file contents."),
+  N_("--ignore-file-name-case  Ignore case when comparing file names."),
+  N_("--no-ignore-file-name-case  Consider case when comparing file names."),
+  N_("-E  --ignore-tab-expansion  Ignore changes due to tab expansion."),
+  N_("-b  --ignore-space-change  Ignore changes in the amount of white space."),
+  N_("-w  --ignore-all-space  Ignore all white space."),
+  N_("-B  --ignore-blank-lines  Ignore changes whose lines are all blank."),
+  N_("-I RE  --ignore-matching-lines=RE  Ignore changes whose lines all match RE."),
+  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+#if O_BINARY
+  N_("--binary  Read and write data in binary mode."),
+#endif
+  N_("-a  --text  Treat all files as text."),
+  "",
+  N_("-c  -C NUM  --context[=NUM]  Output NUM (default 3) lines of copied context.\n\
+-u  -U NUM  --unified[=NUM]  Output NUM (default 3) lines of unified context.\n\
+  --label LABEL  Use LABEL instead of file name.\n\
+  -p  --show-c-function  Show which C function each change is in.\n\
+  -F RE  --show-function-line=RE  Show the most recent line matching RE."),
+  N_("-q  --brief  Output only whether files differ."),
+  N_("-e  --ed  Output an ed script."),
+  N_("--normal  Output a normal diff."),
+  N_("-n  --rcs  Output an RCS format diff."),
+  N_("-y  --side-by-side  Output in two columns.\n\
+  -W NUM  --width=NUM  Output at most NUM (default 130) print columns.\n\
+  --left-column  Output only the left column of common lines.\n\
+  --suppress-common-lines  Do not output common lines."),
+  N_("-D NAME  --ifdef=NAME  Output merged file to show '#ifdef NAME' diffs."),
+  N_("--GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT."),
+  N_("--line-format=LFMT  Similar, but format all input lines with LFMT."),
+  N_("--LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT."),
+  N_("  LTYPE is 'old', 'new', or 'unchanged'.  GTYPE is LTYPE or 'changed'."),
+  N_("  GFMT may contain:\n\
+    %<  lines from FILE1\n\
+    %>  lines from FILE2\n\
+    %=  lines common to FILE1 and FILE2\n\
+    %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-style spec for LETTER\n\
+      LETTERs are as follows for new group, lower case for old group:\n\
+        F  first line number\n\
+        L  last line number\n\
+        N  number of lines = L-F+1\n\
+        E  F-1\n\
+        M  L+1"),
+  N_("  LFMT may contain:\n\
+    %L  contents of line\n\
+    %l  contents of line, excluding any trailing newline\n\
+    %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for input line number"),
+  N_("  Either GFMT or LFMT may contain:\n\
+    %%  %\n\
+    %c'C'  the single character C\n\
+    %c'\\OOO'  the character with octal code OOO"),
+  "",
+  N_("-l  --paginate  Pass the output through 'pr' to paginate it."),
+  N_("-t  --expand-tabs  Expand tabs to spaces in output."),
+  N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+  N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
+  N_("--suppress-blank-empty  Suppress space or tab before empty output lines."),
+  "",
+  N_("-r  --recursive  Recursively compare any subdirectories found."),
+  N_("-N  --new-file  Treat absent files as empty."),
+  N_("--unidirectional-new-file  Treat absent first files as empty."),
+  N_("-s  --report-identical-files  Report when two files are the same."),
+  N_("-x PAT  --exclude=PAT  Exclude files that match PAT."),
+  N_("-X FILE  --exclude-from=FILE  Exclude files that match any pattern in FILE."),
+  N_("-S FILE  --starting-file=FILE  Start with FILE when comparing directories."),
+  N_("--from-file=FILE1  Compare FILE1 to all operands.  FILE1 can be a directory."),
+  N_("--to-file=FILE2  Compare all operands to FILE2.  FILE2 can be a directory."),
+  "",
+  N_("--horizon-lines=NUM  Keep NUM lines of the common prefix and suffix."),
+  N_("-d  --minimal  Try hard to find a smaller set of changes."),
+  N_("--speed-large-files  Assume large files and many scattered small changes."),
+  "",
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  "",
+  N_("FILES are 'FILE1 FILE2' or 'DIR1 DIR2' or 'DIR FILE...' or 'FILE... DIR'."),
+  N_("If --from-file or --to-file is given, there are no restrictions on FILES."),
+  N_("If a FILE is '-', read standard input."),
+  N_("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILES\n"), program_name);
+
+  for (p = option_help_msgid;  *p;  p++)
+    {
+      if (!**p)
+	putchar ('\n');
+      else
+	{
+	  char const *msg = _(*p);
+	  char const *nl;
+	  while ((nl = strchr (msg, '\n')))
+	    {
+	      int msglen = nl + 1 - msg;
+	      printf ("  %.*s", msglen, msg);
+	      msg = nl + 1;
+	    }
+
+	  printf ("  %s\n" + 2 * (*msg != ' ' && *msg != '-'), msg);
+	}
+    }
+  emit_bug_reporting_address ();
+}
+
+/* Set VAR to VALUE, reporting an OPTION error if this is a
+   conflict.  */
+static void
+specify_value (char const **var, char const *value, char const *option)
+{
+  if (*var && strcmp (*var, value) != 0)
+    {
+      error (0, 0, _("conflicting %s option value '%s'"), option, value);
+      try_help (NULL, NULL);
+    }
+  *var = value;
+}
+
+/* Set the output style to STYLE, diagnosing conflicts.  */
+static void
+specify_style (enum output_style style)
+{
+  if (output_style != style)
+    {
+      if (output_style != OUTPUT_UNSPECIFIED)
+	try_help ("conflicting output style options", NULL);
+      output_style = style;
+    }
+}
+
+/* Set the last-modified time of *ST to be the current time.  */
+
+static void
+set_mtime_to_now (struct stat *st)
+{
+#ifdef STAT_TIMESPEC
+  gettime (&STAT_TIMESPEC (st, st_mtim));
+#else
+  struct timespec t;
+  gettime (&t);
+  st->st_mtime = t.tv_sec;
+# if defined STAT_TIMESPEC_NS
+  STAT_TIMESPEC_NS (st, st_mtim) = t.tv_nsec;
+# elif defined HAVE_STRUCT_STAT_ST_SPARE1
+  st->st_spare1 = t.tv_nsec / 1000;
+# endif
+#endif
+}
+
+/* Compare two files (or dirs) with parent comparison PARENT
+   and names NAME0 and NAME1.
+   (If PARENT is null, then the first name is just NAME0, etc.)
+   This is self-contained; it opens the files and closes them.
+
+   Value is EXIT_SUCCESS if files are the same, EXIT_FAILURE if
+   different, EXIT_TROUBLE if there is a problem opening them.  */
+
+static int
+compare_files (struct comparison const *parent,
+	       char const *name0,
+	       char const *name1)
+{
+  struct comparison cmp;
+#define DIR_P(f) (S_ISDIR (cmp.file[f].stat.st_mode) != 0)
+  register int f;
+  int status = EXIT_SUCCESS;
+  bool same_files;
+  char *free0;
+  char *free1;
+
+  /* If this is directory comparison, perhaps we have a file
+     that exists only in one of the directories.
+     If so, just print a message to that effect.  */
+
+  if (! ((name0 && name1)
+	 || (unidirectional_new_file && name1)
+	 || new_file))
+    {
+      char const *name = name0 ? name0 : name1;
+      char const *dir = parent->file[!name0].name;
+
+      /* See POSIX 1003.1-2001 for this format.  */
+      message ("Only in %s: %s\n", dir, name);
+
+      /* Return EXIT_FAILURE so that diff_dirs will return
+	 EXIT_FAILURE ("some files differ").  */
+      return EXIT_FAILURE;
+    }
+
+  memset (cmp.file, 0, sizeof cmp.file);
+  cmp.parent = parent;
+
+  /* cmp.file[f].desc markers */
+#define NONEXISTENT (-1) /* nonexistent file */
+#define UNOPENED (-2) /* unopened file (e.g. directory) */
+#define ERRNO_ENCODE(errno) (-3 - (errno)) /* encoded errno value */
+
+#define ERRNO_DECODE(desc) (-3 - (desc)) /* inverse of ERRNO_ENCODE */
+
+  cmp.file[0].desc = name0 ? UNOPENED : NONEXISTENT;
+  cmp.file[1].desc = name1 ? UNOPENED : NONEXISTENT;
+
+  /* Now record the full name of each file, including nonexistent ones.  */
+
+  if (!name0)
+    name0 = name1;
+  if (!name1)
+    name1 = name0;
+
+  if (!parent)
+    {
+      free0 = NULL;
+      free1 = NULL;
+      cmp.file[0].name = name0;
+      cmp.file[1].name = name1;
+    }
+  else
+    {
+      cmp.file[0].name = free0
+	= dir_file_pathname (parent->file[0].name, name0);
+      cmp.file[1].name = free1
+	= dir_file_pathname (parent->file[1].name, name1);
+    }
+
+  /* Stat the files.  */
+
+  for (f = 0; f < 2; f++)
+    {
+      if (cmp.file[f].desc != NONEXISTENT)
+	{
+	  if (f && file_name_cmp (cmp.file[f].name, cmp.file[0].name) == 0)
+	    {
+	      cmp.file[f].desc = cmp.file[0].desc;
+	      cmp.file[f].stat = cmp.file[0].stat;
+	    }
+	  else if (STREQ (cmp.file[f].name, "-"))
+	    {
+	      cmp.file[f].desc = STDIN_FILENO;
+	      if (O_BINARY && binary && ! isatty (STDIN_FILENO))
+		xfreopen (NULL, "rb", stdin);
+	      if (fstat (STDIN_FILENO, &cmp.file[f].stat) != 0)
+		cmp.file[f].desc = ERRNO_ENCODE (errno);
+	      else
+		{
+		  if (S_ISREG (cmp.file[f].stat.st_mode))
+		    {
+		      off_t pos = lseek (STDIN_FILENO, 0, SEEK_CUR);
+		      if (pos < 0)
+			cmp.file[f].desc = ERRNO_ENCODE (errno);
+		      else
+			cmp.file[f].stat.st_size =
+			  MAX (0, cmp.file[f].stat.st_size - pos);
+		    }
+
+		  /* POSIX 1003.1-2001 requires current time for
+		     stdin.  */
+		  set_mtime_to_now (&cmp.file[f].stat);
+		}
+	    }
+	  else if (stat (cmp.file[f].name, &cmp.file[f].stat) != 0)
+	    cmp.file[f].desc = ERRNO_ENCODE (errno);
+	}
+    }
+
+  /* Mark files as nonexistent as needed for -N and -P, if they are
+     inaccessible empty regular files (the kind of files that 'patch'
+     creates to indicate nonexistent backups), or if they are
+     top-level files that do not exist but their counterparts do
+     exist.  */
+  for (f = 0; f < 2; f++)
+    if ((new_file || (f == 0 && unidirectional_new_file))
+	&& (cmp.file[f].desc == UNOPENED
+	    ? (S_ISREG (cmp.file[f].stat.st_mode)
+	       && ! (cmp.file[f].stat.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO))
+	       && cmp.file[f].stat.st_size == 0)
+	    : (cmp.file[f].desc == ERRNO_ENCODE (ENOENT)
+	       && ! parent
+	       && cmp.file[1 - f].desc == UNOPENED)))
+      cmp.file[f].desc = NONEXISTENT;
+
+  for (f = 0; f < 2; f++)
+    if (cmp.file[f].desc == NONEXISTENT)
+      {
+	memset (&cmp.file[f].stat, 0, sizeof cmp.file[f].stat);
+	cmp.file[f].stat.st_mode = cmp.file[1 - f].stat.st_mode;
+      }
+
+  for (f = 0; f < 2; f++)
+    {
+      int e = ERRNO_DECODE (cmp.file[f].desc);
+      if (0 <= e)
+	{
+	  errno = e;
+	  perror_with_name (cmp.file[f].name);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  if (status == EXIT_SUCCESS && ! parent && DIR_P (0) != DIR_P (1))
+    {
+      /* If one is a directory, and it was specified in the command line,
+	 use the file in that dir with the other file's basename.  */
+
+      int fnm_arg = DIR_P (0);
+      int dir_arg = 1 - fnm_arg;
+      char const *fnm = cmp.file[fnm_arg].name;
+      char const *dir = cmp.file[dir_arg].name;
+      char const *filename = cmp.file[dir_arg].name = free0
+	= dir_file_pathname (dir, last_component (fnm));
+
+      if (STREQ (fnm, "-"))
+	fatal ("cannot compare '-' to a directory");
+
+      if (stat (filename, &cmp.file[dir_arg].stat) != 0)
+	{
+	  perror_with_name (filename);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  if (status != EXIT_SUCCESS)
+    {
+      /* One of the files should exist but does not.  */
+    }
+  else if (cmp.file[0].desc == NONEXISTENT
+	   && cmp.file[1].desc == NONEXISTENT)
+    {
+      /* Neither file "exists", so there's nothing to compare.  */
+    }
+  else if ((same_files
+	    = (cmp.file[0].desc != NONEXISTENT
+	       && cmp.file[1].desc != NONEXISTENT
+	       && 0 < same_file (&cmp.file[0].stat, &cmp.file[1].stat)
+	       && same_file_attributes (&cmp.file[0].stat,
+					&cmp.file[1].stat)))
+	   && no_diff_means_no_output)
+    {
+      /* The two named files are actually the same physical file.
+	 We know they are identical without actually reading them.  */
+    }
+  else if (DIR_P (0) & DIR_P (1))
+    {
+      if (output_style == OUTPUT_IFDEF)
+	fatal ("-D option not supported with directories");
+
+      /* If both are directories, compare the files in them.  */
+
+      if (parent && !recursive)
+	{
+	  /* But don't compare dir contents one level down
+	     unless -r was specified.
+	     See POSIX 1003.1-2001 for this format.  */
+	  message ("Common subdirectories: %s and %s\n",
+		   cmp.file[0].name, cmp.file[1].name);
+	}
+      else
+	status = diff_dirs (&cmp, compare_files);
+    }
+  else if ((DIR_P (0) | DIR_P (1))
+	   || (parent
+	       && (! S_ISREG (cmp.file[0].stat.st_mode)
+		   || ! S_ISREG (cmp.file[1].stat.st_mode))))
+    {
+      if (cmp.file[0].desc == NONEXISTENT || cmp.file[1].desc == NONEXISTENT)
+	{
+	  /* We have a subdirectory that exists only in one directory.  */
+
+	  if ((DIR_P (0) | DIR_P (1))
+	      && recursive
+	      && (new_file
+		  || (unidirectional_new_file
+		      && cmp.file[0].desc == NONEXISTENT)))
+	    status = diff_dirs (&cmp, compare_files);
+	  else
+	    {
+	      char const *dir;
+
+	      /* PARENT must be non-NULL here.  */
+	      assert (parent);
+	      dir = parent->file[cmp.file[0].desc == NONEXISTENT].name;
+
+	      /* See POSIX 1003.1-2001 for this format.  */
+	      message ("Only in %s: %s\n", dir, name0);
+
+	      status = EXIT_FAILURE;
+	    }
+	}
+      else
+	{
+	  /* We have two files that are not to be compared.  */
+
+	  /* See POSIX 1003.1-2001 for this format.  */
+	  message5 ("File %s is a %s while file %s is a %s\n",
+		    file_label[0] ? file_label[0] : cmp.file[0].name,
+		    file_type (&cmp.file[0].stat),
+		    file_label[1] ? file_label[1] : cmp.file[1].name,
+		    file_type (&cmp.file[1].stat));
+
+	  /* This is a difference.  */
+	  status = EXIT_FAILURE;
+	}
+    }
+  else if (files_can_be_treated_as_binary
+	   && S_ISREG (cmp.file[0].stat.st_mode)
+	   && S_ISREG (cmp.file[1].stat.st_mode)
+	   && cmp.file[0].stat.st_size != cmp.file[1].stat.st_size)
+    {
+      message ("Files %s and %s differ\n",
+	       file_label[0] ? file_label[0] : cmp.file[0].name,
+	       file_label[1] ? file_label[1] : cmp.file[1].name);
+      status = EXIT_FAILURE;
+    }
+  else
+    {
+      /* Both exist and neither is a directory.  */
+
+      /* Open the files and record their descriptors.  */
+
+      int oflags = O_RDONLY | (binary ? O_BINARY : 0);
+
+      if (cmp.file[0].desc == UNOPENED)
+	if ((cmp.file[0].desc = open (cmp.file[0].name, oflags, 0)) < 0)
+	  {
+	    perror_with_name (cmp.file[0].name);
+	    status = EXIT_TROUBLE;
+	  }
+      if (cmp.file[1].desc == UNOPENED)
+	{
+	  if (same_files)
+	    cmp.file[1].desc = cmp.file[0].desc;
+	  else if ((cmp.file[1].desc = open (cmp.file[1].name, oflags, 0)) < 0)
+	    {
+	      perror_with_name (cmp.file[1].name);
+	      status = EXIT_TROUBLE;
+	    }
+	}
+
+      /* Compare the files, if no error was found.  */
+
+      if (status == EXIT_SUCCESS)
+	status = diff_2_files (&cmp);
+
+      /* Close the file descriptors.  */
+
+      if (0 <= cmp.file[0].desc && close (cmp.file[0].desc) != 0)
+	{
+	  perror_with_name (cmp.file[0].name);
+	  status = EXIT_TROUBLE;
+	}
+      if (0 <= cmp.file[1].desc && cmp.file[0].desc != cmp.file[1].desc
+	  && close (cmp.file[1].desc) != 0)
+	{
+	  perror_with_name (cmp.file[1].name);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  /* Now the comparison has been done, if no error prevented it,
+     and STATUS is the value this function will return.  */
+
+  if (status == EXIT_SUCCESS)
+    {
+      if (report_identical_files && !DIR_P (0))
+	message ("Files %s and %s are identical\n",
+		 file_label[0] ? file_label[0] : cmp.file[0].name,
+		 file_label[1] ? file_label[1] : cmp.file[1].name);
+    }
+  else
+    {
+      /* Flush stdout so that the user sees differences immediately.
+	 This can hurt performance, unfortunately.  */
+      if (fflush (stdout) != 0)
+	pfatal_with_name (_("standard output"));
+    }
+
+  free (free0);
+  free (free1);
+
+  return status;
+}
diff --git a/src/diff3.c b/src/diff3.c
index 0f11fdc..fbfb28b 100644
--- a/src/diff3.c
+++ b/src/diff3.c
@@ -316,9 +316,9 @@ main (int argc, char **argv)
   if (argc - optind != 3)
     {
       if (argc - optind < 3)
-	try_help ("missing operand after `%s'", argv[argc - 1]);
+	try_help ("missing operand after '%s'", argv[argc - 1]);
       else
-	try_help ("extra operand `%s'", argv[optind + 3]);
+	try_help ("extra operand '%s'", argv[optind + 3]);
     }
 
   file = &argv[optind];
@@ -351,7 +351,7 @@ main (int argc, char **argv)
 	 file instead.  */
       common = 3 - common;
       if (STREQ (file[0], "-") || STREQ (file[common], "-"))
-	fatal ("`-' specified for more than one input file");
+	fatal ("'-' specified for more than one input file");
     }
 
   mapping[0] = 0;
@@ -412,7 +412,7 @@ try_help (char const *reason_msgid, char const *operand)
   if (reason_msgid)
     error (0, 0, _(reason_msgid), operand);
   error (EXIT_TROUBLE, 0,
-	 _("Try `%s --help' for more information."), program_name);
+	 _("Try '%s --help' for more information."), program_name);
   abort ();
 }
 
@@ -435,7 +435,7 @@ static char const * const option_help_msgid[] = {
   "",
   N_("-m  --merge  Output merged file instead of ed script (default -A)."),
   N_("-L LABEL  --label=LABEL  Use LABEL instead of file name."),
-  N_("-i  Append `w' and `q' commands to ed scripts."),
+  N_("-i  Append 'w' and 'q' commands to ed scripts."),
   N_("-a  --text  Treat all files as text."),
   N_("--strip-trailing-cr  Strip trailing carriage return on input."),
   N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
@@ -460,7 +460,7 @@ usage (void)
     else
       putchar ('\n');
   printf ("\n%s\n%s\n",
-	  _("If a FILE is `-', read standard input."),
+	  _("If a FILE is '-', read standard input."),
 	  _("Exit status is 0 if successful, 1 if conflicts, 2 if trouble."));
   emit_bug_reporting_address ();
 }
@@ -1275,12 +1275,12 @@ read_diff (char const *filea,
   if (EXIT_TROUBLE <= status)
     error (EXIT_TROUBLE, werrno,
 	   _(status == 126
-	     ? "subsidiary program `%s' could not be invoked"
+	     ? "subsidiary program '%s' could not be invoked"
 	     : status == 127
-	     ? "subsidiary program `%s' not found"
+	     ? "subsidiary program '%s' not found"
 	     : status == INT_MAX
-	     ? "subsidiary program `%s' failed"
-	     : "subsidiary program `%s' failed (exit status %d)"),
+	     ? "subsidiary program '%s' failed"
+	     : "subsidiary program '%s' failed (exit status %d)"),
 	   diff_program, status);
 
   return diff_result + total;
diff --git a/src/diff3.c.orig b/src/diff3.c.orig
new file mode 100644
index 0000000..fbfb28b
--- /dev/null
+++ b/src/diff3.c.orig
@@ -0,0 +1,1747 @@
+/* diff3 - compare three files line by line
+
+   Copyright (C) 1988-1989, 1992-1996, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+#include <unlocked-io.h>
+
+#include <c-stack.h>
+#include <cmpbuf.h>
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <inttostr.h>
+#include <progname.h>
+#include <sh-quote.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <xfreopen.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "diff3"
+
+#define AUTHORS \
+  proper_name ("Randy Smith")
+
+/* Internal data structures and macros for the diff3 program; includes
+   data structures for both diff3 diffs and normal diffs.  */
+
+/* Different files within a three way diff.  */
+#define	FILE0	0
+#define	FILE1	1
+#define	FILE2	2
+
+/* A three way diff is built from two two-way diffs; the file which
+   the two two-way diffs share is:  */
+#define	FILEC	FILE2
+
+/* Different files within a two way diff.
+   FC is the common file, FO the other file.  */
+#define FO 0
+#define FC 1
+
+/* The ranges are indexed by */
+#define	RANGE_START	0
+#define	RANGE_END	1
+
+enum diff_type {
+  ERROR,			/* Should not be used */
+  ADD,				/* Two way diff add */
+  CHANGE,			/* Two way diff change */
+  DELETE,			/* Two way diff delete */
+  DIFF_ALL,			/* All three are different */
+  DIFF_1ST,			/* Only the first is different */
+  DIFF_2ND,			/* Only the second */
+  DIFF_3RD			/* Only the third */
+};
+
+/* Two way diff */
+struct diff_block {
+  lin ranges[2][2];		/* Ranges are inclusive */
+  char **lines[2];		/* The actual lines (may contain nulls) */
+  size_t *lengths[2];		/* Line lengths (including newlines, if any) */
+  struct diff_block *next;
+};
+
+/* Three way diff */
+
+struct diff3_block {
+  enum diff_type correspond;	/* Type of diff */
+  lin ranges[3][2];		/* Ranges are inclusive */
+  char **lines[3];		/* The actual lines (may contain nulls) */
+  size_t *lengths[3];		/* Line lengths (including newlines, if any) */
+  struct diff3_block *next;
+};
+
+/* Access the ranges on a diff block.  */
+#define	D_LOWLINE(diff, filenum)	\
+  ((diff)->ranges[filenum][RANGE_START])
+#define	D_HIGHLINE(diff, filenum)	\
+  ((diff)->ranges[filenum][RANGE_END])
+#define	D_NUMLINES(diff, filenum)	\
+  (D_HIGHLINE (diff, filenum) - D_LOWLINE (diff, filenum) + 1)
+
+/* Access the line numbers in a file in a diff by relative line
+   numbers (i.e. line number within the diff itself).  Note that these
+   are lvalues and can be used for assignment.  */
+#define	D_RELNUM(diff, filenum, linenum)	\
+  ((diff)->lines[filenum][linenum])
+#define	D_RELLEN(diff, filenum, linenum)	\
+  ((diff)->lengths[filenum][linenum])
+
+/* And get at them directly, when that should be necessary.  */
+#define	D_LINEARRAY(diff, filenum)	\
+  ((diff)->lines[filenum])
+#define	D_LENARRAY(diff, filenum)	\
+  ((diff)->lengths[filenum])
+
+/* Next block.  */
+#define	D_NEXT(diff)	((diff)->next)
+
+/* Access the type of a diff3 block.  */
+#define	D3_TYPE(diff)	((diff)->correspond)
+
+/* Line mappings based on diffs.  The first maps off the top of the
+   diff, the second off of the bottom.  */
+#define	D_HIGH_MAPLINE(diff, fromfile, tofile, linenum)	\
+  ((linenum)						\
+   - D_HIGHLINE ((diff), (fromfile))			\
+   + D_HIGHLINE ((diff), (tofile)))
+
+#define	D_LOW_MAPLINE(diff, fromfile, tofile, linenum)	\
+  ((linenum)						\
+   - D_LOWLINE ((diff), (fromfile))			\
+   + D_LOWLINE ((diff), (tofile)))
+
+/* Options variables for flags set on command line.  */
+
+/* If nonzero, treat all files as text files, never as binary.  */
+static bool text;
+
+/* Remove trailing carriage returns from input.  */
+static bool strip_trailing_cr;
+
+/* If nonzero, write out an ed script instead of the standard diff3 format.  */
+static bool edscript;
+
+/* If nonzero, in the case of overlapping diffs (type DIFF_ALL),
+   preserve the lines which would normally be deleted from
+   file 1 with a special flagging mechanism.  */
+static bool flagging;
+
+/* Use a tab to align output lines (-T).  */
+static bool initial_tab;
+
+/* If nonzero, do not output information for overlapping diffs.  */
+static bool simple_only;
+
+/* If nonzero, do not output information for non-overlapping diffs.  */
+static bool overlap_only;
+
+/* If nonzero, show information for DIFF_2ND diffs.  */
+static bool show_2nd;
+
+/* If nonzero, include `:wq' at the end of the script
+   to write out the file being edited.   */
+static bool finalwrite;
+
+/* If nonzero, output a merged file.  */
+static bool merge;
+
+static char *read_diff (char const *, char const *, char **);
+static char *scan_diff_line (char *, char **, size_t *, char *, char);
+static enum diff_type process_diff_control (char **, struct diff_block *);
+static bool compare_line_list (char * const[], size_t const[], char * const[], size_t const[], lin);
+static bool copy_stringlist (char * const[], size_t const[], char *[], size_t[], lin);
+static bool output_diff3_edscript (FILE *, struct diff3_block *, int const[3], int const[3], char const *, char const *, char const *);
+static bool output_diff3_merge (FILE *, FILE *, struct diff3_block *, int const[3], int const[3], char const *, char const *, char const *);
+static struct diff3_block *create_diff3_block (lin, lin, lin, lin, lin, lin);
+static struct diff3_block *make_3way_diff (struct diff_block *, struct diff_block *);
+static struct diff3_block *reverse_diff3_blocklist (struct diff3_block *);
+static struct diff3_block *using_to_diff3_block (struct diff_block *[2], struct diff_block *[2], int, int, struct diff3_block const *);
+static struct diff_block *process_diff (char const *, char const *, struct diff_block **);
+static void check_stdout (void);
+static void fatal (char const *) __attribute__((noreturn));
+static void output_diff3 (FILE *, struct diff3_block *, int const[3], int const[3]);
+static void perror_with_exit (char const *) __attribute__((noreturn));
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void usage (void);
+
+static char const *diff_program = DEFAULT_DIFF_PROGRAM;
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  DIFF_PROGRAM_OPTION = CHAR_MAX + 1,
+  HELP_OPTION,
+  STRIP_TRAILING_CR_OPTION
+};
+
+static struct option const longopts[] =
+{
+  {"diff-program", 1, 0, DIFF_PROGRAM_OPTION},
+  {"easy-only", 0, 0, '3'},
+  {"ed", 0, 0, 'e'},
+  {"help", 0, 0, HELP_OPTION},
+  {"initial-tab", 0, 0, 'T'},
+  {"label", 1, 0, 'L'},
+  {"merge", 0, 0, 'm'},
+  {"overlap-only", 0, 0, 'x'},
+  {"show-all", 0, 0, 'A'},
+  {"show-overlap", 0, 0, 'E'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"text", 0, 0, 'a'},
+  {"version", 0, 0, 'v'},
+  {0, 0, 0, 0}
+};
+
+int
+main (int argc, char **argv)
+{
+  int c, i;
+  int common;
+  int mapping[3];
+  int rev_mapping[3];
+  int incompat = 0;
+  bool conflicts_found;
+  struct diff_block *thread0, *thread1, *last_block;
+  struct diff3_block *diff3;
+  int tag_count = 0;
+  char *tag_strings[3];
+  char *commonname;
+  char **file;
+  struct stat statb;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+
+  while ((c = getopt_long (argc, argv, "aeimvx3AEL:TX", longopts, 0)) != -1)
+    {
+      switch (c)
+	{
+	case 'a':
+	  text = true;
+	  break;
+	case 'A':
+	  show_2nd = true;
+	  flagging = true;
+	  incompat++;
+	  break;
+	case 'x':
+	  overlap_only = true;
+	  incompat++;
+	  break;
+	case '3':
+	  simple_only = true;
+	  incompat++;
+	  break;
+	case 'i':
+	  finalwrite = true;
+	  break;
+	case 'm':
+	  merge = true;
+	  break;
+	case 'X':
+	  overlap_only = true;
+	  /* Fall through.  */
+	case 'E':
+	  flagging = true;
+	  /* Fall through.  */
+	case 'e':
+	  incompat++;
+	  break;
+	case 'T':
+	  initial_tab = true;
+	  break;
+	case STRIP_TRAILING_CR_OPTION:
+	  strip_trailing_cr = true;
+	  break;
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+	case DIFF_PROGRAM_OPTION:
+	  diff_program = optarg;
+	  break;
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+	case 'L':
+	  /* Handle up to three -L options.  */
+	  if (tag_count < 3)
+	    {
+	      tag_strings[tag_count++] = optarg;
+	      break;
+	    }
+	  try_help ("too many file label options", 0);
+	default:
+	  try_help (0, 0);
+	}
+    }
+
+  edscript = incompat & ~merge;  /* -AeExX3 without -m implies ed script.  */
+  show_2nd |= ~incompat & merge;  /* -m without -AeExX3 implies -A.  */
+  flagging |= ~incompat & merge;
+
+  if (incompat > 1  /* Ensure at most one of -AeExX3.  */
+      || finalwrite & merge /* -i -m would rewrite input file.  */
+      || (tag_count && ! flagging)) /* -L requires one of -AEX.  */
+    try_help ("incompatible options", 0);
+
+  if (argc - optind != 3)
+    {
+      if (argc - optind < 3)
+	try_help ("missing operand after '%s'", argv[argc - 1]);
+      else
+	try_help ("extra operand '%s'", argv[optind + 3]);
+    }
+
+  file = &argv[optind];
+
+  for (i = tag_count; i < 3; i++)
+    tag_strings[i] = file[i];
+
+  /* Always compare file1 to file2, even if file2 is "-".
+     This is needed for -mAeExX3.  Using the file0 as
+     the common file would produce wrong results, because if the
+     file0-file1 diffs didn't line up with the file0-file2 diffs
+     (which is entirely possible since we don't use diff's -n option),
+     diff3 might report phantom changes from file1 to file2.
+
+     Also, try to compare file0 to file1, because this is where
+     changes are expected to come from.  Diffing between these pairs
+     of files is more likely to avoid phantom changes from file0 to file1.
+
+     Historically, the default common file was file2, so some older
+     applications (e.g. Emacs ediff) used file2 as the ancestor.  So,
+     for compatibility, if this is a 3-way diff (not a merge or
+     edscript), prefer file2 as the common file.  */
+
+  common = 2 - (edscript | merge);
+
+  if (STREQ (file[common], "-"))
+    {
+      /* Sigh.  We've got standard input as the common file.  We can't
+	 call diff twice on stdin.  Use the other arg as the common
+	 file instead.  */
+      common = 3 - common;
+      if (STREQ (file[0], "-") || STREQ (file[common], "-"))
+	fatal ("'-' specified for more than one input file");
+    }
+
+  mapping[0] = 0;
+  mapping[1] = 3 - common;
+  mapping[2] = common;
+
+  for (i = 0; i < 3; i++)
+    rev_mapping[mapping[i]] = i;
+
+  for (i = 0; i < 3; i++)
+    if (strcmp (file[i], "-") != 0)
+      {
+	if (stat (file[i], &statb) < 0)
+	  perror_with_exit (file[i]);
+	else if (S_ISDIR (statb.st_mode))
+	  error (EXIT_TROUBLE, EISDIR, "%s", file[i]);
+      }
+
+#ifdef SIGCHLD
+  /* System V fork+wait does not work if SIGCHLD is ignored.  */
+  signal (SIGCHLD, SIG_DFL);
+#endif
+
+  /* Invoke diff twice on two pairs of input files, combine the two
+     diffs, and output them.  */
+
+  commonname = file[rev_mapping[FILEC]];
+  thread1 = process_diff (file[rev_mapping[FILE1]], commonname, &last_block);
+  thread0 = process_diff (file[rev_mapping[FILE0]], commonname, &last_block);
+  diff3 = make_3way_diff (thread0, thread1);
+  if (edscript)
+    conflicts_found
+      = output_diff3_edscript (stdout, diff3, mapping, rev_mapping,
+			       tag_strings[0], tag_strings[1], tag_strings[2]);
+  else if (merge)
+    {
+      xfreopen (file[rev_mapping[FILE0]], "r", stdin);
+      conflicts_found
+	= output_diff3_merge (stdin, stdout, diff3, mapping, rev_mapping,
+			      tag_strings[0], tag_strings[1], tag_strings[2]);
+      if (ferror (stdin))
+	fatal ("read failed");
+    }
+  else
+    {
+      output_diff3 (stdout, diff3, mapping, rev_mapping);
+      conflicts_found = false;
+    }
+
+  check_stdout ();
+  exit (conflicts_found);
+  return conflicts_found;
+}
+
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0,
+	 _("Try '%s --help' for more information."), program_name);
+  abort ();
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    perror_with_exit (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-e  --ed  Output unmerged changes from OLDFILE to YOURFILE into MYFILE."),
+  N_("-E  --show-overlap  Output unmerged changes, bracketing conflicts."),
+  N_("-A  --show-all  Output all changes, bracketing conflicts."),
+  N_("-x  --overlap-only  Output overlapping changes."),
+  N_("-X  Output overlapping changes, bracketing them."),
+  N_("-3  --easy-only  Output unmerged nonoverlapping changes."),
+  "",
+  N_("-m  --merge  Output merged file instead of ed script (default -A)."),
+  N_("-L LABEL  --label=LABEL  Use LABEL instead of file name."),
+  N_("-i  Append 'w' and 'q' commands to ed scripts."),
+  N_("-a  --text  Treat all files as text."),
+  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+  N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+  N_("--diff-program=PROGRAM  Use PROGRAM to compare files."),
+  "",
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... MYFILE OLDFILE YOURFILE\n"),
+	  program_name);
+  printf ("%s\n\n", _("Compare three files line by line."));
+  for (p = option_help_msgid;  *p;  p++)
+    if (**p)
+      printf ("  %s\n", _(*p));
+    else
+      putchar ('\n');
+  printf ("\n%s\n%s\n",
+	  _("If a FILE is '-', read standard input."),
+	  _("Exit status is 0 if successful, 1 if conflicts, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+/* Combine the two diffs together into one.
+   Here is the algorithm:
+
+     File2 is shared in common between the two diffs.
+     Diff02 is the diff between 0 and 2.
+     Diff12 is the diff between 1 and 2.
+
+	1) Find the range for the first block in File2.
+	    a) Take the lowest of the two ranges (in File2) in the two
+	       current blocks (one from each diff) as being the low
+	       water mark.  Assign the upper end of this block as
+	       being the high water mark and move the current block up
+	       one.  Mark the block just moved over as to be used.
+	    b) Check the next block in the diff that the high water
+	       mark is *not* from.
+
+	       *If* the high water mark is above
+	       the low end of the range in that block,
+
+		   mark that block as to be used and move the current
+		   block up.  Set the high water mark to the max of
+		   the high end of this block and the current.  Repeat b.
+
+	 2) Find the corresponding ranges in File0 (from the blocks
+	    in diff02; line per line outside of diffs) and in File1.
+	    Create a diff3_block, reserving space as indicated by the ranges.
+
+	 3) Copy all of the pointers for file2 in.  At least for now,
+	    do memcmp's between corresponding strings in the two diffs.
+
+	 4) Copy all of the pointers for file0 and 1 in.  Get what is
+	    needed from file2 (when there isn't a diff block, it's
+	    identical to file2 within the range between diff blocks).
+
+	 5) If the diff blocks used came from only one of the two
+	    strings of diffs, then that file (i.e. the one other than
+	    the common file in that diff) is the odd person out.  If
+	    diff blocks are used from both sets, check to see if files
+	    0 and 1 match:
+
+		Same number of lines?  If so, do a set of memcmp's (if
+	    a memcmp matches; copy the pointer over; it'll be easier
+	    later during comparisons).  If they match, 0 & 1 are the
+	    same.  If not, all three different.
+
+     Then do it again, until the blocks are exhausted.  */
+
+
+/* Make a three way diff (chain of diff3_block's) from two two way
+   diffs (chains of diff_block's).  Assume that each of the two diffs
+   passed are onto the same file (i.e. that each of the diffs were
+   made "to" the same file).  Return a three way diff pointer with
+   numbering FILE0 = the other file in diff02, FILE1 = the other file
+   in diff12, and FILEC = the common file.  */
+
+static struct diff3_block *
+make_3way_diff (struct diff_block *thread0, struct diff_block *thread1)
+{
+  /* Work on the two diffs passed to it as threads.  Thread number 0
+     is diff02, thread number 1 is diff12.  USING is the base of the
+     list of blocks to be used to construct each block of the three
+     way diff; if no blocks from a particular thread are to be used,
+     that element of USING is 0.  LAST_USING contains the last
+     elements on each of the using lists.
+
+     HIGH_WATER_MARK is the highest line number in the common file
+     described in any of the diffs in either of the USING lists.
+     HIGH_WATER_THREAD names the thread.  Similarly BASE_WATER_MARK
+     and BASE_WATER_THREAD describe the lowest line number in the
+     common file described in any of the diffs in either of the USING
+     lists.  HIGH_WATER_DIFF is the diff from which the
+     HIGH_WATER_MARK was taken.
+
+     HIGH_WATER_DIFF should always be equal to
+     LAST_USING[HIGH_WATER_THREAD].  OTHER_DIFF is the next diff to
+     check for higher water, and should always be equal to
+     CURRENT[HIGH_WATER_THREAD ^ 1].  OTHER_THREAD is the thread in
+     which the OTHER_DIFF is, and hence should always be equal to
+     HIGH_WATER_THREAD ^ 1.
+
+     LAST_DIFF is the last diff block produced by this routine, for
+     line correspondence purposes between that diff and the one
+     currently being worked on.  It is ZERO_DIFF before any blocks
+     have been created.  */
+
+  struct diff_block *using[2];
+  struct diff_block *last_using[2];
+  struct diff_block *current[2];
+
+  lin high_water_mark;
+
+  int high_water_thread;
+  int base_water_thread;
+  int other_thread;
+
+  struct diff_block *high_water_diff;
+  struct diff_block *other_diff;
+
+  struct diff3_block *result;
+  struct diff3_block *tmpblock;
+  struct diff3_block **result_end;
+
+  struct diff3_block const *last_diff3;
+
+  static struct diff3_block const zero_diff3;
+
+  /* Initialization */
+  result = 0;
+  result_end = &result;
+  current[0] = thread0; current[1] = thread1;
+  last_diff3 = &zero_diff3;
+
+  /* Sniff up the threads until we reach the end */
+
+  while (current[0] || current[1])
+    {
+      using[0] = using[1] = last_using[0] = last_using[1] = 0;
+
+      /* Setup low and high water threads, diffs, and marks.  */
+      if (!current[0])
+	base_water_thread = 1;
+      else if (!current[1])
+	base_water_thread = 0;
+      else
+	base_water_thread =
+	  (D_LOWLINE (current[0], FC) > D_LOWLINE (current[1], FC));
+
+      high_water_thread = base_water_thread;
+
+      high_water_diff = current[high_water_thread];
+
+      high_water_mark = D_HIGHLINE (high_water_diff, FC);
+
+      /* Make the diff you just got info from into the using class */
+      using[high_water_thread]
+	= last_using[high_water_thread]
+	= high_water_diff;
+      current[high_water_thread] = high_water_diff->next;
+      last_using[high_water_thread]->next = 0;
+
+      /* And mark the other diff */
+      other_thread = high_water_thread ^ 0x1;
+      other_diff = current[other_thread];
+
+      /* Shuffle up the ladder, checking the other diff to see if it
+	 needs to be incorporated.  */
+      while (other_diff
+	     && D_LOWLINE (other_diff, FC) <= high_water_mark + 1)
+	{
+
+	  /* Incorporate this diff into the using list.  Note that
+	     this doesn't take it off the current list */
+	  if (using[other_thread])
+	    last_using[other_thread]->next = other_diff;
+	  else
+	    using[other_thread] = other_diff;
+	  last_using[other_thread] = other_diff;
+
+	  /* Take it off the current list.  Note that this following
+	     code assumes that other_diff enters it equal to
+	     current[high_water_thread ^ 0x1] */
+	  current[other_thread] = current[other_thread]->next;
+	  other_diff->next = 0;
+
+	  /* Set the high_water stuff
+	     If this comparison is equal, then this is the last pass
+	     through this loop; since diff blocks within a given
+	     thread cannot overlap, the high_water_mark will be
+	     *below* the range_start of either of the next diffs.  */
+
+	  if (high_water_mark < D_HIGHLINE (other_diff, FC))
+	    {
+	      high_water_thread ^= 1;
+	      high_water_mark = D_HIGHLINE (other_diff, FC);
+	    }
+
+	  /* Set the other diff */
+	  other_thread = high_water_thread ^ 0x1;
+	  other_diff = current[other_thread];
+	}
+
+      /* The using lists contain a list of all of the blocks to be
+	 included in this diff3_block.  Create it.  */
+
+      tmpblock = using_to_diff3_block (using, last_using,
+				       base_water_thread, high_water_thread,
+				       last_diff3);
+
+      if (!tmpblock)
+	fatal ("internal error: screwup in format of diff blocks");
+
+      /* Put it on the list.  */
+      *result_end = tmpblock;
+      result_end = &tmpblock->next;
+
+      /* Set up corresponding lines correctly.  */
+      last_diff3 = tmpblock;
+    }
+  return result;
+}
+
+/* Take two lists of blocks (from two separate diff threads) and put
+   them together into one diff3 block.  Return a pointer to this diff3
+   block or 0 for failure.
+
+   All arguments besides using are for the convenience of the routine;
+   they could be derived from the using array.  LAST_USING is a pair
+   of pointers to the last blocks in the using structure.  LOW_THREAD
+   and HIGH_THREAD tell which threads contain the lowest and highest
+   line numbers for File0.  LAST_DIFF3 contains the last diff produced
+   in the calling routine.  This is used for lines mappings that
+   would still be identical to the state that diff ended in.
+
+   A distinction should be made in this routine between the two diffs
+   that are part of a normal two diff block, and the three diffs that
+   are part of a diff3_block.  */
+
+static struct diff3_block *
+using_to_diff3_block (struct diff_block *using[2],
+		      struct diff_block *last_using[2],
+		      int low_thread, int high_thread,
+		      struct diff3_block const *last_diff3)
+{
+  lin low[2], high[2];
+  struct diff3_block *result;
+  struct diff_block *ptr;
+  int d;
+  lin i;
+
+  /* Find the range in the common file.  */
+  lin lowc = D_LOWLINE (using[low_thread], FC);
+  lin highc = D_HIGHLINE (last_using[high_thread], FC);
+
+  /* Find the ranges in the other files.
+     If using[d] is null, that means that the file to which that diff
+     refers is equivalent to the common file over this range.  */
+
+  for (d = 0; d < 2; d++)
+    if (using[d])
+      {
+	low[d] = D_LOW_MAPLINE (using[d], FC, FO, lowc);
+	high[d] = D_HIGH_MAPLINE (last_using[d], FC, FO, highc);
+      }
+    else
+      {
+	low[d] = D_HIGH_MAPLINE (last_diff3, FILEC, FILE0 + d, lowc);
+	high[d] = D_HIGH_MAPLINE (last_diff3, FILEC, FILE0 + d, highc);
+      }
+
+  /* Create a block with the appropriate sizes */
+  result = create_diff3_block (low[0], high[0], low[1], high[1], lowc, highc);
+
+  /* Copy information for the common file.
+     Return with a zero if any of the compares failed.  */
+
+  for (d = 0; d < 2; d++)
+    for (ptr = using[d]; ptr; ptr = D_NEXT (ptr))
+      {
+	lin result_offset = D_LOWLINE (ptr, FC) - lowc;
+
+	if (!copy_stringlist (D_LINEARRAY (ptr, FC),
+			      D_LENARRAY (ptr, FC),
+			      D_LINEARRAY (result, FILEC) + result_offset,
+			      D_LENARRAY (result, FILEC) + result_offset,
+			      D_NUMLINES (ptr, FC)))
+	  return 0;
+      }
+
+  /* Copy information for file d.  First deal with anything that might be
+     before the first diff.  */
+
+  for (d = 0; d < 2; d++)
+    {
+      struct diff_block *u = using[d];
+      lin lo = low[d], hi = high[d];
+
+      for (i = 0;
+	   i + lo < (u ? D_LOWLINE (u, FO) : hi + 1);
+	   i++)
+	{
+	  D_RELNUM (result, FILE0 + d, i) = D_RELNUM (result, FILEC, i);
+	  D_RELLEN (result, FILE0 + d, i) = D_RELLEN (result, FILEC, i);
+	}
+
+      for (ptr = u; ptr; ptr = D_NEXT (ptr))
+	{
+	  lin result_offset = D_LOWLINE (ptr, FO) - lo;
+	  lin linec;
+
+	  if (!copy_stringlist (D_LINEARRAY (ptr, FO),
+				D_LENARRAY (ptr, FO),
+				D_LINEARRAY (result, FILE0 + d) + result_offset,
+				D_LENARRAY (result, FILE0 + d) + result_offset,
+				D_NUMLINES (ptr, FO)))
+	    return 0;
+
+	  /* Catch the lines between here and the next diff */
+	  linec = D_HIGHLINE (ptr, FC) + 1 - lowc;
+	  for (i = D_HIGHLINE (ptr, FO) + 1 - lo;
+	       i < (D_NEXT (ptr) ? D_LOWLINE (D_NEXT (ptr), FO) : hi + 1) - lo;
+	       i++)
+	    {
+	      D_RELNUM (result, FILE0 + d, i) = D_RELNUM (result, FILEC, linec);
+	      D_RELLEN (result, FILE0 + d, i) = D_RELLEN (result, FILEC, linec);
+	      linec++;
+	    }
+	}
+    }
+
+  /* Set correspond */
+  if (!using[0])
+    D3_TYPE (result) = DIFF_2ND;
+  else if (!using[1])
+    D3_TYPE (result) = DIFF_1ST;
+  else
+    {
+      lin nl0 = D_NUMLINES (result, FILE0);
+      lin nl1 = D_NUMLINES (result, FILE1);
+
+      if (nl0 != nl1
+	  || !compare_line_list (D_LINEARRAY (result, FILE0),
+				 D_LENARRAY (result, FILE0),
+				 D_LINEARRAY (result, FILE1),
+				 D_LENARRAY (result, FILE1),
+				 nl0))
+	D3_TYPE (result) = DIFF_ALL;
+      else
+	D3_TYPE (result) = DIFF_3RD;
+    }
+
+  return result;
+}
+
+/* Copy pointers from a list of strings to a different list of
+   strings.  If a spot in the second list is already filled, make sure
+   that it is filled with the same string; if not, return false, the copy
+   incomplete.  Upon successful completion of the copy, return true.  */
+
+static bool
+copy_stringlist (char * const fromptrs[], size_t const fromlengths[],
+		 char *toptrs[], size_t tolengths[],
+		 lin copynum)
+{
+  register char * const *f = fromptrs;
+  register char **t = toptrs;
+  register size_t const *fl = fromlengths;
+  register size_t *tl = tolengths;
+
+  while (copynum--)
+    {
+      if (*t)
+	{
+	  if (*fl != *tl || memcmp (*f, *t, *fl) != 0)
+	    return false;
+	}
+      else
+	{
+	  *t = *f;
+	  *tl = *fl;
+	}
+
+      t++; f++; tl++; fl++;
+    }
+
+  return true;
+}
+
+/* Create a diff3_block, with ranges as specified in the arguments.
+   Allocate the arrays for the various pointers (and zero them) based
+   on the arguments passed.  Return the block as a result.  */
+
+static struct diff3_block *
+create_diff3_block (lin low0, lin high0,
+		    lin low1, lin high1,
+		    lin low2, lin high2)
+{
+  struct diff3_block *result = xmalloc (sizeof *result);
+  lin numlines;
+
+  D3_TYPE (result) = ERROR;
+  D_NEXT (result) = 0;
+
+  /* Assign ranges */
+  D_LOWLINE (result, FILE0) = low0;
+  D_HIGHLINE (result, FILE0) = high0;
+  D_LOWLINE (result, FILE1) = low1;
+  D_HIGHLINE (result, FILE1) = high1;
+  D_LOWLINE (result, FILE2) = low2;
+  D_HIGHLINE (result, FILE2) = high2;
+
+  /* Allocate and zero space */
+  numlines = D_NUMLINES (result, FILE0);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE0) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE0) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE0) = 0;
+      D_LENARRAY (result, FILE0) = 0;
+    }
+
+  numlines = D_NUMLINES (result, FILE1);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE1) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE1) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE1) = 0;
+      D_LENARRAY (result, FILE1) = 0;
+    }
+
+  numlines = D_NUMLINES (result, FILE2);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE2) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE2) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE2) = 0;
+      D_LENARRAY (result, FILE2) = 0;
+    }
+
+  /* Return */
+  return result;
+}
+
+/* Compare two lists of lines of text.
+   Return 1 if they are equivalent, 0 if not.  */
+
+static bool
+compare_line_list (char * const list1[], size_t const lengths1[],
+		   char * const list2[], size_t const lengths2[],
+		   lin nl)
+{
+  char * const *l1 = list1;
+  char * const *l2 = list2;
+  size_t const *lgths1 = lengths1;
+  size_t const *lgths2 = lengths2;
+
+  while (nl--)
+    if (!*l1 || !*l2 || *lgths1 != *lgths2++
+	|| memcmp (*l1++, *l2++, *lgths1++) != 0)
+      return false;
+  return true;
+}
+
+/* Input and parse two way diffs.  */
+
+static struct diff_block *
+process_diff (char const *filea,
+	      char const *fileb,
+	      struct diff_block **last_block)
+{
+  char *diff_contents;
+  char *diff_limit;
+  char *scan_diff;
+  enum diff_type dt;
+  lin i;
+  struct diff_block *block_list;
+  struct diff_block **block_list_end = &block_list;
+  struct diff_block *bptr IF_LINT (= NULL);
+  size_t too_many_lines = (PTRDIFF_MAX
+			   / MIN (sizeof *bptr->lines[1],
+				  sizeof *bptr->lengths[1]));
+
+  diff_limit = read_diff (filea, fileb, &diff_contents);
+  scan_diff = diff_contents;
+
+  while (scan_diff < diff_limit)
+    {
+      bptr = xmalloc (sizeof *bptr);
+      bptr->lines[0] = bptr->lines[1] = 0;
+      bptr->lengths[0] = bptr->lengths[1] = 0;
+
+      dt = process_diff_control (&scan_diff, bptr);
+      if (dt == ERROR || *scan_diff != '\n')
+	{
+	  fprintf (stderr, _("%s: diff failed: "), program_name);
+	  do
+	    {
+	      putc (*scan_diff, stderr);
+	    }
+	  while (*scan_diff++ != '\n');
+	  exit (EXIT_TROUBLE);
+	}
+      scan_diff++;
+
+      /* Force appropriate ranges to be null, if necessary */
+      switch (dt)
+	{
+	case ADD:
+	  bptr->ranges[0][0]++;
+	  break;
+	case DELETE:
+	  bptr->ranges[1][0]++;
+	  break;
+	case CHANGE:
+	  break;
+	default:
+	  fatal ("internal error: invalid diff type in process_diff");
+	  break;
+	}
+
+      /* Allocate space for the pointers for the lines from filea, and
+	 parcel them out among these pointers */
+      if (dt != ADD)
+	{
+	  lin numlines = D_NUMLINES (bptr, 0);
+	  if (too_many_lines <= numlines)
+	    xalloc_die ();
+	  bptr->lines[0] = xmalloc (numlines * sizeof *bptr->lines[0]);
+	  bptr->lengths[0] = xmalloc (numlines * sizeof *bptr->lengths[0]);
+	  for (i = 0; i < numlines; i++)
+	    scan_diff = scan_diff_line (scan_diff,
+					&(bptr->lines[0][i]),
+					&(bptr->lengths[0][i]),
+					diff_limit,
+					'<');
+	}
+
+      /* Get past the separator for changes */
+      if (dt == CHANGE)
+	{
+	  if (strncmp (scan_diff, "---\n", 4))
+	    fatal ("invalid diff format; invalid change separator");
+	  scan_diff += 4;
+	}
+
+      /* Allocate space for the pointers for the lines from fileb, and
+	 parcel them out among these pointers */
+      if (dt != DELETE)
+	{
+	  lin numlines = D_NUMLINES (bptr, 1);
+	  if (too_many_lines <= numlines)
+	    xalloc_die ();
+	  bptr->lines[1] = xmalloc (numlines * sizeof *bptr->lines[1]);
+	  bptr->lengths[1] = xmalloc (numlines * sizeof *bptr->lengths[1]);
+	  for (i = 0; i < numlines; i++)
+	    scan_diff = scan_diff_line (scan_diff,
+					&(bptr->lines[1][i]),
+					&(bptr->lengths[1][i]),
+					diff_limit,
+					'>');
+	}
+
+      /* Place this block on the blocklist.  */
+      *block_list_end = bptr;
+      block_list_end = &bptr->next;
+    }
+
+  *block_list_end = NULL;
+  *last_block = bptr;
+  return block_list;
+}
+
+/* Skip tabs and spaces, and return the first character after them.  */
+
+static char *
+skipwhite (char *s)
+{
+  while (*s == ' ' || *s == '\t')
+    s++;
+  return s;
+}
+
+/* Read a nonnegative line number from S, returning the address of the
+   first character after the line number, and storing the number into
+   *PNUM.  Return 0 if S does not point to a valid line number.  */
+
+static char *
+readnum (char *s, lin *pnum)
+{
+  unsigned char c = *s;
+  lin num = 0;
+
+  if (! ISDIGIT (c))
+    return 0;
+
+  do
+    {
+      num = c - '0' + num * 10;
+      c = *++s;
+    }
+  while (ISDIGIT (c));
+
+  *pnum = num;
+  return s;
+}
+
+/* Parse a normal format diff control string.  Return the type of the
+   diff (ERROR if the format is bad).  All of the other important
+   information is filled into to the structure pointed to by db, and
+   the string pointer (whose location is passed to this routine) is
+   updated to point beyond the end of the string parsed.  Note that
+   only the ranges in the diff_block will be set by this routine.
+
+   If some specific pair of numbers has been reduced to a single
+   number, then both corresponding numbers in the diff block are set
+   to that number.  In general these numbers are interpreted as ranges
+   inclusive, unless being used by the ADD or DELETE commands.  It is
+   assumed that these will be special cased in a superior routine.   */
+
+static enum diff_type
+process_diff_control (char **string, struct diff_block *db)
+{
+  char *s = *string;
+  enum diff_type type;
+
+  /* Read first set of digits */
+  s = readnum (skipwhite (s), &db->ranges[0][RANGE_START]);
+  if (! s)
+    return ERROR;
+
+  /* Was that the only digit? */
+  s = skipwhite (s);
+  if (*s == ',')
+    {
+      s = readnum (s + 1, &db->ranges[0][RANGE_END]);
+      if (! s)
+	return ERROR;
+    }
+  else
+    db->ranges[0][RANGE_END] = db->ranges[0][RANGE_START];
+
+  /* Get the letter */
+  s = skipwhite (s);
+  switch (*s)
+    {
+    case 'a':
+      type = ADD;
+      break;
+    case 'c':
+      type = CHANGE;
+      break;
+    case 'd':
+      type = DELETE;
+      break;
+    default:
+      return ERROR;			/* Bad format */
+    }
+  s++;				/* Past letter */
+
+  /* Read second set of digits */
+  s = readnum (skipwhite (s), &db->ranges[1][RANGE_START]);
+  if (! s)
+    return ERROR;
+
+  /* Was that the only digit? */
+  s = skipwhite (s);
+  if (*s == ',')
+    {
+      s = readnum (s + 1, &db->ranges[1][RANGE_END]);
+      if (! s)
+	return ERROR;
+      s = skipwhite (s);		/* To move to end */
+    }
+  else
+    db->ranges[1][RANGE_END] = db->ranges[1][RANGE_START];
+
+  *string = s;
+  return type;
+}
+
+static char *
+read_diff (char const *filea,
+	   char const *fileb,
+	   char **output_placement)
+{
+  char *diff_result;
+  size_t current_chunk_size, total;
+  int fd, wstatus, status;
+  int werrno = 0;
+  struct stat pipestat;
+
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+
+  char const *argv[9];
+  char const **ap;
+  int fds[2];
+  pid_t pid;
+
+  ap = argv;
+  *ap++ = diff_program;
+  if (text)
+    *ap++ = "-a";
+  if (strip_trailing_cr)
+    *ap++ = "--strip-trailing-cr";
+  *ap++ = "--horizon-lines=100";
+  *ap++ = "--";
+  *ap++ = filea;
+  *ap++ = fileb;
+  *ap = 0;
+
+  if (pipe (fds) != 0)
+    perror_with_exit ("pipe");
+
+  pid = vfork ();
+  if (pid == 0)
+    {
+      /* Child */
+      close (fds[0]);
+      if (fds[1] != STDOUT_FILENO)
+	{
+	  dup2 (fds[1], STDOUT_FILENO);
+	  close (fds[1]);
+	}
+
+      /* The cast to (char **) is needed for portability to older
+	 hosts with a nonstandard prototype for execvp.  */
+      execvp (diff_program, (char **) argv);
+
+      _exit (errno == ENOENT ? 127 : 126);
+    }
+
+  if (pid == -1)
+    perror_with_exit ("fork");
+
+  close (fds[1]);		/* Prevent erroneous lack of EOF */
+  fd = fds[0];
+
+#else
+
+  FILE *fpipe;
+  char const args[] = " --horizon-lines=100 -- ";
+  char *command = xmalloc (shell_quote_length (diff_program)
+			   + sizeof "-a"
+			   + sizeof "--strip-trailing-cr"
+			   + sizeof args - 1
+			   + shell_quote_length (filea) + 1
+			   + shell_quote_length (fileb) + 1);
+  char *p = command;
+  p = shell_quote_copy (p, diff_program);
+  if (text)
+    {
+      strcpy (p, " -a");
+      p += 3;
+    }
+  if (strip_trailing_cr)
+    {
+      strcpy (p, " --strip-trailing-cr");
+      p += 20;
+    }
+  strcpy (p, args);
+  p += sizeof args - 1;
+  p = shell_quote_copy (p, filea);
+  *p++ = ' ';
+  p = shell_quote_copy (p, fileb);
+  *p = 0;
+  errno = 0;
+  fpipe = popen (command, "r");
+  if (!fpipe)
+    perror_with_exit (command);
+  free (command);
+  fd = fileno (fpipe);
+
+#endif
+
+  if (fstat (fd, &pipestat) != 0)
+    perror_with_exit ("fstat");
+  current_chunk_size = MAX (1, STAT_BLOCKSIZE (pipestat));
+  diff_result = xmalloc (current_chunk_size);
+  total = 0;
+
+  for (;;)
+    {
+      size_t bytes_to_read = current_chunk_size - total;
+      size_t bytes = block_read (fd, diff_result + total, bytes_to_read);
+      total += bytes;
+      if (bytes != bytes_to_read)
+	{
+	  if (bytes == SIZE_MAX)
+	    perror_with_exit (_("read failed"));
+	  break;
+	}
+      if (PTRDIFF_MAX / 2 <= current_chunk_size)
+	xalloc_die ();
+      current_chunk_size *= 2;
+      diff_result = xrealloc (diff_result, current_chunk_size);
+    }
+
+  if (total != 0 && diff_result[total-1] != '\n')
+    fatal ("invalid diff format; incomplete last line");
+
+  *output_placement = diff_result;
+
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+
+  wstatus = pclose (fpipe);
+  if (wstatus == -1)
+    werrno = errno;
+
+#else
+
+  if (close (fd) != 0)
+    perror_with_exit ("close");
+  if (waitpid (pid, &wstatus, 0) < 0)
+    perror_with_exit ("waitpid");
+
+#endif
+
+  status = ! werrno && WIFEXITED (wstatus) ? WEXITSTATUS (wstatus) : INT_MAX;
+
+  if (EXIT_TROUBLE <= status)
+    error (EXIT_TROUBLE, werrno,
+	   _(status == 126
+	     ? "subsidiary program '%s' could not be invoked"
+	     : status == 127
+	     ? "subsidiary program '%s' not found"
+	     : status == INT_MAX
+	     ? "subsidiary program '%s' failed"
+	     : "subsidiary program '%s' failed (exit status %d)"),
+	   diff_program, status);
+
+  return diff_result + total;
+}
+
+
+/* Scan a regular diff line (consisting of > or <, followed by a
+   space, followed by text (including nulls) up to a newline.
+
+   This next routine began life as a macro and many parameters in it
+   are used as call-by-reference values.  */
+static char *
+scan_diff_line (char *scan_ptr, char **set_start, size_t *set_length,
+		char *limit, char leadingchar)
+{
+  char *line_ptr;
+
+  if (!(scan_ptr[0] == leadingchar
+	&& scan_ptr[1] == ' '))
+    fatal ("invalid diff format; incorrect leading line chars");
+
+  *set_start = line_ptr = scan_ptr + 2;
+  while (*line_ptr++ != '\n')
+    continue;
+
+  /* Include newline if the original line ended in a newline,
+     or if an edit script is being generated.
+     Copy any missing newline message to stderr if an edit script is being
+     generated, because edit scripts cannot handle missing newlines.
+     Return the beginning of the next line.  */
+  *set_length = line_ptr - *set_start;
+  if (line_ptr < limit && *line_ptr == '\\')
+    {
+      if (edscript)
+	fprintf (stderr, "%s:", program_name);
+      else
+	--*set_length;
+      line_ptr++;
+      do
+	{
+	  if (edscript)
+	    putc (*line_ptr, stderr);
+	}
+      while (*line_ptr++ != '\n');
+    }
+
+  return line_ptr;
+}
+
+/* Output a three way diff passed as a list of diff3_block's.  The
+   argument MAPPING is indexed by external file number (in the
+   argument list) and contains the internal file number (from the diff
+   passed).  This is important because the user expects outputs in
+   terms of the argument list number, and the diff passed may have
+   been done slightly differently (if the last argument was "-", for
+   example).  REV_MAPPING is the inverse of MAPPING.  */
+
+static void
+output_diff3 (FILE *outputfile, struct diff3_block *diff,
+	      int const mapping[3], int const rev_mapping[3])
+{
+  int i;
+  int oddoneout;
+  char *cp;
+  struct diff3_block *ptr;
+  lin line;
+  size_t length;
+  int dontprint;
+  static int skew_increment[3] = { 2, 3, 1 }; /* 0==>2==>1==>3 */
+  char const *line_prefix = initial_tab ? "\t" : "  ";
+
+  for (ptr = diff; ptr; ptr = D_NEXT (ptr))
+    {
+      char x[2];
+
+      switch (ptr->correspond)
+	{
+	case DIFF_ALL:
+	  x[0] = 0;
+	  dontprint = 3;	/* Print them all */
+	  oddoneout = 3;	/* Nobody's odder than anyone else */
+	  break;
+	case DIFF_1ST:
+	case DIFF_2ND:
+	case DIFF_3RD:
+	  oddoneout = rev_mapping[ptr->correspond - DIFF_1ST];
+
+	  x[0] = oddoneout + '1';
+	  x[1] = 0;
+	  dontprint = oddoneout == 0;
+	  break;
+	default:
+	  fatal ("internal error: invalid diff type passed to output");
+	}
+      fprintf (outputfile, "====%s\n", x);
+
+      /* Go 0, 2, 1 if the first and third outputs are equivalent.  */
+      for (i = 0; i < 3;
+	   i = (oddoneout == 1 ? skew_increment[i] : i + 1))
+	{
+	  int realfile = mapping[i];
+	  lin lowt = D_LOWLINE (ptr, realfile);
+	  lin hight = D_HIGHLINE (ptr, realfile);
+	  long int llowt = lowt;
+	  long int lhight = hight;
+
+	  fprintf (outputfile, "%d:", i + 1);
+	  switch (lowt - hight)
+	    {
+	    case 1:
+	      fprintf (outputfile, "%lda\n", llowt - 1);
+	      break;
+	    case 0:
+	      fprintf (outputfile, "%ldc\n", llowt);
+	      break;
+	    default:
+	      fprintf (outputfile, "%ld,%ldc\n", llowt, lhight);
+	      break;
+	    }
+
+	  if (i == dontprint) continue;
+
+	  if (lowt <= hight)
+	    {
+	      line = 0;
+	      do
+		{
+		  fputs (line_prefix, outputfile);
+		  cp = D_RELNUM (ptr, realfile, line);
+		  length = D_RELLEN (ptr, realfile, line);
+		  fwrite (cp, sizeof (char), length, outputfile);
+		}
+	      while (++line < hight - lowt + 1);
+	      if (cp[length - 1] != '\n')
+		fprintf (outputfile, "\n\\ %s\n",
+			 _("No newline at end of file"));
+	    }
+	}
+    }
+}
+
+
+/* Output to OUTPUTFILE the lines of B taken from FILENUM.  Double any
+   initial '.'s; yield nonzero if any initial '.'s were doubled.  */
+
+static bool
+dotlines (FILE *outputfile, struct diff3_block *b, int filenum)
+{
+  lin i;
+  bool leading_dot = false;
+
+  for (i = 0;
+       i < D_NUMLINES (b, filenum);
+       i++)
+    {
+      char *line = D_RELNUM (b, filenum, i);
+      if (line[0] == '.')
+	{
+	  leading_dot = true;
+	  fputc ('.', outputfile);
+	}
+      fwrite (line, sizeof (char),
+	      D_RELLEN (b, filenum, i), outputfile);
+    }
+
+  return leading_dot;
+}
+
+/* Output to OUTPUTFILE a '.' line.  If LEADING_DOT is true, also
+   output a command that removes initial '.'s starting with line START
+   and continuing for NUM lines.  (START is long int, not lin, for
+   convenience with printf %ld formats.)  */
+
+static void
+undotlines (FILE *outputfile, bool leading_dot, long int start, lin num)
+{
+  fputs (".\n", outputfile);
+  if (leading_dot)
+    {
+      if (num == 1)
+	fprintf (outputfile, "%lds/^\\.//\n", start);
+      else
+	fprintf (outputfile, "%ld,%lds/^\\.//\n", start, start + num - 1);
+    }
+}
+
+/* Output a diff3 set of blocks as an ed script.  This script applies
+   the changes between file's 2 & 3 to file 1.  Take the precise
+   format of the ed script to be output from global variables set
+   during options processing.  Reverse the order of
+   the set of diff3 blocks in DIFF; this gets
+   around the problems involved with changing line numbers in an ed
+   script.
+
+   As in `output_diff3', the variable MAPPING maps from file number
+   according to the argument list to file number according to the diff
+   passed.  All files listed below are in terms of the argument list.
+   REV_MAPPING is the inverse of MAPPING.
+
+   FILE0, FILE1 and FILE2 are the strings to print as the names of the
+   three files.  These may be the actual names, or may be the
+   arguments specified with -L.
+
+   Return 1 if conflicts were found.  */
+
+static bool
+output_diff3_edscript (FILE *outputfile, struct diff3_block *diff,
+		       int const mapping[3], int const rev_mapping[3],
+		       char const *file0, char const *file1, char const *file2)
+{
+  bool leading_dot;
+  bool conflicts_found = false;
+  bool conflict;
+  struct diff3_block *b;
+
+  for (b = reverse_diff3_blocklist (diff); b; b = b->next)
+    {
+      /* Must do mapping correctly.  */
+      enum diff_type type
+	= (b->correspond == DIFF_ALL
+	   ? DIFF_ALL
+	   : DIFF_1ST + rev_mapping[b->correspond - DIFF_1ST]);
+
+      long int low0, high0;
+
+      /* If we aren't supposed to do this output block, skip it.  */
+      switch (type)
+	{
+	default: continue;
+	case DIFF_2ND: if (!show_2nd) continue; conflict = true; break;
+	case DIFF_3RD: if (overlap_only) continue; conflict = false; break;
+	case DIFF_ALL: if (simple_only) continue; conflict = flagging; break;
+	}
+
+      low0 = D_LOWLINE (b, mapping[FILE0]);
+      high0 = D_HIGHLINE (b, mapping[FILE0]);
+
+      if (conflict)
+	{
+	  conflicts_found = true;
+
+
+	  /* Mark end of conflict.  */
+
+	  fprintf (outputfile, "%lda\n", high0);
+	  leading_dot = false;
+	  if (type == DIFF_ALL)
+	    {
+	      if (show_2nd)
+		{
+		  /* Append lines from FILE1.  */
+		  fprintf (outputfile, "||||||| %s\n", file1);
+		  leading_dot = dotlines (outputfile, b, mapping[FILE1]);
+		}
+	      /* Append lines from FILE2.  */
+	      fputs ("=======\n", outputfile);
+	      leading_dot |= dotlines (outputfile, b, mapping[FILE2]);
+	    }
+	  fprintf (outputfile, ">>>>>>> %s\n", file2);
+	  undotlines (outputfile, leading_dot, high0 + 2,
+		      (D_NUMLINES (b, mapping[FILE1])
+		       + D_NUMLINES (b, mapping[FILE2]) + 1));
+
+
+	  /* Mark start of conflict.  */
+
+	  fprintf (outputfile, "%lda\n<<<<<<< %s\n", low0 - 1,
+		   type == DIFF_ALL ? file0 : file1);
+	  leading_dot = false;
+	  if (type == DIFF_2ND)
+	    {
+	      /* Prepend lines from FILE1.  */
+	      leading_dot = dotlines (outputfile, b, mapping[FILE1]);
+	      fputs ("=======\n", outputfile);
+	    }
+	  undotlines (outputfile, leading_dot, low0 + 1,
+		      D_NUMLINES (b, mapping[FILE1]));
+	}
+      else if (D_NUMLINES (b, mapping[FILE2]) == 0)
+	/* Write out a delete */
+	{
+	  if (low0 == high0)
+	    fprintf (outputfile, "%ldd\n", low0);
+	  else
+	    fprintf (outputfile, "%ld,%ldd\n", low0, high0);
+	}
+      else
+	/* Write out an add or change */
+	{
+	  switch (high0 - low0)
+	    {
+	    case -1:
+	      fprintf (outputfile, "%lda\n", high0);
+	      break;
+	    case 0:
+	      fprintf (outputfile, "%ldc\n", high0);
+	      break;
+	    default:
+	      fprintf (outputfile, "%ld,%ldc\n", low0, high0);
+	      break;
+	    }
+
+	  undotlines (outputfile, dotlines (outputfile, b, mapping[FILE2]),
+		      low0, D_NUMLINES (b, mapping[FILE2]));
+	}
+    }
+  if (finalwrite)
+    fputs ("w\nq\n", outputfile);
+  return conflicts_found;
+}
+
+/* Read from INFILE and output to OUTPUTFILE a set of diff3_blocks
+   DIFF as a merged file.  This acts like 'ed file0
+   <[output_diff3_edscript]', except that it works even for binary
+   data or incomplete lines.
+
+   As before, MAPPING maps from arg list file number to diff file
+   number, REV_MAPPING is its inverse, and FILE0, FILE1, and FILE2 are
+   the names of the files.
+
+   Return 1 if conflicts were found.  */
+
+static bool
+output_diff3_merge (FILE *infile, FILE *outputfile, struct diff3_block *diff,
+		    int const mapping[3], int const rev_mapping[3],
+		    char const *file0, char const *file1, char const *file2)
+{
+  int c;
+  lin i;
+  bool conflicts_found = false;
+  bool conflict;
+  struct diff3_block *b;
+  lin linesread = 0;
+
+  for (b = diff; b; b = b->next)
+    {
+      /* Must do mapping correctly.  */
+      enum diff_type type
+	= ((b->correspond == DIFF_ALL)
+	   ? DIFF_ALL
+	   : DIFF_1ST + rev_mapping[b->correspond - DIFF_1ST]);
+      char const *format_2nd = "<<<<<<< %s\n";
+
+      /* If we aren't supposed to do this output block, skip it.  */
+      switch (type)
+	{
+	default: continue;
+	case DIFF_2ND: if (!show_2nd) continue; conflict = true; break;
+	case DIFF_3RD: if (overlap_only) continue; conflict = false; break;
+	case DIFF_ALL: if (simple_only) continue; conflict = flagging;
+	  format_2nd = "||||||| %s\n";
+	  break;
+	}
+
+      /* Copy I lines from file 0.  */
+      i = D_LOWLINE (b, FILE0) - linesread - 1;
+      linesread += i;
+      while (0 <= --i)
+	do
+	  {
+	    c = getc (infile);
+	    if (c == EOF)
+	      {
+		if (ferror (infile))
+		  perror_with_exit (_("read failed"));
+		else if (feof (infile))
+		  fatal ("input file shrank");
+	      }
+	    putc (c, outputfile);
+	  }
+	while (c != '\n');
+
+      if (conflict)
+	{
+	  conflicts_found = true;
+
+	  if (type == DIFF_ALL)
+	    {
+	      /* Put in lines from FILE0 with bracket.  */
+	      fprintf (outputfile, "<<<<<<< %s\n", file0);
+	      for (i = 0;
+		   i < D_NUMLINES (b, mapping[FILE0]);
+		   i++)
+		fwrite (D_RELNUM (b, mapping[FILE0], i), sizeof (char),
+			D_RELLEN (b, mapping[FILE0], i), outputfile);
+	    }
+
+	  if (show_2nd)
+	    {
+	      /* Put in lines from FILE1 with bracket.  */
+	      fprintf (outputfile, format_2nd, file1);
+	      for (i = 0;
+		   i < D_NUMLINES (b, mapping[FILE1]);
+		   i++)
+		fwrite (D_RELNUM (b, mapping[FILE1], i), sizeof (char),
+			D_RELLEN (b, mapping[FILE1], i), outputfile);
+	    }
+
+	  fputs ("=======\n", outputfile);
+	}
+
+      /* Put in lines from FILE2.  */
+      for (i = 0;
+	   i < D_NUMLINES (b, mapping[FILE2]);
+	   i++)
+	fwrite (D_RELNUM (b, mapping[FILE2], i), sizeof (char),
+		D_RELLEN (b, mapping[FILE2], i), outputfile);
+
+      if (conflict)
+	fprintf (outputfile, ">>>>>>> %s\n", file2);
+
+      /* Skip I lines in file 0.  */
+      i = D_NUMLINES (b, FILE0);
+      linesread += i;
+      while (0 <= --i)
+	while ((c = getc (infile)) != '\n')
+	  if (c == EOF)
+	    {
+	      if (ferror (infile))
+		perror_with_exit (_("read failed"));
+	      else if (feof (infile))
+		{
+		  if (i || b->next)
+		    fatal ("input file shrank");
+		  return conflicts_found;
+		}
+	    }
+    }
+  /* Copy rest of common file.  */
+  while ((c = getc (infile)) != EOF || !(ferror (infile) | feof (infile)))
+    putc (c, outputfile);
+  return conflicts_found;
+}
+
+/* Reverse the order of the list of diff3 blocks.  */
+
+static struct diff3_block *
+reverse_diff3_blocklist (struct diff3_block *diff)
+{
+  register struct diff3_block *tmp, *next, *prev;
+
+  for (tmp = diff, prev = 0;  tmp;  tmp = next)
+    {
+      next = tmp->next;
+      tmp->next = prev;
+      prev = tmp;
+    }
+
+  return prev;
+}
+
+static void
+fatal (char const *msgid)
+{
+  error (EXIT_TROUBLE, 0, "%s", _(msgid));
+  abort ();
+}
+
+static void
+perror_with_exit (char const *string)
+{
+  error (EXIT_TROUBLE, errno, "%s", string);
+  abort ();
+}
diff --git a/src/dir.c b/src/dir.c
index 5b4eaec..5e08318 100644
--- a/src/dir.c
+++ b/src/dir.c
@@ -154,7 +154,7 @@ compare_names (char const *name1, char const *name2)
 	r = strcoll (name1, name2);
       if (errno)
 	{
-	  error (0, errno, _("cannot compare file names `%s' and `%s'"),
+	  error (0, errno, _("cannot compare file names '%s' and '%s'"),
 		 name1, name2);
 	  longjmp (failed_locale_specific_sorting, 1);
 	}
diff --git a/src/dir.c.orig b/src/dir.c.orig
new file mode 100644
index 0000000..5e08318
--- /dev/null
+++ b/src/dir.c.orig
@@ -0,0 +1,283 @@
+/* Read, sort and compare two directories.  Used for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006-2007,
+   2009-2010 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <error.h>
+#include <exclude.h>
+#include <setjmp.h>
+#include <xalloc.h>
+
+/* Read the directory named by DIR and store into DIRDATA a sorted vector
+   of filenames for its contents.  DIR->desc == -1 means this directory is
+   known to be nonexistent, so set DIRDATA to an empty vector.
+   Return -1 (setting errno) if error, 0 otherwise.  */
+
+struct dirdata
+{
+  size_t nnames;	/* Number of names.  */
+  char const **names;	/* Sorted names of files in dir, followed by 0.  */
+  char *data;	/* Allocated storage for file names.  */
+};
+
+/* Whether file names in directories should be compared with
+   locale-specific sorting.  */
+static bool locale_specific_sorting;
+
+/* Where to go if locale-specific sorting fails.  */
+static jmp_buf failed_locale_specific_sorting;
+
+static bool dir_loop (struct comparison const *, int);
+static int compare_names_for_qsort (void const *, void const *);
+
+
+/* Read a directory and get its vector of names.  */
+
+static bool
+dir_read (struct file_data const *dir, struct dirdata *dirdata)
+{
+  register struct dirent *next;
+  register size_t i;
+
+  /* Address of block containing the files that are described.  */
+  char const **names;
+
+  /* Number of files in directory.  */
+  size_t nnames;
+
+  /* Allocated and used storage for file name data.  */
+  char *data;
+  size_t data_alloc, data_used;
+
+  dirdata->names = 0;
+  dirdata->data = 0;
+  nnames = 0;
+  data = 0;
+
+  if (dir->desc != -1)
+    {
+      /* Open the directory and check for errors.  */
+      register DIR *reading = opendir (dir->name);
+      if (!reading)
+	return false;
+
+      /* Initialize the table of filenames.  */
+
+      data_alloc = 512;
+      data_used = 0;
+      dirdata->data = data = xmalloc (data_alloc);
+
+      /* Read the directory entries, and insert the subfiles
+	 into the `data' table.  */
+
+      while ((errno = 0, (next = readdir (reading)) != 0))
+	{
+	  char *d_name = next->d_name;
+	  size_t d_size = _D_EXACT_NAMLEN (next) + 1;
+
+	  /* Ignore "." and "..".  */
+	  if (d_name[0] == '.'
+	      && (d_name[1] == 0 || (d_name[1] == '.' && d_name[2] == 0)))
+	    continue;
+
+	  if (excluded_file_name (excluded, d_name))
+	    continue;
+
+	  while (data_alloc < data_used + d_size)
+	    {
+	      if (PTRDIFF_MAX / 2 <= data_alloc)
+		xalloc_die ();
+	      dirdata->data = data = xrealloc (data, data_alloc *= 2);
+	    }
+
+	  memcpy (data + data_used, d_name, d_size);
+	  data_used += d_size;
+	  nnames++;
+	}
+      if (errno)
+	{
+	  int e = errno;
+	  closedir (reading);
+	  errno = e;
+	  return false;
+	}
+#if CLOSEDIR_VOID
+      closedir (reading);
+#else
+      if (closedir (reading) != 0)
+	return false;
+#endif
+    }
+
+  /* Create the `names' table from the `data' table.  */
+  if (PTRDIFF_MAX / sizeof *names - 1 <= nnames)
+    xalloc_die ();
+  dirdata->names = names = xmalloc ((nnames + 1) * sizeof *names);
+  dirdata->nnames = nnames;
+  for (i = 0;  i < nnames;  i++)
+    {
+      names[i] = data;
+      data += strlen (data) + 1;
+    }
+  names[nnames] = 0;
+  return true;
+}
+
+/* Compare file names, returning a value compatible with strcmp.  */
+
+static int
+compare_names (char const *name1, char const *name2)
+{
+  if (locale_specific_sorting)
+    {
+      int r;
+      errno = 0;
+      if (ignore_file_name_case)
+	r = strcasecoll (name1, name2);
+      else
+	r = strcoll (name1, name2);
+      if (errno)
+	{
+	  error (0, errno, _("cannot compare file names '%s' and '%s'"),
+		 name1, name2);
+	  longjmp (failed_locale_specific_sorting, 1);
+	}
+      return r;
+    }
+
+  return (ignore_file_name_case
+	  ? strcasecmp (name1, name2)
+	  : file_name_cmp (name1, name2));
+}
+
+/* A wrapper for compare_names suitable as an argument for qsort.  */
+
+static int
+compare_names_for_qsort (void const *file1, void const *file2)
+{
+  char const *const *f1 = file1;
+  char const *const *f2 = file2;
+  return compare_names (*f1, *f2);
+}
+
+/* Compare the contents of two directories named in CMP.
+   This is a top-level routine; it does everything necessary for diff
+   on two directories.
+
+   CMP->file[0].desc == -1 says directory CMP->file[0] doesn't exist,
+   but pretend it is empty.  Likewise for CMP->file[1].
+
+   HANDLE_FILE is a caller-provided subroutine called to handle each file.
+   It gets three operands: CMP, name of file in dir 0, name of file in dir 1.
+   These names are relative to the original working directory.
+
+   For a file that appears in only one of the dirs, one of the name-args
+   to HANDLE_FILE is zero.
+
+   Returns the maximum of all the values returned by HANDLE_FILE,
+   or EXIT_TROUBLE if trouble is encountered in opening files.  */
+
+int
+diff_dirs (struct comparison const *cmp,
+	   int (*handle_file) (struct comparison const *,
+			       char const *, char const *))
+{
+  struct dirdata dirdata[2];
+  int volatile val = EXIT_SUCCESS;
+  int i;
+
+  if ((cmp->file[0].desc == -1 || dir_loop (cmp, 0))
+      && (cmp->file[1].desc == -1 || dir_loop (cmp, 1)))
+    {
+      error (0, 0, _("%s: recursive directory loop"),
+	     cmp->file[cmp->file[0].desc == -1].name);
+      return EXIT_TROUBLE;
+    }
+
+  /* Get contents of both dirs.  */
+  for (i = 0; i < 2; i++)
+    if (! dir_read (&cmp->file[i], &dirdata[i]))
+      {
+	perror_with_name (cmp->file[i].name);
+	val = EXIT_TROUBLE;
+      }
+
+  if (val == EXIT_SUCCESS)
+    {
+      char const **volatile names[2];
+      names[0] = dirdata[0].names;
+      names[1] = dirdata[1].names;
+
+      /* Use locale-specific sorting if possible, else native byte order.  */
+      locale_specific_sorting = true;
+      if (setjmp (failed_locale_specific_sorting))
+	locale_specific_sorting = false;
+
+      /* Sort the directories.  */
+      for (i = 0; i < 2; i++)
+	qsort (names[i], dirdata[i].nnames, sizeof *dirdata[i].names,
+	       compare_names_for_qsort);
+
+      /* If `-S name' was given, and this is the topmost level of comparison,
+	 ignore all file names less than the specified starting name.  */
+
+      if (starting_file && ! cmp->parent)
+	{
+	  while (*names[0] && compare_names (*names[0], starting_file) < 0)
+	    names[0]++;
+	  while (*names[1] && compare_names (*names[1], starting_file) < 0)
+	    names[1]++;
+	}
+
+      /* Loop while files remain in one or both dirs.  */
+      while (*names[0] || *names[1])
+	{
+	  /* Compare next name in dir 0 with next name in dir 1.
+	     At the end of a dir,
+	     pretend the "next name" in that dir is very large.  */
+	  int nameorder = (!*names[0] ? 1 : !*names[1] ? -1
+			   : compare_names (*names[0], *names[1]));
+	  int v1 = (*handle_file) (cmp,
+				   0 < nameorder ? 0 : *names[0]++,
+				   nameorder < 0 ? 0 : *names[1]++);
+	  if (val < v1)
+	    val = v1;
+	}
+    }
+
+  for (i = 0; i < 2; i++)
+    {
+      free (dirdata[i].names);
+      free (dirdata[i].data);
+    }
+
+  return val;
+}
+
+/* Return nonzero if CMP is looping recursively in argument I.  */
+
+static bool
+dir_loop (struct comparison const *cmp, int i)
+{
+  struct comparison const *p = cmp;
+  while ((p = p->parent))
+    if (0 < same_file (&p->file[i].stat, &cmp->file[i].stat))
+      return true;
+  return false;
+}
diff --git a/src/sdiff.c b/src/sdiff.c
index 4344e8d..5bbecd8 100644
--- a/src/sdiff.c
+++ b/src/sdiff.c
@@ -175,7 +175,7 @@ try_help (char const *reason_msgid, char const *operand)
 {
   if (reason_msgid)
     error (0, 0, _(reason_msgid), operand);
-  error (EXIT_TROUBLE, 0, _("Try `%s --help' for more information."),
+  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
 	 program_name);
   abort ();
 }
@@ -230,7 +230,7 @@ usage (void)
     else
       putchar ('\n');
   printf ("\n%s\n%s\n",
-	  _("If a FILE is `-', read standard input."),
+	  _("If a FILE is '-', read standard input."),
 	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
   emit_bug_reporting_address ();
 }
@@ -286,12 +286,12 @@ check_child_status (int werrno, int wstatus, int max_ok_status,
     {
       error (0, werrno,
 	     _(status == 126
-	       ? "subsidiary program `%s' could not be invoked"
+	       ? "subsidiary program '%s' could not be invoked"
 	       : status == 127
-	       ? "subsidiary program `%s' not found"
+	       ? "subsidiary program '%s' not found"
 	       : status == INT_MAX
-	       ? "subsidiary program `%s' failed"
-	       : "subsidiary program `%s' failed (exit status %d)"),
+	       ? "subsidiary program '%s' failed"
+	       : "subsidiary program '%s' failed (exit status %d)"),
 	     subsidiary_program, status);
       exiterr ();
     }
@@ -572,9 +572,9 @@ main (int argc, char *argv[])
   if (argc - optind != 2)
     {
       if (argc - optind < 2)
-	try_help ("missing operand after `%s'", argv[argc - 1]);
+	try_help ("missing operand after '%s'", argv[argc - 1]);
       else
-	try_help ("extra operand `%s'", argv[optind + 2]);
+	try_help ("extra operand '%s'", argv[optind + 2]);
     }
 
   if (! output)
diff --git a/src/sdiff.c.orig b/src/sdiff.c.orig
new file mode 100644
index 0000000..5bbecd8
--- /dev/null
+++ b/src/sdiff.c.orig
@@ -0,0 +1,1236 @@
+/* sdiff - side-by-side merge of file differences
+
+   Copyright (C) 1992-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2010 Free
+   Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+#include <unlocked-io.h>
+
+#include <c-stack.h>
+#include <dirname.h>
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <progname.h>
+#include <sh-quote.h>
+#include <version-etc.h>
+#include <xalloc.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "sdiff"
+
+#define AUTHORS \
+  proper_name ("Thomas Lord")
+
+/* Size of chunks read from files which must be parsed into lines.  */
+#define SDIFF_BUFSIZE ((size_t) 65536)
+
+static char const *editor_program = DEFAULT_EDITOR_PROGRAM;
+static char const **diffargv;
+
+static char * volatile tmpname;
+static FILE *tmp;
+
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+static pid_t volatile diffpid;
+#endif
+
+struct line_filter;
+
+static void catchsig (int);
+static bool edit (struct line_filter *, char const *, lin, lin, struct line_filter *, char const *, lin, lin, FILE *);
+static bool interact (struct line_filter *, struct line_filter *, char const *, struct line_filter *, char const *, FILE *);
+static void checksigs (void);
+static void diffarg (char const *);
+static void fatal (char const *) __attribute__((noreturn));
+static void perror_fatal (char const *) __attribute__((noreturn));
+static void trapsigs (void);
+static void untrapsig (int);
+
+#define NUM_SIGS (sizeof sigs / sizeof *sigs)
+static int const sigs[] = {
+#ifdef SIGHUP
+       SIGHUP,
+#endif
+#ifdef SIGQUIT
+       SIGQUIT,
+#endif
+#ifdef SIGTERM
+       SIGTERM,
+#endif
+#ifdef SIGXCPU
+       SIGXCPU,
+#endif
+#ifdef SIGXFSZ
+       SIGXFSZ,
+#endif
+#ifdef SIGPIPE
+       SIGPIPE,
+# define handler_index_of_SIGPIPE (NUM_SIGS - 2)
+#endif
+       SIGINT
+#define handler_index_of_SIGINT (NUM_SIGS - 1)
+};
+
+#if HAVE_SIGACTION
+  /* Prefer `sigaction' if available, since `signal' can lose signals.  */
+  static struct sigaction initial_action[NUM_SIGS];
+# define initial_handler(i) (initial_action[i].sa_handler)
+  static void signal_handler (int, void (*) (int));
+#else
+  static void (*initial_action[NUM_SIGS]) ();
+# define initial_handler(i) (initial_action[i])
+# define signal_handler(sig, handler) signal (sig, handler)
+#endif
+
+#if ! HAVE_SIGPROCMASK
+# define sigset_t int
+# define sigemptyset(s) (*(s) = 0)
+# ifndef sigmask
+#  define sigmask(sig) (1 << ((sig) - 1))
+# endif
+# define sigaddset(s, sig) (*(s) |= sigmask (sig))
+# ifndef SIG_BLOCK
+#  define SIG_BLOCK 0
+# endif
+# ifndef SIG_SETMASK
+#  define SIG_SETMASK (! SIG_BLOCK)
+# endif
+# if ! HAVE_SIGBLOCK
+#  define sigblock(mask) (mask)
+#  define sigsetmask(mask) (mask)
+# endif
+# define sigprocmask(how, n, o) \
+    ((how) == SIG_BLOCK \
+     ? ((o) ? (*(sigset_t *) (o) = sigblock (*(n))) : sigblock (*(n))) \
+     : sigsetmask (*(n)))
+#endif
+
+static bool diraccess (char const *);
+static int temporary_file (void);
+
+/* Options: */
+
+/* Name of output file if -o specified.  */
+static char const *output;
+
+/* Do not print common lines.  */
+static bool suppress_common_lines;
+
+/* Value for the long option that does not have single-letter equivalents.  */
+enum
+{
+  DIFF_PROGRAM_OPTION = CHAR_MAX + 1,
+  HELP_OPTION,
+  STRIP_TRAILING_CR_OPTION,
+  TABSIZE_OPTION
+};
+
+static struct option const longopts[] =
+{
+  {"diff-program", 1, 0, DIFF_PROGRAM_OPTION},
+  {"expand-tabs", 0, 0, 't'},
+  {"help", 0, 0, HELP_OPTION},
+  {"ignore-all-space", 0, 0, 'W'}, /* swap W and w for historical reasons */
+  {"ignore-blank-lines", 0, 0, 'B'},
+  {"ignore-case", 0, 0, 'i'},
+  {"ignore-matching-lines", 1, 0, 'I'},
+  {"ignore-space-change", 0, 0, 'b'},
+  {"ignore-tab-expansion", 0, 0, 'E'},
+  {"left-column", 0, 0, 'l'},
+  {"minimal", 0, 0, 'd'},
+  {"output", 1, 0, 'o'},
+  {"speed-large-files", 0, 0, 'H'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"suppress-common-lines", 0, 0, 's'},
+  {"tabsize", 1, 0, TABSIZE_OPTION},
+  {"text", 0, 0, 'a'},
+  {"version", 0, 0, 'v'},
+  {"width", 1, 0, 'w'},
+  {0, 0, 0, 0}
+};
+
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+	 program_name);
+  abort ();
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    perror_fatal (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-o FILE  --output=FILE  Operate interactively, sending output to FILE."),
+  "",
+  N_("-i  --ignore-case  Consider upper- and lower-case to be the same."),
+  N_("-E  --ignore-tab-expansion  Ignore changes due to tab expansion."),
+  N_("-b  --ignore-space-change  Ignore changes in the amount of white space."),
+  N_("-W  --ignore-all-space  Ignore all white space."),
+  N_("-B  --ignore-blank-lines  Ignore changes whose lines are all blank."),
+  N_("-I RE  --ignore-matching-lines=RE  Ignore changes whose lines all match RE."),
+  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+  N_("-a  --text  Treat all files as text."),
+  "",
+  N_("-w NUM  --width=NUM  Output at most NUM (default 130) print columns."),
+  N_("-l  --left-column  Output only the left column of common lines."),
+  N_("-s  --suppress-common-lines  Do not output common lines."),
+  "",
+  N_("-t  --expand-tabs  Expand tabs to spaces in output."),
+  N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
+  "",
+  N_("-d  --minimal  Try hard to find a smaller set of changes."),
+  N_("-H  --speed-large-files  Assume large files and many scattered small changes."),
+  N_("--diff-program=PROGRAM  Use PROGRAM to compare files."),
+  "",
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILE1 FILE2\n"), program_name);
+  printf ("%s\n\n", _("Side-by-side merge of file differences."));
+  for (p = option_help_msgid;  *p;  p++)
+    if (**p)
+      printf ("  %s\n", _(*p));
+    else
+      putchar ('\n');
+  printf ("\n%s\n%s\n",
+	  _("If a FILE is '-', read standard input."),
+	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+/* Clean up after a signal or other failure.  This function is
+   async-signal-safe.  */
+static void
+cleanup (int signo __attribute__((unused)))
+{
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+  if (0 < diffpid)
+    kill (diffpid, SIGPIPE);
+#endif
+  if (tmpname)
+    unlink (tmpname);
+}
+
+static void exiterr (void) __attribute__((noreturn));
+static void
+exiterr (void)
+{
+  cleanup (0);
+  untrapsig (0);
+  checksigs ();
+  exit (EXIT_TROUBLE);
+}
+
+static void
+fatal (char const *msgid)
+{
+  error (0, 0, "%s", _(msgid));
+  exiterr ();
+}
+
+static void
+perror_fatal (char const *msg)
+{
+  int e = errno;
+  checksigs ();
+  error (0, e, "%s", msg);
+  exiterr ();
+}
+
+static void
+check_child_status (int werrno, int wstatus, int max_ok_status,
+		    char const *subsidiary_program)
+{
+  int status = (! werrno && WIFEXITED (wstatus)
+		? WEXITSTATUS (wstatus)
+		: INT_MAX);
+
+  if (max_ok_status < status)
+    {
+      error (0, werrno,
+	     _(status == 126
+	       ? "subsidiary program '%s' could not be invoked"
+	       : status == 127
+	       ? "subsidiary program '%s' not found"
+	       : status == INT_MAX
+	       ? "subsidiary program '%s' failed"
+	       : "subsidiary program '%s' failed (exit status %d)"),
+	     subsidiary_program, status);
+      exiterr ();
+    }
+}
+
+static FILE *
+ck_fopen (char const *fname, char const *type)
+{
+  FILE *r = fopen (fname, type);
+  if (! r)
+    perror_fatal (fname);
+  return r;
+}
+
+static void
+ck_fclose (FILE *f)
+{
+  if (fclose (f))
+    perror_fatal ("fclose");
+}
+
+static size_t
+ck_fread (char *buf, size_t size, FILE *f)
+{
+  size_t r = fread (buf, sizeof (char), size, f);
+  if (r == 0 && ferror (f))
+    perror_fatal (_("read failed"));
+  return r;
+}
+
+static void
+ck_fwrite (char const *buf, size_t size, FILE *f)
+{
+  if (fwrite (buf, sizeof (char), size, f) != size)
+    perror_fatal (_("write failed"));
+}
+
+static void
+ck_fflush (FILE *f)
+{
+  if (fflush (f) != 0)
+    perror_fatal (_("write failed"));
+}
+
+static char const *
+expand_name (char *name, bool is_dir, char const *other_name)
+{
+  if (STREQ (name, "-"))
+    fatal ("cannot interactively merge standard input");
+  if (! is_dir)
+    return name;
+  else
+    {
+      /* Yield NAME/BASE, where BASE is OTHER_NAME's basename.  */
+      char const *base = last_component (other_name);
+      size_t namelen = strlen (name), baselen = base_len (base);
+      bool insert_slash = *last_component (name) && name[namelen - 1] != '/';
+      char *r = xmalloc (namelen + insert_slash + baselen + 1);
+      memcpy (r, name, namelen);
+      r[namelen] = '/';
+      memcpy (r + namelen + insert_slash, base, baselen);
+      r[namelen + insert_slash + baselen] = '\0';
+      return r;
+    }
+}
+
+struct line_filter {
+  FILE *infile;
+  char *bufpos;
+  char *buffer;
+  char *buflim;
+};
+
+static void
+lf_init (struct line_filter *lf, FILE *infile)
+{
+  lf->infile = infile;
+  lf->bufpos = lf->buffer = lf->buflim = xmalloc (SDIFF_BUFSIZE + 1);
+  lf->buflim[0] = '\n';
+}
+
+/* Fill an exhausted line_filter buffer from its INFILE */
+static size_t
+lf_refill (struct line_filter *lf)
+{
+  size_t s = ck_fread (lf->buffer, SDIFF_BUFSIZE, lf->infile);
+  lf->bufpos = lf->buffer;
+  lf->buflim = lf->buffer + s;
+  lf->buflim[0] = '\n';
+  checksigs ();
+  return s;
+}
+
+/* Advance LINES on LF's infile, copying lines to OUTFILE */
+static void
+lf_copy (struct line_filter *lf, lin lines, FILE *outfile)
+{
+  char *start = lf->bufpos;
+
+  while (lines)
+    {
+      lf->bufpos = (char *) memchr (lf->bufpos, '\n', lf->buflim - lf->bufpos);
+      if (! lf->bufpos)
+	{
+	  ck_fwrite (start, lf->buflim - start, outfile);
+	  if (! lf_refill (lf))
+	    return;
+	  start = lf->bufpos;
+	}
+      else
+	{
+	  --lines;
+	  ++lf->bufpos;
+	}
+    }
+
+  ck_fwrite (start, lf->bufpos - start, outfile);
+}
+
+/* Advance LINES on LF's infile without doing output */
+static void
+lf_skip (struct line_filter *lf, lin lines)
+{
+  while (lines)
+    {
+      lf->bufpos = (char *) memchr (lf->bufpos, '\n', lf->buflim - lf->bufpos);
+      if (! lf->bufpos)
+	{
+	  if (! lf_refill (lf))
+	    break;
+	}
+      else
+	{
+	  --lines;
+	  ++lf->bufpos;
+	}
+    }
+}
+
+/* Snarf a line into a buffer.  Return EOF if EOF, 0 if error, 1 if OK.  */
+static int
+lf_snarf (struct line_filter *lf, char *buffer, size_t bufsize)
+{
+  for (;;)
+    {
+      char *start = lf->bufpos;
+      char *next = (char *) memchr (start, '\n', lf->buflim + 1 - start);
+      size_t s = next - start;
+      if (bufsize <= s)
+	return 0;
+      memcpy (buffer, start, s);
+      if (next < lf->buflim)
+	{
+	  buffer[s] = 0;
+	  lf->bufpos = next + 1;
+	  return 1;
+	}
+      if (! lf_refill (lf))
+	return s ? 0 : EOF;
+      buffer += s;
+      bufsize -= s;
+    }
+}
+
+int
+main (int argc, char *argv[])
+{
+  int opt;
+  char const *prog;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (cleanup);
+
+  prog = getenv ("EDITOR");
+  if (prog)
+    editor_program = prog;
+
+  diffarg (DEFAULT_DIFF_PROGRAM);
+
+  /* parse command line args */
+  while ((opt = getopt_long (argc, argv, "abBdEHiI:lo:stvw:W", longopts, 0))
+	 != -1)
+    {
+      switch (opt)
+	{
+	case 'a':
+	  diffarg ("-a");
+	  break;
+
+	case 'b':
+	  diffarg ("-b");
+	  break;
+
+	case 'B':
+	  diffarg ("-B");
+	  break;
+
+	case 'd':
+	  diffarg ("-d");
+	  break;
+
+	case 'E':
+	  diffarg ("-E");
+	  break;
+
+	case 'H':
+	  diffarg ("-H");
+	  break;
+
+	case 'i':
+	  diffarg ("-i");
+	  break;
+
+	case 'I':
+	  diffarg ("-I");
+	  diffarg (optarg);
+	  break;
+
+	case 'l':
+	  diffarg ("--left-column");
+	  break;
+
+	case 'o':
+	  output = optarg;
+	  break;
+
+	case 's':
+	  suppress_common_lines = true;
+	  break;
+
+	case 't':
+	  diffarg ("-t");
+	  break;
+
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case 'w':
+	  diffarg ("-W");
+	  diffarg (optarg);
+	  break;
+
+	case 'W':
+	  diffarg ("-w");
+	  break;
+
+	case DIFF_PROGRAM_OPTION:
+	  diffargv[0] = optarg;
+	  break;
+
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case STRIP_TRAILING_CR_OPTION:
+	  diffarg ("--strip-trailing-cr");
+	  break;
+
+	case TABSIZE_OPTION:
+	  diffarg ("--tabsize");
+	  diffarg (optarg);
+	  break;
+
+	default:
+	  try_help (0, 0);
+	}
+    }
+
+  if (argc - optind != 2)
+    {
+      if (argc - optind < 2)
+	try_help ("missing operand after '%s'", argv[argc - 1]);
+      else
+	try_help ("extra operand '%s'", argv[optind + 2]);
+    }
+
+  if (! output)
+    {
+      /* easy case: diff does everything for us */
+      if (suppress_common_lines)
+	diffarg ("--suppress-common-lines");
+      diffarg ("-y");
+      diffarg ("--");
+      diffarg (argv[optind]);
+      diffarg (argv[optind + 1]);
+      diffarg (0);
+      execvp (diffargv[0], (char **) diffargv);
+      perror_fatal (diffargv[0]);
+    }
+  else
+    {
+      char const *lname, *rname;
+      FILE *left, *right, *out, *diffout;
+      bool interact_ok;
+      struct line_filter lfilt;
+      struct line_filter rfilt;
+      struct line_filter diff_filt;
+      bool leftdir = diraccess (argv[optind]);
+      bool rightdir = diraccess (argv[optind + 1]);
+
+      if (leftdir & rightdir)
+	fatal ("both files to be compared are directories");
+
+      lname = expand_name (argv[optind], leftdir, argv[optind + 1]);
+      left = ck_fopen (lname, "r");
+      rname = expand_name (argv[optind + 1], rightdir, argv[optind]);
+      right = ck_fopen (rname, "r");
+      out = ck_fopen (output, "w");
+
+      diffarg ("--sdiff-merge-assist");
+      diffarg ("--");
+      diffarg (argv[optind]);
+      diffarg (argv[optind + 1]);
+      diffarg (0);
+
+      trapsigs ();
+
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+      {
+	size_t cmdsize = 1;
+	char *p, *command;
+	int i;
+
+	for (i = 0;  diffargv[i];  i++)
+	  cmdsize += shell_quote_length (diffargv[i]) + 1;
+	command = p = xmalloc (cmdsize);
+	for (i = 0;  diffargv[i];  i++)
+	  {
+	    p = shell_quote_copy (p, diffargv[i]);
+	    *p++ = ' ';
+	  }
+	p[-1] = 0;
+	errno = 0;
+	diffout = popen (command, "r");
+	if (! diffout)
+	  perror_fatal (command);
+	free (command);
+      }
+#else
+      {
+	int diff_fds[2];
+# if HAVE_WORKING_VFORK
+	sigset_t procmask;
+	sigset_t blocked;
+# endif
+
+	if (pipe (diff_fds) != 0)
+	  perror_fatal ("pipe");
+
+# if HAVE_WORKING_VFORK
+	/* Block SIGINT and SIGPIPE.  */
+	sigemptyset (&blocked);
+	sigaddset (&blocked, SIGINT);
+	sigaddset (&blocked, SIGPIPE);
+	sigprocmask (SIG_BLOCK, &blocked, &procmask);
+# endif
+	diffpid = vfork ();
+	if (diffpid < 0)
+	  perror_fatal ("fork");
+	if (! diffpid)
+	  {
+	    /* Alter the child's SIGINT and SIGPIPE handlers;
+	       this may munge the parent.
+	       The child ignores SIGINT in case the user interrupts the editor.
+	       The child does not ignore SIGPIPE, even if the parent does.  */
+	    if (initial_handler (handler_index_of_SIGINT) != SIG_IGN)
+	      signal_handler (SIGINT, SIG_IGN);
+	    signal_handler (SIGPIPE, SIG_DFL);
+# if HAVE_WORKING_VFORK
+	    /* Stop blocking SIGINT and SIGPIPE in the child.  */
+	    sigprocmask (SIG_SETMASK, &procmask, 0);
+# endif
+	    close (diff_fds[0]);
+	    if (diff_fds[1] != STDOUT_FILENO)
+	      {
+		dup2 (diff_fds[1], STDOUT_FILENO);
+		close (diff_fds[1]);
+	      }
+
+	    execvp (diffargv[0], (char **) diffargv);
+	    _exit (errno == ENOENT ? 127 : 126);
+	  }
+
+# if HAVE_WORKING_VFORK
+	/* Restore the parent's SIGINT and SIGPIPE behavior.  */
+	if (initial_handler (handler_index_of_SIGINT) != SIG_IGN)
+	  signal_handler (SIGINT, catchsig);
+	if (initial_handler (handler_index_of_SIGPIPE) != SIG_IGN)
+	  signal_handler (SIGPIPE, catchsig);
+	else
+	  signal_handler (SIGPIPE, SIG_IGN);
+
+	/* Stop blocking SIGINT and SIGPIPE in the parent.  */
+	sigprocmask (SIG_SETMASK, &procmask, 0);
+# endif
+
+	close (diff_fds[1]);
+	diffout = fdopen (diff_fds[0], "r");
+	if (! diffout)
+	  perror_fatal ("fdopen");
+      }
+#endif
+
+      lf_init (&diff_filt, diffout);
+      lf_init (&lfilt, left);
+      lf_init (&rfilt, right);
+
+      interact_ok = interact (&diff_filt, &lfilt, lname, &rfilt, rname, out);
+
+      ck_fclose (left);
+      ck_fclose (right);
+      ck_fclose (out);
+
+      {
+	int wstatus;
+	int werrno = 0;
+
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+	wstatus = pclose (diffout);
+	if (wstatus == -1)
+	  werrno = errno;
+#else
+	ck_fclose (diffout);
+	while (waitpid (diffpid, &wstatus, 0) < 0)
+	  if (errno == EINTR)
+	    checksigs ();
+	  else
+	    perror_fatal ("waitpid");
+	diffpid = 0;
+#endif
+
+	if (tmpname)
+	  {
+	    unlink (tmpname);
+	    tmpname = 0;
+	  }
+
+	if (! interact_ok)
+	  exiterr ();
+
+	check_child_status (werrno, wstatus, EXIT_FAILURE, diffargv[0]);
+	untrapsig (0);
+	checksigs ();
+	exit (WEXITSTATUS (wstatus));
+      }
+    }
+  return EXIT_SUCCESS;			/* Fool `-Wall'.  */
+}
+
+static void
+diffarg (char const *a)
+{
+  static size_t diffargs, diffarglim;
+
+  if (diffargs == diffarglim)
+    {
+      if (! diffarglim)
+	diffarglim = 16;
+      else if (PTRDIFF_MAX / (2 * sizeof *diffargv) <= diffarglim)
+	xalloc_die ();
+      else
+	diffarglim *= 2;
+      diffargv = xrealloc (diffargv, diffarglim * sizeof *diffargv);
+    }
+  diffargv[diffargs++] = a;
+}
+
+/* Signal handling */
+
+static bool volatile ignore_SIGINT;
+static int volatile signal_received;
+static bool sigs_trapped;
+
+static void
+catchsig (int s)
+{
+#if ! HAVE_SIGACTION
+  signal (s, SIG_IGN);
+#endif
+  if (! (s == SIGINT && ignore_SIGINT))
+    signal_received = s;
+}
+
+#if HAVE_SIGACTION
+static struct sigaction catchaction;
+
+static void
+signal_handler (int sig, void (*handler) (int))
+{
+  catchaction.sa_handler = handler;
+  sigaction (sig, &catchaction, 0);
+}
+#endif
+
+static void
+trapsigs (void)
+{
+  int i;
+
+#if HAVE_SIGACTION
+  catchaction.sa_flags = SA_RESTART;
+  sigemptyset (&catchaction.sa_mask);
+  for (i = 0;  i < NUM_SIGS;  i++)
+    sigaddset (&catchaction.sa_mask, sigs[i]);
+#endif
+
+  for (i = 0;  i < NUM_SIGS;  i++)
+    {
+#if HAVE_SIGACTION
+      sigaction (sigs[i], 0, &initial_action[i]);
+#else
+      initial_action[i] = signal (sigs[i], SIG_IGN);
+#endif
+      if (initial_handler (i) != SIG_IGN)
+	signal_handler (sigs[i], catchsig);
+    }
+
+#ifdef SIGCHLD
+  /* System V fork+wait does not work if SIGCHLD is ignored.  */
+  signal (SIGCHLD, SIG_DFL);
+#endif
+
+  sigs_trapped = true;
+}
+
+/* Untrap signal S, or all trapped signals if S is zero.  */
+static void
+untrapsig (int s)
+{
+  int i;
+
+  if (sigs_trapped)
+    for (i = 0;  i < NUM_SIGS;  i++)
+      if ((! s || sigs[i] == s)  &&  initial_handler (i) != SIG_IGN)
+	{
+#if HAVE_SIGACTION
+	  sigaction (sigs[i], &initial_action[i], 0);
+#else
+	  signal (sigs[i], initial_action[i]);
+#endif
+	}
+}
+
+/* Exit if a signal has been received.  */
+static void
+checksigs (void)
+{
+  int s = signal_received;
+  if (s)
+    {
+      cleanup (0);
+
+      /* Yield an exit status indicating that a signal was received.  */
+      untrapsig (s);
+      kill (getpid (), s);
+
+      /* That didn't work, so exit with error status.  */
+      exit (EXIT_TROUBLE);
+    }
+}
+
+static void
+give_help (void)
+{
+  fprintf (stderr, "%s", _("\
+ed:\tEdit then use both versions, each decorated with a header.\n\
+eb:\tEdit then use both versions.\n\
+el or e1:\tEdit then use the left version.\n\
+er or e2:\tEdit then use the right version.\n\
+e:\tDiscard both versions then edit a new one.\n\
+l or 1:\tUse the left version.\n\
+r or 2:\tUse the right version.\n\
+s:\tSilently include common lines.\n\
+v:\tVerbosely include common lines.\n\
+q:\tQuit.\n\
+"));
+}
+
+static int
+skip_white (void)
+{
+  int c;
+  for (;;)
+    {
+      c = getchar ();
+      if (! isspace (c) || c == '\n')
+	break;
+      checksigs ();
+    }
+  if (ferror (stdin))
+    perror_fatal (_("read failed"));
+  return c;
+}
+
+static void
+flush_line (void)
+{
+  int c;
+  while ((c = getchar ()) != '\n' && c != EOF)
+    continue;
+  if (ferror (stdin))
+    perror_fatal (_("read failed"));
+}
+
+
+/* interpret an edit command */
+static bool
+edit (struct line_filter *left, char const *lname, lin lline, lin llen,
+      struct line_filter *right, char const *rname, lin rline, lin rlen,
+      FILE *outfile)
+{
+  for (;;)
+    {
+      int cmd0 IF_LINT (= 0);
+      int cmd1 IF_LINT (= 0);
+      bool gotcmd = false;
+
+      while (! gotcmd)
+	{
+	  if (putchar ('%') != '%')
+	    perror_fatal (_("write failed"));
+	  ck_fflush (stdout);
+
+	  cmd0 = skip_white ();
+	  switch (cmd0)
+	    {
+	    case '1': case '2': case 'l': case 'r':
+	    case 's': case 'v': case 'q':
+	      if (skip_white () != '\n')
+		{
+		  give_help ();
+		  flush_line ();
+		  continue;
+		}
+	      gotcmd = true;
+	      break;
+
+	    case 'e':
+	      cmd1 = skip_white ();
+	      switch (cmd1)
+		{
+		case '1': case '2': case 'b': case 'd': case 'l': case 'r':
+		  if (skip_white () != '\n')
+		    {
+		      give_help ();
+		      flush_line ();
+		      continue;
+		    }
+		  gotcmd = true;
+		  break;
+		case '\n':
+		  gotcmd = true;
+		  break;
+		default:
+		  give_help ();
+		  flush_line ();
+		  continue;
+		}
+	      break;
+
+	    case EOF:
+	      if (feof (stdin))
+		{
+		  gotcmd = true;
+		  cmd0 = 'q';
+		  break;
+		}
+	      /* Fall through.  */
+	    default:
+	      flush_line ();
+	      /* Fall through.  */
+	    case '\n':
+	      give_help ();
+	      continue;
+	    }
+	}
+
+      switch (cmd0)
+	{
+	case '1': case 'l':
+	  lf_copy (left, llen, outfile);
+	  lf_skip (right, rlen);
+	  return true;
+	case '2': case 'r':
+	  lf_copy (right, rlen, outfile);
+	  lf_skip (left, llen);
+	  return true;
+	case 's':
+	  suppress_common_lines = true;
+	  break;
+	case 'v':
+	  suppress_common_lines = false;
+	  break;
+	case 'q':
+	  return false;
+	case 'e':
+	  {
+	    int fd;
+
+	    if (tmpname)
+	      tmp = fopen (tmpname, "w");
+	    else
+	      {
+		if ((fd = temporary_file ()) < 0)
+		  perror_fatal ("mkstemp");
+		tmp = fdopen (fd, "w");
+	      }
+
+	    if (! tmp)
+	      perror_fatal (tmpname);
+
+	    switch (cmd1)
+	      {
+	      case 'd':
+		if (llen)
+		  {
+		    if (llen == 1)
+		      fprintf (tmp, "--- %s %ld\n", lname, (long int) lline);
+		    else
+		      fprintf (tmp, "--- %s %ld,%ld\n", lname,
+			       (long int) lline,
+			       (long int) (lline + llen - 1));
+		  }
+		/* Fall through.  */
+	      case '1': case 'b': case 'l':
+		lf_copy (left, llen, tmp);
+		break;
+
+	      default:
+		lf_skip (left, llen);
+		break;
+	      }
+
+	    switch (cmd1)
+	      {
+	      case 'd':
+		if (rlen)
+		  {
+		    if (rlen == 1)
+		      fprintf (tmp, "+++ %s %ld\n", rname, (long int) rline);
+		    else
+		      fprintf (tmp, "+++ %s %ld,%ld\n", rname,
+			       (long int) rline,
+			       (long int) (rline + rlen - 1));
+		  }
+		/* Fall through.  */
+	      case '2': case 'b': case 'r':
+		lf_copy (right, rlen, tmp);
+		break;
+
+	      default:
+		lf_skip (right, rlen);
+		break;
+	      }
+
+	    ck_fclose (tmp);
+
+	    {
+	      int wstatus;
+	      int werrno = 0;
+	      ignore_SIGINT = true;
+	      checksigs ();
+
+	      {
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+		char *command =
+		  xmalloc (shell_quote_length (editor_program)
+			   + 1 + strlen (tmpname) + 1);
+		sprintf (shell_quote_copy (command, editor_program),
+			 " %s", tmpname);
+		wstatus = system (command);
+		if (wstatus == -1)
+		  werrno = errno;
+		free (command);
+#else
+		pid_t pid;
+
+		pid = vfork ();
+		if (pid == 0)
+		  {
+		    char const *argv[3];
+		    int i = 0;
+
+		    argv[i++] = editor_program;
+		    argv[i++] = tmpname;
+		    argv[i] = 0;
+
+		    execvp (editor_program, (char **) argv);
+		    _exit (errno == ENOENT ? 127 : 126);
+		  }
+
+		if (pid < 0)
+		  perror_fatal ("fork");
+
+		while (waitpid (pid, &wstatus, 0) < 0)
+		  if (errno == EINTR)
+		    checksigs ();
+		  else
+		    perror_fatal ("waitpid");
+#endif
+	      }
+
+	      ignore_SIGINT = false;
+	      check_child_status (werrno, wstatus, EXIT_SUCCESS,
+				  editor_program);
+	    }
+
+	    {
+	      char buf[SDIFF_BUFSIZE];
+	      size_t size;
+	      tmp = ck_fopen (tmpname, "r");
+	      while ((size = ck_fread (buf, SDIFF_BUFSIZE, tmp)) != 0)
+		{
+		  checksigs ();
+		  ck_fwrite (buf, size, outfile);
+		}
+	      ck_fclose (tmp);
+	    }
+	    return true;
+	  }
+	default:
+	  give_help ();
+	  break;
+	}
+    }
+}
+
+/* Alternately reveal bursts of diff output and handle user commands.  */
+static bool
+interact (struct line_filter *diff,
+	  struct line_filter *left, char const *lname,
+	  struct line_filter *right, char const *rname,
+	  FILE *outfile)
+{
+  lin lline = 1, rline = 1;
+
+  for (;;)
+    {
+      char diff_help[256];
+      int snarfed = lf_snarf (diff, diff_help, sizeof diff_help);
+
+      if (snarfed <= 0)
+	return snarfed != 0;
+
+      checksigs ();
+
+      if (diff_help[0] == ' ')
+	puts (diff_help + 1);
+      else
+	{
+	  char *numend;
+	  uintmax_t val;
+	  lin llen, rlen, lenmax;
+	  errno = 0;
+	  llen = val = strtoumax (diff_help + 1, &numend, 10);
+	  if (llen < 0 || llen != val || errno || *numend != ',')
+	    fatal (diff_help);
+	  rlen = val = strtoumax (numend + 1, &numend, 10);
+	  if (rlen < 0 || rlen != val || errno || *numend)
+	    fatal (diff_help);
+
+	  lenmax = MAX (llen, rlen);
+
+	  switch (diff_help[0])
+	    {
+	    case 'i':
+	      if (suppress_common_lines)
+		lf_skip (diff, lenmax);
+	      else
+		lf_copy (diff, lenmax, stdout);
+
+	      lf_copy (left, llen, outfile);
+	      lf_skip (right, rlen);
+	      break;
+
+	    case 'c':
+	      lf_copy (diff, lenmax, stdout);
+	      if (! edit (left, lname, lline, llen,
+			  right, rname, rline, rlen,
+			  outfile))
+		return false;
+	      break;
+
+	    default:
+	      fatal (diff_help);
+	    }
+
+	  lline += llen;
+	  rline += rlen;
+	}
+    }
+}
+
+/* Return true if DIR is an existing directory.  */
+static bool
+diraccess (char const *dir)
+{
+  struct stat buf;
+  return stat (dir, &buf) == 0 && S_ISDIR (buf.st_mode);
+}
+
+#ifndef P_tmpdir
+# define P_tmpdir "/tmp"
+#endif
+#ifndef TMPDIR_ENV
+# define TMPDIR_ENV "TMPDIR"
+#endif
+
+/* Open a temporary file and return its file descriptor.  Put into
+   tmpname the address of a newly allocated buffer that holds the
+   file's name.  Use the prefix "sdiff".  */
+static int
+temporary_file (void)
+{
+  char const *tmpdir = getenv (TMPDIR_ENV);
+  char const *dir = tmpdir ? tmpdir : P_tmpdir;
+  char *buf = xmalloc (strlen (dir) + 1 + 5 + 6 + 1);
+  int fd;
+  int e;
+  sigset_t procmask;
+  sigset_t blocked;
+  sprintf (buf, "%s/sdiffXXXXXX", dir);
+  sigemptyset (&blocked);
+  sigaddset (&blocked, SIGINT);
+  sigprocmask (SIG_BLOCK, &blocked, &procmask);
+  fd = mkstemp (buf);
+  e = errno;
+  if (0 <= fd)
+    tmpname = buf;
+  sigprocmask (SIG_SETMASK, &procmask, 0);
+  errno = e;
+  return fd;
+}
diff --git a/src/util.c b/src/util.c
index 3be03e9..d18bf38 100644
--- a/src/util.c
+++ b/src/util.c
@@ -298,12 +298,12 @@ finish_output (void)
       if (status)
 	error (EXIT_TROUBLE, werrno,
 	       _(status == 126
-		 ? "subsidiary program `%s' could not be invoked"
+		 ? "subsidiary program '%s' could not be invoked"
 		 : status == 127
-		 ? "subsidiary program `%s' not found"
+		 ? "subsidiary program '%s' not found"
 		 : status == INT_MAX
-		 ? "subsidiary program `%s' failed"
-		 : "subsidiary program `%s' failed (exit status %d)"),
+		 ? "subsidiary program '%s' failed"
+		 : "subsidiary program '%s' failed (exit status %d)"),
 	       pr_program, status);
     }
 
diff --git a/src/util.c.orig b/src/util.c.orig
new file mode 100644
index 0000000..d18bf38
--- /dev/null
+++ b/src/util.c.orig
@@ -0,0 +1,788 @@
+/* Support routines for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <dirname.h>
+#include <error.h>
+#include <sh-quote.h>
+#include <xalloc.h>
+
+char const pr_program[] = PR_PROGRAM;
+
+/* Queue up one-line messages to be printed at the end,
+   when -l is specified.  Each message is recorded with a `struct msg'.  */
+
+struct msg
+{
+  struct msg *next;
+  char args[1]; /* Format + 4 args, each '\0' terminated, concatenated.  */
+};
+
+/* Head of the chain of queues messages.  */
+
+static struct msg *msg_chain;
+
+/* Tail of the chain of queues messages.  */
+
+static struct msg **msg_chain_end = &msg_chain;
+
+/* Use when a system call returns non-zero status.
+   NAME should normally be the file name.  */
+
+void
+perror_with_name (char const *name)
+{
+  error (0, errno, "%s", name);
+}
+
+/* Use when a system call returns non-zero status and that is fatal.  */
+
+void
+pfatal_with_name (char const *name)
+{
+  int e = errno;
+  print_message_queue ();
+  error (EXIT_TROUBLE, e, "%s", name);
+  abort ();
+}
+
+/* Print an error message containing MSGID, then exit.  */
+
+void
+fatal (char const *msgid)
+{
+  print_message_queue ();
+  error (EXIT_TROUBLE, 0, "%s", _(msgid));
+  abort ();
+}
+
+/* Like printf, except if -l in effect then save the message and print later.
+   This is used for things like "Only in ...".  */
+
+void
+message (char const *format_msgid, char const *arg1, char const *arg2)
+{
+  message5 (format_msgid, arg1, arg2, 0, 0);
+}
+
+void
+message5 (char const *format_msgid, char const *arg1, char const *arg2,
+	  char const *arg3, char const *arg4)
+{
+  if (paginate)
+    {
+      char *p;
+      char const *arg[5];
+      int i;
+      size_t size[5];
+      size_t total_size = offsetof (struct msg, args);
+      struct msg *new;
+
+      arg[0] = format_msgid;
+      arg[1] = arg1;
+      arg[2] = arg2;
+      arg[3] = arg3 ? arg3 : "";
+      arg[4] = arg4 ? arg4 : "";
+
+      for (i = 0;  i < 5;  i++)
+	total_size += size[i] = strlen (arg[i]) + 1;
+
+      new = xmalloc (total_size);
+
+      for (i = 0, p = new->args;  i < 5;  p += size[i++])
+	memcpy (p, arg[i], size[i]);
+
+      *msg_chain_end = new;
+      new->next = 0;
+      msg_chain_end = &new->next;
+    }
+  else
+    {
+      if (sdiff_merge_assist)
+	putchar (' ');
+      printf (_(format_msgid), arg1, arg2, arg3, arg4);
+    }
+}
+
+/* Output all the messages that were saved up by calls to `message'.  */
+
+void
+print_message_queue (void)
+{
+  char const *arg[5];
+  int i;
+  struct msg *m = msg_chain;
+
+  while (m)
+    {
+      struct msg *next = m->next;
+      arg[0] = m->args;
+      for (i = 0;  i < 4;  i++)
+	arg[i + 1] = arg[i] + strlen (arg[i]) + 1;
+      printf (_(arg[0]), arg[1], arg[2], arg[3], arg[4]);
+      free (m);
+      m = next;
+    }
+}
+
+/* Call before outputting the results of comparing files NAME0 and NAME1
+   to set up OUTFILE, the stdio stream for the output to go to.
+
+   Usually, OUTFILE is just stdout.  But when -l was specified
+   we fork off a `pr' and make OUTFILE a pipe to it.
+   `pr' then outputs to our stdout.  */
+
+static char const *current_name0;
+static char const *current_name1;
+static bool currently_recursive;
+
+void
+setup_output (char const *name0, char const *name1, bool recursive)
+{
+  current_name0 = name0;
+  current_name1 = name1;
+  currently_recursive = recursive;
+  outfile = 0;
+}
+
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+static pid_t pr_pid;
+#endif
+
+void
+begin_output (void)
+{
+  char *name;
+
+  if (outfile != 0)
+    return;
+
+  /* Construct the header of this piece of diff.  */
+  name = xmalloc (strlen (current_name0) + strlen (current_name1)
+		  + strlen (switch_string) + 7);
+
+  /* POSIX 1003.1-2001 specifies this format.  But there are some bugs in
+     the standard: it says that we must print only the last component
+     of the pathnames, and it requires two spaces after "diff" if
+     there are no options.  These requirements are silly and do not
+     match historical practice.  */
+  sprintf (name, "diff%s %s %s", switch_string, current_name0, current_name1);
+
+  if (paginate)
+    {
+      if (fflush (stdout) != 0)
+	pfatal_with_name (_("write failed"));
+
+      /* Make OUTFILE a pipe to a subsidiary `pr'.  */
+      {
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+	int pipes[2];
+
+	if (pipe (pipes) != 0)
+	  pfatal_with_name ("pipe");
+
+	pr_pid = vfork ();
+	if (pr_pid < 0)
+	  pfatal_with_name ("fork");
+
+	if (pr_pid == 0)
+	  {
+	    close (pipes[1]);
+	    if (pipes[0] != STDIN_FILENO)
+	      {
+		if (dup2 (pipes[0], STDIN_FILENO) < 0)
+		  pfatal_with_name ("dup2");
+		close (pipes[0]);
+	      }
+
+	    execl (pr_program, pr_program, "-h", name, (char *) 0);
+	    _exit (errno == ENOENT ? 127 : 126);
+	  }
+	else
+	  {
+	    close (pipes[0]);
+	    outfile = fdopen (pipes[1], "w");
+	    if (!outfile)
+	      pfatal_with_name ("fdopen");
+	  }
+#else
+	char *command = xmalloc (sizeof pr_program - 1 + 7
+				 + shell_quote_length (name) + 1);
+	char *p;
+	sprintf (command, "%s -f -h ", pr_program);
+	p = command + sizeof pr_program - 1 + 7;
+	p = shell_quote_copy (p, name);
+	*p = 0;
+	errno = 0;
+	outfile = popen (command, "w");
+	if (!outfile)
+	  pfatal_with_name (command);
+	free (command);
+#endif
+      }
+    }
+  else
+    {
+
+      /* If -l was not specified, output the diff straight to `stdout'.  */
+
+      outfile = stdout;
+
+      /* If handling multiple files (because scanning a directory),
+	 print which files the following output is about.  */
+      if (currently_recursive)
+	printf ("%s\n", name);
+    }
+
+  free (name);
+
+  /* A special header is needed at the beginning of context output.  */
+  switch (output_style)
+    {
+    case OUTPUT_CONTEXT:
+      print_context_header (files, false);
+      break;
+
+    case OUTPUT_UNIFIED:
+      print_context_header (files, true);
+      break;
+
+    default:
+      break;
+    }
+}
+
+/* Call after the end of output of diffs for one file.
+   Close OUTFILE and get rid of the `pr' subfork.  */
+
+void
+finish_output (void)
+{
+  if (outfile != 0 && outfile != stdout)
+    {
+      int status;
+      int wstatus;
+      int werrno = 0;
+      if (ferror (outfile))
+	fatal ("write failed");
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+      wstatus = pclose (outfile);
+      if (wstatus == -1)
+	werrno = errno;
+#else
+      if (fclose (outfile) != 0)
+	pfatal_with_name (_("write failed"));
+      if (waitpid (pr_pid, &wstatus, 0) < 0)
+	pfatal_with_name ("waitpid");
+#endif
+      status = (! werrno && WIFEXITED (wstatus)
+		? WEXITSTATUS (wstatus)
+		: INT_MAX);
+      if (status)
+	error (EXIT_TROUBLE, werrno,
+	       _(status == 126
+		 ? "subsidiary program '%s' could not be invoked"
+		 : status == 127
+		 ? "subsidiary program '%s' not found"
+		 : status == INT_MAX
+		 ? "subsidiary program '%s' failed"
+		 : "subsidiary program '%s' failed (exit status %d)"),
+	       pr_program, status);
+    }
+
+  outfile = 0;
+}
+
+/* Compare two lines (typically one from each input file)
+   according to the command line options.
+   For efficiency, this is invoked only when the lines do not match exactly
+   but an option like -i might cause us to ignore the difference.
+   Return nonzero if the lines differ.  */
+
+bool
+lines_differ (char const *s1, char const *s2)
+{
+  register char const *t1 = s1;
+  register char const *t2 = s2;
+  size_t column = 0;
+
+  while (1)
+    {
+      register unsigned char c1 = *t1++;
+      register unsigned char c2 = *t2++;
+
+      /* Test for exact char equality first, since it's a common case.  */
+      if (c1 != c2)
+	{
+	  switch (ignore_white_space)
+	    {
+	    case IGNORE_ALL_SPACE:
+	      /* For -w, just skip past any white space.  */
+	      while (isspace (c1) && c1 != '\n') c1 = *t1++;
+	      while (isspace (c2) && c2 != '\n') c2 = *t2++;
+	      break;
+
+	    case IGNORE_SPACE_CHANGE:
+	      /* For -b, advance past any sequence of white space in
+		 line 1 and consider it just one space, or nothing at
+		 all if it is at the end of the line.  */
+	      if (isspace (c1))
+		{
+		  while (c1 != '\n')
+		    {
+		      c1 = *t1++;
+		      if (! isspace (c1))
+			{
+			  --t1;
+			  c1 = ' ';
+			  break;
+			}
+		    }
+		}
+
+	      /* Likewise for line 2.  */
+	      if (isspace (c2))
+		{
+		  while (c2 != '\n')
+		    {
+		      c2 = *t2++;
+		      if (! isspace (c2))
+			{
+			  --t2;
+			  c2 = ' ';
+			  break;
+			}
+		    }
+		}
+
+	      if (c1 != c2)
+		{
+		  /* If we went too far when doing the simple test
+		     for equality, go back to the first non-white-space
+		     character in both sides and try again.  */
+		  if (c2 == ' ' && c1 != '\n'
+		      && s1 + 1 < t1
+		      && isspace ((unsigned char) t1[-2]))
+		    {
+		      --t1;
+		      continue;
+		    }
+		  if (c1 == ' ' && c2 != '\n'
+		      && s2 + 1 < t2
+		      && isspace ((unsigned char) t2[-2]))
+		    {
+		      --t2;
+		      continue;
+		    }
+		}
+
+	      break;
+
+	    case IGNORE_TAB_EXPANSION:
+	      if ((c1 == ' ' && c2 == '\t')
+		  || (c1 == '\t' && c2 == ' '))
+		{
+		  size_t column2 = column;
+		  for (;; c1 = *t1++)
+		    {
+		      if (c1 == ' ')
+			column++;
+		      else if (c1 == '\t')
+			column += tabsize - column % tabsize;
+		      else
+			break;
+		    }
+		  for (;; c2 = *t2++)
+		    {
+		      if (c2 == ' ')
+			column2++;
+		      else if (c2 == '\t')
+			column2 += tabsize - column2 % tabsize;
+		      else
+			break;
+		    }
+		  if (column != column2)
+		    return true;
+		}
+	      break;
+
+	    case IGNORE_NO_WHITE_SPACE:
+	      break;
+	    }
+
+	  /* Lowercase all letters if -i is specified.  */
+
+	  if (ignore_case)
+	    {
+	      c1 = tolower (c1);
+	      c2 = tolower (c2);
+	    }
+
+	  if (c1 != c2)
+	    break;
+	}
+      if (c1 == '\n')
+	return false;
+
+      column += c1 == '\t' ? tabsize - column % tabsize : 1;
+    }
+
+  return true;
+}
+
+/* Find the consecutive changes at the start of the script START.
+   Return the last link before the first gap.  */
+
+struct change *
+find_change (struct change *start)
+{
+  return start;
+}
+
+struct change *
+find_reverse_change (struct change *start)
+{
+  return start;
+}
+
+/* Divide SCRIPT into pieces by calling HUNKFUN and
+   print each piece with PRINTFUN.
+   Both functions take one arg, an edit script.
+
+   HUNKFUN is called with the tail of the script
+   and returns the last link that belongs together with the start
+   of the tail.
+
+   PRINTFUN takes a subscript which belongs together (with a null
+   link at the end) and prints it.  */
+
+void
+print_script (struct change *script,
+	      struct change * (*hunkfun) (struct change *),
+	      void (*printfun) (struct change *))
+{
+  struct change *next = script;
+
+  while (next)
+    {
+      struct change *this, *end;
+
+      /* Find a set of changes that belong together.  */
+      this = next;
+      end = (*hunkfun) (next);
+
+      /* Disconnect them from the rest of the changes,
+	 making them a hunk, and remember the rest for next iteration.  */
+      next = end->link;
+      end->link = 0;
+#ifdef DEBUG
+      debug_script (this);
+#endif
+
+      /* Print this hunk.  */
+      (*printfun) (this);
+
+      /* Reconnect the script so it will all be freed properly.  */
+      end->link = next;
+    }
+}
+
+/* Print the text of a single line LINE,
+   flagging it with the characters in LINE_FLAG (which say whether
+   the line is inserted, deleted, changed, etc.).  LINE_FLAG must not
+   end in a blank, unless it is a single blank.  */
+
+void
+print_1_line (char const *line_flag, char const *const *line)
+{
+  char const *base = line[0], *limit = line[1]; /* Help the compiler.  */
+  FILE *out = outfile; /* Help the compiler some more.  */
+  char const *flag_format = 0;
+
+  /* If -T was specified, use a Tab between the line-flag and the text.
+     Otherwise use a Space (as Unix diff does).
+     Print neither space nor tab if line-flags are empty.
+     But omit trailing blanks if requested.  */
+
+  if (line_flag && *line_flag)
+    {
+      char const *flag_format_1 = flag_format = initial_tab ? "%s\t" : "%s ";
+      char const *line_flag_1 = line_flag;
+
+      if (suppress_blank_empty && **line == '\n')
+	{
+	  flag_format_1 = "%s";
+
+	  /* This hack to omit trailing blanks takes advantage of the
+	     fact that the only way that LINE_FLAG can end in a blank
+	     is when LINE_FLAG consists of a single blank.  */
+	  line_flag_1 += *line_flag_1 == ' ';
+	}
+
+      fprintf (out, flag_format_1, line_flag_1);
+    }
+
+  output_1_line (base, limit, flag_format, line_flag);
+
+  if ((!line_flag || line_flag[0]) && limit[-1] != '\n')
+    fprintf (out, "\n\\ %s\n", _("No newline at end of file"));
+}
+
+/* Output a line from BASE up to LIMIT.
+   With -t, expand white space characters to spaces, and if FLAG_FORMAT
+   is nonzero, output it with argument LINE_FLAG after every
+   internal carriage return, so that tab stops continue to line up.  */
+
+void
+output_1_line (char const *base, char const *limit, char const *flag_format,
+	       char const *line_flag)
+{
+  if (!expand_tabs)
+    fwrite (base, sizeof (char), limit - base, outfile);
+  else
+    {
+      register FILE *out = outfile;
+      register unsigned char c;
+      register char const *t = base;
+      register size_t column = 0;
+      size_t tab_size = tabsize;
+
+      while (t < limit)
+	switch ((c = *t++))
+	  {
+	  case '\t':
+	    {
+	      size_t spaces = tab_size - column % tab_size;
+	      column += spaces;
+	      do
+		putc (' ', out);
+	      while (--spaces);
+	    }
+	    break;
+
+	  case '\r':
+	    putc (c, out);
+	    if (flag_format && t < limit && *t != '\n')
+	      fprintf (out, flag_format, line_flag);
+	    column = 0;
+	    break;
+
+	  case '\b':
+	    if (column == 0)
+	      continue;
+	    column--;
+	    putc (c, out);
+	    break;
+
+	  default:
+	    column += isprint (c) != 0;
+	    putc (c, out);
+	    break;
+	  }
+    }
+}
+
+char const change_letter[] = { 0, 'd', 'a', 'c' };
+
+/* Translate an internal line number (an index into diff's table of lines)
+   into an actual line number in the input file.
+   The internal line number is I.  FILE points to the data on the file.
+
+   Internal line numbers count from 0 starting after the prefix.
+   Actual line numbers count from 1 within the entire file.  */
+
+lin
+translate_line_number (struct file_data const *file, lin i)
+{
+  return i + file->prefix_lines + 1;
+}
+
+/* Translate a line number range.  This is always done for printing,
+   so for convenience translate to long int rather than lin, so that the
+   caller can use printf with "%ld" without casting.  */
+
+void
+translate_range (struct file_data const *file,
+		 lin a, lin b,
+		 long int *aptr, long int *bptr)
+{
+  *aptr = translate_line_number (file, a - 1) + 1;
+  *bptr = translate_line_number (file, b + 1) - 1;
+}
+
+/* Print a pair of line numbers with SEPCHAR, translated for file FILE.
+   If the two numbers are identical, print just one number.
+
+   Args A and B are internal line numbers.
+   We print the translated (real) line numbers.  */
+
+void
+print_number_range (char sepchar, struct file_data *file, lin a, lin b)
+{
+  long int trans_a, trans_b;
+  translate_range (file, a, b, &trans_a, &trans_b);
+
+  /* Note: we can have B < A in the case of a range of no lines.
+     In this case, we should print the line number before the range,
+     which is B.  */
+  if (trans_b > trans_a)
+    fprintf (outfile, "%ld%c%ld", trans_a, sepchar, trans_b);
+  else
+    fprintf (outfile, "%ld", trans_b);
+}
+
+/* Look at a hunk of edit script and report the range of lines in each file
+   that it applies to.  HUNK is the start of the hunk, which is a chain
+   of `struct change'.  The first and last line numbers of file 0 are stored in
+   *FIRST0 and *LAST0, and likewise for file 1 in *FIRST1 and *LAST1.
+   Note that these are internal line numbers that count from 0.
+
+   If no lines from file 0 are deleted, then FIRST0 is LAST0+1.
+
+   Return UNCHANGED if only ignorable lines are inserted or deleted,
+   OLD if lines of file 0 are deleted,
+   NEW if lines of file 1 are inserted,
+   and CHANGED if both kinds of changes are found. */
+
+enum changes
+analyze_hunk (struct change *hunk,
+	      lin *first0, lin *last0,
+	      lin *first1, lin *last1)
+{
+  struct change *next;
+  lin l0, l1;
+  lin show_from, show_to;
+  lin i;
+  bool trivial = ignore_blank_lines || ignore_regexp.fastmap;
+  size_t trivial_length = ignore_blank_lines - 1;
+    /* If 0, ignore zero-length lines;
+       if SIZE_MAX, do not ignore lines just because of their length.  */
+  bool skip_leading_white_space =
+    (ignore_blank_lines && IGNORE_SPACE_CHANGE <= ignore_white_space);
+
+  char const * const *linbuf0 = files[0].linbuf;  /* Help the compiler.  */
+  char const * const *linbuf1 = files[1].linbuf;
+
+  show_from = show_to = 0;
+
+  *first0 = hunk->line0;
+  *first1 = hunk->line1;
+
+  next = hunk;
+  do
+    {
+      l0 = next->line0 + next->deleted - 1;
+      l1 = next->line1 + next->inserted - 1;
+      show_from += next->deleted;
+      show_to += next->inserted;
+
+      for (i = next->line0; i <= l0 && trivial; i++)
+	{
+	  char const *line = linbuf0[i];
+	  char const *newline = linbuf0[i + 1] - 1;
+	  size_t len = newline - line;
+	  char const *p = line;
+	  if (skip_leading_white_space)
+	    while (isspace ((unsigned char) *p) && *p != '\n')
+	      p++;
+	  if (newline - p != trivial_length
+	      && (! ignore_regexp.fastmap
+		  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
+	    trivial = 0;
+	}
+
+      for (i = next->line1; i <= l1 && trivial; i++)
+	{
+	  char const *line = linbuf1[i];
+	  char const *newline = linbuf1[i + 1] - 1;
+	  size_t len = newline - line;
+	  char const *p = line;
+	  if (skip_leading_white_space)
+	    while (isspace ((unsigned char) *p) && *p != '\n')
+	      p++;
+	  if (newline - p != trivial_length
+	      && (! ignore_regexp.fastmap
+		  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
+	    trivial = 0;
+	}
+    }
+  while ((next = next->link) != 0);
+
+  *last0 = l0;
+  *last1 = l1;
+
+  /* If all inserted or deleted lines are ignorable,
+     tell the caller to ignore this hunk.  */
+
+  if (trivial)
+    return UNCHANGED;
+
+  return (show_from ? OLD : UNCHANGED) | (show_to ? NEW : UNCHANGED);
+}
+
+/* Concatenate three strings, returning a newly malloc'd string.  */
+
+char *
+concat (char const *s1, char const *s2, char const *s3)
+{
+  char *new = xmalloc (strlen (s1) + strlen (s2) + strlen (s3) + 1);
+  sprintf (new, "%s%s%s", s1, s2, s3);
+  return new;
+}
+
+/* Yield a new block of SIZE bytes, initialized to zero.  */
+
+void *
+zalloc (size_t size)
+{
+  void *p = xmalloc (size);
+  memset (p, 0, size);
+  return p;
+}
+
+/* Yield the newly malloc'd pathname
+   of the file in DIR whose filename is FILE.  */
+
+char *
+dir_file_pathname (char const *dir, char const *file)
+{
+  char const *base = last_component (dir);
+  size_t baselen = base_len (base);
+  bool omit_slash = baselen == 0 || base[baselen - 1] == '/';
+  return concat (dir, "/" + omit_slash, file);
+}
+
+void
+debug_script (struct change *sp)
+{
+  fflush (stdout);
+
+  for (; sp; sp = sp->link)
+    {
+      long int line0 = sp->line0;
+      long int line1 = sp->line1;
+      long int deleted = sp->deleted;
+      long int inserted = sp->inserted;
+      fprintf (stderr, "%3ld %3ld delete %ld insert %ld\n",
+	       line0, line1, deleted, inserted);
+    }
+
+  fflush (stderr);
+}
diff --git a/test/diffutils b/test/diffutils
new file mode 160000
index 0000000..487e009
--- /dev/null
+++ b/test/diffutils
@@ -0,0 +1 @@
+Subproject commit 487e009ed7294021dcc0b66c2b5a5046aea51ab4
diff --git a/test/diffutils-3.0-patch/Makefile.am b/test/diffutils-3.0-patch/Makefile.am
new file mode 100644
index 0000000..48fbf7d
--- /dev/null
+++ b/test/diffutils-3.0-patch/Makefile.am
@@ -0,0 +1,55 @@
+# Automakefile for GNU diffutils programs.
+
+# Copyright (C) 2001-2002, 2006, 2009-2010 Free Software Foundation, Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+bin_PROGRAMS = cmp diff diff3 sdiff
+
+noinst_HEADERS = system.h
+
+localedir = $(datadir)/locale
+
+AM_CPPFLAGS = -I../lib -I$(top_srcdir)/lib
+AM_CFLAGS = $(WARN_CFLAGS) $(WERROR_CFLAGS)
+
+LDADD = \
+  ../lib/libdiffutils.a \
+  $(LIBCSTACK) \
+  $(LIBINTL) \
+  $(LIBICONV) \
+  $(LIBSIGSEGV) \
+  $(LIB_CLOCK_GETTIME)
+
+diff_LDADD = $(LDADD)
+cmp_LDADD = $(LDADD)
+sdiff_LDADD = $(LDADD)
+diff3_LDADD = $(LDADD)
+
+cmp_SOURCES = cmp.c
+diff3_SOURCES = diff3.c
+sdiff_SOURCES = sdiff.c
+diff_SOURCES = \
+  analyze.c context.c diff.c diff.h dir.c ed.c ifdef.c io.c \
+  normal.c side.c util.c
+
+MOSTLYCLEANFILES = paths.h paths.ht
+
+cmp.$(OBJEXT) diff3.$(OBJEXT) diff.$(OBJEXT) sdiff.$(OBJEXT): paths.h
+
+gdiff = `echo diff|sed '$(transform)'`
+BUILT_SOURCES = paths.h
+paths.h: Makefile.am
+	$(AM_V_GEN)(echo '#define DEFAULT_DIFF_PROGRAM "'$(gdiff)'"' && \
+	  echo '#define LOCALEDIR "$(localedir)"') >$@t && mv $@t $@
diff --git a/test/diffutils-3.0-patch/analyze.c b/test/diffutils-3.0-patch/analyze.c
new file mode 100644
index 0000000..e797248
--- /dev/null
+++ b/test/diffutils-3.0-patch/analyze.c
@@ -0,0 +1,723 @@
+/* Analyze file differences for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006-2007,
+   2009-2010 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <cmpbuf.h>
+#include <error.h>
+#include <file-type.h>
+#include <xalloc.h>
+
+/* The core of the Diff algorithm.  */
+#define ELEMENT lin
+#define EQUAL(x,y) ((x) == (y))
+#define OFFSET lin
+#define EXTRA_CONTEXT_FIELDS /* none */
+#define NOTE_DELETE(c, xoff) (files[0].changed[files[0].realindexes[xoff]] = 1)
+#define NOTE_INSERT(c, yoff) (files[1].changed[files[1].realindexes[yoff]] = 1)
+#define USE_HEURISTIC 1
+#include <diffseq.h>
+
+/* Discard lines from one file that have no matches in the other file.
+
+   A line which is discarded will not be considered by the actual
+   comparison algorithm; it will be as if that line were not in the file.
+   The file's `realindexes' table maps virtual line numbers
+   (which don't count the discarded lines) into real line numbers;
+   this is how the actual comparison algorithm produces results
+   that are comprehensible when the discarded lines are counted.
+
+   When we discard a line, we also mark it as a deletion or insertion
+   so that it will be printed in the output.  */
+
+static void
+discard_confusing_lines (struct file_data filevec[])
+{
+  int f;
+  lin i;
+  char *discarded[2];
+  lin *equiv_count[2];
+  lin *p;
+
+  /* Allocate our results.  */
+  p = xmalloc ((filevec[0].buffered_lines + filevec[1].buffered_lines)
+	       * (2 * sizeof *p));
+  for (f = 0; f < 2; f++)
+    {
+      filevec[f].undiscarded = p;  p += filevec[f].buffered_lines;
+      filevec[f].realindexes = p;  p += filevec[f].buffered_lines;
+    }
+
+  /* Set up equiv_count[F][I] as the number of lines in file F
+     that fall in equivalence class I.  */
+
+  p = zalloc (filevec[0].equiv_max * (2 * sizeof *p));
+  equiv_count[0] = p;
+  equiv_count[1] = p + filevec[0].equiv_max;
+
+  for (i = 0; i < filevec[0].buffered_lines; ++i)
+    ++equiv_count[0][filevec[0].equivs[i]];
+  for (i = 0; i < filevec[1].buffered_lines; ++i)
+    ++equiv_count[1][filevec[1].equivs[i]];
+
+  /* Set up tables of which lines are going to be discarded.  */
+
+  discarded[0] = zalloc (filevec[0].buffered_lines
+			 + filevec[1].buffered_lines);
+  discarded[1] = discarded[0] + filevec[0].buffered_lines;
+
+  /* Mark to be discarded each line that matches no line of the other file.
+     If a line matches many lines, mark it as provisionally discardable.  */
+
+  for (f = 0; f < 2; f++)
+    {
+      size_t end = filevec[f].buffered_lines;
+      char *discards = discarded[f];
+      lin *counts = equiv_count[1 - f];
+      lin *equivs = filevec[f].equivs;
+      size_t many = 5;
+      size_t tem = end / 64;
+
+      /* Multiply MANY by approximate square root of number of lines.
+	 That is the threshold for provisionally discardable lines.  */
+      while ((tem = tem >> 2) > 0)
+	many *= 2;
+
+      for (i = 0; i < end; i++)
+	{
+	  lin nmatch;
+	  if (equivs[i] == 0)
+	    continue;
+	  nmatch = counts[equivs[i]];
+	  if (nmatch == 0)
+	    discards[i] = 1;
+	  else if (nmatch > many)
+	    discards[i] = 2;
+	}
+    }
+
+  /* Don't really discard the provisional lines except when they occur
+     in a run of discardables, with nonprovisionals at the beginning
+     and end.  */
+
+  for (f = 0; f < 2; f++)
+    {
+      lin end = filevec[f].buffered_lines;
+      register char *discards = discarded[f];
+
+      for (i = 0; i < end; i++)
+	{
+	  /* Cancel provisional discards not in middle of run of discards.  */
+	  if (discards[i] == 2)
+	    discards[i] = 0;
+	  else if (discards[i] != 0)
+	    {
+	      /* We have found a nonprovisional discard.  */
+	      register lin j;
+	      lin length;
+	      lin provisional = 0;
+
+	      /* Find end of this run of discardable lines.
+		 Count how many are provisionally discardable.  */
+	      for (j = i; j < end; j++)
+		{
+		  if (discards[j] == 0)
+		    break;
+		  if (discards[j] == 2)
+		    ++provisional;
+		}
+
+	      /* Cancel provisional discards at end, and shrink the run.  */
+	      while (j > i && discards[j - 1] == 2)
+		discards[--j] = 0, --provisional;
+
+	      /* Now we have the length of a run of discardable lines
+		 whose first and last are not provisional.  */
+	      length = j - i;
+
+	      /* If 1/4 of the lines in the run are provisional,
+		 cancel discarding of all provisional lines in the run.  */
+	      if (provisional * 4 > length)
+		{
+		  while (j > i)
+		    if (discards[--j] == 2)
+		      discards[j] = 0;
+		}
+	      else
+		{
+		  register lin consec;
+		  lin minimum = 1;
+		  lin tem = length >> 2;
+
+		  /* MINIMUM is approximate square root of LENGTH/4.
+		     A subrun of two or more provisionals can stand
+		     when LENGTH is at least 16.
+		     A subrun of 4 or more can stand when LENGTH >= 64.  */
+		  while (0 < (tem >>= 2))
+		    minimum <<= 1;
+		  minimum++;
+
+		  /* Cancel any subrun of MINIMUM or more provisionals
+		     within the larger run.  */
+		  for (j = 0, consec = 0; j < length; j++)
+		    if (discards[i + j] != 2)
+		      consec = 0;
+		    else if (minimum == ++consec)
+		      /* Back up to start of subrun, to cancel it all.  */
+		      j -= consec;
+		    else if (minimum < consec)
+		      discards[i + j] = 0;
+
+		  /* Scan from beginning of run
+		     until we find 3 or more nonprovisionals in a row
+		     or until the first nonprovisional at least 8 lines in.
+		     Until that point, cancel any provisionals.  */
+		  for (j = 0, consec = 0; j < length; j++)
+		    {
+		      if (j >= 8 && discards[i + j] == 1)
+			break;
+		      if (discards[i + j] == 2)
+			consec = 0, discards[i + j] = 0;
+		      else if (discards[i + j] == 0)
+			consec = 0;
+		      else
+			consec++;
+		      if (consec == 3)
+			break;
+		    }
+
+		  /* I advances to the last line of the run.  */
+		  i += length - 1;
+
+		  /* Same thing, from end.  */
+		  for (j = 0, consec = 0; j < length; j++)
+		    {
+		      if (j >= 8 && discards[i - j] == 1)
+			break;
+		      if (discards[i - j] == 2)
+			consec = 0, discards[i - j] = 0;
+		      else if (discards[i - j] == 0)
+			consec = 0;
+		      else
+			consec++;
+		      if (consec == 3)
+			break;
+		    }
+		}
+	    }
+	}
+    }
+
+  /* Actually discard the lines. */
+  for (f = 0; f < 2; f++)
+    {
+      char *discards = discarded[f];
+      lin end = filevec[f].buffered_lines;
+      lin j = 0;
+      for (i = 0; i < end; ++i)
+	if (minimal || discards[i] == 0)
+	  {
+	    filevec[f].undiscarded[j] = filevec[f].equivs[i];
+	    filevec[f].realindexes[j++] = i;
+	  }
+	else
+	  filevec[f].changed[i] = 1;
+      filevec[f].nondiscarded_lines = j;
+    }
+
+  free (discarded[0]);
+  free (equiv_count[0]);
+}
+
+/* Adjust inserts/deletes of identical lines to join changes
+   as much as possible.
+
+   We do something when a run of changed lines include a
+   line at one end and have an excluded, identical line at the other.
+   We are free to choose which identical line is included.
+   `compareseq' usually chooses the one at the beginning,
+   but usually it is cleaner to consider the following identical line
+   to be the "change".  */
+
+static void
+shift_boundaries (struct file_data filevec[])
+{
+  int f;
+
+  for (f = 0; f < 2; f++)
+    {
+      char *changed = filevec[f].changed;
+      char *other_changed = filevec[1 - f].changed;
+      lin const *equivs = filevec[f].equivs;
+      lin i = 0;
+      lin j = 0;
+      lin i_end = filevec[f].buffered_lines;
+
+      while (1)
+	{
+	  lin runlength, start, corresponding;
+
+	  /* Scan forwards to find beginning of another run of changes.
+	     Also keep track of the corresponding point in the other file.  */
+
+	  while (i < i_end && !changed[i])
+	    {
+	      while (other_changed[j++])
+		continue;
+	      i++;
+	    }
+
+	  if (i == i_end)
+	    break;
+
+	  start = i;
+
+	  /* Find the end of this run of changes.  */
+
+	  while (changed[++i])
+	    continue;
+	  while (other_changed[j])
+	    j++;
+
+	  do
+	    {
+	      /* Record the length of this run of changes, so that
+		 we can later determine whether the run has grown.  */
+	      runlength = i - start;
+
+	      /* Move the changed region back, so long as the
+		 previous unchanged line matches the last changed one.
+		 This merges with previous changed regions.  */
+
+	      while (start && equivs[start - 1] == equivs[i - 1])
+		{
+		  changed[--start] = 1;
+		  changed[--i] = 0;
+		  while (changed[start - 1])
+		    start--;
+		  while (other_changed[--j])
+		    continue;
+		}
+
+	      /* Set CORRESPONDING to the end of the changed run, at the last
+		 point where it corresponds to a changed run in the other file.
+		 CORRESPONDING == I_END means no such point has been found.  */
+	      corresponding = other_changed[j - 1] ? i : i_end;
+
+	      /* Move the changed region forward, so long as the
+		 first changed line matches the following unchanged one.
+		 This merges with following changed regions.
+		 Do this second, so that if there are no merges,
+		 the changed region is moved forward as far as possible.  */
+
+	      while (i != i_end && equivs[start] == equivs[i])
+		{
+		  changed[start++] = 0;
+		  changed[i++] = 1;
+		  while (changed[i])
+		    i++;
+		  while (other_changed[++j])
+		    corresponding = i;
+		}
+	    }
+	  while (runlength != i - start);
+
+	  /* If possible, move the fully-merged run of changes
+	     back to a corresponding run in the other file.  */
+
+	  while (corresponding < i)
+	    {
+	      changed[--start] = 1;
+	      changed[--i] = 0;
+	      while (other_changed[--j])
+		continue;
+	    }
+	}
+    }
+}
+
+/* Cons an additional entry onto the front of an edit script OLD.
+   LINE0 and LINE1 are the first affected lines in the two files (origin 0).
+   DELETED is the number of lines deleted here from file 0.
+   INSERTED is the number of lines inserted here in file 1.
+
+   If DELETED is 0 then LINE0 is the number of the line before
+   which the insertion was done; vice versa for INSERTED and LINE1.  */
+
+static struct change *
+add_change (lin line0, lin line1, lin deleted, lin inserted,
+	    struct change *old)
+{
+  struct change *new = xmalloc (sizeof *new);
+
+  new->line0 = line0;
+  new->line1 = line1;
+  new->inserted = inserted;
+  new->deleted = deleted;
+  new->link = old;
+  return new;
+}
+
+/* Scan the tables of which lines are inserted and deleted,
+   producing an edit script in reverse order.  */
+
+static struct change *
+build_reverse_script (struct file_data const filevec[])
+{
+  struct change *script = 0;
+  char *changed0 = filevec[0].changed;
+  char *changed1 = filevec[1].changed;
+  lin len0 = filevec[0].buffered_lines;
+  lin len1 = filevec[1].buffered_lines;
+
+  /* Note that changedN[lenN] does exist, and is 0.  */
+
+  lin i0 = 0, i1 = 0;
+
+  while (i0 < len0 || i1 < len1)
+    {
+      if (changed0[i0] | changed1[i1])
+	{
+	  lin line0 = i0, line1 = i1;
+
+	  /* Find # lines changed here in each file.  */
+	  while (changed0[i0]) ++i0;
+	  while (changed1[i1]) ++i1;
+
+	  /* Record this change.  */
+	  script = add_change (line0, line1, i0 - line0, i1 - line1, script);
+	}
+
+      /* We have reached lines in the two files that match each other.  */
+      i0++, i1++;
+    }
+
+  return script;
+}
+
+/* Scan the tables of which lines are inserted and deleted,
+   producing an edit script in forward order.  */
+
+static struct change *
+build_script (struct file_data const filevec[])
+{
+  struct change *script = 0;
+  char *changed0 = filevec[0].changed;
+  char *changed1 = filevec[1].changed;
+  lin i0 = filevec[0].buffered_lines, i1 = filevec[1].buffered_lines;
+
+  /* Note that changedN[-1] does exist, and is 0.  */
+
+  while (i0 >= 0 || i1 >= 0)
+    {
+      if (changed0[i0 - 1] | changed1[i1 - 1])
+	{
+	  lin line0 = i0, line1 = i1;
+
+	  /* Find # lines changed here in each file.  */
+	  while (changed0[i0 - 1]) --i0;
+	  while (changed1[i1 - 1]) --i1;
+
+	  /* Record this change.  */
+	  script = add_change (i0, i1, line0 - i0, line1 - i1, script);
+	}
+
+      /* We have reached lines in the two files that match each other.  */
+      i0--, i1--;
+    }
+
+  return script;
+}
+
+/* If CHANGES, briefly report that two files differed.
+   Return 2 if trouble, CHANGES otherwise.  */
+static int
+briefly_report (int changes, struct file_data const filevec[])
+{
+  if (changes)
+    {
+      char const *label0 = file_label[0] ? file_label[0] : filevec[0].name;
+      char const *label1 = file_label[1] ? file_label[1] : filevec[1].name;
+
+      if (brief)
+	message ("Files %s and %s differ\n", label0, label1);
+      else
+	{
+	  message ("Binary files %s and %s differ\n", label0, label1);
+	  changes = 2;
+	}
+    }
+
+  return changes;
+}
+
+/* Report the differences of two files.  */
+int
+diff_2_files (struct comparison *cmp)
+{
+  int f;
+  struct change *e, *p;
+  struct change *script;
+  int changes;
+
+
+  /* If we have detected that either file is binary,
+     compare the two files as binary.  This can happen
+     only when the first chunk is read.
+     Also, --brief without any --ignore-* options means
+     we can speed things up by treating the files as binary.  */
+
+  if (read_files (cmp->file, files_can_be_treated_as_binary))
+    {
+      /* Files with different lengths must be different.  */
+      if (cmp->file[0].stat.st_size != cmp->file[1].stat.st_size
+	  && (cmp->file[0].desc < 0 || S_ISREG (cmp->file[0].stat.st_mode))
+	  && (cmp->file[1].desc < 0 || S_ISREG (cmp->file[1].stat.st_mode)))
+	changes = 1;
+
+      /* Standard input equals itself.  */
+      else if (cmp->file[0].desc == cmp->file[1].desc)
+	changes = 0;
+
+      else
+	/* Scan both files, a buffer at a time, looking for a difference.  */
+	{
+	  /* Allocate same-sized buffers for both files.  */
+	  size_t lcm_max = PTRDIFF_MAX - 1;
+	  size_t buffer_size =
+	    buffer_lcm (sizeof (word),
+			buffer_lcm (STAT_BLOCKSIZE (cmp->file[0].stat),
+				    STAT_BLOCKSIZE (cmp->file[1].stat),
+				    lcm_max),
+			lcm_max);
+	  for (f = 0; f < 2; f++)
+	    cmp->file[f].buffer = xrealloc (cmp->file[f].buffer, buffer_size);
+
+	  for (;; cmp->file[0].buffered = cmp->file[1].buffered = 0)
+	    {
+	      /* Read a buffer's worth from both files.  */
+	      for (f = 0; f < 2; f++)
+		if (0 <= cmp->file[f].desc)
+		  file_block_read (&cmp->file[f],
+				   buffer_size - cmp->file[f].buffered);
+
+	      /* If the buffers differ, the files differ.  */
+	      if (cmp->file[0].buffered != cmp->file[1].buffered
+		  || memcmp (cmp->file[0].buffer,
+			     cmp->file[1].buffer,
+			     cmp->file[0].buffered))
+		{
+		  changes = 1;
+		  break;
+		}
+
+	      /* If we reach end of file, the files are the same.  */
+	      if (cmp->file[0].buffered != buffer_size)
+		{
+		  changes = 0;
+		  break;
+		}
+	    }
+	}
+
+      changes = briefly_report (changes, cmp->file);
+    }
+  else
+    {
+      struct context ctxt;
+      lin diags;
+      lin too_expensive;
+
+      /* Allocate vectors for the results of comparison:
+	 a flag for each line of each file, saying whether that line
+	 is an insertion or deletion.
+	 Allocate an extra element, always 0, at each end of each vector.  */
+
+      size_t s = cmp->file[0].buffered_lines + cmp->file[1].buffered_lines + 4;
+      char *flag_space = zalloc (s);
+      cmp->file[0].changed = flag_space + 1;
+      cmp->file[1].changed = flag_space + cmp->file[0].buffered_lines + 3;
+
+      /* Some lines are obviously insertions or deletions
+	 because they don't match anything.  Detect them now, and
+	 avoid even thinking about them in the main comparison algorithm.  */
+
+      discard_confusing_lines (cmp->file);
+
+      /* Now do the main comparison algorithm, considering just the
+	 undiscarded lines.  */
+
+      ctxt.xvec = cmp->file[0].undiscarded;
+      ctxt.yvec = cmp->file[1].undiscarded;
+      diags = (cmp->file[0].nondiscarded_lines
+	       + cmp->file[1].nondiscarded_lines + 3);
+      ctxt.fdiag = xmalloc (diags * (2 * sizeof *ctxt.fdiag));
+      ctxt.bdiag = ctxt.fdiag + diags;
+      ctxt.fdiag += cmp->file[1].nondiscarded_lines + 1;
+      ctxt.bdiag += cmp->file[1].nondiscarded_lines + 1;
+
+      ctxt.heuristic = speed_large_files;
+
+      /* Set TOO_EXPENSIVE to be approximate square root of input size,
+	 bounded below by 256.  */
+      too_expensive = 1;
+      for (;  diags != 0;  diags >>= 2)
+	too_expensive <<= 1;
+      ctxt.too_expensive = MAX (256, too_expensive);
+
+      files[0] = cmp->file[0];
+      files[1] = cmp->file[1];
+
+      compareseq (0, cmp->file[0].nondiscarded_lines,
+		  0, cmp->file[1].nondiscarded_lines, minimal, &ctxt);
+
+      free (ctxt.fdiag - (cmp->file[1].nondiscarded_lines + 1));
+
+      /* Modify the results slightly to make them prettier
+	 in cases where that can validly be done.  */
+
+      shift_boundaries (cmp->file);
+
+      /* Get the results of comparison in the form of a chain
+	 of `struct change's -- an edit script.  */
+
+      if (output_style == OUTPUT_ED)
+	script = build_reverse_script (cmp->file);
+      else
+	script = build_script (cmp->file);
+
+      /* Set CHANGES if we had any diffs.
+	 If some changes are ignored, we must scan the script to decide.  */
+      if (ignore_blank_lines || ignore_regexp.fastmap)
+	{
+	  struct change *next = script;
+	  changes = 0;
+
+	  while (next && changes == 0)
+	    {
+	      struct change *this, *end;
+	      lin first0, last0, first1, last1;
+
+	      /* Find a set of changes that belong together.  */
+	      this = next;
+	      end = find_change (next);
+
+	      /* Disconnect them from the rest of the changes, making them
+		 a hunk, and remember the rest for next iteration.  */
+	      next = end->link;
+	      end->link = 0;
+
+	      /* Determine whether this hunk is really a difference.  */
+	      if (analyze_hunk (this, &first0, &last0, &first1, &last1))
+		changes = 1;
+
+	      /* Reconnect the script so it will all be freed properly.  */
+	      end->link = next;
+	    }
+	}
+      else
+	changes = (script != 0);
+
+      if (brief)
+	changes = briefly_report (changes, cmp->file);
+      else
+	{
+	  if (changes || !no_diff_means_no_output)
+	    {
+	      /* Record info for starting up output,
+		 to be used if and when we have some output to print.  */
+	      setup_output (file_label[0] ? file_label[0] : cmp->file[0].name,
+			    file_label[1] ? file_label[1] : cmp->file[1].name,
+			    cmp->parent != 0);
+
+	      switch (output_style)
+		{
+		case OUTPUT_CONTEXT:
+		  print_context_script (script, false);
+		  break;
+
+		case OUTPUT_UNIFIED:
+		  print_context_script (script, true);
+		  break;
+
+		case OUTPUT_ED:
+		  print_ed_script (script);
+		  break;
+
+		case OUTPUT_FORWARD_ED:
+		  pr_forward_ed_script (script);
+		  break;
+
+		case OUTPUT_RCS:
+		  print_rcs_script (script);
+		  break;
+
+		case OUTPUT_NORMAL:
+		  print_normal_script (script);
+		  break;
+
+		case OUTPUT_IFDEF:
+		  print_ifdef_script (script);
+		  break;
+
+		case OUTPUT_SDIFF:
+		  print_sdiff_script (script);
+		  break;
+
+		default:
+		  abort ();
+		}
+
+	      finish_output ();
+	    }
+	}
+
+      free (cmp->file[0].undiscarded);
+
+      free (flag_space);
+
+      for (f = 0; f < 2; f++)
+	{
+	  free (cmp->file[f].equivs);
+	  free (cmp->file[f].linbuf + cmp->file[f].linbuf_base);
+	}
+
+      for (e = script; e; e = p)
+	{
+	  p = e->link;
+	  free (e);
+	}
+
+      if (! ROBUST_OUTPUT_STYLE (output_style))
+	for (f = 0; f < 2; ++f)
+	  if (cmp->file[f].missing_newline)
+	    {
+	      error (0, 0, "%s: %s\n",
+		     file_label[f] ? file_label[f] : cmp->file[f].name,
+		     _("No newline at end of file"));
+	      changes = 2;
+	    }
+    }
+
+  if (cmp->file[0].buffer != cmp->file[1].buffer)
+    free (cmp->file[0].buffer);
+  free (cmp->file[1].buffer);
+
+  return changes;
+}
diff --git a/test/diffutils-3.0-patch/cmp b/test/diffutils-3.0-patch/cmp
new file mode 100755
index 0000000000000000000000000000000000000000..1ce19d349a464e0e695c57bc891d53e693f6ec84
GIT binary patch
literal 178488
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
Shw#}AfB74W*TIB?ruZ9`1?*J-

literal 0
HcmV?d00001

diff --git a/test/diffutils-3.0-patch/cmp.c b/test/diffutils-3.0-patch/cmp.c
new file mode 100644
index 0000000..e19f013
--- /dev/null
+++ b/test/diffutils-3.0-patch/cmp.c
@@ -0,0 +1,685 @@
+/* cmp - compare two files byte by byte
+
+   Copyright (C) 1990-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2010 Free
+   Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+
+#include <c-stack.h>
+#include <cmpbuf.h>
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <hard-locale.h>
+#include <inttostr.h>
+#include <progname.h>
+#include <unlocked-io.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <xfreopen.h>
+#include <xstrtol.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "cmp"
+
+#define AUTHORS \
+  proper_name_utf8 ("Torbjorn Granlund", "Torbj\303\266rn Granlund"), \
+  proper_name ("David MacKenzie")
+
+#if defined LC_MESSAGES && ENABLE_NLS
+# define hard_locale_LC_MESSAGES hard_locale (LC_MESSAGES)
+#else
+# define hard_locale_LC_MESSAGES 0
+#endif
+
+static int cmp (void);
+static off_t file_position (int);
+static size_t block_compare (word const *, word const *);
+static size_t block_compare_and_count (word const *, word const *, off_t *);
+static void sprintc (char *, unsigned char);
+
+/* Filenames of the compared files.  */
+static char const *file[2];
+
+/* File descriptors of the files.  */
+static int file_desc[2];
+
+/* Status of the files.  */
+static struct stat stat_buf[2];
+
+/* Read buffers for the files.  */
+static word *buffer[2];
+
+/* Optimal block size for the files.  */
+static size_t buf_size;
+
+/* Initial prefix to ignore for each file.  */
+static off_t ignore_initial[2];
+
+/* Number of bytes to compare.  */
+static uintmax_t bytes = UINTMAX_MAX;
+
+/* Output format.  */
+static enum comparison_type
+  {
+    type_first_diff,	/* Print the first difference.  */
+    type_all_diffs,	/* Print all differences.  */
+    type_no_stdout,	/* Do not output to stdout; only stderr.  */
+    type_status		/* Exit status only.  */
+  } comparison_type;
+
+/* If nonzero, print values of bytes quoted like cat -t does. */
+static bool opt_print_bytes;
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  HELP_OPTION = CHAR_MAX + 1
+};
+
+static struct option const long_options[] =
+{
+  {"print-bytes", 0, 0, 'b'},
+  {"print-chars", 0, 0, 'c'}, /* obsolescent as of diffutils 2.7.3 */
+  {"ignore-initial", 1, 0, 'i'},
+  {"verbose", 0, 0, 'l'},
+  {"bytes", 1, 0, 'n'},
+  {"silent", 0, 0, 's'},
+  {"quiet", 0, 0, 's'},
+  {"version", 0, 0, 'v'},
+  {"help", 0, 0, HELP_OPTION},
+  {0, 0, 0, 0}
+};
+
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0,
+	 _("Try '%s --help' for more information."), program_name);
+  abort ();
+}
+
+static char const valid_suffixes[] = "kKMGTPEZY0";
+
+/* Update ignore_initial[F] according to the result of parsing an
+   *operand ARGPTR of --ignore-initial, updating *ARGPTR to point
+   *after the operand.  If DELIMITER is nonzero, the operand may be
+   *followed by DELIMITER; otherwise it must be null-terminated.  */
+static void
+specify_ignore_initial (int f, char **argptr, char delimiter)
+{
+  uintmax_t val;
+  char const *arg = *argptr;
+  strtol_error e = xstrtoumax (arg, argptr, 0, &val, valid_suffixes);
+  if (! (e == LONGINT_OK
+	 || (e == LONGINT_INVALID_SUFFIX_CHAR && **argptr == delimiter))
+      || TYPE_MAXIMUM (off_t) < val)
+    try_help ("invalid --ignore-initial value '%s'", arg);
+  if (ignore_initial[f] < val)
+    ignore_initial[f] = val;
+}
+
+/* Specify the output format.  */
+static void
+specify_comparison_type (enum comparison_type t)
+{
+  if (comparison_type && comparison_type != t)
+    try_help ("options -l and -s are incompatible", 0);
+  comparison_type = t;
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    error (EXIT_TROUBLE, 0, "%s", _("write failed"));
+  else if (fclose (stdout) != 0)
+    error (EXIT_TROUBLE, errno, "%s", _("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-b  --print-bytes  Print differing bytes."),
+  N_("-i SKIP  --ignore-initial=SKIP  Skip the first SKIP bytes of input."),
+  N_("-i SKIP1:SKIP2  --ignore-initial=SKIP1:SKIP2"),
+  N_("  Skip the first SKIP1 bytes of FILE1 and the first SKIP2 bytes of FILE2."),
+  N_("-l  --verbose  Output byte numbers and values of all differing bytes."),
+  N_("-n LIMIT  --bytes=LIMIT  Compare at most LIMIT bytes."),
+  N_("-s  --quiet  --silent  Output nothing; yield exit status only."),
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILE1 [FILE2 [SKIP1 [SKIP2]]]\n"),
+	  program_name);
+  printf ("%s\n\n", _("Compare two files byte by byte."));
+  for (p = option_help_msgid;  *p;  p++)
+    printf ("  %s\n", _(*p));
+  printf ("\n%s\n%s\n\n%s\n%s\n",
+	  _("SKIP1 and SKIP2 are the number of bytes to skip in each file."),
+	  _("SKIP values may be followed by the following multiplicative suffixes:\n\
+kB 1000, K 1024, MB 1,000,000, M 1,048,576,\n\
+GB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y."),
+	  _("If a FILE is '-' or missing, read standard input."),
+	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+int
+main (int argc, char **argv)
+{
+  int c, f, exit_status;
+  size_t words_per_buffer;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+
+  /* Parse command line options.  */
+
+  while ((c = getopt_long (argc, argv, "bci:ln:sv", long_options, 0))
+	 != -1)
+    switch (c)
+      {
+      case 'b':
+      case 'c': /* 'c' is obsolescent as of diffutils 2.7.3 */
+	opt_print_bytes = true;
+	break;
+
+      case 'i':
+	specify_ignore_initial (0, &optarg, ':');
+	if (*optarg++ == ':')
+	  specify_ignore_initial (1, &optarg, 0);
+	else if (ignore_initial[1] < ignore_initial[0])
+	  ignore_initial[1] = ignore_initial[0];
+	break;
+
+      case 'l':
+	specify_comparison_type (type_all_diffs);
+	break;
+
+      case 'n':
+	{
+	  uintmax_t n;
+	  if (xstrtoumax (optarg, 0, 0, &n, valid_suffixes) != LONGINT_OK)
+	    try_help ("invalid --bytes value '%s'", optarg);
+	  if (n < bytes)
+	    bytes = n;
+	}
+	break;
+
+      case 's':
+	specify_comparison_type (type_status);
+	break;
+
+      case 'v':
+	version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		     AUTHORS, (char *) NULL);
+	check_stdout ();
+	return EXIT_SUCCESS;
+
+      case HELP_OPTION:
+	usage ();
+	check_stdout ();
+	return EXIT_SUCCESS;
+
+      default:
+	try_help (0, 0);
+      }
+
+  if (optind == argc)
+    try_help ("missing operand after '%s'", argv[argc - 1]);
+
+  file[0] = argv[optind++];
+  file[1] = optind < argc ? argv[optind++] : "-";
+
+  for (f = 0; f < 2 && optind < argc; f++)
+    {
+      char *arg = argv[optind++];
+      specify_ignore_initial (f, &arg, 0);
+    }
+
+  if (optind < argc)
+    try_help ("extra operand '%s'", argv[optind]);
+
+  for (f = 0; f < 2; f++)
+    {
+      /* If file[1] is "-", treat it first; this avoids a misdiagnostic if
+	 stdin is closed and opening file[0] yields file descriptor 0.  */
+      int f1 = f ^ (STREQ (file[1], "-"));
+
+      /* Two files with the same name and offset are identical.
+	 But wait until we open the file once, for proper diagnostics.  */
+      if (f && ignore_initial[0] == ignore_initial[1]
+	  && file_name_cmp (file[0], file[1]) == 0)
+	return EXIT_SUCCESS;
+
+      if (STREQ (file[f1], "-"))
+	{
+	  file_desc[f1] = STDIN_FILENO;
+	  if (O_BINARY && ! isatty (STDIN_FILENO))
+	    xfreopen (NULL, "rb", stdin);
+	}
+      else
+	file_desc[f1] = open (file[f1], O_RDONLY | O_BINARY, 0);
+
+      if (file_desc[f1] < 0 || fstat (file_desc[f1], stat_buf + f1) != 0)
+	{
+	  if (file_desc[f1] < 0 && comparison_type == type_status)
+	    exit (EXIT_TROUBLE);
+	  else
+	    error (EXIT_TROUBLE, errno, "%s", file[f1]);
+	}
+    }
+
+  /* If the files are links to the same inode and have the same file position,
+     they are identical.  */
+
+  if (0 < same_file (&stat_buf[0], &stat_buf[1])
+      && same_file_attributes (&stat_buf[0], &stat_buf[1])
+      && file_position (0) == file_position (1))
+    return EXIT_SUCCESS;
+
+  /* If output is redirected to the null device, we can avoid some of
+     the work.  */
+
+  if (comparison_type != type_status)
+    {
+      struct stat outstat, nullstat;
+
+      if (fstat (STDOUT_FILENO, &outstat) == 0
+	  && stat (NULL_DEVICE, &nullstat) == 0
+	  && 0 < same_file (&outstat, &nullstat))
+	comparison_type = type_no_stdout;
+    }
+
+  /* If only a return code is needed,
+     and if both input descriptors are associated with plain files,
+     conclude that the files differ if they have different sizes
+     and if more bytes will be compared than are in the smaller file.  */
+
+  if (comparison_type == type_status
+      && S_ISREG (stat_buf[0].st_mode)
+      && S_ISREG (stat_buf[1].st_mode))
+    {
+      off_t s0 = stat_buf[0].st_size - file_position (0);
+      off_t s1 = stat_buf[1].st_size - file_position (1);
+      if (s0 < 0)
+	s0 = 0;
+      if (s1 < 0)
+	s1 = 0;
+      if (s0 != s1 && MIN (s0, s1) < bytes)
+	exit (EXIT_FAILURE);
+    }
+
+  /* Get the optimal block size of the files.  */
+
+  buf_size = buffer_lcm (STAT_BLOCKSIZE (stat_buf[0]),
+			 STAT_BLOCKSIZE (stat_buf[1]),
+			 PTRDIFF_MAX - sizeof (word));
+
+  /* Allocate word-aligned buffers, with space for sentinels at the end.  */
+
+  words_per_buffer = (buf_size + 2 * sizeof (word) - 1) / sizeof (word);
+  buffer[0] = xmalloc (2 * sizeof (word) * words_per_buffer);
+  buffer[1] = buffer[0] + words_per_buffer;
+
+  exit_status = cmp ();
+
+  for (f = 0; f < 2; f++)
+    if (close (file_desc[f]) != 0)
+      error (EXIT_TROUBLE, errno, "%s", file[f]);
+  if (exit_status != EXIT_SUCCESS && comparison_type < type_no_stdout)
+    check_stdout ();
+  exit (exit_status);
+  return exit_status;
+}
+
+/* Compare the two files already open on `file_desc[0]' and `file_desc[1]',
+   using `buffer[0]' and `buffer[1]'.
+   Return EXIT_SUCCESS if identical, EXIT_FAILURE if different,
+   >1 if error.  */
+
+static int
+cmp (void)
+{
+  off_t line_number = 1;	/* Line number (1...) of difference. */
+  off_t byte_number = 1;	/* Byte number (1...) of difference. */
+  uintmax_t remaining = bytes;	/* Remaining number of bytes to compare.  */
+  size_t read0, read1;		/* Number of bytes read from each file. */
+  size_t first_diff;		/* Offset (0...) in buffers of 1st diff. */
+  size_t smaller;		/* The lesser of `read0' and `read1'. */
+  word *buffer0 = buffer[0];
+  word *buffer1 = buffer[1];
+  char *buf0 = (char *) buffer0;
+  char *buf1 = (char *) buffer1;
+  int differing = 0;
+  int f;
+  int offset_width IF_LINT (= 0);
+
+  if (comparison_type == type_all_diffs)
+    {
+      off_t byte_number_max = MIN (bytes, TYPE_MAXIMUM (off_t));
+
+      for (f = 0; f < 2; f++)
+	if (S_ISREG (stat_buf[f].st_mode))
+	  {
+	    off_t file_bytes = stat_buf[f].st_size - file_position (f);
+	    if (file_bytes < byte_number_max)
+	      byte_number_max = file_bytes;
+	  }
+
+      for (offset_width = 1; (byte_number_max /= 10) != 0; offset_width++)
+	continue;
+    }
+
+  for (f = 0; f < 2; f++)
+    {
+      off_t ig = ignore_initial[f];
+      if (ig && file_position (f) == -1)
+	{
+	  /* lseek failed; read and discard the ignored initial prefix.  */
+	  do
+	    {
+	      size_t bytes_to_read = MIN (ig, buf_size);
+	      size_t r = block_read (file_desc[f], buf0, bytes_to_read);
+	      if (r != bytes_to_read)
+		{
+		  if (r == SIZE_MAX)
+		    error (EXIT_TROUBLE, errno, "%s", file[f]);
+		  break;
+		}
+	      ig -= r;
+	    }
+	  while (ig);
+	}
+    }
+
+  do
+    {
+      size_t bytes_to_read = buf_size;
+
+      if (remaining != UINTMAX_MAX)
+	{
+	  if (remaining < bytes_to_read)
+	    bytes_to_read = remaining;
+	  remaining -= bytes_to_read;
+	}
+
+      read0 = block_read (file_desc[0], buf0, bytes_to_read);
+      if (read0 == SIZE_MAX)
+	error (EXIT_TROUBLE, errno, "%s", file[0]);
+      read1 = block_read (file_desc[1], buf1, bytes_to_read);
+      if (read1 == SIZE_MAX)
+	error (EXIT_TROUBLE, errno, "%s", file[1]);
+
+      /* Insert sentinels for the block compare.  */
+
+      buf0[read0] = ~buf1[read0];
+      buf1[read1] = ~buf0[read1];
+
+      /* If the line number should be written for differing files,
+	 compare the blocks and count the number of newlines
+	 simultaneously.  */
+      first_diff = (comparison_type == type_first_diff
+		    ? block_compare_and_count (buffer0, buffer1, &line_number)
+		    : block_compare (buffer0, buffer1));
+
+      byte_number += first_diff;
+      smaller = MIN (read0, read1);
+
+      if (first_diff < smaller)
+	{
+	  switch (comparison_type)
+	    {
+	    case type_first_diff:
+	      {
+		char byte_buf[INT_BUFSIZE_BOUND (off_t)];
+		char line_buf[INT_BUFSIZE_BOUND (off_t)];
+		char const *byte_num = offtostr (byte_number, byte_buf);
+		char const *line_num = offtostr (line_number, line_buf);
+		if (!opt_print_bytes)
+		  {
+		    /* See POSIX 1003.1-2001 for this format.  This
+		       message is used only in the POSIX locale, so it
+		       need not be translated.  */
+		    static char const char_message[] =
+		      "%s %s differ: char %s, line %s\n";
+
+		    /* The POSIX rationale recommends using the word
+		       "byte" outside the POSIX locale.  Some gettext
+		       implementations translate even in the POSIX
+		       locale if certain other environment variables
+		       are set, so use "byte" if a translation is
+		       available, or if outside the POSIX locale.  */
+		    static char const byte_msgid[] =
+		      N_("%s %s differ: byte %s, line %s\n");
+		    char const *byte_message = _(byte_msgid);
+		    bool use_byte_message = (byte_message != byte_msgid
+					     || hard_locale_LC_MESSAGES);
+
+		    printf (use_byte_message ? byte_message : char_message,
+			    file[0], file[1], byte_num, line_num);
+		  }
+		else
+		  {
+		    unsigned char c0 = buf0[first_diff];
+		    unsigned char c1 = buf1[first_diff];
+		    char s0[5];
+		    char s1[5];
+		    sprintc (s0, c0);
+		    sprintc (s1, c1);
+		    printf (_("%s %s differ: byte %s, line %s is %3o %s %3o %s\n"),
+			    file[0], file[1], byte_num, line_num,
+			    c0, s0, c1, s1);
+		}
+	      }
+	      /* Fall through.  */
+	    case type_status:
+	      return EXIT_FAILURE;
+
+	    case type_all_diffs:
+	      do
+		{
+		  unsigned char c0 = buf0[first_diff];
+		  unsigned char c1 = buf1[first_diff];
+		  if (c0 != c1)
+		    {
+		      char byte_buf[INT_BUFSIZE_BOUND (off_t)];
+		      char const *byte_num = offtostr (byte_number, byte_buf);
+		      if (!opt_print_bytes)
+			{
+			  /* See POSIX 1003.1-2001 for this format.  */
+			  printf ("%*s %3o %3o\n",
+				  offset_width, byte_num, c0, c1);
+			}
+		      else
+			{
+			  char s0[5];
+			  char s1[5];
+			  sprintc (s0, c0);
+			  sprintc (s1, c1);
+			  printf ("%*s %3o %-4s %3o %s\n",
+				  offset_width, byte_num, c0, s0, c1, s1);
+			}
+		    }
+		  byte_number++;
+		  first_diff++;
+		}
+	      while (first_diff < smaller);
+	      differing = -1;
+	      break;
+
+	    case type_no_stdout:
+	      differing = 1;
+	      break;
+	    }
+	}
+
+      if (read0 != read1)
+	{
+	  if (differing <= 0 && comparison_type != type_status)
+	    {
+	      /* See POSIX 1003.1-2001 for this format.  */
+	      fprintf (stderr, _("cmp: EOF on %s\n"), file[read1 < read0]);
+	    }
+
+	  return EXIT_FAILURE;
+	}
+    }
+  while (differing <= 0 && read0 == buf_size);
+
+  return differing == 0 ? EXIT_SUCCESS : EXIT_FAILURE;
+}
+
+/* Compare two blocks of memory P0 and P1 until they differ,
+   and count the number of '\n' occurrences in the common
+   part of P0 and P1.
+   If the blocks are not guaranteed to be different, put sentinels at the ends
+   of the blocks before calling this function.
+
+   Return the offset of the first byte that differs.
+   Increment *COUNT by the count of '\n' occurrences.  */
+
+static size_t
+block_compare_and_count (word const *p0, word const *p1, off_t *count)
+{
+  word l;		/* One word from first buffer. */
+  word const *l0, *l1;	/* Pointers into each buffer. */
+  char const *c0, *c1;	/* Pointers for finding exact address. */
+  size_t cnt = 0;	/* Number of '\n' occurrences. */
+  word nnnn;		/* Newline, sizeof (word) times.  */
+  int i;
+
+  nnnn = 0;
+  for (i = 0; i < sizeof nnnn; i++)
+    nnnn = (nnnn << CHAR_BIT) | '\n';
+
+  /* Find the rough position of the first difference by reading words,
+     not bytes.  */
+
+  for (l0 = p0, l1 = p1;  (l = *l0) == *l1;  l0++, l1++)
+    {
+      l ^= nnnn;
+      for (i = 0; i < sizeof l; i++)
+	{
+	  unsigned char uc = l;
+	  cnt += ! uc;
+	  l >>= CHAR_BIT;
+	}
+    }
+
+  /* Find the exact differing position (endianness independent).  */
+
+  for (c0 = (char const *) l0, c1 = (char const *) l1;
+       *c0 == *c1;
+       c0++, c1++)
+    cnt += *c0 == '\n';
+
+  *count += cnt;
+  return c0 - (char const *) p0;
+}
+
+/* Compare two blocks of memory P0 and P1 until they differ.
+   If the blocks are not guaranteed to be different, put sentinels at the ends
+   of the blocks before calling this function.
+
+   Return the offset of the first byte that differs.  */
+
+static size_t
+block_compare (word const *p0, word const *p1)
+{
+  word const *l0, *l1;
+  char const *c0, *c1;
+
+  /* Find the rough position of the first difference by reading words,
+     not bytes.  */
+
+  for (l0 = p0, l1 = p1;  *l0 == *l1;  l0++, l1++)
+    continue;
+
+  /* Find the exact differing position (endianness independent).  */
+
+  for (c0 = (char const *) l0, c1 = (char const *) l1;
+       *c0 == *c1;
+       c0++, c1++)
+    continue;
+
+  return c0 - (char const *) p0;
+}
+
+/* Put into BUF the unsigned char C, making unprintable bytes
+   visible by quoting like cat -t does.  */
+
+static void
+sprintc (char *buf, unsigned char c)
+{
+  if (! isprint (c))
+    {
+      if (c >= 128)
+	{
+	  *buf++ = 'M';
+	  *buf++ = '-';
+	  c -= 128;
+	}
+      if (c < 32)
+	{
+	  *buf++ = '^';
+	  c += 64;
+	}
+      else if (c == 127)
+	{
+	  *buf++ = '^';
+	  c = '?';
+	}
+    }
+
+  *buf++ = c;
+  *buf = 0;
+}
+
+/* Position file F to ignore_initial[F] bytes from its initial position,
+   and yield its new position.  Don't try more than once.  */
+
+static off_t
+file_position (int f)
+{
+  static bool positioned[2];
+  static off_t position[2];
+
+  if (! positioned[f])
+    {
+      positioned[f] = true;
+      position[f] = lseek (file_desc[f], ignore_initial[f], SEEK_CUR);
+    }
+  return position[f];
+}
diff --git a/test/diffutils-3.0-patch/context.c b/test/diffutils-3.0-patch/context.c
new file mode 100644
index 0000000..0be8cc5
--- /dev/null
+++ b/test/diffutils-3.0-patch/context.c
@@ -0,0 +1,493 @@
+/* Context-format output routines for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1991-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include "c-ctype.h"
+#include <inttostr.h>
+#include <stat-time.h>
+#include <strftime.h>
+
+static char const *find_function (char const * const *, lin);
+static struct change *find_hunk (struct change *);
+static void mark_ignorable (struct change *);
+static void pr_context_hunk (struct change *);
+static void pr_unidiff_hunk (struct change *);
+
+/* Last place find_function started searching from.  */
+static lin find_function_last_search;
+
+/* The value find_function returned when it started searching there.  */
+static lin find_function_last_match;
+
+/* Print a label for a context diff, with a file name and date or a label.  */
+
+static void
+print_context_label (char const *mark,
+		     struct file_data *inf,
+		     char const *label)
+{
+  if (label)
+    fprintf (outfile, "%s %s\n", mark, label);
+  else
+    {
+      char buf[MAX (INT_STRLEN_BOUND (int) + 32,
+		    INT_STRLEN_BOUND (time_t) + 11)];
+      struct tm const *tm = localtime (&inf->stat.st_mtime);
+      int nsec = get_stat_mtime_ns (&inf->stat);
+      if (! (tm && nstrftime (buf, sizeof buf, time_format, tm, 0, nsec)))
+	{
+	  verify (TYPE_IS_INTEGER (time_t));
+	  if (LONG_MIN <= TYPE_MINIMUM (time_t)
+	      && TYPE_MAXIMUM (time_t) <= LONG_MAX)
+	    {
+	      long int sec = inf->stat.st_mtime;
+	      sprintf (buf, "%ld.%.9d", sec, nsec);
+	    }
+	  else if (TYPE_MAXIMUM (time_t) <= INTMAX_MAX)
+	    {
+	      intmax_t sec = inf->stat.st_mtime;
+	      sprintf (buf, "%"PRIdMAX".%.9d", sec, nsec);
+	    }
+	  else
+	    {
+	      uintmax_t sec = inf->stat.st_mtime;
+	      sprintf (buf, "%"PRIuMAX".%.9d", sec, nsec);
+	    }
+	}
+      fprintf (outfile, "%s %s\t%s\n", mark, inf->name, buf);
+    }
+}
+
+/* Print a header for a context diff, with the file names and dates.  */
+
+void
+print_context_header (struct file_data inf[], bool unidiff)
+{
+  if (unidiff)
+    {
+      print_context_label ("---", &inf[0], file_label[0]);
+      print_context_label ("+++", &inf[1], file_label[1]);
+    }
+  else
+    {
+      print_context_label ("***", &inf[0], file_label[0]);
+      print_context_label ("---", &inf[1], file_label[1]);
+    }
+}
+
+/* Print an edit script in context format.  */
+
+void
+print_context_script (struct change *script, bool unidiff)
+{
+  if (ignore_blank_lines || ignore_regexp.fastmap)
+    mark_ignorable (script);
+  else
+    {
+      struct change *e;
+      for (e = script; e; e = e->link)
+	e->ignore = false;
+    }
+
+  find_function_last_search = - files[0].prefix_lines;
+  find_function_last_match = LIN_MAX;
+
+  if (unidiff)
+    print_script (script, find_hunk, pr_unidiff_hunk);
+  else
+    print_script (script, find_hunk, pr_context_hunk);
+}
+
+/* Print a pair of line numbers with a comma, translated for file FILE.
+   If the second number is not greater, use the first in place of it.
+
+   Args A and B are internal line numbers.
+   We print the translated (real) line numbers.  */
+
+static void
+print_context_number_range (struct file_data const *file, lin a, lin b)
+{
+  long int trans_a, trans_b;
+  translate_range (file, a, b, &trans_a, &trans_b);
+
+  /* We can have B <= A in the case of a range of no lines.
+     In this case, we should print the line number before the range,
+     which is B.
+
+     POSIX 1003.1-2001 requires two line numbers separated by a comma
+     even if the line numbers are the same.  However, this does not
+     match existing practice and is surely an error in the
+     specification.  */
+
+  if (trans_b <= trans_a)
+    fprintf (outfile, "%ld", trans_b);
+  else
+    fprintf (outfile, "%ld,%ld", trans_a, trans_b);
+}
+
+/* Print FUNCTION in a context header.  */
+static void
+print_context_function (FILE *out, char const *function)
+{
+  int i, j;
+  putc (' ', out);
+  for (i = 0; c_isspace ((unsigned char) function[i]) && function[i] != '\n'; i++)
+    continue;
+  for (j = i; j < i + 40 && function[j] != '\n'; j++)
+    continue;
+  while (i < j && c_isspace ((unsigned char) function[j - 1]))
+    j--;
+  fwrite (function + i, sizeof (char), j - i, out);
+}
+
+/* Print a portion of an edit script in context format.
+   HUNK is the beginning of the portion to be printed.
+   The end is marked by a `link' that has been nulled out.
+
+   Prints out lines from both files, and precedes each
+   line with the appropriate flag-character.  */
+
+static void
+pr_context_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1, i;
+  char const *prefix;
+  char const *function;
+  FILE *out;
+
+  /* Determine range of line numbers involved in each file.  */
+
+  enum changes changes = analyze_hunk (hunk, &first0, &last0, &first1, &last1);
+  if (! changes)
+    return;
+
+  /* Include a context's width before and after.  */
+
+  i = - files[0].prefix_lines;
+  first0 = MAX (first0 - context, i);
+  first1 = MAX (first1 - context, i);
+  if (last0 < files[0].valid_lines - context)
+    last0 += context;
+  else
+    last0 = files[0].valid_lines - 1;
+  if (last1 < files[1].valid_lines - context)
+    last1 += context;
+  else
+    last1 = files[1].valid_lines - 1;
+
+  /* If desired, find the preceding function definition line in file 0.  */
+  function = NULL;
+  if (function_regexp.fastmap)
+    function = find_function (files[0].linbuf, first0);
+
+  begin_output ();
+  out = outfile;
+
+  fputs ("***************", out);
+
+  if (function)
+    print_context_function (out, function);
+
+  fputs ("\n*** ", out);
+  print_context_number_range (&files[0], first0, last0);
+  fputs (" ****\n", out);
+
+  if (changes & OLD)
+    {
+      struct change *next = hunk;
+
+      for (i = first0; i <= last0; i++)
+	{
+	  /* Skip past changes that apply (in file 0)
+	     only to lines before line I.  */
+
+	  while (next && next->line0 + next->deleted <= i)
+	    next = next->link;
+
+	  /* Compute the marking for line I.  */
+
+	  prefix = " ";
+	  if (next && next->line0 <= i)
+	    /* The change NEXT covers this line.
+	       If lines were inserted here in file 1, this is "changed".
+	       Otherwise it is "deleted".  */
+	    prefix = (next->inserted > 0 ? "!" : "-");
+
+	  print_1_line (prefix, &files[0].linbuf[i]);
+	}
+    }
+
+  fputs ("--- ", out);
+  print_context_number_range (&files[1], first1, last1);
+  fputs (" ----\n", out);
+
+  if (changes & NEW)
+    {
+      struct change *next = hunk;
+
+      for (i = first1; i <= last1; i++)
+	{
+	  /* Skip past changes that apply (in file 1)
+	     only to lines before line I.  */
+
+	  while (next && next->line1 + next->inserted <= i)
+	    next = next->link;
+
+	  /* Compute the marking for line I.  */
+
+	  prefix = " ";
+	  if (next && next->line1 <= i)
+	    /* The change NEXT covers this line.
+	       If lines were deleted here in file 0, this is "changed".
+	       Otherwise it is "inserted".  */
+	    prefix = (next->deleted > 0 ? "!" : "+");
+
+	  print_1_line (prefix, &files[1].linbuf[i]);
+	}
+    }
+}
+
+/* Print a pair of line numbers with a comma, translated for file FILE.
+   If the second number is smaller, use the first in place of it.
+   If the numbers are equal, print just one number.
+
+   Args A and B are internal line numbers.
+   We print the translated (real) line numbers.  */
+
+static void
+print_unidiff_number_range (struct file_data const *file, lin a, lin b)
+{
+  long int trans_a, trans_b;
+  translate_range (file, a, b, &trans_a, &trans_b);
+
+  /* We can have B < A in the case of a range of no lines.
+     In this case, we print the line number before the range,
+     which is B.  It would be more logical to print A, but
+     'patch' expects B in order to detect diffs against empty files.  */
+  if (trans_b <= trans_a)
+    fprintf (outfile, trans_b < trans_a ? "%ld,0" : "%ld", trans_b);
+  else
+    fprintf (outfile, "%ld,%ld", trans_a, trans_b - trans_a + 1);
+}
+
+/* Print a portion of an edit script in unidiff format.
+   HUNK is the beginning of the portion to be printed.
+   The end is marked by a `link' that has been nulled out.
+
+   Prints out lines from both files, and precedes each
+   line with the appropriate flag-character.  */
+
+static void
+pr_unidiff_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1;
+  lin i, j, k;
+  struct change *next;
+  char const *function;
+  FILE *out;
+
+  /* Determine range of line numbers involved in each file.  */
+
+  if (! analyze_hunk (hunk, &first0, &last0, &first1, &last1))
+    return;
+
+  /* Include a context's width before and after.  */
+
+  i = - files[0].prefix_lines;
+  first0 = MAX (first0 - context, i);
+  first1 = MAX (first1 - context, i);
+  if (last0 < files[0].valid_lines - context)
+    last0 += context;
+  else
+    last0 = files[0].valid_lines - 1;
+  if (last1 < files[1].valid_lines - context)
+    last1 += context;
+  else
+    last1 = files[1].valid_lines - 1;
+
+  /* If desired, find the preceding function definition line in file 0.  */
+  function = NULL;
+  if (function_regexp.fastmap)
+    function = find_function (files[0].linbuf, first0);
+
+  begin_output ();
+  out = outfile;
+
+  fputs ("@@ -", out);
+  print_unidiff_number_range (&files[0], first0, last0);
+  fputs (" +", out);
+  print_unidiff_number_range (&files[1], first1, last1);
+  fputs (" @@", out);
+
+  if (function)
+    print_context_function (out, function);
+
+  putc ('\n', out);
+
+  next = hunk;
+  i = first0;
+  j = first1;
+
+  while (i <= last0 || j <= last1)
+    {
+
+      /* If the line isn't a difference, output the context from file 0. */
+
+      if (!next || i < next->line0)
+	{
+	  char const *const *line = &files[0].linbuf[i++];
+	  if (! (suppress_blank_empty && **line == '\n'))
+	    putc (initial_tab ? '\t' : ' ', out);
+	  print_1_line (NULL, line);
+	  j++;
+	}
+      else
+	{
+	  /* For each difference, first output the deleted part. */
+
+	  k = next->deleted;
+	  while (k--)
+	    {
+	      char const * const *line = &files[0].linbuf[i++];
+	      putc ('-', out);
+	      if (initial_tab && ! (suppress_blank_empty && **line == '\n'))
+		putc ('\t', out);
+	      print_1_line (NULL, line);
+	    }
+
+	  /* Then output the inserted part. */
+
+	  k = next->inserted;
+	  while (k--)
+	    {
+	      char const * const *line = &files[1].linbuf[j++];
+	      putc ('+', out);
+	      if (initial_tab && ! (suppress_blank_empty && **line == '\n'))
+		putc ('\t', out);
+	      print_1_line (NULL, line);
+	    }
+
+	  /* We're done with this hunk, so on to the next! */
+
+	  next = next->link;
+	}
+    }
+}
+
+/* Scan a (forward-ordered) edit script for the first place that more than
+   2*CONTEXT unchanged lines appear, and return a pointer
+   to the `struct change' for the last change before those lines.  */
+
+static struct change *
+find_hunk (struct change *start)
+{
+  struct change *prev;
+  lin top0, top1;
+  lin thresh;
+
+  /* Threshold distance is 2 * CONTEXT + 1 between two non-ignorable
+     changes, but only CONTEXT if one is ignorable.  Watch out for
+     integer overflow, though.  */
+  lin non_ignorable_threshold =
+    (LIN_MAX - 1) / 2 < context ? LIN_MAX : 2 * context + 1;
+  lin ignorable_threshold = context;
+
+  do
+    {
+      /* Compute number of first line in each file beyond this changed.  */
+      top0 = start->line0 + start->deleted;
+      top1 = start->line1 + start->inserted;
+      prev = start;
+      start = start->link;
+      thresh = (prev->ignore || (start && start->ignore)
+		? ignorable_threshold
+		: non_ignorable_threshold);
+      /* It is not supposed to matter which file we check in the end-test.
+	 If it would matter, crash.  */
+      if (start && start->line0 - top0 != start->line1 - top1)
+	abort ();
+    } while (start
+	     /* Keep going if less than THRESH lines
+		elapse before the affected line.  */
+	     && start->line0 - top0 < thresh);
+
+  return prev;
+}
+
+/* Set the `ignore' flag properly in each change in SCRIPT.
+   It should be 1 if all the lines inserted or deleted in that change
+   are ignorable lines.  */
+
+static void
+mark_ignorable (struct change *script)
+{
+  while (script)
+    {
+      struct change *next = script->link;
+      lin first0, last0, first1, last1;
+
+      /* Turn this change into a hunk: detach it from the others.  */
+      script->link = NULL;
+
+      /* Determine whether this change is ignorable.  */
+      script->ignore = ! analyze_hunk (script,
+				       &first0, &last0, &first1, &last1);
+
+      /* Reconnect the chain as before.  */
+      script->link = next;
+
+      /* Advance to the following change.  */
+      script = next;
+    }
+}
+
+/* Find the last function-header line in LINBUF prior to line number LINENUM.
+   This is a line containing a match for the regexp in `function_regexp'.
+   Return the address of the text, or NULL if no function-header is found.  */
+
+static char const *
+find_function (char const * const *linbuf, lin linenum)
+{
+  lin i = linenum;
+  lin last = find_function_last_search;
+  find_function_last_search = i;
+
+  while (last <= --i)
+    {
+      /* See if this line is what we want.  */
+      char const *line = linbuf[i];
+      size_t linelen = linbuf[i + 1] - line - 1;
+
+      /* FIXME: re_search's size args should be size_t, not int.  */
+      int len = MIN (linelen, INT_MAX);
+
+      if (0 <= re_search (&function_regexp, line, len, 0, len, NULL))
+	{
+	  find_function_last_match = i;
+	  return line;
+	}
+    }
+  /* If we search back to where we started searching the previous time,
+     find the line we found last time.  */
+  if (find_function_last_match != LIN_MAX)
+    return linbuf[find_function_last_match];
+
+  return NULL;
+}
diff --git a/test/diffutils-3.0-patch/diff b/test/diffutils-3.0-patch/diff
new file mode 100755
index 0000000000000000000000000000000000000000..cf3834cf5b318323a77e8f9089df929e5de0015a
GIT binary patch
literal 807328
zcmb4s3w#ts*6&QnKtQk~f*TQ+h@&PVnz(=&NpuDi>46!H3#_OpfdGO8h|mM5Aq>t0
zXxjl++4b?c%KBPXcNN7&KqW6og3o|&5djtGW&jZ-L<Hvk|J5@|!!qB!cl?>|bLv#p
zsZ*y;ojO(3EGY8boMN}z62BDN4K_mC2D=5y{A;si%3TG_KW<x|tuy{!ZoACZ5wJtx
zn8GyoY0uVp(TQi8NVVBI;F*g5^HNMiUW!}1B%ZxZv@P*WaL6a?YyY|9ujcd9m(2nb
zPjD{MnUB1tziOtZzdAwS6VHk9Lgx(>X#B|(FQjI^ta!exc)rB5nFZsQcqZD%w(<W_
zW_5VF0TFidVJj4W+n=Q6uXv9#k?+5hni+p79U}0FXMSe^+7i!1zFU!xeEz@w(&L1G
zjMtY;E{EgoOFZMC?V7Tw69x^qrfg#WvZ*ry^ZL)r8`OW$fU9TEy!u+vZkA8lp(93%
zni6u%1Vo;D;D71>)6ac>*^mdWUO)Ufck7?G{@N`gJp0ZYm{yAaSq9s+$v@t<(%!o}
zag*@>H2j}+@guz(celLtPVt;)CXXJU{@0c2;~!mBI_rlCo};cKTJLK&9qYd4xntcy
zn)G)HjGc|(S5$m9{H00g`zN7)1r0e{IeU}PKb@rfZ_t9Xm9r>GIkzUE*OTBcPr~Op
zN$Bg6@cC*I`h!X6E0W+BCBfg71V1DR{}YnP=gTDcZb{0gLY`IrN!mLoN%^Ca;D;uu
z_xdE|KcA$Wmy(o2^K~}<E0eUVBuTy1N$Q=Mr2Gq#(5p%6otuQ-ouvG?lF(00LO(A_
zyPimbpPvL@nWWxBN$4L>LO(Hy9G*@_p9H@u3I6FM<@=M+-<5>^A4%Hv?<8`bmZbdm
zQGO=MI`g+R3H{Yc_{l^8XVYi;6KBIala#+R34VE!^6g2=zcWcWBa_h2Nz$&jlhFH<
z&~Hw{=iVgc<Rqb|yKy$Ttw}=PElGPnOhP{>3IBgjLcbyjKffly4^L9gkR<s3Bq`^U
zB=lKH@J15+*d*moNkacq5_xV;f@fcyt-sz$g72P0{ymfM`EwHdYVdQOt(R^2nhB`M
zW=r_H8S#3XfA1!`?YA2Bl0J9_{db@s{)sd2M}fZt_|<3N-;S4aCcX)LlK#x{bAf01
z>&__W_ISN3<M@RCd}W+|)fx0Q__?KYYX{k8E3-<=@3&2wH>tGDHhISM@k;3w+pJ0B
zCr+F?%Qm}w*3=owWZUdXO4-cP@nw^2(<jVQX3j0O;ZNDjxsztuCeJLNG=rtgD4kwz
zn^~?*oiUN%tkNk+oLm-|J!M>A269iEG|^T*wS1Co+&Cmp43yg@mfkZ-Q6|k(Y;#Ld
z>huY=(z2PeC$Zv5vu4di^;7SeF}}=J9#Cf6rp}%_yL^1<B)$l)$YdGHwM|Gc6euqT
zL*pmRoTY$+iBo6T#!Z?xRk2N<G@Z<p&zgD9tnt&wO`S0ZZBeGqoH1_3`010#>||vs
zUdD|ZKYRA1S<1M{<ENIfp7CWf0@L|oHg(*%Qsw^gN#nrvxakwdl?G;wn?8P?4RRqH
zD5eaO2+TloDKiOTwqerra^-%Akc{vF%F@~8;BFk6Ib-HHik9pMu?ub?NeJj#+c=Ql
z3jnQ|84wv~u#U3XlO|1L$>YnE*~<9RX(AJPak3DgZF(C=rQ>H$V!uqEFnj6@h+^Eh
zz+^PWHlu7@+4vdvOr0@#Ci-mB49Yywya{B;hE`0PF^3&Ge%3u?0KB4~=1!fcOtDR#
zT{?coWYQoV<TLI;?#c7Oi(;ERch*z|-Bdbr#+-2`KcJ(4XHK3t{(ixBsc0?|OQ%tq
zLi%&ZPgTmNPP9=PWdcJvQHkP8IA`+AS!n4rktT{iTbItBg6=mvcJf4_oA=G8LYVvr
zM53X}OrbHNx$QX7*8(@Ubav^?vNANyY#F+5`ph|#Y!jg3RNIL&r;mq{nGJ4Na<UDP
zj~mB923;Qyegq*C%<@pmEYS~QEP#(PXr(e~7PWmc)xEv6$+IR=GpW2nTiaj9O%4d=
z?wJlvHmezD8|w28xoO<BSLY6Bf4#2l_1dckw!QxWHX{YA)&Kp!)c;HR|DOA7sf=`-
z4gdd-OG(PV9jkGebXy`Gu;R~u#d6zW`x^F^xW@&YYTFZs1HGmq0@1;CI1Zmbb!s<C
z=LBH>T3?$Wo?NpJ7H{UCgnee1h3ogkFENi0Uz$MTnV1)dpKQS=>^AX?0VIA2yG?vq
z0*Pm0z961+Z{nAj7l^+%fy6UowaI@cyi+cTU#10*siN(dWx>ZqAkuOy_{1E;gggtL
zbtisq3!bt|{A3HBJSBd`7JOn3X4)7FJ{~F(SxPMUE{Q_$oMORqt)KXnTk!3XKbviy
z1&@wz`voodbK9^s+Y$?2vf!6n@Cn^x@)H*Pc^3MW7QEH(S!KbWZ=qjp!86vB_^q?x
zdnS;0)>!ZtSny32{O>IIW(%IaPvZBb1%F`ziRUg0zLy2BTkscI@P{q<L=2S4trq;n
z7JA$3?Rxur3qH+)?_<HITkx3{e1-*oi3Oi&!S}V`vn=>aE%+P@-f6+-S@4%x@NNtK
zatmIz;3rz}#TNV(7W^0sKFfkHvEZ{U_$e0rl@@%t1>ettpJ%~eWx)q6`2H6B5)1xn
z3x2r;e~ktIgayyFTH?3Tg3nDL@myuWUu(gyw%|E`C4TEH_yGwdo;4PHTL>KZCJTO$
zg}&K>zs`dH(t^*k;CET@E(>0_;2G;m{0>|2`3WSRtrmQN1#f$!UH@;e;L|Ml8!h;B
z3*K$PXISta3qI3=A7a60S@1Vm@HrNIp#`63!53NZZVUcq3tqP1hg$H(7QAf1kFnsr
z7JP{XKg@!kV!?9_o%oeo@V*2R&v_QS-+~WX@FOhvB^LZG7W{GxzSx3)!h&ZEJMmj-
z!T&LV#B-GeKhlC<ZNZPS;MZC3=FWtfSYyHe$wJ>`!QW=VH(T&yEch=ic&;@Qzg-sm
z9SJ0!x&?oy1%KFrA8Wz4TJU#S@V5B6l|I7V7JQloKhA<rx8O@G_zVkvyak_W!J8w^
zOq4?h(qzr?@5lPu<f<CQp$~@lB8N7m)tl+DfzKf+cG(N~EA?^Xjj-^<j9oGOE_;eF
zT`i+oz>gA6AzUNihY8cQGFA)tA;NU2jFkd@fG}MtW4VB55vB`e1O<FAVT#2l7w`na
zbeW720pCHGu98tK;6D<ki)6S3Jd7}1BO^z^LkQC)GBO2xJz=^+M!JBnB}^B{unG7|
z!gPI%!>53_tS@1@JjN~o_aaPJ$7mLCcfxdWj2Z!VAxziCSS{cb!gOhjl>$EgC}6rW
z#&Q84Axsy>2nu*VVY)6xxq!bTOqazd5%AZ9>8cpT0^UZLE{fq6@Oy;mnix3(t|LsB
z#K;uz2EuejjC29NL6|OxVH5Dngz0)1hflKo&k@cfyi34O5vHqQGz<7q!hH$X2>4;b
zbS;e40)B`vT?%8RfFB@CSHf5>;8}#}LKr~--%FS-f>AEu354ky7$pL}gD_nJqgcRy
zBurPpa0_@CVY&cDj(~>{=G1Rw3ix`$obruy0bfg)Q@vpm@Rfu)#T$oDi2f(csomHm
z;9i6|r5nux?oOCfxltqFE`&LS8><DJLYPyxu~NXt{|uN@wy|8mM+kGOHi81)Pnc7*
zQ7+)`2y<#SN(B5hVNS_Lv4FP`=2UFB1^gaiF6E3I0oM`clx$=QcmrWh#YVb--yqB>
z*suxsWx||#jl;i*{wM4vyi34O5$05DGz<7q!kl7_8Ua5{m{Y5<TEGtx=9Frz6z~It
zIh7jA1w4x|r%)p(;Cl&k>NLs)Jb^H$Oru1=cM#@OX%q|ikAyiz8g2m(Bh0DM$Pw@m
z!kiL~OaWg{m{XyVF5qhka|$$U0=|+kr#|EGanb*TIprC<1l)@-r#hoqz}*RRiZf~i
z+=VcwHe<DbQwVcPGgb=t_;SFU%8ca#K0=sNm=P54e!`r(jB){gN0?KVQ6k{433IA4
ziUqulFsCTPE#UVEb80ej1YAd$Q<9M>;0=U16&dLQeuFTlAj2l$mkD#~F%JJK`k!zK
z;aviLiZG`dqglWcB7JR>mjf2R;@p<%RhJC0={LD?IAVQJ9%9?@GEz1=@m75`{^$n8
zT)ciIQ~u7B$J$apMvCV)&!4>NscM{Av3W*&MvWdRFFddcbh4^A)AcfpQA}L2TIkG_
z!cSoyku|)^kx@?fdd?C>xd(lbcbq}yXe@Mc;3Df6e)WJ41?0&N8*C}FXE9^C+~}rk
zLF+EzGq>jFSIh*>=gg5^a=NtW8q8j@0M#bBc2@`H&WIDa@sip^45rmWlwUj1nU*SR
zHrXCWrAce$G|in>tEZ`5ood76g?nQiVp{^2lRj;O9hE+uCaX=M-8ag$dI$NF??SsW
z<j$i~-3A30%6E1M^cA$SmX=#1Yd!2DRSwmp$)VQFz(M07lg<$+5Ils|y$OW9@*-K2
z=jCn#gXhVe3wyZbP#tm{M~-MtyTC$CG05lVSE9X9RVS(HI?UaaoS04dB0~#eX5+Nr
zmneCaJJ4BPI1v=+uT?>%qZ|ToYI0Re;P*bQ%$Zq~+ahaYomoCr_p5vS>Mvfk!FU-h
zb+<HRDp&c?aJOI}w?_0C>h~P0;W?9^Uy;IV;Y<hyh(L~D;8Ofe4Rmz}_ohiz&wzvI
z6X4YzxI~Dh#ofgnxS+j3kP+Ks%wRd}lY~63m9=^Ea<}Ae^QsVI>KF2{X74%S=5;7g
zzO?XDH+m6&Vs&!oT8Jq%uswPOs6kqRe$`eqnuMb^fslV<HFD>z=z-M04!LTJ6h4Ip
z8e<?U@+L<Vr#sNQjX~u+Sv@8iOARx&f%Y`sa?aq*dug1pW6koVsh`U#{%_}OM>Old
zIXkvZzO+Y!tm6N6*1i#}m6EmbnBIlh`U|cehGN!2<2phV^|JJQ)2yD}*d{qtpXm)X
zWcXbNW^FS*hG=qIgwoZ^m&RLOB8vZ9w0y5z)uJ@z9?Xs9Ku$i2<~><3QtwrJG|HX7
zfWFofbIE({Qu|Eg{aCJwDFx6GpL)tvgW6pVxdTV0+W7N}lwgUh?tDG%=NElyi+9?|
z47o#vGgHs*X}49?1g`SNHnSn=9GV$E^_Z-2Fb+u5<<53nxJEfgt~w}HWuZf&U3?nG
zK5Rhre!sdGPrvI>;8s*Ey6L|v7sY}D7Mv)xz5c0tZK&Vu;J%4oh3H^7VlX(yyBHOs
zKA-AzMz4YT3n+KH&-J~MAy2DEnLe1TSUoh$p00oO3po5<ZcKHW11%LJt_c!4F=qf(
zFH>I!0vSDLldArS4%x^+XEkk|zVR4GrVlbuJ!4kejolc#J}uwL;WGsUHg9B{T~^0J
zkhR~#Ztc{sYGqliKo&a7FFY99)3xfLS_W0kl-G@3^)i25yspN%=Xs~aGW1g{zpBQo
zZVI@_OL^{g{YrB4UybNN?BL$czz-(Rsep59jA9y-P&7@BtZ)Xwk16U%YKE{A4Ybb~
ztg^kH{G_Qmjc*whV5~F4ul|_3-LD>PYYfba-!(UFj?1eJO&_N9IPBGm*yGJ|=u}Mk
zy*#ZYLylB9OS~NdIeIB}ysK(Zs#~gh7nZ;qYlzm;NR*Jqox8=S9@5W+Dv9=`eiJw+
z1T;jv9K^wSQ*8HFv{SE##BI#5qX#lT;AvtGO8u%W*Bz{4aOyWoPfzGwn%|U%(YV*`
zlD~EdUMxj{P!#oOyr_&sQGEpi%0<SxATcXZQ@`R%hF44d1}5Muj>J(8o7{OtY7oV=
zO#ud#DYO|Qw=sjgAXPPDum>w3UcY)ss#*zRi`pzcip~;h!<p1GMhgEA8t8+`#za(~
z3+)}n>2XDV5czUjMC<*LuGh;|+ms<ixiu|ycI9fnTIa3(&M~~I>v;i(H&zop<gI$-
z2HHra%PlY|J~j0Z(KNhm;+t&WB5&O<hZ@qN>*Y{mn!K<cyAWtWEHkj&Sb<zZqc;+%
z@1rt7-O`0<hL%X--$1}A1^hK|M)P5E(H`j$1RDJCkdw_9>2aRFYKwAx?iNo=tzEg?
ztG@58{T>YF_X;@VSZ(x>U+ewB2(>pXUf1`BsgHEzZn$iZdAAx~Or}r|PLK;5OvW%z
zKHd^`E=19(3MN*?nT49wt#a*d2MRbhxF=P)m|SKEIm6C<A*;p3N_SaZUW|gHooTQK
z_izT@^QrqVaDF;$wyIp;C*Cko`ZT9gj3r?U9O?RpNP(FM>^DczMu4mB(QYU}e*^Ev
zT)61+!cD8d)SY*E#(M7Z-0c}x4{r*`PS5nS79OFWRdbe<dypda38E02aJL#8Xn8!N
z;X8Ro6{)|BmP>yeDXTvtSTIl4ZfJDWE$U05h-rBYvvEw8@I{~YFjVW^o8jDbBv^*7
z+xXi>0AKA5U$6g9v6%VxJ=o8U>5r)B>5k{5q6Ehyi~HI#cTM1{2d_1F)lWQSx9N|=
z@qul~gKcoU@<w0254BB}`d}4--d?{l4~-4FhamY|^+&xk>Ik*QJZhs9&gqOMEsXsY
ztVoM{0Vq^kW6sUN+#$ALL7z2!ZFX7fS%TJh)^!1mtPLEF@~g|gcH1u8654%uVQo70
z(e##AY2u|S7vcg%>WQc-YXw&#7mfau+$|fJSI<SgP*5rSJfaC0m(D4{>tR3sBA}jk
zqFmWkr_^B3NLAkusXA^366G0#Anpc7S3q`xR|qindK}CU;CYGE&Hy#XY=EKGG^IQF
z`ZtPebc_WGie_tY)F-m;z_8aGLj|o}3e$%p{d_@x6-xv?t9%oL4UTTW2=GObPZIe$
znRR$Yo>r91V2tOTnw{t=ZQ!L<ePO=#ZOFfPh|L??l%_w0wW4?7i7$~H*lBzu%00O{
z-W0z8UrMld13-v!XZQ?J?){PYgamUDtwA?EiCi=Q>(L1Q7RZuZ3*Kc{vn&m%gE;4c
z!r0Fhfi_SRWy1Pzco3X{Ot*tE;{%a;@!wwRYumt})5aF4Wp2##&aOdF&u0!Hulg<g
zjocdD4kk8!1=WpSH~DI*PZ-qXqu@f8tPRbQ2M^7WLdrQnMv5_k-j>y1>p~HDwE<50
zK?{O6*p!b%HPG}SqU`$UB|>lI$P{Gxy83)DM+fzgoQ-Ou`Xiv)C{z)X^Gs%eYqL#S
zi^=-i{QlBk>hd$Cztpf6X>H9V&5?ZOE`<$f?1hqaKXSyY4=mKjt%O?Mi?zHl0{sl3
z%n4D@70xjm_M_Pp$^oqWjkjP$G{+_Aq)=<Tx9>!=8XaALVs95k{!tEzql5t{!CSgX
zp4N=HHGi{Ef`xS}Z$#aHXHjLMsLx*$$|;3E21teLDvEm>XeuZb?k1!J3!VlBLvY}Z
zhr~dDbl-oqukFHZq3;eatP?{|gNtKa0OCf+4@iRlAhM?dQ(Z!na_=%&kbCjwRX6K*
z5qMAloAhD=ivh?;xrx9E0o3b*0HCg0P%C_Yulm*cl}Op}GX88_hd+=h3|a>2f^L^N
z(|zhhPBm9K^$ILE^xvVSh>_0At+5zg&9Mvog<3n9!=)EGvC*+5&axaT*p1f|v|L&y
z!y$x?`!Jqn<N<DQ{DGpNWU`s86}-2QePyvPTMr0rkiyr(j<t^tCm^qDvlK2xK0jSt
zl^At1%i4h@e1l`@zvD%J1Q61miJ~{$g?3i&!YBouz6Sv!5ua#qJd8xa$KOTXiUjy5
z^M(o@Kv^~^{2!<VAVok`Hwca#zXL5w!$`afcoCmKZFXR*ZEu<tjlBjH4HYHVB)G~m
zx%w&yI(M9I0O|T5AyjbqU#3x#swBXTjvat$wnThFbKHw!+SK+1s8^$7Bv4daNHL5;
z(VL+yu_Ld_$F|Cm`{As{I>F@_uczbiv8;6)4-$-cIJM|==o}P`i^7d1um~KQ@GbZ!
z(~H$Uo*DcDW$5bE$6>Us57G|8Kb2+meV@7)PW6UsAX@!V#Ne=cO5<ETc|T;g@VAv9
z^+zVA+5?}{d6C&egAp_VpWiG16IC%OT!TgKY2E%c^S0T-9+dl;Mlg4q)~ys$@q}Wd
zr4@Cdx)j%Y%DGsBR;>WJ+H)w<<iU;-JfuZaS%K;p2>|tTDzzJHu?lE#tOiQ-{67GC
zLI-j@p%a~@#eJAz-3R8ctJl>aE$a!>>7Ulp#ar5lGW-#xW3#`iMN(%Vqj#gQ&altM
zIDndC%PW=+>Hvls9d7`|4uV~oZrYV^Die0)LfRD})P;36OzOH9!A+xwD5_Ev<&eU2
z0n)C#2`8h`Q3^DTIprC}5=C>27KEu%cto5~6NJ|Tjn)XlIuJHE9)CIB<~1VU#Ufvd
z6doQoTq8xk6rkzv7z2O~72F-qBrTqgT#b(5fJO2QQD);m<7JKmxN!u>SwgMvLg1O6
zjNQ0N)c0@X47GNY!Y=`2gT6;Q8Xb=UP4|fn>V=eGLCtxnKnia`G9qf+ZfJ1C;%w;q
z47h?vTG*bFIL`Q9fQ1mN=+aLGI3kg{S%A;XkEgB$h;@BT{~P!V6<h!^RJI4BEL6}L
z00eT3Gf1Pu2B-=%jTcKSsBJfZ%7vO^51I_{6doZx1?x#^Q3tWqE0_S3EpQI9j>a3U
zKWx;xhwwBPQBt8EEVzyp%2HvsfuQk53cGcXBLh0iPs+zm`PBWg^jeb~@tl;i--8Dw
zOSgy+4TixscmU0Os6EH7LPn|ZL)leuAIgx`ZV%uwzmu#MjK_=U0R35n)rBR}|AIHo
zaSc*nI;1dfnZTLC%-Y4V7$q%nWFSde>*$V$2+4JEJSH&Ry5iBrQ3WEHzxfpu)LQs_
zJnvkn4eSO)=jLP0moybcDq~9=CrKB%DJ^)}5xm)ps^DIr`=zD-1A4mG@6eJ-eQd+D
zifEcQwArp-{|HiCKaPk@%(O2+EM%WP<qbO)V-uZuFzTMj&8K`3r5;m~&i%LsTc()r
zBlGOS`|=^T-}OsiUjqb+1>_h^VEu1I-H4;H2Z1WVJ8ukDw_bwLb>|E$ZxPS}l6R5V
zuZ@oG$N&a`qhzZ2s!#Zb4N(-S>KHw!M#r&#^tJsBieMZ8TojqxOhZuGVoZa>zmBuC
zF&Xm_kfwzhCD#9PXk86#Aj;JQGa_P{5zryZ4e-c-e^cNK-ZY`bCiGVmYA~UdCe%bo
z>-iv{b$CTLbO~=!F3qV4{(4!UcklswLEwVm11Yuu0z!_zfGUVKuBbt8g?8DEUhq7%
zo_9Y0BbfVx>$A!M@%4{fiq)jz9Fq&}?(vC!FdMF}Yg3`*+od^jKn+jN^_kl9GQ2MM
zM8CQWg6WLSn?iKccwMyDYX5%b>g`y?dD7A&FdPu`P@7b>53fFT;5M*?D3$RgK*+Ni
zpb*=`fEyjl0kT!b5`bVa-f>k5TV3jS@&3Lxb$@nU=s1REA#kDnc4;Y>IpDrNz4{~c
zjNY6DW3eq%@Y;(M?O*DQJB9P>C`V>=3?_kBkz%aJ>Q8PAvSa?m4xI$ih!wQ{<7;+0
z5@O>HqRs;Kx>h*EV&oOk<L<@+?hsyl&(2IfdRp?{7m(avBrDO@>NVu*dT_<|B55_N
zyHX?%tOpDW@+KY|xO~)~yB~C_V+|0RqY7n<k=g~+#;uTvaFX@u-veAC!UF@JoQH9K
zKBwL<uAm$SE+Hb5bvBrYxkS86ivO61$wUkz#S27)YV4xl5r|XjTlK@hdDKltPjXo5
z$OSR{tfd_V!vjEs;1O)*7Lu7d5^|gaB71ae^*9z9yBC9}ne`pT8(P;gx35iKk9Ylt
zy|lR1%^ZSRD4_aUl6{1v+=E_q>)o>YogDh%aPcT_V@-K4h`h1ZCLWE&SGjF^725p^
z$N#zoYbMx6%l+r!fjHi|vbtw(%3bvgyU<Tiez~ifNwHmV{a!~XL0{X7WyKy@t&?l_
z-zeLg<*ls&WZqzA-iFKwubBD2i{}p(c+m!1;JneusaIn1zN^782q^o{_2dU5dC7es
zP=4RWLXXkanXiI7bx*AMF5^LDfxR<kn@`3YJfpqphn`Vh1RA)x^ChbHx%T-rmk*v+
zP9frDGrZb;X;Nfd3L52lufl1J#+$j03N_jhrm=fnC#0n}0_$~sCM_LALM`=kuPZgC
zd=quHuiw0(gD{i_Ko2rW&?93<ybRL{548?=74B<QzV^BHOW|8ZAqduC`^m3<=gt1y
zpS_>!f-xMJKJ`s!P&`*Sm*9!L6&M;f0?$31+*yK$Sm7+@!U2w<2xn%>YO60>AExI2
z6n82y6Zq6!BUI-na&|Mq;f!x1K<QHt`?8y1rO@)3p~H5c3&Co<PshyYJV=sqZ=?t>
zVdrwz92t5(k@Mup5WIw)PXH-JzJRO1z;%{4bjUuevG6cFA?PtMX|ju9(4}-H<Pc!2
zz{LL7C?qu&Hm9`_3TN+rcp}vGEW}z0rL{ii%pw)hyir&dA)Aa)W?gI49oLVd@D^FU
zBTeZe4~8>cks-TMofX|h^h$R1Zj_dWP$~LfhMORV_NV(?howjQ(5Pu$WbKZ0IOulS
z^_497cgpGxIeW9ub#VU6K3DyGgx|X!^18b24E&EAc@P^aei5|J@VN}HdR$gNoZrjm
zYMkHGuQ}1m)Q{leLo;g8)0>p-K6R@wX>4eQoc)zg{X`D^+M`gqWvAgqa}i7mLux|t
zq^gs!lTZ*jlKL5OmHpfG2kV91&(l&3+|LIz4{V{Hnl$K4L+ZKqzz(b#7H*;vTNa1b
z^5=hxf={ww%0cTn{yCP{?Or~}v(^KWVR`!+QqMzq(N{so5Nvvp`lZh`3hqOsKYenv
zCDRMTFK=Ln;kRIzI;y!9jd#X-xJCG2sn~uZttE1z^>9K5o3Tfk>h!wmq-7_-4m&xs
zNZsT^IJKC4Tf)UJ*7@w<p=P`d8o~Zua0Mo_={6;k6{S^N$PPw8gdO}9>a@tKt)H8v
zN3iNfCBraIdWnUY>wRlKZ?1gK=X$^LZz$_ftJhVrvo-K%^mGh89b?!ZDxU6jHF?$F
z*x9{(u8%8!=hu`N8eI5Ms~q|f-C&@*8<ekP^()cc2zL9j5i&<kpSnHX<NJ*3Agj2(
za^E4NNZp0z%)s3IXN>tGcsXH(gMT6XrzZB((n$$h5S*6@FXc~hFii}QTcN&w^;01O
zpB8ook%clG!%i#C-7f5+))gzvdVe-X&JJ#h)t<c3m%UB4Z}Vk;?ahsPv!j0d`?o}T
z--#G?iqG}6v~)L$k@-Shk_Y>o^Q5I8#$RPAQioTDv{B;Vr^T4}VHKJ#E&V4F{H~}J
zS&0{4<o4LG$W=S=3Jc8MM1#=*Wwdoy?F=knl;1@9V6d>bUEyStZ;6cUgI$`d4*Arl
zovT@p_KtWK<!&FQjk@^oaM!3lho!1}(A!>Y=y(_YHU&}*e9wg~$~Q~#F&r+dk2qI}
z>YsM56wgmi*AEJD>2}VlRoLJ8PO9onwM}T|eo;Bp7Xf}@X|ZvJI>xXeGA%8-7VV1n
zCl~Tsj~ZDueAyp+)f3*@6F17)Soe3m#h1I!m%Yzt--!k00=afyitPHeawd#T<-IaS
zRq^~%dGIJ_`TVh7^)oLGPnol1{w==2{}NVqevv=o{9;68z#*@8gV&Ys3=Dv;0BKP;
z(F+sy!`#b=2@@P13dQhhqi%qjjLJ__zK`2I4!ETwAuY6*TY<2nY(Ulb6b^JXhXZkp
zJh(VZityemZS)v(7LXpvMhpZSvSLKX4f(R`fRjUIFyuxNUd?&<DyQAJ7>-hW+`>{B
z-@zkK$O%1DEIb&$y2-N<wIBq}zf{~Dh!62bo$GgOoMwpx<8tKosdYZ}V=hKy!L*sj
z%pVnoBc}+nmuh%0eaY&6Ga#a0APNe+Wqe0YS+ytv6N+F#*8b&ONe%=bvi7vl7vnyN
z2qZ=tDyBvWHB?Pf1Y0P4>XordIAomHM5D~z3sHe69aBujjcity-{q|Jsk^<>h_1DW
z=6JJf{4Tw+)38X_EWfII?M+_S;mUKUuj?oYwSlt~vd?c2HuYWb!`}j*tJy3u6N*qP
ztG{|Bf1*U6tFE#W)GghsHj5JV`J%)cQQ~H^#OC=8!y~Czf$VqOR>{`o?Du8Ym-9!m
z?X26BE6+_ZEPT|Mj3$b~WW0|qZI_@)cbX8zVT-r~uMv`Y+R4fx$+&#8cNiBSA?`mN
z!07Mx;*(fUwBl@layMqAX92;-SB3-&dOy_{-rj|>`cZWg{7?NVoCI12>j$OWlu<u<
zITMy60miwjE+G;6+to}n%h&#z2epd+r%mrhq(z@@AOEKRCyw>NuA3)&q_qP#g9E)B
z0ejlwzn}nF3zhTXy2-7buUv#ZlqEOAN@zD_U1mFMvlZBaFw@~b5EaS+A%<A^B9U*+
zJn?u?mN%f$qW^La>OC|R)`p;)n}$Z|Cm&{2Z?9wn)dsA6^mFi~24I?5h#F!7_kE8(
zXSan;Lc>E$s2uIn)(Gt!yk-|*sVc|<v{#tu)1EhT9YK_z%lWUqV5lch;&&aDs;WrX
zh{1xV`O0$m%RMNUZk8jkWs&@1n5$ITzEkT|RWnZl19HE&NT>Hla34Vfuu{48bRLu-
zMzFbz%Mi*VxbUbrBO%y|o)>2<4kH-hbsbPp_&)u%PpM;qOvZ+qOwin9EL3%iSA$OB
zTp@P|wSs>+GA~v4VMPpa2{h`8xGAFyky=>LLGJLjpj1OLbcl`8wZ9Abni)b|^P<hd
zJ3=v81hFnrLuv6h?Xh?PIq?GEOEEnUp#JeRR{ogC6%st4&)_ZlBF<)d;`1u|$l97#
z3Ky&Vt~jy+_brs#WS0j&Mg}Ud&1yEKs-_ZWth6kYDh^EHTo2Y5q0~*VyC#LJu3{e=
z&TPI&8JusmQNM-tV>Q)5l*Xz{;E8xum<a4;<!<w7e-`xG>*T?+4z4h?>2taE5Y7*@
zC|&WA;<wk}J@88|mWTeTZGqoK3uw<h4XL@{wGq<*wv|sQS=hTq`gSFHi`M%azU=V3
z>gVhr329-rNEi4LjAIYGmSX~kn9`LSpgk~#Jxb*4&wbkE24`(^$RPZ<qzRs{ri}sd
z!rdHK3x5>@tLopdI>svuA7J+g@*L}&;-w$c5H~4s9n$>Ti)>x)7Jt<b(o#nEumyjv
zM_SuG$S4J)H{oqk_%U*#z6Wy@&5+jSU*HbMlni$;mg1IHG`gj=F|QrY99MLoF4&3H
zo{ypVFDmnb6&J)(lwQU^(I@TpLtrtCSSVa!A1rD^>IF7`_OHn5SDOMbpI>-uccsX1
z2VAYvGMutN^~dGf<Eb!l($Yr($E|4XaZ~!+0>2;>?~lj`sXT;au$sFq+7%C>Fs|eC
zvwe~L^St(Bp5TosfqghEVE4P4r0@+Ou7sOehc4&@TXnqRiy~=lir7wwI=x(sgnsRy
z42&0}T!kL#1d7z|l^s37R=aW${z6m+#0W1m@F8->X#=0i5uXG<_y~@xWgo|xj7ZmW
zk<}i}iQ93mc48fr>wK<l%C&y=us6Hei;xLu3eSth%kM=QnRV31>u5kxu5AG<m$+2=
zKw35w*224RGZn@+7$+>G@CzXIYJc!zGsE~DQc3D*NWoGY<TNhPkK5KaLfX42ZTRO>
z<WZ8l-mCn(Y(Ihn5bPna_gL_OSW4ihh9NOqGzx9)4iRrLx<eCv*>%R_%u^NftVc)N
zq-B)^+4eRLUxXeSw}Tq~6mp-3{aYgsAof#vR^=g~g%}()m3QZEiCz@UPeVAur#(zF
z1p3YpR4w?ZRc;IxJpO231S`JrX^(P9La0aauwih$2NbQ5U+sMaufqPo?HaCj?Gn!(
zs1?qh`bIj)<b`$S5R0WNJe`?eV$2dOC6o_qQ|XZww8g08FoLI2qW}1j`Btv)!5i!`
zOY(Ji-i?;S&aip}brGY14FgP*2lFiE0-)yUx8N%?KJ77*4~z8pEDfB~^B5LM-6h-W
z5Wc<}t;1-fM-yZsJf<ahE-?cK%B3Q-4Hr2D>k!Zdepx3B@WSKbA^Gc~4igiPDy+-g
zJ;ApAa#2(x<`;wm9Dn+AU)#?zj_0irDiiVHRM<AmCa+&kthPq9N!^M-Svt1M&<xSK
z#zuxC#Oc}WM!CZ~&L9fazx|Ldranx2vmZNag!V{3c8h%M%MscO{Y>j3YwvX6?16FM
z`n0lFF#iHu0D4_(4^~JqTi_@M3~k3=DePj$s5lN*V-Mzcv;|s%`4Ube31YkjT5t{(
zVI8_Ue!n)hw$<+%ix8Mc_~}?zhjcrP3I6Yh5cvf$o6>bTRam^UA_K*;7#7gguT`*s
zimk0monXbU?(#`RH9prarL=8)__h36zbk*MSN+7R)&+)<w;>IwzlZgz<I4qtQ{~e3
z^+baA1lP)WoDX<pm2GDIKO@8ucnQUMv$y$OpG#GjL9||1&HMo{z#Xw<>F7so+4Y`=
z!t-Moxfpisyfc8{cO40Q1J~YonPUyl=kSc%0Pn(+C6KmMH4(T_!Eej3gC>PzR8;L1
z_6UO0KJ9IG7p7iz4E&H*K-`L6vPJX&RwmpbO&@~j(Y3LgV3Dqgsqd%ND^uy-eak#J
zdI@QJf)$<6hrjsLD10wDyFQF_w3Vz&J<RlAMGCvvo8913kD~LcbEqAdTr>2Wo}?dv
zH=l}~TAVSPg17QaS)GEq$E2Haze9FOoeSZRH+2RT5GyY%8^Bwz;B_<&K4cx(!C1gS
z<v@4C3qaUcY;P)VL?L|ehj@D4hfrJz%o5gVI73*>9b2r3a*!-Hf+q}I_yarP4_DRr
z)$6dagmu*0!GaH$vJP$-HKJs0_?6*_(E?|OV^06(J@&wl`lozqZ&UmACh`7Q4c;+)
z*6|U^Z`NNoN$8{KFPbEWDQ*pdijyn_8f}5m2y~A25bHuPs9mE6NMCg@a9DF(36?^7
zD!dwL5#ykzyM@L+oDIx9XwZ<0E#9l~VtkB0K22jcb8kY^%<f-fcE50naP&@E`ZIXN
zdW7x68Xa5V-zD@Qbr6&xKU=MLr~M{{mxB&|08V&HVYUzF7VSfV`7ZRePd(|&J{Yd?
zsXt?vjcpIrL+yVrM(;QN>|fe+0I^goU45{OS-cy7uJ=JN`r*r6)Qdc^uw_&$iyJ(d
z;v6Nl#E%MuqF}}Ltxqk1x=cyOAmAdK8*+ZvPtvksR2r8qE%PLl#>;>Y^v0-%IfoDo
z1t}2JA4!RhU6zWM$;*uwkes{S_yZonf{z~Q%c0a2;)6_}awdF&G~49R+Z<`&cHr-U
z$A%3Z!A>xtd7@hjY`|h-4B$G!gK7GAxMLD3m<C*$wD?L;XpV6JaJo&$dJJ*+8bGLw
zx1OK_P(h;tuWhS>6m0uoIbb{lB%S_Qw?L2H9fkFDIWS)Jn|BXmN5~U=$C-)3Z2>qd
zn-S*OL@O^ZJZam7^If}*k3fsohWn$no_9%TTuVX3%+pn?z=|$!p)UJ{&8pgh!=YG<
zr)_xYA{?*4o->xE@3PtY-#>sS@f2C<)Sq0S7y?&10hGppZUp`m2M%8ffYDnKHX!XO
z95WKpz1$XpKN8G}Q~$9De&cfELV)^9jfuDjjy3+uC3xrnf>wz$UH@S(w4LdKB7G^X
zP501^Z}en;6`6I+9XypfM+qL!RAzchYdw+su7DNjU@ye2jT*b_@B&ORb#^#8T>?LP
zT($ErmP?yKa6a@wT6=9_<YqXIt*LV^MKPH;GaA~IUYOk^8gVBmjkNda+JwObdRWIa
zwBKInY6@(Meunin=d$Bnq^f(-4(7x`6-xb1V;hF_#!S3Y@6+^=O%yubi~>-$%|B>p
z25lF#e7F8Ft_cYm#GDZ_-dcGH_NeYq``R|<uybnkXV`OMp`YLf1TGN3f!{d5q<J7g
z6Zb<c<<Au5b5}uQNV;wT%RjyZ+l0)!F%N$b06vV01||xTv+F?fIcNkAa%315kaeIq
zKS4n&*6#oNw4N&Y*?>m!ccb@h^Ch+bUE3;aa}nNHkU2c!>khAAn@<|?RrET}@0hYj
z1|P_Rf49{y6}~TPvk<5}2EUaGp*?_3|IL?OkLY0FYM*P%{43~3beIRR{Umpg(}VM}
zAURl!R^>k|Dh<U%-$uE2*6ZHQ7J0|7EFrcLI*>=ot9fJ?>kqBqr^RUG4W<wWvbRE;
z^326`eS7=lNaYj+fV}Dt`tD7jsjBg5_{b7m%%1l{NLZ5;F;-W*v7hMqefl|A(D2OQ
z1+q4JN}+0OEJ6(!3=rXJics^THwpr%8~zDA=8Ypv4%T2uSU5=Zcl`Pln(;2=x&VP1
za5GYl^gf0LrTMhWhTlnT7+8o$G;i{9pY~vDH4pLn)Z@6v!J8f(&X*S=>=#?$m4<%C
zwa^xX#&`)pm*xpx@4sH=uAJ*YWi7VqkKAGD&ILH!sSLnzcZA|LrCCA`3I1fYe=Rd0
z)u*;v2(Y~Tfa?RXznF+Gg$`s<`LU(JI}(_<(Vu(uyfK`LVG9$1{hos$9s~%SVCQ*A
znE~WuU&^jpS@Ja@;>E*X95?AqAl47YG1Ta&!;Cm?V;;3p&i+EiB4}AU%p1KICPVm+
zDO6a{L*WuMOV1^Z{XLlNsf%E?g-;`exj~8E`Vs8tvoLA!AY&Il=jhAURAHlBLZ^%2
zUwwz@<=y%RIJ%9A9hY6qU{h}qwB2o5V;YL;dqJtcNHWZdU}u1{nqIxm;4p%t8#=a?
zSx(9aLFsAPjKjl0B=9ncZ!i}73j**fPXYs0cZl(HFpy!~fEvtrv#d>r8XlCw{eXfh
zqOBM|McD6at^D5SIxa2i&V<nXG+Xr;)U$38{>ajZR$T3oI}AJtA<zlHB%G#ajYh>T
zR674jGMI`=%|_29gI{B~3CEAqdU|#7cWBE6|J9ZXlD-B~PiRkyGRxcrL4-e}Vltvb
z2iXwMyDEqhamuRgfpel$m&@8kh|()1vUXFZ2<?nS(0zZUF1z#v!{yL}=_dOKDZ`7{
z3(jX#b>KE&;g+V)z;r6JmieziL$fUEDcfNMXq^vW0)_mlXQ1xrJIlq>IL5vfroZ5h
zuuummtyJ|BX!S0`&HfLaz5ih(jB}7Z-j2ln`bjYaV1uatS=9eb>OV#Tgr*OIggJ{p
zBlNB3b*R(SZ|FbtEUy1hd?-5<HxuLFFnz2u1^_yl+l-pyPt4S&+{?svS$qJ%96Rno
z@3Ne%cABNnvuZH_rl4hF0AwNbAQ&n*1cvnc(5V~%orfV=yZDWVAb@sV2tj@bw(0NJ
zpQa8%weR5>OZBS_C@iiyOQ;Sj<D^-_Av857KTe83a-38nX@I2hVa01xn{g-)DuFG}
zn{WpFS8^%*g^@f1&aDUR>A=Z^JsdpInNfL;Z!oTlNXs}rxb_H-=F8wo8PX%e@#fX0
z!x|N_23bvYD)UD~^7l|Bk)N{>>gmvJKg42Imo2I*hdr5%>iP!@UR~H1L5wSd1s{kP
z3~GBYuZx0R*#w8(Ps`GoJ69iJe5L6h;N~)|Z{V+-qs8G=aD$z{c5W7co1^50GjBUT
z4^v4*^XGFUM-u$>3l{u7!B2iNex5lki-n*3Gx$+D+Wjyk;(mfyzqCz~;-*V{7-bkQ
ziDBf%t&S!f=Y@VaHb6hTh|JnYM4Y>n&X_}-6iQaGU;!xXvNkg7!j{n9--Q}F%Y#Rv
z7cUn)(cc)J<z8|vhI6jiY13B~b2)cFd_N&RDmRHrpzT>w)mV;7Whg7X_+sGCqLhPb
z|63`y;mqY(l=7T7sZ}Ze5hp!EDR<Ritj|I1@yUOu>G|Ehk(JT5aLU*SUm61=o>tJ7
z*1&u?w%wj~Nn6^E|4MVTrQM1$IRbuu7nOerpzXH8ZesY&gvra>{TFw*1)Ewuixxmx
zxN(0f(7$>zM-<Pe#$!fE?~nBAWx(HQyoZGL`~s=-d}=$fjl_=$;=dsQ*0Y@+j*5De
zXNgYWED@&rV8Pd*wgt|`%=#MNr10x#G!{gP$ESWD?UJzfYE;(xo#`AjQsQ8or@Hm?
zpawX3t@e{vU|3=C45!h-^X2djiozJVjvN07U|quh1mbca0yqw|Z$swoZrr%L&27_%
z`A}lpWPn3cLDnH?#wKVkKa+;*KDe_=q`^(cQ+Rm47!|0hz3IaL=4q;glSX+T)Azqk
zbr_k6U_Am02#x4@lZ4x)TzV(=c@aq3@Hk`{zddHI$c&!Vlxrb4)jIgJX|O1>dHK#G
z{iOi`{f`Ql%+A0CzS1o|yWz9%mR&f}G(2rqHWsWRq$o>;N8)~fy#=YWTVboPsBYBX
z!I4f`?NAhMQO@&5Ml<A<H5SY4l!nyw3h;Bti&@D&ERvrUXUMo7YSrFI$YG>%DOPO4
zqk%pluBgNL$4KHjL98eB+l01Wylxf-BllP~F3-erCZ<<g2&-Wcxy0!QTK%u<QHLo%
z@wtJ|DMad!aCR3Scml*|8_w1v27-Nx25w~BkI5%kaA&bls#F*c=(<$(8;X@9W1X3}
zn1)`Y6Xa80a0Xd|y7OoG6;u_ADUS6RIxsJ%?C=6IFRTeQoeFRBN=1iI2!gG}C=S8H
zqg=R$^H7l&0b}@=hxChJAiX$?!I%KAK_g5?Go*K*;l$)2Blj4jA<&Uol*@~72x}-e
z;pDLt9tw5lTnF3ojv&(i2IXKBsy|aA?>I}4lP*EddVawM0bCXn=f^{TY+(b}|F~$7
zqLg{Gjwn9xLUd1i{{#z$-$H>@wW57!d-XHWEw5B~DD)kUY?<e&xT6<I9fIQli2tT~
zH6=Ao|J03rWt5E2!X`@F;wp)Lk=Azmc|>0XeGziLSjU?n_C+2eJHE(G@au=W5iP9x
z5M?ly75=w)Nipw8!`00U9ft_Ypbw#UgnR)F0<;bm3(=TZb~EIdHZMbe@-6Iv3D+2B
znmli%sOkDk*k%=U{miZ*rL=@mD}7oUwJB1MP%Pw`g*@=xqkgz9lixAL{Ank4+K+n6
zT8_zlr+yGGxRPjeBoE>3f$mt|$F~v~`uqdX+JN&zr%p-XKSC<#&r=AOEyk;Qis}~b
z1&YSh^YJ%koQpqHm=(3`?J5r>!$KGZM>opxjdC}juyY=eQ0I0Wjz;G-OI1E70{a{t
zizqLEgs_y$s5DcMO@=F;$Mt1gT>$3b#xRr=mKfS4Yb!+YSevTH7VZ<<h%p<g<-l3^
zoq&%M_JC8V>T47!n!-=WhYFs$A6G-9u!>~}jdZtQK@bvz+1`c<HWrt<IgIp4*z3Rr
zPti{97oq=x1t0qa;r{?Wy}ghawNdNYFb@V=8~7F;)g_k<!QjLdg2EMIEMR=&9fL!c
z(R0RV<Uo5w4Fkn{(1xF})5LqVIcdQg`Ui#vEA6&`#~b-mdTxuSk&7prx$E8?10Cz|
ze2;eXX=fBJ=V->NUf((w#r*>ttMqGFfSK<OOd#~dBS_J^{RcOUsG$AQJnFf|{lJ-a
zO4yo8dc?Ff!qVi{oNj20CxydY#_w*tDVm52O!%q*Sw!^F_!h~_Jz72)S7RQtr*K);
z7UcMS2DL8S$2h-K^(fxGq5Shi4;o=WU?R+N*hf+o1BTqk&i*`f!zpg#8g~OD#%*ER
zM}eNgiro!miWeU4l)^z8Q>M0Q*El)ywi}gsOd)IzaPV}y00)cZ$b*QpY{J<Tbk8GZ
zSE(QB&kKry2j;{B83=;ZRp*I5P4r_rFSSu*=tsy)foD2kI8;RG8!UKn7<HwJTiVzJ
zB%pK^I{&2LoCBxoM)VYL!i1T8nfC{9Kw&f6jy*QmvEtM0SXX>m$#94|gQStxZu7iF
z8{a!&{XE%U_;Fz~ZUbQe5tB~M8XifFc_TfBVz-+S>@>OdJ0z6#z!GT`7HE5>pgI-1
z9zW{6u>RwE7b^_V!T!V5>y0^}N0uj;*FSKMCy23)@d$CVP;B=Lk#e!=jie5x$;HaA
zL%RMGbgQa{j-nLq431H_X}t8ec;kv+Pnx_u(LqvGU+Ug+<55$d@W$9(nB+K7z|X+U
z#zBX<f~LiI2@xORuSaI5pH5^FppCLI8${S^grKCVgQ6!s2(Vkk!8uub#JL<r$u6I>
zL<$e!tJX6W1Q@kaxFUt{zyk_l7{UpF#Yv>N28D3_&Zs~I=6JE#CD-Rl8f=p>j>7{+
ztXx!rk3A@<>XGOkU@CxtRr3XY1Q0ZV;=p$#HaWuPZQv7voP}i9J7QNA`@z68#W7Dn
zEP>Y$@&|)x-kqpSJz^d-F!l)HpxJCf-1=}@u1<&k>RTxNexRo}Bit$dr8mGTjKY$q
zk;R*RvpcuO8>)oWki0j$z3R>QG!W>61rb)JbWIGi7eF0q#oSSg7divx#CJ-$A7)Lt
z2QEcsRcu~2y%ELJ3#bAanox`;U;<h44A?}hClmWFc+>xGQiT@-U`xk<EUqw%@O?5v
z!qQnEyZSVPbv|Vbd)@PEZZ<SVA1T5<*c?tUai>D;k|%Van6p@_Fx8xT#Z0PS$+9OS
zg?r}s<N~BpQ^+BrFMpG4<2AF8LqSq6Oi;zM{)k&%BFRV*DJIWm5&9p^+~$NXsryB>
zr?qM|vKwCjU%d<dqn?X?5#E!r0=k;$IAbn=#CFF!aCY?DAp*L(Tk~+oEpN~e+lCKe
zNH)HTwCewmpcMqw>saKsAmJ!!_n)w85wT)?nCV6vz7C_!%&fLS(0VD9GWcKyhFVc(
z0QXlJ4aF4{`1RUsxaWiQ3AYQc9{#+tTh`7IPCYF9?RVZK<Oqd#uR$lo1GuO}yAjT`
z(iIz7`d?qCBm;0T`_b{LH@)T{v=Lsj`WjV{-ZflF9T7Nq%}1dNR8R4J2kUx|QDJyJ
zM+^JfS~_J0&ebnMZWJw%<NE3k*nS;7dYZ(p01YMfEE3v9A?A-@!T6i0)7PP3gqIXL
z!SI`o{+sH4_kBn*w_E8=v2)Vkr(navcmV{IY_PyZBBhh@C@`>JuR!>i4+PNyG+Wft
zUa71Nf?%Rc67!qqHtr&*zsA>9yr05NZw==*Q6c%kg^&thY;Z4?%MdRNmZU&WID@YP
zR@QFE9f&a*fxUQ3$6I>f8%CBx>vPbnXmyi<t7mS|wdV_peCuTp$gXvK1a`^V>$JDB
zYc(H%=G+?8$AT~=ZCvMON1ZV(nF}OZdu^;eO|M7u<GqM;ObC=+i^i`5tMs_pq|-cZ
z@Pms1)zE$ZZsZaJ7d_(lO#tLEz<@9lBMxH#kHWpeQQ(IuSdlck;h&-8Mt3@&Qussi
zuHB!e_XZmf4hw``VGOw11|~f3@~>WbKQEkNnhT`s-Twtj2scZV1o{j@Zc!fZO%Oo~
zX7<1S2kH<Du9w1(pjcm|^nC6CMo~=g!Sk{0g4lc@U0Qon5162u{HvvKwqUB@_8Gj0
zw^zUQ9v(Lh;LHl6_;kc^Z>PgpMk#S7+vkeT8R&PN#C>SYtT>Ml?Z$o+m~O!M?T7$i
z?mnb{g$WSU7^vxUccC@HZgIxO-t=Cd{g^)GRj`UP-8>tK;>CAK^->CkjZ)DpocG4}
zztVL4V|+I1m*^(s$jguyq9>?2awP1mfiQRhBM-+2&{fD*0SUmn=j21KOQdiY(a5kk
zJWbRTvQwffFSELLoGU@8-y?tu=M?>}IGU=f7Xx6K#@C#iAMA;KtU@(L6aI+fve@?4
z-=E6`JuH#v`Z2gbgseD^)R=lHpGFb%N3=_HmX=Yq9ryTw(`TV$IO%ZJ!n5RVSvb0Y
zB(Lj3X)&i(gzgSflh~0HP!VFMtV=DzX3uo6GXR3YZ7z60J8;PXhi0&;6#(@yL=@8W
z!{FcRI>_tk_P}0aDmlTl6GVX&(rP@bgZSP+gX5%!5kVmx5G+B0K2or!bZT(yLLxG}
z;|u~XYj29{0PBlqx@{ZCoBq{5*}^x?I}RXYc1!XGkv#AZWx`QWCdpc=6Zc?C*r$Qp
zjL-3)J%S&=jASe*p4ZA+o_-Q@Esp%&kw`}OMux$_;-f<5WeCN?Z|l+aVFrvfL(3{$
z%?s{tD<+g@QwCchzOy2H!U$=B#XQ~`uQDQ|<ebD|vFIw(E}7(l_${LvnjkDD!rf^!
zCkd|8jX4nS<mHfIMRcJ)daR`>tS2Wr&&-#oEQGtimd+4uCbPG~sp~WivPuv_3di7C
zKnnHI0kE%eezbwR?<G~9{*_3T)HL>QA~{}sLZsqJKB|q~&|aR`xC2d@yxfcuo*DOp
zHMlgN(LS|4&<#@sc5doTKT_9n*)nXG({Zl83X<F?_86YWVgnOjZ!pE<0?Yq7bO_+Y
ziGmh(DGrp%>MdDIutiw#%TzL-NNy6zZ6A>d{bpD2i6LI3!3j+4(U|vlDmzAVc?bhx
zAZ#>sna&bA2J@~CbcD;_Mai$`y;&ZQ(Oc-MxR7=J$5=%zL0y);j}$NF;1@79jJ_Of
zX8aLk<4JZ78-$T(tNs#`iYV-U+5{FRJ@OM|2g>VCFYq%^>LXd;-6+t!nEUBJ01jaJ
zYmexS1UdouU*x?8{`%SEeNm2(>!vAZmFsh7$Q6CU&Z*91Gep0fgK{D7F!CqlJsV$g
zJ5AP+|CaTFY_q>jSw91XY?Cg#KwkmR&6MyC2;_2<ex`(naNL`!LmAY+1R31fCZ9I}
zMniFV$Y;^N=h202@{rs0?;Ly>rETZ7eKXJ8!#xGATI%sJHd18LCS<K=XY%YtC*Coo
z3Tg#&@4?A~ALumH=x?KMLf@w-PcjRp9&YMkcQA)V=b3wAtJqeQl|z!ec!A9<5bIy;
zmjIiEQZGTNxiuRPQ5z<q)OMjt%f#{AxEh;wK<Mzz7%ivEH6JcuLaw1rY&We?yMMO9
z9dO$=9{#u6X4nVXY|A&So&$In;hzQ&u9=&FcN31>{5D<Ee0;~`NeBW*?{Gk>6)Yz7
zK7=pi;q!rVzoBrs;i8^~p9^ieQGbFwA&q-KXGv$0p@2r%OHtlj4DlQFlH~cAF7mOx
z%ojQ|38#TN&y{cjz9r^7DtpMH8!i+!d4wX7H8-wqt9ufAy0{YgkssG!MW|ZrcJPQf
z;`6u1g1_}wjs$<pQ4R)wyF$^WjrActC)C<`?nUwTwNbVu%{dVK4NlS9kWys$Du3iY
zmShk9nkg;b2b{+|EBwiK@_KuEkV_Jqx9UA9{0d&gg8TuX@@Gg@8;DT9&?jK^ghP-b
z_QNZQKAfCUCpG!94LNdOx-a56C9D2*a%k^iajC4RM$X2$&qFe%`k^mUd;IHs8nE!0
zc$5SOSQ-kuo+?{1wrgxiLt$!)O}7cMNlj6IyMCOlUB*?AV7%R)V|BJP%znSizanrx
z8h9&CQ(Y0bq%EGs+f$KAU&6n;Gx0e+s-P`+e5^7cyiM8Z3ErP_g*S40hrp+dPcHCs
zka=<089RuNv*{ROh`4*<7{k&>-|$EqJt?Hmze1T4k()!mcAEPXt`nSV+Lw@#L(CFd
z+DMPB(#GMj;ICKUix{}-o6R$?9dN5ZMOr+ON`Ny7nsEo-EbUdlHHNc!8zII<y&EPq
zc)^gnq&@^=Et-znR>K5AhG0y;{yCsCghUF_t+#m*`!hF<gbLw)E|fk+>^IRCs66U|
zE4!H3F;IeZ48=C1={^SwDkj1^N*wdx9tGAUxL7GggyR{RiYpld^mcyf>7_&NciF<*
zmHxrsE>ntl$Wq$)2|nTpIr5Wg@Sh>ZVu<m!tR)$7;=m_73nC9L;|lO9rxbpfoFHrT
zUmO>pDzf_{lTz}1%HaGm<(~Y@6l^>Slh)OVa1XD&sEA^2w(IK<!h(=CT!s>qC5WII
z(<oD6m%LhKt5+Mu4?y7ruznD;kKq@>3WFMMzPd-`izBfWGYGL5WI{r)GS&slG3J%C
z8}!$i_dJo;P5S{SBB4_C!5c1<sy;vmNo)TE4J=cJ29NtNcEtROgGEp>1dU!1AUhzx
zN%$L>+nQJscj2>-x0feoY@-=H8>~#h;XrQu2Jue=OI1_iCF0Zy){2n;*b#-Wmr!bM
z4NocJY$#%x(HEiTLQi6P&y`RThQPW0MU^!f&=K|YZL!b+Sz7yhp&(F>G*8~Q${=*=
zwd_=xJ;U*Fk#&5e!RIwQ7Bj{Y-2S=ChFk%hdfFt*r`;@T8;{c3(a@mjDUl)D^DmSZ
zPlsxlHv9=;AYoMws-Hyv(nilNhYk*WvxJMfeR^*?tZVN|0i75*rt3DaDxQ3j(ad=A
zV8~{9JbijReTOCeBBuMWJ(=UFo-$+zRBmIy7P+|@W>s3u{Xc#aAw$38ZxAuI(C|fO
zb15Xg4#|VzkW#vS&a+(ZfRLA%5!g=gXdSo=dS7%DYzZ`3^5N@%dHA;VS|H71P<1$Z
z8@m^^29_X@XU@hjI(Zy!(CZEGa!~&vuT*%#FBP4@=S7DgZ;+qN#IZL1OA%sV;*`dQ
zY(W~+FR>8Zh<9o27@RfTY&WhYkoX>gmg*D=Z5}6^4__NYM+)~A84!`#Y;?e@MgBM-
z205hb54D;N#ZsDkkhs>Qqc6OXBD*+)E3N&R{qrwKi+W(Z%Z_4P2FE1LFwZIY6d&FV
zw~fWo=44`Ask^y_LC=oSfDE4Y5+}a(k;o4{$`i9>yS<@J%RGyFRfxf<*2AFUV8Eu#
zJCVyA-})=C3ecYuf1tm}Q?Z{{OoNB_17HT+ae%FM{xERX0i5Y0#Bkz4Ky3iV6Gj0B
z)eiCTGJ2RmKterNGcRsJ`c%i?@T$}Jnzi!&?B_nUHriIdr~~yWAdEi2^S<KWXSo>q
zxFK_4+_m9hMAdOCNbvY0i#*zoTsv+i%H{ZC9KKEjo*Y-3@G<1B9H=)tp(C2Z0E8O4
zGfnIH3TV;Zt^z9Pe-|L(&j=k5b}P+t9Cdl(XodFdYN(N{Rj=d&C**z~tmqT#qTu#j
zpDvz;urm__0_s$cuhk0s97lmRrrd`WO&__j2wAy>ejO^cDWiB8wHpxnlBb1|DcB*d
zP0W)%T#IylI47HzUZl16#mq=LT&8aBB{_lJFz`WF7aUKhF$w2>A!j$?Gt%Dp*9$~c
zGwwgZZQ9=!W!2tVi7Mp|;yNvSwy`4sace3=wueL$@yVaZLzi$$f?Pz*6^HMSa?<1Z
zh_-kwujWcicA_xMWASa(AZNy}S-$qTDXulE2xWhcea*L7Cep8G(cIB^UJ!-^#k)9P
z#@~%N{~DNv!-mpg@d?k!0F?FiN>Zw#EPdK!#$Q4LrJ0$v$3$g_JfWhE@rnZfVI2M>
zx)s-SOlC}K9I$=1eZ0t#Sx_9ahS1*DL@f?WEv6U}ezG>xEw4kV{4L;WiMc`z2z53{
zi=QH+u0zs8f9A{Jx7fD1Qxgo}6Fd(YWC)jkur?79w+7|e1jBzN!#)ecr01~-<9^hY
zs2?<078(e$>MhcY292zW8sl23yLs-#6qPX#$@**9N)x@<-u~12bKZUU?1(lOH^+Yj
zIerVwTjF2vc#dj{4^CIpL_78u5t$Ob5Ez3S8=@0&01~%`I>+0iOpLcXw?%*HNulAK
zcTH)w+t0?u%$tV)&AO(c@I?PM3XMdPtwCs{sgk)hA~<2%FUl-~rqJxesCGvCOpdCB
z?kOoh*BepHaF+907Jtx#?=kVL_d*fzc6aH2cnpk#Y6iHlOgXCa8jxD=(cWS}vas{_
z9@lkBK9BHJ6Vdrwu4Q!IDeGL1;m?(Y9S*`6X{`zTci@>}v?U-5Z%@$6+M<;}$m*hI
zjuUN>DcMC|nvkjJi*^ADtl}q1m>ct<J`v60)At*E7?VM8htZafRY~Mo5kZBh3P47Y
zT?R6*_8P15Yl~TxR}&_|t5vgbA3v~q&3WL!bxI2Dz`1Ko)2TUFDG$UKJ$vLGYhGga
zYKZjTh1&69G(FG<S3uIB)0h!@$*v6Lu(Y;UUIzC;5Lm|T5CJMbX&1i?sTM|tpYVi!
z#SN_4_`-Ce9oPxN?cHaK;WhcPw|mv?etSK>3_~2Pt5-cHJ&rHR?DVU@dF@f3>q`&d
z!o2Ocje}CmlZv?92Q_r*IGcDoDpCfcnCS1?^*uoa5~WXY9&W50#AR}S<ffQ{iQBw<
z;z!8Ur3ZHV;=wg?>Q#fgAS|!CJRR&wi~6EQFt$W6iwPS}`g=urOUS1bb|5iWu<14!
zO~z5#M+^>t=JCUPSD(#9AqvmvO(PLR4GH5myn{hto3{~XA~|3XZ~O^|0Gi}=4=onI
zPU7_a&?bD81`~q=*W!5m2VDUFlDEM!`AHm1!I+^LtL`&iY%jD02@%4>E;=Z9H!PE0
zS(dCV--QyeMZ!;jJ%?8umB4DyuYSbu<G^A2z#o}!_g{ip1R?%1XQtn^Ctk~EqF$x%
zFtxYNnJ@St#EIi?QRO;ZGK*&eIqsxy#Gv4>lh^f&v^XE~@!NmE{=u-wfIX<wrmrZm
z+oEfEOdV~2<iVt0Jt0`+cR<qp>QCHSP`|{-L(pNE!5{h)PeSZb@Xs~i-&Z;6mqr{&
z2%Fi{eEptfS9$qO*QNPg@fN9Y^4i(4WAv-Ab@3%$#VVisC{j_gRm}M8=FnzeKXz<n
zh+{;gH+EuuIMN@_L17CYP5eU$XUp3*NnixjIb_!ne8=;1Z>0D6va4Qtyw2;|Aw64@
zR<~q@uoL)qI^YVRKX(XeOdf~WzYFaVhZRnMdF%wR)6y%)@={^Hp5f87O`rQCqk7^z
zCcdzhf0(Y-B_HAIm{6MmUvSLvqPu~{;-84{ssqI5AMn+#z>jRoDLMO)w*!zW|NRJF
zA^vQEk+4U&U44*@Ab8=+j^gZw*Zz6i*F$hWdy!5X!OhXNVu4Km%=~PV`ixlgsEZDR
z0)#avMUE6+2xsu640Hz`I#KwBx$0P!-4~y!zZ%WMDGdjAM5o^k>#ud2g9M~6;A6v|
zMw>r;L~#NT93fnz)&6>;d~83zk&5kfl#G9;s0%hCc*IvM58*h;xJCQPF4Q&a2+nTG
zZ^xBTlGgq?h@}N5VHZ8iK7x;z5DSJJH>aTlUC9CfYt|Tcz5^KLqtd6HLGg67WP!0n
z=p9l0l|*at&pl~tb_p<4!v{a)g<Vt3k(3ky72E|_E>iF><N*C8-{U9FNm{H=xr;(r
zW15OWrwqq-Ix5t9eu3k)K5gI>*3RgXg3oYhYgUTFu#y5@fk?tfw7K{ymo?L+!#~9|
z1vl3Rj>NZYx4Chq)x89vj?NA6F!_cM#00b*p9MOJqR>UBU{CU>Ra|lqB|b;?NPL@3
z!A0O>U&*z5JA`Yvd9n%wGEQ8r7Ei@F2FrjvY@MN_aGr+Wclgx7a~U0QdM}kPIIK9n
z0|i!yLkw$ilCj+G4xa3S<9|3#ra!QPvw1o{BL;s{eEO+0^<}yCeHW&n88}E(PvXE{
zxDZI^P)79XsC;bT?N>l7{TMINx{c;Lj`{Obf>Y#3DlVTCas&3C=t$NJ<Co{>5m9Wi
znTo9N-^V#AB3X^m3)=h>zjl>V++er~g!qSZytO|#{Pq)m+;2z=eCI`Y2LCt-7PeA&
zKbnuPs-@c$oRemcW15|Dk=SD0fU8=#>nr{l93Ef=1I66O%)mz%Q7rv*bM1tDZZq(K
z&Cd+Xo7mFC$MLW|igg%!TkVSNRUA3=sre1kqArjt`t`0`p&SD@;9#!!5F^wgFI*!!
zp=v%<UUY#0fr~D9QoNuGzK@F{4c`|-4@hfm`RIawA%oxt@)okU*F)?#$MU-b4j9Ws
zVh{}lzoLoz*~->sVrMga0Sr7Okb^MHaZn~iSG8GWGyOGOYZhXFtl4B-D50KW@hF9x
z<HbUcvCYj@Fy17LVNCqA4?epttLR+rd8pWU#a(7u<wqzJ(v)%WylM?9GljYFpW>hM
zdHG5i-&|bQ)X8MJgy*b+tjdLZZ5VFS;(s%#Uwl;JyC#dD7PMozDP4i#halon9yS4h
z-ia%Ehj-d`on_hnt^NrqI)vk+0h`@MHaSU5e6U3vQ{ZIr4J;iC8xbN=(0a^kwR=12
ze-?FsiV?b>MKesx5?n{O0$#!pIJ%l+Dh?bcF0k{mGrnz*hT{l%c1&5A)<xvN_?_^H
z`+tU$!<07;fZ<j);tlLm_$`xTp5O^|_q*^1@zz<n4u88T_u+4vGF)$2P9cK0(Jm%P
z++FXwQj9l_L)rd5@8|}8j=qljI<2|e)@M?l$6)EWu<_bq<LYMP>SHX5a~l|D;$J<2
z^DoNsW;aIHw~ep$nD%S}AH`?Zz^G;1i}7w+hMwS4FE_brDV$=@41BBKnqU$iha*>|
zsjE)25FZ;m;pM_pXvTqBv+OM_J%}2G96((e!<Tp<hyQ>QZ=IEE@VA>X6@SyP9>*La
zc(eGAqW!qtD%!t(IcB2VZDRXPK8AVsFy|C|t!O{K#j+KCRn-=;ut_vu&aRDaXfLn2
zt^FW>u1x|7{$_wHTE?E>PcO$fL$Ac!&o-MQG}<Ppz;+`lPOF`1S-(P)^&F8OmKE!i
z%`JsPAjN*jdbQc7_1?(MaB~}kb=_e+k8+?df=mi8Xcw8V1-gObIAWYxEw~cUKUm5r
zSYGaSPfOuURB)aCGBCWs(cVQ@Gf;ubSQ9D?d}<6rVWvGtwxRY+r4L&M-b7_l;{sO3
z0z&nf;s(3`U`YW-|Ax;E97UYYuO7qqFXM*vP3KCmOkWmWZn61KAF7L*fa3@j^KaxT
z48!=z*2Mgq4IReG+6p+)$9Brum}7-0YQ&w%50Mx1+;4I=b{-6$3*R$2h<{9thR`jm
zpYamh6wWd^il1@4Nb1#o*9o7BneboC=<2o=XK@$ceD}Y2CKvzC7REHaW)3n>Z~<Ir
zd|`!OOxg^Kk1r1(rhrNUYvpzAcC21n#*bzv4rhpetHaAPI{V|sJcpw{O}015`1aG{
zPvcnZsONXY<q7?2+`}WonEn`J6sFYP06xhsd94}+8&0z*4Bbl6VzFMpoI-EEIJi;R
zBBdA3BMigm!T)q3blg6tE5p!JI4EQl#U>mg7PHU<xBw0POZZZ71qZ&^hc3)&x<up$
zhJ1Cx{1@Y0_(Z_N_O5OfG@K<=$KA{(rVZ6`2i~QsMJ?1Wa}~{h15aHvhK*JiWuZd7
zauHJ<LzyiyuT`G`*qDBpy3%NT{u2&_(X$giqw)38M9aB`;z%@GEVh)eSP+K59O<>X
zLo68z>*NjXD>MA7JVWcuB}1sjVKn{B@{aJ6R@uj8*D;@T^Lt)<t=EMs3Ur@gg@+(;
zek(%655x-dJTWE9I0U>o4sh*bF1~p+1pkji>MY!EI0!-b)ScWtbiIc)6&GwZz;Q>z
z^EPr~hM*7TwQuM5(XcpwPdT5iz4$Og3%**49g6J%9k<c_*-buLY3yGaBOwNSp{78r
z>%{{9ShHtIig7W-l#pyZ4&l=_u0#d0wvqKf$c#!zYyS^r?*boXb?yDnkOT${K2gy|
z1&tatC_+L}6A6-#1fGEjqA1W8FL<N2c%fv5P(g@J0!*iAIj0xfp4!@;)_U60*4h?P
zYe={StW^*%RI6OH`i!H1qJSvm|NZU#%uHfE?|J`xK4hNDe)e8_?X}llx4rgqk%aP=
zBsyeCa1$N7_*uDJx-mPJl7k;}g@4<`cz9!ddl-ttl#sfLMj}<nVg2|5tyc2@tLA!>
z)PlU=DajOaseao9oy@D$m-zMGsuUFCmQiomY%HSGnM%O*?Z*Ul)gdSTJ6+(xvF`if
zsE+&Hj_hFB5ez%^T`b9r8>T}JHcJ&C@-wtsc(FyByqrnT$}!k}Wx>*mEQ%Y09Amii
zp2LmpQ)uT1GIKGC9Vhs0OWjF};l#dFA;2)|wtV`P2<Q7Ho=)i`C~30FIBkXM)Ri!G
z`!<}|k{Uq)FpwI@Z*G0?w=sX7N&jobikKi_dyMoO*z^_1y2^W%1;rThHMx7m>m2xk
zLD}s@m)0kC{Y$`3Py^R1U?;+y6pyeqm`&z?ur*vj4VlOiC$4ZViEsXKP_+j)1f!R`
z$)Tl+<OwbNVkVX+<8QF>CC4*xYY(12!7xB^J8#S>)I-os=$_X&g(WXKvo`)Fn!`C_
zN0P5iV370elXU;DaTR-2-^ab{d-G&lU-3Pp2=tL-<?O*<X~4IDBI3vWEafw=4aSiE
zzT#GnYlTI8${5(Vo=@Z4o=2;`-0;NyA7tV!zQ!TvtL(-(PK-+&mFp$M206v=Vt(pJ
zGm+#))A@;gRcgv%h-Fk5DM?8b-fx~kR_8RFc>=hrE8Em>;N<qJFCxd>3k#}QPPAQD
z+jJMap4qhOeGO33uVn1N{`;o0U6V3o3N@6-n-!`0=Yl=5vXW`tI!xF5SyFa-qx>3r
z#g{0yf*1g^iBcVK-Q<~(<XuSDXo!+o$$2sE(t3s*vMmQ`3iWj2?Oas6$9#lO<q>)s
ztZjD>w|u;?8QpqIPwC$}QLl}>sN+l&UgKhX8Q~6pMM>0HB#XV9@6&8qPsYq1g{&9j
zg!t51-Yznf&%5c2oPT_|_=xWxuU~2F#jLdOI5xCq^6S%Ml%oAP7qK6|hAz0RjyN6g
z@41KG2lo-ukhX3FemD5H^cuG8MgJ&GQE3Z83m?|o`*aM)!UwGWnf1~?U}lK*(r*fs
zNI;=*Gm#H_Q+GljmTy~!efxDmC;ms;$aUiR?B`@?d`+%?x{|usP?q%EY&%M#oaybR
zz+f$pMHO&{gJg027E*mGXdAQoRLi(D-Q$Cy!=2WjYIrD5F7*Q}H{?m%>nxW)CdW^5
z?Yu7(_*kVsq8-XN3%b-##Dh%#;aDS#xzBr^0aG>>7RRLp?hoAHM$^}3{D6ZGo-Ez-
z6=QcnBQzg?7jGm4XTBh?_4JfWt%fZ$g>zsSPl;h5AO&RVRJnnvVHE9y|E8H1*1fhw
zDD?@bfc|Jj0BbjmA#>Tl-4?KPt)?)%5V(50OZ4PXJt^^@l<J8hC_6&-iNJOA@aL*Z
zRwO>8YVXK05$fxyZ}1$66ycBchi9p;n+J+R(R=TCo(Ytjc$~vG^DA*ku>^LCF|#$x
z;H?Eu*D|SCT$00f)EG{Y;Kxnm6Y9}T>#$g+@H;Y5vu|(%P86L2!s1!m(o+&0?<VsJ
z$A3B89xdo`x9#<!tR=iLk$yPppL1IO-BglEh+rft!{4Vsc;zDd3OCshQvJkm)DGOh
z9Y@9tik{{s@$C}Obe373(D1d7+S|@uL+hK-lQT&cn(okuxCxU2g6UV>d+ue=55x>z
z@qEe!(f<6P&BwKWAk%Q=2C_r&8qG7PBPcJ5ca73@!>I>r<8NJ58{ag_%o4Q#X&J7Z
zYbkZ@QpjL6a{5lgth@;KCMLo--RG_ne+ygWXZFY!w~YJu@s>wl4&A!Ri$?L|w0$Uq
zRegf^vC*yiNWN8exjU^#1njsQ^@Y>cV{Xo{H%V?N61_4E$+wS?d=>}~-xuzBoBiIM
zWS}EI5K}5z!8lH7UosB+z{&L!XfbcxU=2RPzoADn^|S~+2kC^X{t<gxUlEaLtIYDz
zyp#L$HPH}E)ec29n5gd`nUD6yUgOKm(ipukx8Clfxt~B<us}6f#&=W@@<gX<?6pYZ
z+)IXN{$6}OKc5*%Iud=oW!z1dtNX2DJ;+_>b4PfaEYU=_4S%I$(ZmV35X9IEz5l}q
zh@%&#wjX0ybD>tBC&T;}zlW7!PN88V!{|&`F>lM?4ErO<pwv^8M$5Rrk2B-&XL=zy
z0W+4a4sPfdt<A{^%SL7pu}Yg2^G<$N{qO0x-1L3DqCV)qrjv;oe$`D38*$RvRQM)l
zsHo{<Mt~WUsVTGW64#P9ZYl&oA~Hgz%_y4sPW0;w-J|;6Jkg*s*Q3n$h-F5y3U%BE
z(%cK>N4RiEDTadNxaX?%5q4{YcJIV{;4#^_H6v1iRqS8V+^W_uyG7aii=A(4o|C;!
zDrozd7rB83Utog(mdd>JaV%4WLQ!zZ9g)NbQ`)P~108DtpI)qF7&|l<MHt>yOmOK|
zI6Q`27#aSK^0Rj_eQB%K`N;-(h}7N#ox#r9;08AVh7!Y$o<L1V35W_Or?^gijZu=E
z)%!!z<!1ST0uj7RjSgE-N&A}8ie`P{k)PElu>?xq&rF>KKj+6Aj7fhsCY*BxadO;V
zMn5$iL}%&4)b}#pZMOI%%b)lUgt^(uv6rd?eXI|;#0D^4llN{>%ed9xIS{>ejfo#;
zpDlV&k^F4rF_hd>9C7NoP((4>beZC9$}3)dN(+VeO?>gjrJ1N7S_9tDwXs5cQWjl^
zd2nb^`gMPtTgHtVt42zIddKkseiHJWqWyj+gd5JOrLKfMGG^xznS5ynxvQ|$8$csw
zx2u~ZY%RWF5mJ)~Inix7AKkl}B1WFoA>rO74e0f3XTWkueR$D;E%BTIFY%7&-7WNV
zxxtiy6lFaMq<=Sjg@tJMV9n->UNJvq;qC?i6isYcWLvZHV-7mS5(qE@VXB(x(#xMt
zU<#>?mqP`X-`m(-UyC7Q=(%Z!)<{!>`Tb2cebbU%=i8C}8@2NA4n{ALAD*s>daBxM
zzc!Dx=DNcij}v=KEtmU(k#s8T#P|*E1~ADd23D`DIfF$x`^b6-0$(QrT=gjw>&Asr
zElESp3H2tmh`}dvWNvv`zbY%(dkZL@B)_KELn37;ZEZimH+8-UioF_27<yFbzlDaE
zJzgb%nDPt)XJF|g!1%d78O$e8X>NXSeqWc!C2{ei{H#3rVcm2W{Gk$J;vc7+k9%0x
z(f))`AvY4gLDm<DEJ;CcFV%6~Y--r(?X<V$RjP2kw^g_8ONI?_gWX;p4h@2%A}X33
z+-Sb&CO#_96owKzzG;}c_f_C*85ieqAa-TTxKk*}7X^8Rs<dDzz&LGt0Zr!dkXIO!
ziFy-HjoaZVUf_0!IYu<JLHmDS0~m3;$7B`IK7JgKkD(QX1s+pP=n6&NXt1Uy4)U<K
z5prjDK*9GQQfK7{6yod}{?g_U?=b!1qKHVVV&tS#xm9e^f7$m%-VTEX)ZvcbPMQE`
z>SX)&6A#<oy-UU3{qTHt3s?5jUjBIZQtu%iSo&qW%(jYBfKE+hT(f*!z3re}DvzgG
zek3@&FI#|ybi7P^URd-i&Qh@N5+O^=;@aQPy!TU<V86b#|EUL(?=w3^&DPPQG$6ld
zj2CNvq9XHj^+R3V$d&N-Luy5k^!Hzm9ru+%v|{4aMH@wIOLf}TfeWvN%7oD$3o+v+
zYXIA$rG*vGd*=b7Q1(l`xwf?M;QD3Jh9~LQvX0y6g3qA5yQrWRw|QdS<HBT)mS1A5
zpwi=jME@AwB83=2pU&!?*rMKuf3mbA#3#`|byV^b|76*kUGxE_yFdLiGw(Pb_+tC@
z`aT%=q{(8S39fIq)BaFbj|u}faAjJ_%^yFW$B2Abe|^SNnJoAZYKQ%7;75EGx7m3>
z%PC`yiz!-$+cLL(lDQ~J&&iD^Wep{Nhkh9c+6Db|fuPU@VKydSB3VC9FY;^`d25A+
zBz+$G184P!hifX+PTP8lw|p{4vEKttbVsy09NdT^ai&b~;r5wCanA@+H1=JJ+4|UP
zPh@AG)0Q*x5KeazfgfV$z%E=3=|9OR3%g_m_O7J$h*~!%^%3a78_el7!4jwSRttsG
zdMy_;d;_iC(2t^-0@w4rF|kvpb+^z{l{qsEKAhFtDKbrU)KUchHBiQO*Wf|OeEKnX
zuwIINT=C(ZL9%-=mvTj9*9<3KN)KJdYdVeX-&y@)reawUGmeLyLRzZ=!Ktz&RwC4$
zt_+MN3y1LSq+@=oZBOwLoYOYEnDQ;3K<5j%FuCUzo<iw~erd9yaVA_!Nl~6Gp>wGz
zT-o`}_XA@Ee5*4Vj#9$~rmBHXo5F>klpd&~auP46&oz|BC^~Jw;%Ow&NyvO~7h_>g
z9>9nXS_MVy)i5zn>32=}UgPrzSfiERl29UpqgqeS$P4uIB;yKDEnwXsJ?05d5QV)v
zJEhDdre5Daf`5nt{s4(d2p_RMsjp_r@ol=q;%Q*)0z*BG!G9W{U(D4ZRKKRZ0_n65
zkCH#PmYP~x=&h!7r6J#5i=*Z(^{2vMDnp<2DYcW&cy8c)s)UbI=Tm|=z+v&P;O8(0
zn58~6Gq}(CcbHRla`PFpS)cpb8L&DtyE(PW56+DZPLIg7|1N8LZO=<?vP@fNrAlkC
zc=RGlFB|@2|HyO!4wcyt;;V>eHAO$XfAraOIWYtgmt`Y%0W0JeD`1yK2mK)PeeDfc
z_RYeUYFOZp3p|IAIh6W5%ENE2=BIgXum1E^lvgocgE^`e7`Y0um76PXg?L^vprLgh
z%bzy4%R8PEb6^`8-P?&jL%EFpU9*yto(@HS;gio@B7%XjUz)*=BsAFW@E60u_tHbq
zM|~SWtugt$7mRL<kTfwuUc&`%T4fZ6{(!r%H10OzN9;p%wvx$bnr@0^n%xu#rB`Gh
zUy*w}7-*W#bK}*ef#{hW8DcUsVo9`yg`LPgm(0)1Kk$_r&q70AKSJR1zKJO<HIfI$
zcB3bE^CbOSW2VvVJQWyB0Xu&UJrEP~-BIXo$^<6?ERq}<NzMhE!mG1-K*f7#u@|?D
zTS%e66CEraPd#B*pLbfut<*zhC{FB+4ybLpCom}bRXj;Rxe7FxJZn1E3va#A&s)X@
zqL-1kzm(wb(Pm-nP||P2yeseM>9M3?98v2!*3m}o^$6>esK}pJ8QOvNS^y3$vbv;0
zS_{dk+~ARPTjn{NYW!Be#AHdg`_GBo_V`R|7FE<Bb*-@X_5E497^Tc@KYY1?^~eXy
z?fa{X*jG{?!e+T{2_~L#H;<Imzs}EUo%#i6Red$sj(FR^+m0>35A-@XAiEy+k>_W%
zjJw@pZ;4%m@R;eO&9<MgR3NF2G%vf?Gg>_|rzmwkC9#T+(`-s!)W4jcjA2<9Wx|P@
zoQVj3yS#s=a9!diPRO=zDsYomu)HbL^-Rpu6bLG}YLJ~Ot(}wGqvY*qUveTthvn4x
zxSZDUT4JgWI^Vv;EE_dC{q&>I)Z~(nP)1z1)!!P2AH}@IoQZM_D>_&nBpNYV4rn@@
zF7okDF7oJ!QUJ-2?yP>A)yT!moeB@{iV%}VXkY8o>Op+mXfPOvehEhq>qo^FOhCj{
zt?k@(Q@{(Ifwp#NtJ~#`7Yl|qk5hC{k<&gGL`km!MKelt^d)(=UveH;ch<VpH>ehV
zWi%Zb17t9upz?PpPLxZhO}V=Cv{G0iQ+g{xC(an-%|%@0CUzR%5iC+hx_xs|9z6B=
zL(j+e^c%Pi?lvp2HAA4aHyHXdJl_PDM=&=SaDD<f><nzt);5L+%}d4rA3sxs*D1-{
zKY~PO!Kim)5Hol^9Ifzv4<#X?V2c0W@X1jaiuL3$)#yDS^PeL?Ci&UupF!whAyhNg
zBJ{DLpNmjV&}B-35rGKGQcs(Oss&62Dqf9`TX7-Lgr<Ye@;OX0dpLQ;tG3Tq@?`ER
zbDjRLEd9xz6;3F-urcK(4tRHyX93290OQ?dE=|tKTe!sLcV1As*8LYN4i_l`vk6DB
zN|En)-b^m9&@c_8IlEPEJ=I!Al6Mmyp|dLK0G`_Q-X2vR-@qvDFuR1UeN0QBjuFPH
z@`qs%p2}|YPC0|iwoc>wj1H>U(z2wWXB64zfKx`h_CK8AVkg02Xq?-<*IU)Z{6F{D
zS>y}8ofeVaG2TFTQ^4W$Vm1~gr!eX2iaJ&z$W!!e6}|PV!n0CG$6mx<Gj1>sQ*-#<
zo|2qf|E{S(MYel<f+d{ZuoW&4;DQx%_nG{_WryD;gksiTXH;eHhhIj0hM@#H9;Ze7
ztc_<{4UU>$j3a*8JGeI`jJLic24nTU#549U9R<v1nPB2_Ie4ZEzdDGolLpv}3l9o$
z1y{;1?fmmihC3AnN?4R1Wz!^yeHPHiHIMumixt6lC@>A{JN^P#$}n6oiXM2AY0j<-
zPiLMxdOlj9qS=;F@ZcFdsMUa?fRzwHMEGTZP}7I`$qxibTUTFN(n%xU5+G*ZKqoJx
zQAyF$5JkV*F^Wf?`pZB^r`XkZ8%O<e>TCa{W8L=oN7fcI%8w7A+<}K;!ym`!Mh{<F
zTf)-=54nl$HO~E;oPY1CseCqe9J4had)}~5&!Wt*JAsd%@!ZWun;3jK7f)Qu_g0PH
zMaR4a47t~ME0ZK^+%xi&wfJIeN6YTeutA+<6y-u@ACBmWmPWmg@XW~9v8uKODS`MV
zV-Xyq)Un<VCqwwsmtm$yslW>f2U59~?*-@BtaY|s$tE_Z!DMbP9U^QEq5c4mh6bE?
zIboz3dC){;#^x$Irvw2#zcjHfzU$1+cM9Tr1|)}kujOV|-v3<JRBjd@)&}&Kjv=K~
zR31dB8dIBinbcvbH^}ZpUVF3InXGYuP**X4Xw9uZ0>y$R=v@yw#CuC{nt0n3*9`OJ
zM#=glK-{VK?6xxMrqlW>#+q9amc6Gd>S}v|3j=HpAcLW{sWeiL)-a|)TYeh2)4s^W
zJ_D*(;Dd4n{LTVgWUzsnI+;hNMyZT>EU`M$x?Ekt+X0t_(wr49!Wor2^COzC$HDax
zC<mPHq8?LnngUy=8Dw8=9Z%O1Lezds=@50>%#j@a1^Cq(4OKmd0@nsG;xLXzo|FPK
zhcn_5T^fc|L45asWMR7<hAt;QPIN#8w`nMxj(&VTKS(`MK8vcZpn5-Ai}>o>ONX)x
z$!QBh6lR#6w(EpOikAG(Eu5nww4nGPyw@FPOOX_=$~n&DmeMg?4GmInw4j0Qyv0;p
z9*CY$4_)qN@L&K)0`;arhkkvJwq>j=;j_=D#?^VBOL2r;_Xfo2$TJ|&)iD@1Efh3X
z#zqf0KmL3pghQrSKo$GX?yJuB#3XLQ4Uqbc)u^&aq}uuF-nBto^-D^JHnb8-^gH_O
zqpXO_{{>~ncbGvLgJLrdX5pnqt~EjCn!033A>zD5&V<`^HOEko${0YH?gv?0y^5Rc
zWSOJM@(VO=O%`tKWI5#3>b*Z%ZgW~M&{A$D%QQ6ua?Vi;bFw{U^RLr(K3HV}MwJk@
zL>M+RWPZ?l!;GHO`bU}ulxcy~e{r=+3}>_d>UoHdSIpz@3*DJ{JkSTNgpDcwJbp;;
zd(C5p#e(*ct^n;^fmV_o9Ru1oslFcf4>Oo#n{n=Foc79tehSAL9}ZbR1V<qCGp?+j
zV+OBWgV*{a9?HQ+Jur-Ka+jKm@5YuBUpfqn5?|_P`!g+=T9vIQ3z8Zp=_N1xd8sT}
zznf!Po)6j>yVOQ7l+imf<8QvJ2RCC3Q%OBU(?&jk>v?zD@5{~iWvM;6@68t}?M}0B
z`W)$PZ)~4WY%#f_{C45?W`Z^i^}Z&~yLvhU6Y#a-y!ifLVq^TDs6EV)_iq3%&gxQ}
zuWv>jZvw?BI^kgcoKS3_;S_I+?8icX4>3s;wUW~QZqt9d<pfhjS@^V45Al9?v&E#O
zK#fSyTS6mQ%Gk$3V>vt_E<=3U_=Za4XyXeaRztR<EZK70w=VvbK5pkRGhhtaJ=<>O
zTI!OZ5XOTB3Emk#JTrk)@Q|y)psEJKf_I50mZ!$sPP9Ubv;#eOOeE2R%;vTitFQ0X
zi{aT`WY?)pdY|jV_o>nLA)zWWQ|~kMtuR-Sx2XG<DwhS`o9jcMkOB+$7gXhEXo?=B
z?l~gj)>T0BU31VY1{xv3Qk8vs4dv|HBiC^SxpHR2wPYrN1wMQT%N+;|q&g|}cnk8*
z6W`*tqm-+)4gB$LrAqHQpt5g&lYM)w-cI7JPk*&+(>`XzIZ5USuijVH9vci3>!WN=
zKuqoS2GF3iI3t=9g=gf0o!%S+nNbI>;S!}ZKi^A|h0iDgusNck@JzkYaVL#pZwQF1
zSoTg8cKm8*n#QeA1w~l>07s@W!J}R&n8bVeTA9~2dOzh@w2p;TM!nKU#&geLO;M5;
z_RO(PVG~h218_?m`8NF&4-t(r(VRAkcj2nnoi-DPg#y;sT1CHbBKs}u^!DStSME7d
z?8ktB2;1YZ4}1T`(rQxJNOSS#(T3R((B-ZfHR|fCYNt+*gcAeSgpm=5i=11Vm=vnr
zG-*%<@SVow=6#pCO?<N1G4-7Hr~e~o9o+9XfY>pfJ}3_7ay2W`Uc^%#fJ~$!Zv};W
z_qk0WnU?QlH~m-?hy;zi@5LD*C6eJtJTi{&J?8TTA5-Ukq!Er0fQ}xGJfK-mc+Nhr
z(7q@!_5Rd=bxhAc{7@fQd!DhAB24fB`5C`typ9+eoYn_u#n_4f!h4<<;tFh{?HfyD
z_>;~eZ2hV&@BK<ejV-dbEZ~>Jt6F8sz3nZdoQW&ViRglDGw4BilA`#OF58zB<a-Cs
zle)>F0#YE+QORs2vNYqT#3ly#krsFqc&DunoTgqqs@}XA#qe{BtONA@jg(SpXXsb=
z_w>03fs|u6sX596Z2K_-KEFaYWCUNl%-1zgmK0YYu;QehI?8jXFxQ`~zKjCdse<UM
z=ZNXOVR3{@9Dmh2v#&G0R}RjdH`dhPeaEnuVc+DN-th@mpEgQ(a@bvdh1kvC_Wqp;
zsmz?|NN$rZw|f&+^mwOH;cPePDg1WsDsQZ<cZ}-YOun;>J`a2)z2U3#;WJ!dpWxe+
z8c#rp&v!h#0chB}MW2PwDEmsMg}am5UxO)#-^B5h?_=EE<UK@k-;y8XeJmxwPd!&7
z%drXF>Ch@BX;7x$<QEkk;K`8c#>WO?Z*S6c^dwrY*B_ImEcH5{=5Q@Kro|7~(^$bN
zC#cN~miM$ef(m-F2FM-0W45eg$|2RlYyd7<EU4Fy$29gsKNwDifZM#U+V6qTX)QyX
z_D-E8n56FAkJiwj<?s?D83t9xCM05S03{+&tyVKK1T%++sx9tHDVCCEGBi>}JUUje
z1yihi6W?%~-#-NyVcoL)fYgId>-lhx_$P!L&)~wW98=m0N1Ey)RRj)TU3B74^A16_
z7$H+edUAz*u3+DEo!}{_F#1c-9uaAFFe@;#j5;f&&s4X)s_K!M7c&A>TWQ;kE@#E7
zri=AVOc>jD*QdTlf!r8qK#OPF^?bLL@7O1(sugBCR8}#T-D-FE2VQWd!6Q>0c<kP8
zyNDM9oZ*^}0i*#--wZXdc~6>#qXpa*^AZfo&R1@eZjl#EpgOJpfYJo1_hXHom|<Jz
z8Y%lu!wydMFb2s`O6h!jI`F^yY393I_>NBun(B9?B*ofs${<hBkS13Ja_CFht%UU%
zurq~gTP|l<_5lD4v|0;-w1vkXgn>Qrb86`L4p(c<+CFcFS~A1k_BM>kuw01WBz@I+
ze)L!ij~ObhV_}W~W0Nt~fO1?;sX7Cx$TIpRq|IB20EFXCrD<=gaKSG5WI%4c3_n{h
z#p@i&q@f81>*ruCW*_}dukIQOn=l}(SNptHNV=BOQ8@QPK=I^kQ{Y;{JJ~9}qME1P
zT{NJo>HnrYrdFD$W!{yDzpg%xO|u8<CsY3$spEN))d$S10WNRr)tWZ9eD1U%Y+Nk7
z$can2W^$DdP2UNg2=D$}GI!$7gV$c9o~Q7;9DR#84264lLxviWS5zJmtz4pik={w>
zkWf<QEPslZW^zTp)ti_xRr<s{2G}zaX?gVPmXOz~O6qQVNEd293y{S8w%2)#HK1BH
zgMC74j?7>1p`u#Jmc@aT>?AsWtjAm9zq^;u^)8sgBALNwpH_HVY1j_Fm!01H>3xRu
z4^WyN(q#y{scQa^-$>u5@bC4h52_VL$X+#^)r#qw{<Rj!7l7Fk@p3@1L~O*@hiJ*$
zEoS*gV9jv{8}BMVSYzTDv-Cs~gbckq3m*ZSh2R%q_A7RpBRN0lcvS2AZ@@q%;G#nh
zzHt?ezJh%TeWs%%B4KhL!fCu$IX6tXn<(eYzvuJL<XKn|qlpPUrT^SK1-qK)6l*cg
zjJhIgEj6a&rpk^rlPB<I9;9${nU1hu%z|{faw^owfmA7uTkZvEKsgU;6z;_{c0Ti1
zTltDvG|k>OBXs~@BvFk+#M`L>z>Cq#KoUt#=ldzerhNf|Av@IJnf9A1GcaT!xLRAQ
z`+$Kkvgk?yqE~`OZ5x0D4Nw_?3^WE1#2^ceJpUzL<X=HDc=1k}X7~{OHlTH^1NXF5
zNL%VcMl8r!dT0n&+%Zs+(VuU|pXz`6y#017RrdbY*em!fQ%7nopZolnp2OI04*BD9
zdPmCE@y%=<AQf}RD|oMHJBLxASY)cP{4J7fVtnV>@l}NY)lm$3=}S$vE)*R^94e$X
zGI?YGvYi@kJC&(#af#{_ReT1*N^14q#lk84@+lQjorTiU=uVJlHU{KogoZmuWvbby
zgn30BbEpt-Ewz1ziVcBLvmq<BVw<pI0evk~{r@4}nl*W6NXo!#=-IE|cB5mZZKD@i
zU!WfJC7|0`WUc&6OttzZe9@kx_AczxUgiMZ55aA!9y3OEJU@@lOPGfAxeuL-E<a1;
zU?Fvq+F6BrEv&TEC;Ig&zvz^B^=3{cPdx|+6EmSq`U3xbZDL(x-n1ezWz;6v#6lj;
z&dG`VXQHF@VL1Nrpy;`^N#do-7rfY*oW_YP6OhPjLb;ML8z&M@?DBL1i|BWK@A!{<
z-<A2XwNn^`J48y|=%vnZ40z6Pos%;B>eBhn@E@19P{<kn3$wG=8UEj;51M<sSKk@_
zm(ot|-S*bfUHmFN9zrQRmraQz)aR~*$NUy*hm+nEdndu7vAC-7-tbJfv$X&Y2!&tY
zNT9-LTq9gFUTe9v@5}A`%k^LmgTVWaUk^1}{*QQuGO&KnS%Hp~yz-f^ccPvv&bNDZ
z>ZPffc`gy#R(S=im?qN^d9yC&YjhA3RjLC*ysM!HZ!MWobEIkb%yjRS8W{l+>lfu?
zT3GM>hBEQW!q^Ai&*<T*>E0j$K^ZmKGX}}}faDI}_TqlIcfGIM#mdgl>E09dpId%<
zwtTpEdCB`WxJFJ>wo#vQjr$Y@^iL;NA5aI4PQ|{kecB*a^$y!EUnE+{YY|4`hXYH`
zX2W=->Wu{?wUIXAE4}24HG;f>H~OZxjTJmzc}i>`nIlzu^XaCzO(>jWV77mPVOjdu
zt4uV}wpj7w0Z2febf<x|5Sz317vo(2IQp(Okg?0;u=bE~sx@&1n^{G9YVKqE_1?Tp
ze9Va?Vcb2=@7Y+rx%p8OC`NLCNY&P`aye0XZj4qrt2tTYaLbWVu@g)`{Llg(L_ef{
z1nG6HTcR~EeT#o>4RBTu;@N2}ACHQb=$t3yNt42d=M@KAx5VB$klR0D9Cqm~a>KSj
z$^ofuUN@KmvB8DMwJgc&8HE_y6YZ~ouR*9hf-JK&_Lffvsj&=a@A)W|ZzdK@DJPvm
zFrW3(5jC9NrO@dA@IEyUPf@S>GTuUb*ve`3Zq26r(ttc(au(u|lr+x7%oprPNQFps
zU0mky!MaQ!#{c9`!iR2zRH;1j_Kc>E5*$6z(o!UNRTzwopcge+s$%nr@KBFVQ>vED
zm-@;yA4EtkVbOqNJFS~lCnru8o0<D}_XiL`*X{y0j|g@HtGuzn&BR}+LlVOwo9#}k
zc0+kz1g|n+@@SLy(0<)0Tm>bL<Eoa>c48gjA!eLl3&7#DN(!}tuf##-Z0u{&UJQZ^
zn8wZU1n+oSD!KT3T+0wfh54rE-aqWnv>ro^5vo%kS$)RoXb6~1*O~PM4dfA1HhLN5
zf*JkK;3fULUihaA-a@)$aAY7gWm12m;>YL1v_5Nl)ow8R;xlH~t=Sj925xJu9VwCY
zF<xZW8^w4Tn~Gr_#Ru1gVyDOV6vbvRip6%8ryc`uetBNiCSHiS-u6i#PwbU!b(mx~
zdXG*tMB4Tv+M3{W<X;#+JgVMl*k$WskF=x|gy(FnH=Y^{tkMain}^7RYYZx<qB)u*
z-ut`>yl(4U$_9qT!A*IitbhIiwQ87ajBIHbi#gAXa#-OQ(n9a`2ADY)ek+L$nPzkN
zrG2(|&%Q46#&C%o1G#3+jiC6cIsD03Wa4l2gNu0zR6E-U=sUerguvB9@(9~;$m|^(
zZuV19!k$y4NMqj~qOCyb4Y~S(EM&BF6LV4%SX%_TQZr7%E@U9d=0`nKu^;EB8!~u5
z9E=TglZ%VIBlSZ3PVWQ#5>1G8E}g7HPP`BT-eHOyIuUZF$aA(x>@~@XZxfx;!2`|4
z96Yr%NN64i6s-xoRHJ~uOc3Z(ThFLbIJu`arRPN*-TK{4wTCuRwkCEJ+A$oH^UK!<
zbrS1|>B}<wl*eQA7-mYL*nTlp>`W|1#B06X^CA!1I%{+S>Xzsi#B86hH7wOqT77~g
zXg!-d)B7^?$$IC<A!3=2BuAO#Q43)|waEs~o;p<VYL_>RXwH>5oOl#snzr5#lrng=
zX<j!bZ!O|T>XKRrBV@~hHi{n~tza&vk<3`16*v}-Zz$4E!P9DCf{0YgM10J9g?WcF
z;`Nqj>G3QTG*ij9*6XCBr2#0mT-d%53$A&eqw(B&>NV-D;!Q}eC`M<%=iF{=x9mYp
zY&ch#?RsYzo905$awxGazB{-wQhK}&w5Rqs-<$ci&zq${2(hEDz`*2HA8jUwO8wT1
zcxSYPdE}SAAX9p*EggGa6d+`%iVJyYzQ%6ujkjMDK4Lgyr_$G0i<;S#Vb`+_#4Pn%
z{iWb{3pNa)-Z3_pAo!%t<a?pwc#VpG<fUD2747wrC33rUH)QG0P2NDh>JE?~i}P_1
zv<C9~+^;R;k2eOt`r|FzYXXVe3TYw!&!X-c<7im(AP*tb%};FQVoj&L+giJ3K3C?5
zvHvo$F?A3DeHPwYUsf{-;>B^`$bdhI$~AF}Rd<tjo2HNAwSTN~afwK1TVh|Sdula`
z&`Yweu)_PV;y_?d^r;kPqzr#lI_7=eY9w!YE6RmO`qMwYI24RF*{*!WA_@4lh|-@N
zU}i6y512WdZS3@75*tg+R#pPebkw<zi76$KL|NiCc{a!>Z1`$s{)H37<(-p*$HGZF
zCDGsco3dKCv)#qw?Pk;A4C0WF=E<(|Cv5X{G$jXecD;qjFumBDc)Sp#Gob5=tO2!8
zd#r18^ZD2_9W_*KazUiKy?^@<Nyo;wHY7GGl(^m)Pu!NvF0z7%Ob=)vWzny61WF{-
zzbpx%Qt)|suyO{AA&K6`QW#Qrj;5=B?!ly$rI#x{n`0hG>fczT{p?>u(u#$!4xXhA
z4wbQ26%B?b<&gK#V68Bl(py%w+|6;T|CVirXt{rX=`4vNp<wy}@M(|V?nU2PVrGt4
z);G55Y>55xU_+q9X&c7Sd5`cI`6UG4R_z%f$eq^Hc^PhRCNIw+uaK7UWzqP=l_SVq
zB$BFlZ{lUQR}!NAy^Z9kU>kG$2zH=)PJ9_J0Y4pKE^!`M`Z(gt>0`L+-KH<sR^EWe
zb0(p+pT^#i^)%!?qUlQbr?}PJ35W8_800TUsy>LGM`YHrV+ZROVZ1yceYNJTv-<8H
z^B~%wv_h1My$kE{t6#vLAv-^rBO_!}D?!D{Gcm21{d=U%uf6`z4nK}{Q$H5ngS1>G
zp^LCt<R<Ft*{b6dm>=GEF7J(;q&5kSaN7O}GZjV~K%Hiy;-vI#i7jC4(YeJ5ewmzP
z4Gib%*xzx17Gi)S;{rAO+%qmPN7%j(q>T%d=yHX*WJR@p!f}BIb@^}RX(yjt*73ek
z`cel0&aSs^d|7!Qc0xzozIcrn2L6uk+Xv5>2Q`6?ckKONGWY*!@Bce<|66<i<IH`h
zz5izB{$+c=By;}{dw)Ckxem`=#d3=;?-OlGf49hceVot~JxhAa+unZ4y2*S*S&YL_
ztoxNt5BngKQk=l-5QAOe?>p#S44-25M9W($>tZMAMAz70MJl6S`29|7TKg#=Jl-Gd
z9C*l%bZEVe&+T0<-oxnxZ4@#wmEp&KW0L^>+Fzet-Y>ifl`DK`x4VtpB>7jlRo&4E
zwQD5Un7j`rP?DU%2Cqi1V?R&GSNu+m1UIooyC0i87QB&F`rswx;OQoDS5Hsu$JD;w
zR`R+Ve~#VUj8WSHcuxACtK6>V^8C-h(N+=-A3~4H>1)!KUy@w&H@oPV1KE>jl9d~7
zzpu6jF9f*|VXN!IO0eU^cLH`eafTdvxFo(#<^qK!n380HjNZTt<tQkJ9kQ5^cKzpk
z5J?V-B(GvEA%zN$yZiAB>kY;gH!&Fl4HhEHQplQQ6e1?=XcC)qEM>Op7>Pe-BgUC(
zV>?xzJTmw(^##bY^V7Ufjur^NHAk(GhAA=S|JJ16UN@A2q!|Nk-rJXD*DE(Uz~zMO
z34v(rfKyZxaz+;1GcOoeIFq}<&0IMnH!qybja%r99Q;+is^*SzgKy+!!Keeytie;b
z;^DM>XXLhp!?+q2HebH7pvW27WyIa)(|x+@9-!7L%n-pR%*$T-wY6^?^Th;wvqtJW
zFEVy+Xyw(VjuZbay?`%-lOswI<DAxS8%#5Fl9z|2n=*8noUh?=6HTn%vqI6CXo`r)
zjmgV7dD{;C3^VeP;NkGti46P^D$*%+!f=drrz{+wh%1mfEb79^iHv3)qj|j>`$J|t
z1P5z?Ly~DNQv8dKkQ~`qb!*63fyaW0yrI~a_%n9eUIvSBlEgfH05YU_eTZ}*_>rUI
zOtZ{n_8nmEOU!T$1tiMc#58&aIR1&;;rJcJMuN31%b}QVWqX$CMf&eX&+wL38@3R8
zQb6?)<Gk&aq6vCGsi?Poj{D-z+?Vvdztl}G3&C5ejx|;3yot*L(evEojL_qfZa`lY
zLre|zUImjP6$4ZIfLpcMbtZJ#H2=pI{Pn>4tUZMcr4cf<=!{)X%4oX8jaLPt=ex;T
zz9ugv)*7+3Ts~PhS;HIilzQV`I$vYK(*mctSo!JQs+lEX2$}IRx`dd3v5sKM9sny~
z*3HC9{$(uqcNK@L_BUOgoo~i?dtR7U{Qh)i`lEK$pHB7Xuk`2dur>6D{R{ru(GL=5
zW@AVEF;h*42kq%N%|7$K!4q_bMUfA}&IKC@_V~d0Qo*^m1p|w2(359AaIR<X3rqaI
zj%j>iNXNT|kHnRGyD>UOn~9XF;vL~H`evIK-xG8PZdI+Wb3x|^&Mf|asbJHWgMqLA
zOuHgT$w8^ez+HO3nfF`L-|D?z;s1$CHr2byJdMM77+cZ<?D&3BtWu#OVydvp*bu|d
zn3ZqLzD`aPYY$6)QL!2Ox%K8;qE2x>NqkvJAbO$8p}5H_$gc79f)mr3{V$9yveDB`
zR3=+Ex}?@He<}0Mpa!*`TS0wmMkIN@Y@vqB@9en-Zq4Du@cD3iVLr*inx^SE_{7sl
zN0<0~N%RS^p6^zj7W=?WPT;OHdMe_T7;$g@Yli$Cks29qn^6o*-@NZ!Z01iS=`h??
zSA-VM3?~QD3M{^A-9pzT({MN$4%u^DI`!fVgEx-PxG<80vOAF%>o*;CDa6~@TNwNy
z<|{(YkHH?Z{t-=;KI8S7^S7YrOCwdyp@q}f$AW*o;=OS4a)q{_G8{<f<1ZbH-K4hX
z1=h0D%>c1WRjiZtHo>);L(R_`xD2tG_!U3CqvE~vJ9Aedo(`yZzJagp{$05~C5FpR
zHyrydN5o44AAo_DLYzCyn%o=SZXBVw1}5d>pB~>mDfG8zBK#D7c=S)>H%%%EtgoH9
zrgN9J!FFrqKDKrmrL`EmD8iHr_9HC`8Y+^Ccpz%cR*G}I%lp}-hPj~~I<1W`AC`wT
zT5B*MmC2IfCgzoSg&$kZ>>t$Ia!-+#t;SGnqQb#e9_HBrrr@RnOhFdHl^mVn#AQ3<
zW|?m8ll|j>b8W%bbgIT0ZuGB(<X|KAhb!=N9rFHq5GXKat%3FH-<fXJMvg4eR@r$)
z(c3yC7BNY@=^}pVH+j+NZr4Ba-R`<#RmN|L`3*9o@#rRQ##LK~XtB5kn<{Tz^OoW1
zrKIHOg92)SCU$yTM{9m<fI0Un>aULmWMhQ1^iQrg(nDF^u>XK~2Mc>=>I0S$E4Ov(
zC=g6U)>_E?ij4hosHrJzcBS5=oZWEIYidMF$D2vz%PXjSOe;)RV|z%PPXS}AYIOZo
z)t~_RC2^h0E`3V&m))i3`RuZmSyr{EMp#sv+d25h$5ca!x@sn9mcRSf%=oez4(&Fa
zMONJg=EbeVM{H=Su>B3AwLnEZWR)TSq(=CX3Bvnvg@)zT*uHFgqz=5tRmlPAlUU#U
za%_sU<rE+0&E;-3qYA4?{U5F~=-IH!T9Mwc-=Cm(g|R(C0+JrByf4UXOS_t1ND;GQ
zv7H-Fsm<sE(EK#caxcq~Y=uG)Rz3ioYqT;X`ywY)IPn2Ig=C*GH>cSmBajmhc^9FR
z%RQlp+03asQ0O{m#da_msk#|6ymA{GGF5EUe}7T^giP~Goz~y0435<zav|ljpEkJ5
z*qGjy{>$jsmD|u5hRh!znfdvr_psnPC|QvQ$+{X{h!o(9^`)-YpGni&NyM571(R~)
znhj?h-YA48>Rj)QkL<+N43xmH7v8h}!$;HzbmP4?3UK2arumU~;G3I@_hu(dIHBYl
z?oAMs|45Vh7jybdW|ztAR%}W=1MO?Pyp^gn*-P(YJ_<&}NX0+UTP}<WOn2x~pY{{`
z?X+?S_L^2xsoJ}dYB>)p!_$g1pshF$VOS{iq`AejH12>wzs^!Y!P82Vm2YVg4SJ=F
z4Q9TAO@JZGrJgqUPd6WMzBCzOy{mbu!i1o;YHbgjs8)o1>EK^7H<Bi&yJ6W9kbNax
zh8Y^JJvUxg!us@?_F<~tT0xg<7G8Q)$mWU3KxAQ5JhYx{cFJA>pdHT0zdFlrhuB;0
z76<;)gu+-pKkJ~`AvcJCMS|QMXKp^`hOb4yJH2;t(aW-?P`fOi@B{4hPW-^2%4wCS
z*~=ekB?J5u7>A{q4qPV?))}_875w|_zBW$rKIIPV()%v+egai|{`)Pw-;#PL`+Ycp
z9+JgT9kESU>0NfcwsLoW!!0nk{+O3Ue2mO~kJGtN`?mfUvhPKo`PY9geZEH_=*P&V
z876_9kOB1izi)71VnDAl!>eJ9&(k<w7Qio^8BORLI?_2kn&WlF&dNN0tU7xQth4fO
zb_^~MJq<!7Y~~b}4bZ<45THr3$a=q5v&rd@A!!oPjaMG^KU>FBNP#B>e)Ug7EJakd
zRVw2jTNW8QsL78N@XTnT&UGS$2YQeF{v#Y0g<aBXCH}06A;M-03HOk%;?xZPhi4(k
zhrAasY$FB7_GMShgqJGdo6P+AT)dyrYurDNZoKTcFo-%PY?a36mTNzEd~li}32c)@
zF7n!zBQHh6fA)<X__x$RmUzIc^6xxHO4-CFUkZ{H^{;FIeOMC!cW#N<t6tAs9Z`=h
zb-s7O2vuHRIxDdQbzoPJkhu_M_zRsCEo{8P!(tMMa*A<a>V&{5ET0$3{8?=Lns9Cj
zT<qq~;8Rxo3kln)AUFH#ga@%hh|0?KxY%CDhz!Pj6qZ${bsNKL<OR*q7r1F;_saLW
zoYs2eJ`<2gG(DG-+v^9j9CthSUC3Qy`-n2RYo|pLPb(tDk4+(BDpFeMX-~BhrE;w}
zpBkA}oVGk$;e`Q?`oY{{vqKYaqYzT^T`qN2{2hx2hR_Xk)upR;K2yO6lYi(9fK&b<
z<F7o(roMb@OK{s8`U$Y*_kjoUQj`V9$L^+@F@g4}J6k>;)_jLunYQmaw65#QKxOng
zx+N%nPKD%&Z9>#xR5-?PyxTq<+wDsW2iYg}X9h_wJe}HmJ?f`Nd3_$`jmLqO&*^DQ
z-&Iu3e#rs+!~(IAZu~E$yEH)2bLta&+@!s$PwdtP+}&pyUC~+n{PtaK`S-^P8aOO%
zm=9fk4muX)P5H&w%1cL-JEmX*Gf(SRvXb$%*MPQ-fgssaZ1Nj0rftfqjpWjpIMA5b
z7(0>e8zcI~2zxLn_$82;%NRaD?Qo4^OD4%Z@dPLgB?<>CAtXieR;23Hro5H;r>Z@+
z5ub*x@Gj2~ah>?js7B-fm}dl1N)(lw5|CLiOKm^JcqyP>HbAj;^;s?qNaTs)lKEpH
zYyGpi!`@^8S4#c;)T`}-^T}nW?SFvExJA&SeTzy&-tBr;c?x?Ju8r?Lss|zO%Pc~~
zGHD9-k*ukI%>o`;5L%Z39_<t1-g+_Z<332;nSo=?O_WRTUbSYfe*X?}T6uZRLfvo4
z-QTJETztTqsP2D~eec(QM}d!dr|mS@PHs%iNVi`TbldBo#g`Y3f|R3W!S)$jTaFBD
zJ}azK7Ck=ZJ%qVQv?}_jFYZ^)qr6pUQ?-97r_EH$QCQQeH8<+|yeywI?c)R&0YpP=
zd2V}{ayZvhhv+Kj6^THcwu^aa$~bLz^Slpy=Udo%wH>_nU%@#aO36#TXCm~#v*>FU
z9^OJGx!46fgILmfJbIPh58(YM?)3D9dh`;wh9C6mI*$#RW+utpu6K@)e-MN>pMAAL
zLB6LE4SL$qiyZ<oO)s?kqDI?$yMbOH=WohC70{Z%<iUkbed4W}&b|HPo60%#=~OV>
z1O^W-JkdVSi@!C%f7K7G3#!QayxRDNa!olodzQD-q^Xo?cPeZPPYQFP_4(L0HE(z1
z+T$sC?9-bJU-glAGDF7U15WEs`tJ`Jgl2u|@@`G5BhbTaz1S2uzt?#n{`dRy{qLXZ
z{e7_4_iNCc{qN6C9Ykxk_{gpoz;w_w1U;}`q_$Ip`KI?lttX$YtKwCl8bND;)WfEz
zrFW-QI|(xZ(@)T-&5nKbxppQGa1(a+nN^GZ8}2w2iWRrMx<(+P*xUD+a+#{se_Pc+
zs&dEaUS%}xO<jGf(BsT&j!h6b$FOYLx;e`U{>2g{{+0Z$;Re1O@p*hqeAzSuHI{q7
zF4aCKf~{@a1~&qrT)bpj>OT(m#oK4c(Bh31E|8i}Q7x4^)nJIhVGXPHtEo^gd}<kX
z$$YVj5A=^k4bE>uEHIh@(46{}x0EhaeDxycwiLD+O`Y3VZ|YZGTiUGfYZu<G%|57V
zMoq(>=eB>-Kjq~wrP{7TZrr>p+Lv4$hz$QgQ4(*SL%YUZ%Why=B(4f^z$9rmn{|)!
z%wRPdF)Sg58}e{4I^Ha%c1jxhX3|!Fq5X<qwtRe6^Ql-D-L)6en!4|9f6Hw<X4h+D
z@#W;bZD3l^cx~s?eEVMvh-`!55suXQU2ZV#UB)Y^Ir7CbH8D=nOa6id8B~%&00VoQ
zyq<Hkdxsra5taguFY{m#0@GRk5)OTFiqy+oX#JAJz~++c7!u9s)FCujv#wE#Yd%li
z&#;h>V-a%f_ed~n28sQDXEE)yO%*9d><a9o6ML;^^B6E(_GgM|0TYkS?if+bXQ{%>
z%+w7u`gwEBzOCi0o$jp*X*?AaJpQ`czdSVvX<9-=ZyZ?U&~bwdizIMhuwpwUrQ@@o
zfXTien(}63?MJdSG$xLi8xzj5!!(h>ylp33b;#C|8wl-`TD0)&+Lp@#7?n;Fev!yv
zeLCv16OMaz0Yc=<&F`4DQdiQ<=OK$JaxsR2&%+e2PUBThzNnoUxjC0)8%bM7I4~s;
zv+;F%Po1gByfMjsC5G$V<5!<0$MzU!CH}5J{n&BCc(CBs+V;DGwb~MVP!Sa2dq17?
z$D5E4wTX?0<B#7J%f5KepU>iF+#CFu{mTVidXRuEED9yZy}%87gW<8mkGNfL=PULj
z5`5bm0r?~@T5Z0qD<?I2esW$u2k6x&IW}T38GnbCHbTSb?M8B`D~tb)7ztu5Oiqeg
zHuGsmt|FTb8CgawveNrLioAGIWw>g6^E{X1>%#XQ3%qm_kc}ygo@fdaO5rU%gVCpY
z3^{zRCxvvz7zzxFt1AZ%(;O|C7ENitF{2l%aVtfgMWYZoIbj-PmSF|&ecVKbzhZ;h
zoK_nf*t+_YKamDWS-HGYATjh{?S1CHK3RgDb#36~o516GV)l-9REjxN0%LvR9AiE~
zU0h=dI1SxNBGK&)#|ChpC?~(0|6T{hHgvPTORlcr9AZwGdnCCulsLTItB`7l=&*fH
z#gW7eJnFsTZ!_PsE*(xz%1<=sOFPcdmyFlBHtP>#^ywZD0!p%=Vf`HJCYmw6%tTDU
z&EZ`>%=R+(J@#>dZ<Ipg**4)+*G#wjlFF2E+o|6n#jw~b;%ngqYc#gG`s9>+iMXVK
z`xwf?3y`G|GaiUsP)&X*Bj_zhk*`nOs$nVXBjKWtn)dx5bd$L&oOnUz2Rl`8tI$42
zYkX&@W(qh)3n$)h<8kxyBkj|%W3wfLBwUc^P(h_M-T2@|E*XlAB!*ZD5hR}~k{5c^
z+YHr}dEZZIwPt5EvZ`v)ZlZFLTA876HSzh?{g&#WxuF16n-~xsXo$WsF%;jss)7pp
zbhn09aB8IbXXV}6tCIzlk1{ut=bpgNHLMQP7na7oer(LP4yN1l$!NpOUMyXz$eVIH
z9jHpj_F9Ycy*-*%(bK&z>Unp;jz65msn+zSyWmA#YR*}H5j{!v*FszDXS@>=nSEV%
z!JoP2i-6oxs~$JR+`SF}drYPZvx?^E#k^0Q$Es!JH^NJLf5HatL3)=pIk5QI_sWNm
z+RGZDS=Q_Qz3;B1ZQMFc{~AO(WO3c@)@-lQg3UA6Jd+ffxtNu?n3K5>&GQ{Y&4;(?
ztD?-S&l-<myec%`>=|`!U%lyoh7KlR`uL->@ZsL;3!>TYR`dT8zCz%WaPWVF&u~{1
zNwe_@RCtfE(q>@$%y@ubgV{g9#DrP-&-_P(?65wYBZCTV-F{Y}HnFv~(<?9q&<{Fc
zL?$>WACL+n6i~h@nP`&*6S?yVzF>lXjX}ELa{ro1Qg9j96O)lvvowIvf(rj-d3|E@
zb{TfyYMkzy*j-<-c|xMTmHqEVy4m3N@;{Q#@+E(#erg&3KXI9c(Qe&OjpxB<`fJ|z
z(igRpaswvszfCtzjT+$i`tt%FCxYo%lex3qy34<2;V78rU#nYR_OI2goBeC`=m!6~
z-20xWgLAJX-|WRWe6H<DjadVF^XstP&XT&tfNsXaf5fnuq#)*eL?(~bSJ>}qhs?ga
zh|hA9!_52U8e$J-xz0rXBqx=-DAkp@B8r#Klb?H$n>UlxVJC7DDA_M&hE^65?SxEI
zwV$}fL^EPQb0y;Wrt}AW*AGRZR872X;Z!#{m8{$O!IcBz9g_BgOF2qrs_TxOT2B7U
z<iw)dc=gJjXl?bi(F>|)M`u)DCwhxsUVVM^tJN39hHsh_I>iXy#xKuZKZ0^rv8*9n
zsS)j^9y?>!f*7xYnSudsPPR8bKQTpJicX!i;A|D$G+=h7G`xW)r}ix`sOy8l>dRIR
zh*njPi#Aq|jCE7&G_&75>)$YuE;CfNUr^Pq9FVECh0X@zd-9|I#`81mSK0C5(a`K8
z+HYA}egYXA6#!zsbH^?%BPxCBXuP6YnQeTkoXan8PDhx9j175_<nMn#8zxBA%6>8+
zXs(5m4V)uWy)_(P7DBiBrZ_h%2k}=@dHDugoV)#&(qh)460=hzzlCKXPm>et1BDK4
zoy+wFxP^8palr^(^y31FOlKM+T&B+iF03<7>lM`4awI=GS<&f@Rk4t>{4^c`MA77=
z{2`uMa`FZ^tEYupj)Y=c;8i0CEqE?cRT6ue<!sg(2-MG_Yl6{D!j+!r?*ui|O3Df<
zAZ})aIZl69NT^O^`N0nLzrFqrx`&vqE+B!WkApw0FKbzRI1pVJsTv!5KO8?gzWF%k
zvAVO}HaZvGMYvKKxnN7En@En7)A|Q0k}eYxMzk&?f)sgeus@?A&H_9_X!N$U?O-fs
zD*TZ!b-~=TsMT*S_HX|9nL|n6m4bm;2f(wKSs~Lo?PwAAH!N@SYOj|8oZJ-I^^J9;
zR8f1srZh-$+LRJZpY(B(_pL{D*vMD;Z&z5<j9Klr=kIru^YKb=YIcc3B66s+c~k>_
z(W*`CmRMJDkO$i8P|+DYSU>QkSl)s4s~QuVQ!6niW%!9dH?r`V@#+PyDDy-3<%{wH
zD}DpPRvvV4_8}KI4Lf7$^l4f8CsK;Il=V>^s2Rge`d7OPfPfF~G436w*pgRlXAS*-
zPW`fb62+r0MrIm&JAItt?9%<HG&zM<y41=R#rc?8-^|v^yklEl`j61D^==woABwNF
ze2SQJQ6>LyJ#RwaNG`)~HAZI;kq`0|#)HtCYm5XX2P?rVr||kc^Sau9eTlqPEl(!(
zFm@ub6*ZVQ;tGnOS86}Gn1ybySLm1TPx(;#<u!$rPrsC-hu-ih77|X(`S!9^PqH!h
z3a(6y*lNZp+dvJHvGmU&9K%cSC{j-Xp1!Qed*EaX{UDlS3QP~BpQz|ecjwy6@S9%k
zvZB$JiG14Z#9skGQ)wPdLrz&12?8gmO)cf+-8(1L6ZjM@Ec+yWq(7-><3|dtEe&2U
zsB3qAe9yjtPp_QDkQ;woF;?xZLb>^{eMk+zq&Ugn>SuI!{p}R|S~*Ph+hQ1k|CeIs
z*s>z9<8K%<oW`yX@hAU8hl0*eyHYo+^)=Vne+6t^9S8|IEB;d*PL9_(JBn(T#_Y`)
zV$kTcF6ZUc_7VT&M?+fdCh|~Ryi4?+EC*aGL)Q7+hUYy4A{UoQ4<*A$qOjB}GNmNJ
zEhg0n`^%p7j^Z3996ws2gK9=78T<JnwzC;7c;I4mqb4eyS4P+ka+QV<kW#lB9<jN{
zoPpL?9?ou=(j@&zfjoY=2A@MsV-QQOE(>`DriQ~k(OVT*oakaZ6d_aj_wMPzBHFbl
zlw5Lr=-#(AumfLCaP1~fg5(D!ms}7cl(K6dyTP|onD@0^UZ{RxH-+`(+o6F{K`Gu6
z88j%L!3O+NrJiOc_!~o*4LSPjMRzP(3KT(lV|nG*9INfkKGC3F^c!WTO<8tY;YhVI
zyA6kZq%i%KzkU*@m2pmH;<F;jrA2Py8tR@{rm>scUVT)*k;Kvx@9+tJ6Ak6jaTOe{
zOBR(|OR(@<rg#m!QdQR#ErjzlFrZ^#H~U5U;k^C_YeJzI){D2jiP+BZ7(H*Na|LiT
zp7T4Y0xUl@Q`)a)*=irURY<Iw9$HvpX`T%<2~x_9;0*N~e*8s|08;k<K$9n$O*V;_
zyzLgqDADJ2MV1^+N<XnmyU}dEYDo&yh{-|RyG!C8f08#K?!D$LZ&6R%zgz-btksLi
zm(`ez$@3+qycmug&Wn}tA1IfU7Lswn`{nVV#288s^Q|Iu*f`8N)Jl=dn$8xX7}Ie&
z*{@0By)IGslO{i&-daM}b=Q9%ln^Yx&#ijVO>A#o5l&nO(O*|dSEprk+V!=`cCp~L
zElWA};rZy55qA5S_yIQ76kER8{&oC+-O)=d;7la)HSG-N-NW&ohxmaTjYsONv=2io
z^DnKfGIg%3FLai5X~#`b3WK|hgyFn~0RQ=fy;q<CE9`3dcMGG4b%jN`YD~mR3~NoD
z#y7f4)p3!d*DSv@)5=%wdLzAM?KkKVB1UsLS(oF>79o~Rhnz`wfi-Kd6DMaM2(2qo
z4xSOd!nAl1BvHb+V7+F2(bICLtrIhIBhT`tmqqeUlHP~8g8f{^L=p0WgUuKnMG$gU
z3}W^vxh78c9&hGx)<X@iAbg5icqp?*k#|QC->?U{MsXSCIPqn)cutBU^*L~@sts&!
zw@txniel4bE6ZC<!)PwgdiOvVEl++^J#^Zxr)IJ9FozXf(Ox))gGVA&n<pl!A8k6p
z#E({O?ykSjrvvz)Id<0?;_LZza(g~n1>8~cs$#J4{Vjjc)T!{SM4jjr1_&dZSIHc)
z%5{czkfK`F`hYwLH#4}MU~oGLOj2jMlJC9K2hn4!K8X(_c{hh9B=aAxT`9$mZ4L0#
z3GA93Js~mV5y@>j8+LgQU9*Kj`Z?&iBT8!zZfuF6gb<<UEdfbPnuj%Bb_6vn8aa-T
zkn6z?o_7mFKv(VHtfS6)q(cU0pZCN-)ev2%>(@2SG!mM4H5!hM-rWo<!{D^F@|BN$
zk#P+};2kYgZ>ASDg7U`ThmBRcCMHHa+N8}4Dh|Uz4&dp8EaLYzf_RMizP&{@;JhZ*
z6Grum{=j;_qSiEB^3iT_-UQCgkvffuk5W3Lg1Eq7jJ!PiS@jM6^6HpMfe9<~M+>A0
ziTp=R6+)#(FZJIHOMUV?n&F1#2u!Y8xAYvzGiS)$2LNog0UBrZB?L5FTC;Kt?hTIC
z*%9VI?LwMV=<+W1&vHo<#T>9)KDnJWOu|lL%+qNU>I`)<GrXN3J$0QAs?+u-t_VaI
zxCT^>xSjReqWKKG?n4t+4k`C3I;sc7Qxj-1$dfuQN0be9{6Whu6gj;lCC9NFUtAoB
z-dWL^nF;1V*DNUOm?%=tio7dC1W=ju4Q5HSw8t>F$?ZcPQA_oS%a{ZE**mGN1=Ax{
zyEPY`x?_<bTa>FecjteDaih7eVEQ$;y?UbtSaTJzK-Jf%dK)KYTF|uRln9v)9w|&c
z!^9(OxpDa0XmTK6R%GnFIgHD!CJgtBZ*!CLYNWOxUV5w+9+Nk9EvC0f)qW}5ghwUv
zS+^OD_cp~f&w_>}X8B(x?;%?hY9g#SoJVX|oUm4$C4AsL2w5@h(`RcQeg~T+^H4{r
z=G_z0vdTfzOveXnrFUx|K_1I<vJpGPH3VyIaaNDU%>7dAvT*YF$jy65t#)IuUu=y6
zR96o1!$Q(A{8o3sAMVhy;!7B21?7Cq^qUNEMY^-Ed~{7V%+$#VM$LxztoWJG8$9Uk
zz!AXO&}MY*<dbXk7#VFCV+P+Gvr%G)S0}#0Jig0K#8sl@Nv-#R*m?0MjaISjVonN*
zFJ43xf}#PVdo_?7LMBxr`0z{dii`pV_SDaeKP<5mWA%B5`;<mv^5RS;Lf)Tz%4iIK
zLM?wpJ<G&vR?!C?jPt8bfLQ4GmYxMCawg@hCgi4_UO&hJ&NYDDn+pc|s*&_Z13e6k
z4KBm?AZ_GLZeOx1<V_y{2#MdQy7ac(`iHz`&#!Rf$Bs5%>5grlWp(O|GBs7&gEp~S
ze&lj6mnnK)a_A%RPkN$zTb`1KJrJ8)(HZAZtjV_b8GA^wVZQ&s%Inm|to(KhUof1+
zd9CAEmHuwBu*+&d&VO!O@Kkvx$F{^)w>;HOvEZpjoI131HinGr*3<J)NO5|mJiC3q
z9slHpSUkOwGf~Kea%v}~*#2iWqA@Ph)nGWWRRRGAjD@N>g0@qQFIU`sbwPAU^#G?$
z`@o4U0sqcQE%z-S4{}<!n1?8T$@@h)6`cp~+o5-{o0Heu91Dlm2auAZ)06i<$cwHt
ztLi3Cnt$SzMAuvi-|;u{V^MNmL<jJBS1?v~a9xSL?iU?;@17PuGyRA<iOpSJ9+m*#
z4l&!`N6El~%9=oRF!o_ZXXWwHxS#hWd5W{T%i?axI#yHXKc9B)lL}<t+veJIqehsC
zeL7L&w6U9kvWou(FXim0s;n+@Rt#aqbyjcYNcdgTiD^S#URr`^@I@YHXw27tCx%+S
z{RlNHw3Bn{C?Fe!o19gNc~5o&r}a|*VI(<+3H=H3rWSNE&v6ws?<S!m4!Oz%v9e1U
zWwF8d;=PN-UBn6-2pAtvQPK%Ht<R|=-3=jR3ie89-)$sOqV0FAY@{W}=m889OVD+J
zqXro=e;f9>e5XyO@7Zp9;Z^A0WymO~F7V%{Q&Zs#8M@><Kw<Mxay~tnRA!27O<hP4
z>V25(0Y6dmrhZo?;HZVj`qt!|ogWF9`5XcC9CYybE7y`w<=c3aJ08A@jFyk`$NOQP
zY1E%jbcgN*NEg62|G_soc!ajp1|DVmHLEhEjGVUGpJuClM%7NBTKnSB?27`%&>PMR
zqsXMHv)?|LE#m3h{uU(ol3}9B@!p4|^G0PU_R_jY?3|t2!^PZH%%*dD0{MhC_K%)K
zd}Fk~JuwCiJJo5v8J~W#x4*J|Da$)KhSoC#Rx#@1&$R6=EBE5ILD#$6T+~fN9Wka7
z=HH?s?-u)dnm5~C6nj_Mi#cA{Ud-}pbRkeL<-(_Xzy2cc99yc`JB^EsVP{~k`LQ@O
zJ9Uf`i~6oFnS4i|V!1`(W`Vd6C7>t}EhS{CKl|sC2%l^rkXk7>da&F3J6H~LP<2uB
z9{J>oD_&&<_yskGiA>?kE7XE=GL)-23@A&Ai#(l`q-T}Ap3V24v3zFBUCT2Q;uT+y
zJ&+7V&3{%S#Oxg8Xf|)0`GlBG?~DFbr8nGMv3a4yf5ax5p6Jz<&L+2yxKvve@4-V%
z00i{iP{dA$9qN#G13f`m4m9IyzsCwt@lD0v4w4ZyR{eLW7RUty)O=0)G4ta+#VcJc
za_{Xaxo$!rS^z)PBO6KTJ;05hEJoYDQtjN+YHmF;yRvGp$sPr|)}s+rF5nATye&V>
zWyPyglck;zS`vtsQG;+-<|aoNz=5`e^T)vyGWi8+pW!HJe$`;gJ5>)P!3nLXVNh3p
z^GJr{Pmdl$#(Z1CqPL&x#;V^50`%Q(b1)m%Y{gx^S-<?tXfLo?JD<rv-_~Om)##*(
zS9K&ne0(7KMUd^!cknC0Tccja`LV!gFb)lX@^Wv9+ON7b(9D5|_n_Z#>+b-x<K@e1
zcE8$(@{4Qljw^<RYsXnGlYVCD#sD*^L{K8=OvAiVu4@h$<g&~>?yjrUuayU3L3Ohz
zIfvid>WNJv2H|jKJ<a!LOrmbSe{L<Nt*^La=T$oK%V{zrIk%Zz&h0V0`*_HAdJi1J
z4sQi0K3xi1CJRb(I{ML=-@C)HQSIsHRRx)?tK%}YD%e(Qtvh^PIsdiGlPNV1i2=}t
z&$|sfNtrv`%L-d{vzAWv1vOfWjrN|BSmy6xGu-B1{O!b#V5v37V2hr-Pxcx0?dddW
zYv6x=KRH(v1)P%Q=|^OD8@@4xd?=0xEC&2hfbT68qp_eXOBOLMb*!XQiggxXXZj>(
z`4n)&;i{ON);V!4hs3oNg}3dUoE-B$`&pY_L;Xtc@v%oQQA*Hsowg^{`prqBYWV{f
z|2XJ;tCFR!<;jFb&1rp$`ecKWr4{vS__I{rFA_Z1*uG>W^Y$h741Yk>(}FPsy?r6R
z2cfDZdS+@NRrH!~&T1#VyR+rv7N<>T&FYlTNY$~0Z=+#U*2bSzjD@Tlf~zQ9M{>$p
zgyW&=k*Kvq3JPW;*iGYbGRdPY6T;?IeF{-yVKQf?VrKf(S#gK4W<+tP1iKrnK5bsp
zh%;(9yM;B`>M)JSe&9-bv2-IT)4P$tDTpRDS?{X$hT|_0$iLL5EU8UJ#$~4Hz)L7<
zoIsQ}Kt-xHHVu>sq4fokQ^NCUJTja!m6!}7b+$B{yE)iuMf1_~a4fxl82u?aM8RM!
z!t&&?^&cOO6$&lb5piF|-fOJd)I`@YHpHtR>4_FH&SwV9HK`1ZBW-{4ehNjenw%W+
zzNlPz0;ZQoIb=pg@4{8xkPXBX?_{s=W^K}29O{sr!u#DP;s>IFy2=b)9Y*id5U0K>
zZtN37`tMW6j(Oi{RU{rH^sl|+q2D`o%@_>i&daFIuBu!_ZH57e5u!jBLfhX_uicxo
zlBJc(x4+Y}Cm1`fypsf>PU}V*6(jHoe<lF>lhA4Vi)d16lG7R$;P8O(ZnSuXv_m0o
z-t<|r9l!vvZHba_Y+AlF{D{}{F$}joe<bHzMhHu*+UndVEk|}2XT@Q<uS|6#8i#iS
zcnNR@NUlKl%0)+HU7|qClU5lSU9p9SgJQ?GJZW`^Er-Z=)h{sx@?iR+HVkJ-vN--O
zin1~T3jh8we6j6Ra6{~|v~fmNbav<8>kpbHGcI218;Y*UjoyC1SM}*%{4WG&hGdu-
zSB%2y><8k6m_i=&F4XMt*$fXZ<(>Bho<)XZI2$e_P8wIx6l^C$U^PRw>D$DRE@MK`
zsjzRPZV{a@q68rwT!m{ZnKuz@OeL8^d{byMEi2X0dl}?(9@>i5lq%DQ444N?OszJd
zIZVo#2(viqL(zQg498dVBFbz}`pk@+s-rzQy&yTY2rUlX&<lkj>Mtk@kZjBgUo#|>
z(L=0PJjZ`rCYBg=&!^21&c-BD?Lgm7jL*O7xrJoD%db+xsIfyfHNS&Hhp;R*>jyXM
zS=EqD3tqC%7Q8Dchdk?IUnWAV+ob$}pSxqf(1fDjKfC@amqW5}EBs^YVO}oS+jqaa
zbfN0}=&b4!qWOwfK;D-#G<u+AQTYk6_uQmghH9ZlZen66%3{JOtk?xDqCp|)emtH*
zq4pu0n>*d^PB7ZzZtrx@TJa!7(!Zs?6}z}nl@Gc%^98UN1Sv9RYMJ{3cc3Y1@C5t@
zp5vm^s*AMO#lpfgodH9h1`{%hmh4>if%&S1`hkX5xOM;-J!LXQdzBDgR99kt$!EtS
zoZzg^^x&Ml!ui9D=fX>{Y!Rn>yplV#4{4b)_Udh+<~`sZ^K#Rvc0A0BDqbwuVqYwH
z+vPY08v(PRK#Brp^ZsaFiEw*0*vA*@)OYpK2ecpUQ0<IJ`(r!kMeQ|2iksjGW=Tfa
zLHGK-<S$TZWCcPCuz$kBjUi1T^g4MWztk%i^0D;I=Yc7}(u$0HDv!fRWoAipTE9zG
zMv6~<M@^c@;lfhIO3ToLhsc8j<&0;Oq3=0`g49-$Id#OFyh~eeNWPG7J~GC^`6^JN
z!yRl5-nlBol3+8nU=gXzNREEKD_L40pN#~%lsWg^4v0+jm&p&G$xR>ygj_X#ERLI8
z>PDN~<ef0mNlcWD3pp}z28+v(Hu}I;qU!s4V$<E>M;qI(J@Hc$u%czE2Ki%Jur9vj
zJD>K%21OEES?m()WAAXPhVnk2RLj;R7&xI}xEkExM3+gG^|~^AH7pHV+#n8yr7l9n
zHK7EI<CE&s$OCm`X!OFCBd0j6tyG|T3>?nthCnSF`Y;gY62gcMh?BVuV|)V&#2R+m
z1=9D^-)i`aXtw<d%)wJ#3`Ca^_j6m*YqgbItyM}nkFXcQS+E$#50^yO88C#7mLq3G
zZr&X0Xz4Ic`{<urI;=avo@9``9^cs~QnzLl#jBs_iGGhO<k2BV+`LoVycrm+PdvB|
zDd=u+pZu02FG*ajI+GyMKGV9frnV1NidKTcUvc6axL^bj=hp=%ByS&v?6f|g5p>#Q
zT9T1>hx)TL)KcwSXKfHBqYFKg`VpG2DL<r5L=B<pq0!T;&xoE^eVWs@9hM>VAu(Zb
zN!{b$A_M7G`@8fu-`*MpP1wpKeGkmUBJB&QO%!X;W~nAFm^#Ytb@nSPkGMQeW>*1E
z*BnO`sWZ4TLy8w}s+;;2w;JUff7YZsAO#*nN>TJi@*ROQR?x&zH@UFPYv0ND=HM~f
zsAIDtM)bwyIN*Gv-zwwo#1ia0)>M|99J=={<5qqvbnkBCjD9~cIa4&Vp1_xq(`ZEY
z8wMyb(b|G5I<H%A-Lb#u9be}wKqc<Y{o{w7=&j^OA-Nq6-TsNo!|nJV+NrO5Vu;Q%
z;T7-T;w)T5pjA1c2*u`ccTI`^Tglk71THFXnKSx;5!>dMiN})~W{ZBIxeX<=*RS2o
z=t%ekJW0T2wj{=sdP_M4NUZ(5NRkjay@y_l#DnORPD{lU$qJUoNY0=oNd9+bwaejK
z_J&CNo%5A@`=J)V(f~-sqn1%Ri#4P`8O`GueOVuAuPdv_9X-BR!>LoT`bX=OVJg|b
z#T|{;o-|I$k-Ug)P8a%kR-DathLSj&b&9ijUirb$C2(zXy-WN^BV&>RNLBakk+e&H
zx2Ko;@^RLG0GQhWv+Ur+N?71X#kP?XgZ=ugr@{~#6%#d|3-UC<thXW=jCWRe^e>!j
ze~=&Sm)o4U5@$BH-#T9%WnR74V*7^A3$F@(4|CFMG5gQyC(r!1($^E++I}(6dsjZ9
zqyoG*Qb30bCD6s#Dxs4bv9mlQZ&G5tsgR?ckMw#MAxzu*Z~22{yDS9Qh;}<@7o2e-
z>NK;10##|j6fFeym~z(;5~4`UDWhSCqvN|n@jZu#jJaksQ+wuUb5px==4fzP)`#b}
zQp5jSZ;OFRT{S?fE7{&2lT>Yct4@LBHieR>hVjRa^Z$%Z;Unbzg&IB|lRxJTm4e9B
zvmz@IM0Y^m3aED^4H(L`{sWuaS-cx@UPVMi(f%!W6CBxKh%9@1JoOZU3_^L#I)EO4
zJ7ce>b3Q>lT%;)a53Hemiq$Z8kC|WwFPSYDivE&v=?7U&a`OjxKJsS_Q_dLdplbvT
zh#CQkKqv&ZcqZZ$IPfwF4zKPt<0Sg7aW?QwUd`K>IYlhUP3NgQIAJ6+V)T`48+%__
zLb8Edb>#Q_1Cq^)rt`^Y<zZGabjgnv9GBjq^)B&TL{ooEC2DTyu*s3xUTX@xnSRU-
zQkRMF!Z2d0@czi*VBkYLHWVf_J(Rl3a13K-$n{tA&ySBWX>ZvoVY8qb))c}%c}ax5
z55xkw!S`Ff9%2`|_RxouOUu|^cSnF7J~)W-ky_!6nxyBl(l9#_acVHVi_9AlB_qkQ
zDeWU}A^s>Y++M?0R`MQ9@|h|g9OaGu;NXNo)PA}qxhBwwYDR%I$*Cn%+avvV8NZ=&
zLDU|s9hA>je2(p-`fxmDy#>3uiHsf56??TFzERutPN>$#FV$CVk9BL6aay0E4EB5P
zWGIp?lQ<J6mg#JnL#XcJJGbG2+3R())Tum?6wxmr{Dt!{Li5#5Xh$ZdxB1$vC6*4e
zY4aGTE844Xag$|2OC*T(@7+v4NdrKKlqXKy<PcF(=V~b%xIXcUH?voJzanHH)81XC
zz36wtiT6@kiK$<}>U-~;+&50EhPD@+ms&V=#uW1oiKo__W9NT4keY;G84*&K@ki?c
zh>$y7<7N6_kfL5duccFyBRpY>3MO~gSDJD2e*SlhB(r^|u+(XNhk8{_wgY>SjzW_Y
zLw0#Oe-*^FcB@F@-PA(>Xj)7T@l-%~w4M+@nO9`&?J{F2r@SWjT>twOy8mohu+p2J
z&DNtx`@$luz*hKI=o?N-v%ZAVg;qa=Jl$lmEV_&cNImHNLD@k-jI|)LzL|i=22`kN
zp?WrR7DTElqcez(f`fW5pz%XMxPgYwcDvpHO*>pdiTr60oy8RB7yFSWL4#7?v7?Fb
z!F_t|eF>Dal%D5*V)7N&#*Yr<d}CYpB2#y4NQT6EJF@A0s1K$-yZ+mJYrVH#nM{IZ
zN_-ee{z@88tT?riABzX<^x?7B1)TV!JYvB&HgGIGCZsLDv}F-7ZLdgki60){ye-V`
z;s+_na=Wf+eK>i)S%SyjzhCvWw(z$xx#BQC9Wu(Sh2oiR#0?oso6)emBX~(9(HKPs
zc_x2r*nZ+B^S7Frub@hiZLtX+GkK%|GGW?s5rG8meODU7Wi0_Cy%)xCa;@5rwCA6g
z%@Cb2^?5&mM#U7*H^#nj!hq`cLM@Uac!j!xQfg*~6&N4r<&Tnm{-8phr~B?it5Z9z
z>kQB=6iG+IZTpxB<neRvlNez5qBdYcEE7yJ8~A_5uZoGI`7)4uw0R8C4n>WuTl~o<
z&?SGH(<<Xr(_(Y-o08yAIFiW!`@-i~obCFrFP-I5GL&iBrblY8C15dsT39<IhQFf3
zh4&P>LH6-9hE`!X?#5=&O>V%2b=VU7g-yNKS`uTPi|x+1BeU_|T4++7IR=wxp%KVH
zVDPNY;-8N8v(FBbe4_Bs!k_SDCmcP`yOC@(8Q(*$J}fULoSM_<HNW7h14R%F$^?09
zNwh{!uAwK03#oO?cVFI2UQ^@_hvE?I3_9AYUqM^7u@{G6$R?P~jMx81+S`D~RaN`{
zNt42~6i$Q!ML~i_NCh<2iiru5(4;+6CZ!@TRZ;3K)+orW?F=pNQ)Z^kI1E%k#H(KG
z6}?4JQLz?;HtAbh6evigg3$6(IEMjRLDCnX`G3A^pGi`<_u>AYe;(+ZmwonLd+qhM
z*Is+=unEwp%hh2kPxck1)q`N8N)u;maxd~1xU`$alg?7EJD9nIDca>%eFd@4s*V}x
zSnAplXj>`j4HcRw@Vb_TyQ*LfwbBbY1sc5UF=#=T(5f({AznCA3CVC())RR!Fo3@N
zP{EJw>b2E>f&#B#uSV`h2t*O2UUmyt@xpx8<TwzznxrZVw3kDZLe>nw7U6@47&9yV
z0%4)r0s)(~n)u<um*5d7(`EGFNO(1vgvga}TR}B(fSQ`QvO(28Y4`Jy53E3{wWb-d
zOWW-G!q_d)(OJ_7aZ!J93CF9ZG~f}!u-`-4i3P&50l22JO^#dK>@#BX-8>(ZGZClp
z;P!qe{6|rOV-eN3msLOzv&o|?lPSZC8c;+XLRotx^28>~p}}Fnx@h2{##p^;KO49e
zKBw>aftA(10cw$A6Ov1REz=EoUL0`2%x4*R0v@GDC4p#WY`rdMhahNO(a_oTHKCF>
zm%pC}NT(?3yTAPt7$~_J(n0E7Z-}vg>t;jS!fjIJc3{wJ!7u5q5Pc?fkkK?=bzt}r
zK8g5;F%7qI>nQa^17`Sq+1X?L<se>dtYAAs=4E!1Ty3N`PM8`BSJs-NPuB8?^lH8A
z^Sq}ORvVJnXnlDydvV5YBfu3`&zQ5|&JEg`rHCp!heA8C;^YWqE{SG@zj2H-ZAf0z
zSs2^XnSUgX<rlBqgRA8WD8VOFTjR~+Q%}S*dk3WZU`9*}n<ecC7UI`MuYF$2lbubo
zWAigui8aAXbXQ|o6VIbum^8$3eCnc>3pc3yJG0X2p-87DxPGsyR3>Q%33472{D|84
zc1&r5lg+*F)PH9WTJS<xo=DZg>=@f=lb`bQ&Bm!mJs+WqnF4N)R1L21?bart`gcAz
zD72h@bkXE27?{-q4feSNmZHNo<;PL7NMg=|cfwP)ugig1&I&<^XmhVYmTD$pk#e3P
z2Cx89r^fpZ5IFJ3?J%K-s~Q8)rW?b|%~qQyQPDT);wz~SX&H|)*oQ-G5+Ytj%uZjN
zQM~dasJG7=COkR|;b<JZ?2EKu7UDCOtpE~Y5xsPDM7Or)oKG@;(SZg9vR31@iZ?x&
zC|*7=?=$hHf6Ze<Oed@|4{{q5qGnz||IOc^{YB{gO}n)s-pW4pc;&xJe;Tsa_;T(U
zoq2}poraC$zeH1b={Crnb~|bk<3nWrgF*#M8$mGe4C@+14|a~<L7j$qSCkOT@h?#H
zji~6h;4v#o0)p``mX<i?`!#ss{D*k{wQ`UKlOI^k_X~5O9Hkdg#>0`Ywk`MPA7GLK
z|LinBW)*6PEb&b{Ik}8|W*@$>o3`SG(}@Ti3zuQa6zZAjvk$G%RfF92B6%V)+f+(k
zKo*3jDmt4!n|g(L{^YLAHjh=0XW*FWimup#z35gbas32;d_fXa>!C3jDam_>@P|+a
zbN<k9M}8K|sIqDfFb!3c7AI=B*JFtzj1xsocV3X_T!(?J9A;4qUha4lm;si5V8WA`
zXT8q+CDSw8c8=QA);+lkiX?JE+T-7(s)|=*^RtMnrC#Yn9-w>(D#<^bd9j*{qjfQY
z3z~beGygIh6iQb(d}Q`A=abu}13v#kXY=goUbdA=Tl?2lCPxzTmOPou5q6pS5SKN{
zn4n}nJvOtwHF-S3;Ao@{$%@m|!U!l?`4hJM_nLRD>?b>h!<o6HQNP0qVN4VzK4IA}
zsy<P;B<3w=7t1TL*$cN1RJD75Tn99%k<4O~>ydn4>GGCeI=Vf-m2?Z$ZJFoz-7#|1
zuFQ*-y)TYz8}%lpen&Tjavw*Ww`KlZqq|VD9shgg&#iWQw26A;EAfv=vwDUFNeHm0
z5)?G{aIj=Mo?}}W;4bX2@0F9J!Te193697+`9V`IS?$-+Ebwj30zpCJpl9V(^gMEW
zmGp$#a8-X~YnjuhYmjTyOmZdc?&tf4O06<+oBDNIdRkYS^Gt?-`4;WD)X1W?{U#s+
z<A5j8tVsYietO*TlQ9z>Ogyw2dJIf5;-hu`!tlak68*4L)mY9~FrCAkCAE`DK%M{L
zC1NIQkU?fj6lx{IKNm66p%72m{#D@cbIDJ~3l~2{lpk5>UiOPuL1_De^m8^x!y6O;
z^?rN52JO)yJ_)}1RHPR;m|W@T{NfB%!xBvJi#>+++y_PO+FFa53ZbqtD68u_=t`lX
zbQXBW9p44toHaV%+w)R&X4}@DaO5Z*l|%ySQ5)Jadq#A3bR{q20=id{P_D)#N4M=d
zJ!aNmb-J@FZ9)6ZQ)2VJim@bl+9L-H%VUQ?jZ<TMQklAC@RLXI8>-FIN9P~u3D{U?
zZEhg`rgz)OQLDSp=_)N9#8+kme$k#vfas)wxj*p>%C*80@T<Wi4>;O#lkOeCPq#SQ
z8uHo=JKsCAp_Mwqvlw$n7dZ9450Nm*4R&wYH&9yV_<PX1G%P{3O-NZp-<Z0fbj={&
zp8b?5GbSZ-%y2}$uExJ;Muk*AC%&;Wf+Z^3lGGpE2%(!@fSvmk@z69X!vMxTS+=Z*
z;zO{8YVAoaMS^pslF`f5bEYrMsB9>U&o$9`K*RHfyzaZTL^Q*K@{(a;)dmecoI`Q~
zP9T@5T@zG5Z*m)X*#qPRD^{odBKuJD1nFF;S%S7%<BU<^dQA@MJF9-ag?dQMQMxd~
zgP0ka&^m5fp#{BHZ5j+eRJ>r8`?SKCol040t7P%QW$YsOHY|=C8io#buu4d8wf0EP
zxMu`n#%+i8vhyI_MB&4U0>SpOUfDf@^%~sgK1mWTW)|7{L=^}8o;Z(#0ytXh5{B32
z#b*?&ackLU1J;qMwt6>501K<pD8W2eQL3l`nl69Jgbn%_n;LLhWGhZL1E1a}g2M^8
zagR6|Z%uR_;+1tX*?$z=^EVsGME;5PQF}+N_Oi-`D~nnlirka=Ep4pNhd<{Aexv_J
zEz^S$*xgav`>c%#FAWT|u$rcTY&w@v6<2fJi4Ll|U-KaK2!bL5q&`dpr{Q>sYw7_c
z!6yJC!ur%q%gzcf_Z#4dD$4$h>rx%-bFR1hf=PV>QVl2nlY^1U^2z9HL7Bc-taX)d
z=3pUElQ2sJw`s@f(&I*tZD*rg<z9f?@Q|E~U58V3gbm&oxnVIuB%$rNXA~#0-g2OM
z8(I$GR2y%xvNI<z!{WuGN6WPZCC!E3ncd4LQ2At>Bjl$Qsvk$BJni_CwfW>x?$i>!
zj1y%&{|kDpAdDB~UAXl9rQ?U}jq+UITYMv6#EH9Sugd(8f3#*-s_eu)p$3^Dygi?$
zqbd(jtEK;T#^YJAz(esWs7YXf!6W$RJozf*rBJXFDeupc4}ldp7Fiw+j)1uhleU~B
zfBRq?cdF*_QxK}*FNzij=h%Z*xX}40;`uTEG%w4tcwyom!7UHSGxC5aghVb4a!GB(
z1M+AokDrFA3QiN$GB8ejimp}!Uj+!bOHxITaaP!3+?N@QP7+)3EK&GkEKEZg&cI9n
z!{GXshAIEJhIIy}Y@@1%^u}H~7{H{9Mm401R$VBOgK15eyFO0#cjgIRb~|GnFHWhE
zcK~w3PtR&V53s_&C5&*BA7)cLKx}F(c;X-M1+<@CswxrnRp&H{@asjo4YnR4&XD^-
zZItCPlQ_l9FIvM_P776U^P8*dlG~LcL>_xqW&2N$#gdN^HrN{PTSspP;=M1h0h%3Q
z9rbcsVCs;6pm4~g)d`F&wTiHM0F5en6$?&tpjoVhmsOB`yx1WTO32?8+(jQ)B<NvL
zH*)`GFNS*glJ)XmPr6=OdQnYQ1pHz-sT`dfUM%5-`~}6C&U(+0%A~q3HMX>%%&#s0
zkMk*JtJ7juhKg{@qjzFe2G_e*Qh#@7mf!dVw`i~<n5%b6UEj3%(tGTEyx2(>q+fM-
z1->Fb7TifGJH<jOxm}D*^mDNOk%+!$43iWS21+m3Yd{QcqeP*)u0-Nvz8d033vMz0
zw%bIa)pqt}e(f(p$CEmn?|Zj0g3RXYaE5a*;kL>N8#CLnA)Xt-!RLk1<?$|5GcJ9K
zK~GdZ%z~GePx6~)n{Ok1O>6|)ophW`)8A8%P3ReFU+{__XUl$nO<7N>nc6<q*54CL
zjwF68wUNu(<j4+ySxIGSfJr{Uyy&;~rSi*vUP8>=igF<yIR6{4Un?@uY@YmsBqPMZ
zj;9a@J6ze|=RYB;!gdS>2zIbA=S8Rp7lWf%_yxMFQqC-LhbwuT?WOI2{uJnnj}b4P
zwSLci+Fo(XNZi%OveRMJcx`w1%%l5;@9!<|r`G8n3DN?&aE2OxmoX^`Yu>+VDxcXo
zWr_Sl995S4BCK?OI}hUpe300)q!Gye2T>}1VYHY>M;I!T3IRXGx<`V0XmHiJD$WzD
z2a0?B7pb$E(tEjM`7W4^y1>ylVWWA}HUI3do*GNOk1Q5i*whXvvQLhh$nmv|(ZW5-
zzm@vOki@hFc%z(E=a+$XjdWNe^Km!?mG5XoL#1{`yjMG=TUJfquh!&(RWm;r;l!Hp
za=)f7YpM@y2e*(w{vG{kpITY_9t}MieiVKlYRk~QLWm{|EU@4cYob<7d~&}g2K8}2
z?Yviqo;1JnDpfo*9LWn-U9sN-L}s~9CsfnmY9q#>G0F;k<l&rJ`CbF{q~+u{(2rA1
z3-+tY$qCg{{hs(4jqX|XZ~K9nnqn2V;>8G#-LGP!2i4p9p7s6?TYHGi9p#*E_1=c1
z8}vcJL&K>mE8nxq3shy-exQ1}G#I1WRAZ2|Dk~;zv<X^2>%*!M5w*+jeF<uR(I3@9
zyvQ(W4-clspoQ=36Td*HYk&2W%H%Q3jS?f_E@n9oWS%*V3aa9NeKzy#xWuTjhuP%w
zRAZP&!Ux_0s7u}fl;)xW>a<|1#PmjFka@^TW08BqK=85!KA)XwnO1RGV4V55<4nQ2
zrnEU&%I8C{QE*DdWrM&WwugXw&VW05IB=W7lLcJz9l#A?>~v}ev<Vvxxc=&CWpWt~
z#V~MF{|KLa6O4`C4=ONLJ%llWB8Px_!GOZ%)O5X!v0JI)9tGg7x*W)iGFCvt72fxI
zy&G3IKEf&iC4|1FU@3BW7=-Q9Dr+J#`QJc%GHeuxU+2Ri#PzpN;ln}1z1OI23jc*$
zBlz&U>KH~D@72#u;a#d@D|_<xhof}}j`tqGi&e)D-&IF!sE+sUOTFqi?_G8LKaAO?
z@Oiu$!C~*J0~P;&<&;g~Qq}P=fj#@<qjso{_rM2Hgj7*_Ao$Myl~hj|2FH8Uk$NN?
zCpf0Ovx@%*ls*zF9-V-(Q5dVAiPovd*5O~asdsP@$Lz@J=P<Id1n9CVNqQV2`a1Kh
z>y51oKgQS2+`oY<^MCC!oX80l1t7e&suq^OO2d4R{V&_!X6!Qc>v>fXJpVw1N;^@E
z$h_cDp3ty)Yc29k#y{uev4-|avO4Y85>AaXI9?<iw0Q2gL{aNyQQWKr5)1^Vv3p9k
zy&S6E@=mu^n1jtv9<tv|rml~qqKpXK^zb>h#9{g(yD{~Y+LN<x*VrmppIP4S+SF@p
zob+%vfLC69lwxWZ@V-D;?Qz4(yc%b1Zcb<M&bl-O1s}p`!lT5EH7ZGx!XZfR+Yns#
zH#6Pw9w)CDs`lKr^mTQ2@!^QUFWpD_{s85JYY0wrUnbjCq?K`T0eRF+A%Apmtlkf%
zTeCy}@>b4Zs-nl_L68|3g`CLG_gMm8RpJztV64ZL-KwP(yk>?~6MP^lau`J@VN-;0
zdA4Vlz9+kE*nE${UidQSCSvw6Nw<lFW?c+EHY_AmUB{01dkl$Qc058ek8{8V5hA1G
z6`ALlmo`?UriXjb-p&rl>}3P`_o-A_wP?@F9*hRgyzq8wdLIe4UZWuHXqbx&S6hbK
zAZ<CGn(=@CI(pIIX0ZkQ1t)FtWu<b-kZ2Psz>Z@ls<(W8j3t}D;RjDGW(!#M$@T4r
zS5(3ZBH*A`1j@7*6cE;3%~35QD`<$}>2H01YjUBcKABanf7fe1E<9)o$h@dhoA<lV
zuAAvMomt~8S}&kb?Zsq64FMJG5U#B_wUU3loDSC2BJa#NaZ#B*78lN`EPZIuo|A*N
zs(}~#f0r8PEkD4*M=%k(Pp4@**zDKLeK;|mLx2;J$A`5W5fxlGT?h|Wu4CqaBPG`>
zSC3pmCvBvY@(?ju!nOHIAGhY>`w1m<%FImbcDO{hjE54|*Q!FdU<Z2efWxME)0Gdf
z7C>+tJj6VCWTH?PThi(M?5%n4&pz3<z5~p@FSuCk6)L9As&24~?Eq|ek_lurx$|37
z5BUse4P3}{zg5{1Yify=qxEPEO9fpd3a4dOIQ~2ihqVtP-=>3Y{Znf3h`q)oPobWi
zR{bVy<fh(X*~_lSj2b2%%D9O$c)|l%VAi5_75YlY3KP47$KeTK#d@0jq_>=bEfdQ}
zRElYsDCUL@>Rd!IU}fC@KsJ*Fei`;AwW?N5FSOJKONIQQvH0qKtsXKo7&Z=!d%XEf
z_CkCH$_xLA?SxF2?mAf-J4ioi9ulSh2=C1wIbk5)*P+hA453+4!R>3Tcl%O*RTI-~
zSW10bphD2xE6dT#P37O#{yt6;Nx3Tm1-`%)$#GXyMt{9wRsZVh*Zn(^qe*PW9|u!b
z_pct2JeVS2lk=o!=cnvbhSRF`2Rcql`;E-!)=G*D7gb6g&>I}VWIpV}K#E{l>0tR4
zz&lv9e}OAt`4d;93?B|lYyWxylWOK-MCw>hflG~6(Attx4!f2sU`S=kc`(|BU~CtV
zFH|NUEj=;R4^@)<Q;C2Pu_`<ovPA^7%AJPntD%k)X}hP~(aftOX1C|h+!ubC(GltE
zkj~j`Vhm3o{@`97{2bbL?POl97Rtg;QY3ovl6&$!$_&;05_qKQOL^$_4^-|YbN?4(
zZRs};^s)y^Uf#0=gfQ;+^OGpV8wg5eHM`eabSDpd{OT;W<hZQJv@9mlMfp8g$;gBw
zrWMaV@~zJCz2q)B$9xx=mupK$4C5D!<F?F|*H#atVkEyR&KQw;nRZ7eKd3!22XJ{n
z^7A$^uPqO##mnez;1`bQU)@TYFv3JnPq$QzPHuKNKJr_V5Bi1A>EVcqWKXH5Ww)2x
z1yL+1@AL8tA0?EbRdEFu6F<e$^P?Swk0y`BH%Z?A@ky4bv@?$DlNKf$&4h2-Wam5j
zvToQg|9t6S-ka;J`D^~X)9_M~k!S}i`P+iyd$g}H`7AT44g^U1ny{HMaC~-^55mr=
z$MG*uweU*ArNt36kwJnK(X4>PV;2(z&N7W|%2JZwvAR#53lt(5PN7Y*TX+~et@Azu
zJS<vZHoT}TL1<4!1lXn2^1oIJ!fQ6M@E|$8-QD(vQ-RZ9&Mt-=Y^NM{)R}8S9rGiU
zV(5)PSF|wpciE%MX2gp==e_Uo7E8vrY$Yey*&{0FADUU6PHWdeUKK$^6>C~{%x_BX
z{mG^6D^ODCzzy-r4J4=YuANO06CRuvazv&t-I^ZY!|AGD`v;pIng7C?mR<8tNbkMj
z(nD>&RO)TnmRd1;NqC~#+?jeQ^2>!E(EXe9$ENo#HhsUSk_RjBa8#78Z(&>On~3Z5
z-pr+=S14#CoKJsS-b%d|KF4#$)7c}#*Rymun^v6$*Rn2&aUP2%x%%@ltY*pzULXV2
zH$%m2t4$WJSA|%jOnco7f7aq{l%HBW8|$KJvv=*~v@h*HGb(|%x+hvc(Fa{bAW<F1
zl2{=x`;ZhnIu@@vK4KEO7QVNX3ggB3Y$*7HmS;NiSNXvY|A<$(X)9-MW_x5M&;ri(
zmi5FpkzxltFlU+4wXD_4b#XKNXc=A0_o+W!FSV<Rie;^d;@x%<3)_v$Rr*a>jNYP8
zK&8eU&}5^12*mYn=??o<`>}M7?qd7Tu<9u_z1-QtM7rLeto4iTycZ4zj|FQt+wzb@
zw3qua?N|@A7;f4(Uig)OrBX?4{i%Vw+@)O$CHm9z9=k&GWG@oL#oQJiu&xRmwWTSH
zyIFVQgl6zZpz=qi73*w5BepI>25;8}qaSwRc`_ZfHX3ifpx(=j;SLXY1MXEuY2p@A
z;3<X?ZaJZU^5~l6Pux@pbFLOe$+ALlBQsMHK6uyP18*P^#+6$n{Oq;Ftepuh_)Lvf
zGzBPOXSSv}wNSlNeH!c^lID1~3Vfd-K*qzk;M&I`3<^K$-ni5^)e)hHNZ;V}hg?4_
z@q$dQcvVqV`o)`F8OqwHk|DefKDSj8fGhT8l|gX}eJu106mGWCl4+P^6ui%n9(>?l
z9Pw_DSney2=Y#aw`SY0<-Abz!$*&ZytE*vj1uA>i9mSbHKR9yBe#EeZkK3u!l}-#V
zO>CkDaW-4vhqZPAA4KdTgBr28Bbax$fFv!T`YS0c+=#35y}^-B@=jC9K5{DAz#8Hs
zGL9%ck#E66uCoG~V0>@U1X1R!+%{E(vDv`%fs)>}+Ky%3EzKy<b{fk1@Oc?f1f7<_
zD$Zji^~*kx#q-u!@aXSJ$FQ!<dKP!ID>(R<`*rMi>K=|Zq`AY`c4l(J5bza);d}uQ
zq1(&7B|selqK+F`e&C6rzOPZ29MP$#;H_mt_%;UAkp9+mS;ipn`6NIM@8;U{+~D}H
z*f#*NmgQx5kP(Nu1&{$ElcfL>{OgZ{tH)}}_Y2h<7y>W5!@x{POrEb<$Q<SeXOr(H
z&spvq<Pgt0qUCx{Jm1N8q?b9emp<f`rHfriBTb266pH1`HUtaH`%#b~PAig7#(3y_
z2zOZ#cd53#-Ze<qlK?pCmz48hM^5B9w5k4<zB79Xhi;Ii0K?AFGt!zib_Kb2j1OAK
z<Z^feQX$d`nsntMG3f$F6S}6C9e!BP2a*9IT>a_V*eJSQs)ziAXHp*&B5)K2@iAbr
za~{YAKeCcYWsI&j$ON#0`t)}!VGQ$6m71AZ_UOcw2m5<)F~gDkkQPLXEkT_4Vlr)X
z=I6&a(n!(kvl!>_B)m(`xpN&2MQ9L-5Gqs-4$!bQh(oZ{``D2yC`C1HzK+vpd)X%-
ze}GA(!hxJU@8|!}1%!V7d%pb?XX>Y~!$iKH&&_bRW@+%aM-_Y7QTSR{&EzsT>mItm
zYEr(V$3QgmYb27vFLvC;_tW)#p<In2mTC;C{4S*m2KiQ#6os6Dpm_XKS9v_o=NkFi
zTck`Ke&K%I1kZvHP{zAfZrAHXvjHsVDQMk9;eG?Y@I95}1C>w&)>rgR!9eLOd>m<k
zqW@MmRWztvv15rIajW5X_@cC{s+Expylb@!j0%N}c>W(!L8K%0t2}S{=VF<?1j`>p
zk25-q;B+qdMCsmhhS;WCg-S20Y&X%fMBy$WAYS;a6d7@sG38}b0yQZ$m%+A$wd!wm
zvz<w(EZncEI2Isy{Wqpwav7<~!u^I_nIN03{}Iqd;W1I{#7y{u>*6`x!BGke%C8Bh
z(+nN9PXX&pnJWeRLc4?6TxgX{aCwB}_*uZ#fCVwyu;_9bj>1;c11U~cy=rOj-QVvU
zNZ+qvU;?^DW`F}LSn&rT_iJ0eRQ7GL8<8*FkX88O*TO7y>{79T^fN!#XzdI?4N1$s
zamXv2)9n|pT7o0dFQi4ZauX3uPSn8IFR|diDR^|f)3@~?q|-$*ds!mv;foG-un+>;
zw}y)8x@{DQ7dyrgP|V#N9ugRDaiHtYEKGb6Wa$~;FR)jy1;^jVE$n$PS^t=RouHx3
zzpl9nJL*!z!z&lyB)Y7j3OAUkn*~VWfK<aWv5l*|MKAF#!mI@?RIc{>PLI(HATVQU
zjoH^j^4~8^@Gaj`^!+dG`#%^>vh7$bQXG3gqUodFwabBuorp0`#wxI<k#;gIl|b8T
zgkyu5$bS=oM<cTg#C8GP(M@qtRlK--iy$Vh;9RzzC1&k5i|`5~u#WCH=>?RZrf~EV
zWuk%CyOV9v=YI3TWqj@}zQjQMt_BG$v)Z)G7wy>sB23UPG_d(zLnuKOdJ&0%&>ixV
z=0m>3U4}AO2dg4#W=E$Iv_2jm&+f@G*_wng4_H4!jvYzRrw%<A?72PSR!26$@76l{
z5O>iR2&ei>8ZLgxgwaY^2w^A@u{jFM@5K}hr11oHa9jj)P99FhP*j}~UPMb~XKD8!
zsM!KpRfhk7>IUQI{!p)>C|q@``u)^BuHQLxJQN7e&^?Od9`KMTj3*qfTUGeY+L(zr
zQy$7h;j1-g*x4drBVM_-GfxbMlY*U0k5G66!DBEVn2yViP1Zxfq7dBA#83oXyo(cD
zgPomP5_}W;T8e*)4GDbv_umZiEg9^cungAnkZZvg?EY<8>zqP&Be@t6bheU5iL#J<
zm%NDtQxUQAUr$S9u0`@lYKD7JobXWCqwkF@O-hq3g%A-F@W1_?OqMAzOWpGhk**BJ
z1HldD5;s$s5vvF0NvRy3X`M5&jwaO~MXhq^*xulQ-)d&gA+>x{`fH-_a~lIfhKRl%
zX+dhifex8oRs$J-<U-D|vH1Z95+`|5#?jJWqmqxrTubEN40rSE_nB%D{f6&DRhwA6
zoKj?why-Kyb()PTaDpiK0tE^tlfu90W#-L&1hUgkSjVkNl<Ui5buwk6s?6;2vOiNd
zhR!=~JFhd}t032Yzc`mIr}6xQc7zmZU{L*=Kkt$+K&n$?xI$zd_=Q7***irO2#)>3
zl5O6W*<^)o+F(D5Ec>iwe_PGHS%7}w_mUf_q+hv{B)v_0Y>x#(FOjd`#pcwR5GX8^
z_s7l7&tXf5)wI5~7D=<gpLNqVzD<m0=lJS*quR&s$rtQ_nY*yS*7%91><?9V`+pk|
zM)I{-eWOi>i&q}7CDHtK)MpBsU5{VcFGMgKc(Az@v_uud<ZE$a+AsXc2|mprbezV4
zkcdnREU8#BPXAorZ!%2eGed=oI@M<EjgZz(8EF&xgZmgD|B;{Vhcjvk2?Jo*t(~BY
z#N$I&oUHjFc(ngx=seBHK4Yt_Us!c3h>91^#A%UaO2!;?rWQt~Yx0QQu{&~i*rqI>
zq7`K?L07!E*nx}}rG!~8ZwdCH4~DK}CeTdI!+VFEC3?iPg{cFLR_}&iZALW|^TZb1
z>eM}juGp@179xIDTNLWWSK727&P@G+$<<3PW$<=lu$EOO7b|UWY#HwU%NZc$4IZ^@
z#1b#7+(6E&$XhycKKJp$VxgS9v+A@aB#8cG-Ga`-d}x9&L4}6Fl5>Kimy2UKDCAQN
zM4Iocr?%aNxoU}BOg;7K1)RThxZhlp`X^?*=G^)VU$-G)CK=DTtek|5(Bt>3;@0G5
zEt)i{VClo+17}c!yT*9);(*6qW`ikKD&Rv}-pxZ{6g8p)3<^i@R$!NDu;wu%Quni=
z3Yu3U6$FZx{RH+FnJTbBSbr&973m8y@_eYX`GN*-@ol^(q_*LVVhb(}#JY|i<%(sB
z;DBFAhRNlDk*KXPI+wB5;;cLK|A<^6Or0&b5f&T>o<}_44e3OldW(<8Qqle=GOpLo
z`*0iw1d(WjatHCkH^8qu<>689hJV*kR6bVvH97h@XbOApDe^F04D{E&4Du4ilU@;m
zwD>u$6NO0A_*2=m{I+H|tu{~12k{f}jpll;{s<>>HF%58rEy`1Ww*&JyInbc;Pl3p
z37*@_puAIqz5tDeymsa6BtCf+P?g&Z&kK-YhWZ9P$w#1+B6%RAp=pDcz1K<|4Vkd5
z#_~C&FOQ8%ZA~<PhW+C*<7~U3ZQv#R76{o}_1}DCdzRz*5b-!lw@Ov8BWN!f{*tq$
zI$i+d+JaRZ#|1%T`&vw-mGu<1aJXRE9VR}!?0Gy_b+uZOW-y4&WMWQrKAD__gL<<K
z^O!_ks2B<|feM;T39y<2$+56z_|C{QO27i(c}J)`3~VB?JvCzgT7UcoOq9ytW3FY>
zR_xmqeR6;W4b|EiBZ;PqAfSITn%?3Qt&Ru7Ix03fuc>ddvE48x@iGreuNn9vTcl{5
z0OSYhYb0Ona9i`pZcs6%&-hfT^Bj6r-lwaRQk*9*v%Wsw{1b7umr0r4WCyQtY@)e7
z^^ZjJ%vg%R|1O5M6@@_xQ1<HKc{h3F<rd1CqYZcq^R009XkHv@n@9`iHXwtE#?o=E
zmD?kM1l^P96r*P#*#1-X;>x<Nd@r230ti@8G2(^cL}!h0k_Cy>PP0a6UUA<Harw#I
z=@LVOu1alVY5?{1!7rJ2m^(v)#UYAUtkF<WXVv%BmXoK&AwQUks)qVt%m$4sS8<Xu
zm7O(Hej&@peVS=`slv<tQ?*#SWiN+vqAz$YY+!+%#Q~p1>mNkV$1x+N>xm+rC~8L?
zb8=F2Kup0UD~G|F`j80_dx;6NI!I%(4EDs!##P_Kwd%kyw~os)mXMSiJ9-HD6G1-I
z8D6cAKpn!fmJgW;YU$dc&a_G~Iu9LTRv#R~CIyKudSA6)hjSjH2mgi;rBSKi))L0}
z`3J+xARW`6&{g<F-mur_^ZX!RW^nYl8I(JM-~Fe0<K>!o!xRv?2Cs(K8aYQ!v8}fa
z`c6ZRanfRL1+G_i!$ISl1-{g5ZLn*ZF?8}f>PM}(3xFYp@Icx^TAMa@qS;&geQRGr
zR|2~x*c-v2VUzf^I!sin=QZIt*nPPEk9H{8{#@B>uM?ufZtK~8qWKp+fRrfw`c{4}
z{ghu=q_I)Hl0^O&JzT~!_v;l%KT=d|+sqn=jUD)!R;=ExBAmRDs9LG-wWKW+|AT8b
zh>B2vaXQ<{x_QEcWV+AX0qwIdSj7Z7*VC3iz~q>7RG>OAw3g~)h0*Kd;+%mXNw1x>
zt8xc8u;^N&fEXo<v0}mdh*+^ASnhs)T|5t+e@3Ig0MrJP*wNzlEIL1SVFdMS4B^((
z-C%N2Q@BM<+u0??uECo>ws9P4EV!MCpVj~IkZplb=PSvx62)(^q<WQD#lU96(yPJr
zKSkY3eWJgks}=mAM);x}#j`c|N`JWoP*}g1A#Mw`+zSm}&yRd-7~j!iY+jkp7BF~7
zH0=Wgk3#13;O93v;+!WDt?&=q{zTZ{*5HdriR9^M!plwOHA@t3#B$HWR6e~0)3REM
zlQDy2j}-BOaM9{zkD$DppCKQ7d2}1@(FZt~q!%+ST8M$@ypG=H%r;)|neW|jn4sVb
zI)(2ro_QJ1Ax5IUjJz$JY8l&YiNXq^tjtyQ?t?^OnJA9rxIE@?`2W;Rc^?5Z^K5Vi
z<H35*<#DBQk!RBB^yD|<EXkDT)-1{F4SMmtLy5^V@1ZVe`Re+L<j1VktX@gbRuM)G
z1YFyh-@}%mz2c-sj&G|AZn;y9qz*Uaic;6H`k(|qGYwj{I5&TpMWlzVLmdqX62eo5
zatRQ#t%JqP-IkqVqGB>S7LIaz*o4?x!%d=atGdbxWW3NEFWRI+99|#PZ<B4n!iI6R
zcfH(v{;i41ZCb>u^{$;@)gEDjj_x~;$W7{_j<Jc{3$p8E+|?Q`{&2hD0)%m3&Ob$i
zTq0o%SUWRe(7#|bHAq3h2aXi^Fd55S%o+)sRK46zsd{iXGkBF1WX3tcjB5BEFyw-l
zE6~d9CFLesxD$RGn9~G5Mf}<Kzvg>=yWfUeNF_0b-jsd_t`Z76+iyM-ZN9a=3JYJ>
zSr^1z$zQMNkjR*4jaPO|Bbx{AsTKCzqyvQPVv32VT_BM$o$wGvWfd;1_47ZfyH(#S
z)itD%<n)m98ku2ux#te%F)+1Kj}fV@jHY$RALy>fx@hp5vvsY41)iKU?=XMYCcmou
zBwLrZk}@wd3u>V5uh+P$7_C;{q~$sGL_U?mdF+s9RZeLb*akPlY}8Y9leuOl-=1if
zRFnF&pSheLD!q(j6Nsvyf%F3WsvneUZ)6N!m$Mt#r_;V&G};A<&|p2$L8c_x01k&D
zFx6XCBqL&uNDPP=Y5*mf)I3=5=DG!xZ!6rS@GC!mpTj%RIx4q-kR5jP`Ne6KZQl1*
zceAi!qcX9sebgp@)@yvdga<qq-?N00xhtw=hLyXIXeC#xLV{GgIIg|>=DMF#F2A}b
zsOouX1dR|yL?z!*p{9p;owwpxt?aY&CK1cF3kLw_JYlP>4|aV=(vc3H<mEaK;S(Um
zM&9j@Tw$$)20r(eFBUM`V!W*~eV;)nNUzts>~8XbigvPf4c1ha^$^vhLCxP;=fJ(w
z!1b25HueMu@@X+DLN45;Vs;QeT||OKyo^`yG0I>&buLxGN)(B|Vz&D`fTXqF;u{W?
zz`k-j#xXf~PFt$*P0|~#6C7Lg4dIMIJ&%b%*R$O`^Ri#yE2FCEx_}mDu!?zS-6mer
z@-}|>5A5Dqw^QX8Jx$+y5e0X?G?e~08+Mbo_z=~=QCu-T2v&(*wM4>Vwm!^G;cdB3
z;Iz>UQ?RFj6KaPYkl;7%<Fh$xA;0^m0obG~!+Ic-D{S&UMv5Ql7)FKh8x)h{qEI<c
zi3gbjYCvwIW)k}#BeFgBF#F@?KSrwuC@+b~>E80J(aTYf?s|081`a-g_7M2B8h1+U
z@)lppXL{u8?%FQyGC?&;sjd+qF3xYE4`k&%kwe*OPqVo4e2_LS&g`!C7N5anZlG>m
z*V*g};9;#Hg@Vust<?HWFvF#z^lGNgYlNOe!4*j!At87~tSJ3Sw;TxgFPcyM;=0-;
zEXx~(xFmQVL)n!H_htr(TGaUp4zpxoScE7?1S3$xWu}oi=oQrD)^ovwkkJ^8xIPoz
zZO}*2bx(BdEzZebQ*<#3kvOO(0O?LA6luVxC|`>~^p_}njiExrw~^$itKzbH;9g1*
z*=kxZU3c@q0Ir$rQ!M9EcDnRNc7>!7b%}PQn8|_e>`P$+$x=tq*H<WmSYS4?3|GV<
z+(kPtCB{UA)Nq|aQ}SFt-Cbw?Ex-9XV?!@<rqEgZ23q<~qiHX*-smIZT^K9#-#lpR
zr<qzW_f?U9u??zq{S=HbU?ixnC8l{fGPuXfKF%lXTHo!{SJ#C{buhAv&@lbp9~A$^
z<bXryv~u=UI6eC$=NhUh3*xEqvf49?A<?ZY(4g)_uydz%2hS^yl#5aw<&x2INutAA
zzR|S3)?4H<GFT9jqaqTkj&+pe<K|Dd9EsHb55rPq;2^`HPO1BurID<E<%!^;Gd?;T
zpa^LvfjPfNrdy7vNMgJ?8o<5{zb!SdW-m<`85_M)6yq>ZLn&qqXUmGhlF+-T{+;q1
zkQ?XHgBZpG0f~sd(9hp(0>S635K<q4^uwq<e3-dS+5dkrmgC~54Rr8pzf8>qxOKtz
zmfvkGB*ipS?JX!BN`Er15ZD-ai?x$Yr@Hm{O*<|fN!O}B+M4Z8+7&=lRwN(u(LPS#
zZw_y!WzkQfaGRl@d}M4jI8PP=Hhhp%fV>7h0V&xyaX7n|Q)1{u{uMv-Hj6<A+j#8?
zzHzHen>$_AvmhzIa-HE#0#@zKJxI5NoUDo_i=rMz`6P{U@XK3d4KbJWGb?W80Rwmf
zeGwO3a0`=G$}ww}oil9aHRzv$8N`$Lv2wEzh!P8`y&^eH;*u0Lxz!_i9C5ICM@;V*
z7!LjBS8JD7yFS$NYs-2*I7%AI++Mx&0^v-&&$~JV)qt6C5)H<&ulSY3T7rzMIX^RR
zv(oSnQznsGT*jwThxs+#L_I$TOIKO#Qc2z-MR*Ph1Vve4i)n$3-LJ*z<AMsCXd!ec
zmVGjHgwte~9%9()PpjXRDN+Os$6fY6RX^R;N8+tp)kYqOS*o``^csrw6rg0nMo2~7
z+tdTPUktY08mYH6UiMm;c5wQe{jn;e#7b9!WhbTrl#qKehI^6>Tju;>xq?!$?`uS9
z5~H-o>fR;$(p}zGw}D3@jV=0>bmmuo;=N7!<yl})-1W}rI@rl7s(d<nphOaLZr(T0
zp=HTmql^4ZGh=rpgB`b_%6;3$9f}9`A%B4Qg%M+US&9TGIen!k8TPk!)g+%QW8M;;
z?P5+_8C<!VHbGx>^fq#`9FgYef<T-Jj|R8wfKXi+8m4RRGm^jJo-9m`I1JyAPr~R7
z<_f2C_l{9JhQSH{NoivI%3|*-+(!h=Y7V>TCNq43tL=AJ(2sg4vs~B>D+_l$u0#8w
zT?&uK`uiVIJ{;A<&_9Ust60b?qa1Y?3*NfXW;`)^mutmrFtlgSfwGtc!WNGGg3T1u
zm<#y{j3H5@01!VI8N*9!ge8R84C79bEgMld$xB!AFc;6RA#SjBoTygE!rQM!NNgf=
zg*aLzY0-ZBTqk*KZIlxW_O~{|bnf^d_=GU&h;fphvid|K2V1?z^s3beNKs%~LvZvz
z%(0Li5w)cbfryjBc4QedGmUcnZWd=&XP!Mkdv>xK{AFwuxRa90s=e%J-pXl>+sBcP
z_6EHg%pzP4J_?^@4;S_Lv(B&U(n<yrzrD_vzrR)+N*0ukck-!NeHc4eG|m#K-nDl_
zL~%6P;yXl5vWP?f#Ovzng<uSUMt;4_xl#&J*L=dx2QnA1Anla9bbDL6rKKWyTeuiE
zOhUF2J563=?)|KeNHH6<H5|<YNjs)NsNHD4kHCnjC7vztZg~E6sP`HEF{)PjpGcB_
zZ%z0c`yO%Fuu<EFyxci&P!8EVr}C(cnP;lQ4&6f<f-!trtGq6fG1miT!YsX$p2G5z
z84B4n@Fe_}Jw|RzO$6Un%lDb_AAE_OI=a~cc)>Jo!r!S*03GK>o}sD1N|BV&VCpYy
z<N;>djPPtQ;g?A%qO4&grTO5D1WKfVFB7~Fn$_Ak`$efxTbVTDWHm@s{U{>S8ii6M
zkEI{isZ}pGS4vJ<wJTqXlXotU0mu#XooL#UdRU4qO}Ppd;ut`iu9itX!zMk)AV;z~
z*$RCb(8KuyB|?W0$H3^=q<b5cl|f@pooXp{i0%qkKEhh@t|Sq;^9c`mfqdK(nbDzw
z?9JfAWJ8RnC}~2J@_(}!nr0X!wNl*|BEwGr2&*ZgTAbu$AL7gi+_pP{Eq{>J@S@3&
z`*7+3n&e0J0ayqD7b-HjJilNRW`++j94ln(h8-d*TnjU3z{{Kgsc67Y=(cHrGsnrq
zX_Edr)6?Mz5qV9AR4S2P0<9vv7h2+AG2iQ8JxzmD;dN}$Uap!@$B1b?X{I?EZkJ3G
z()bL#%chrF&byFAbH#?VzKpeA_b7Szw8DLRDuA|Z7l+RQK8Et1!3U4>z#Z<Ws&7?a
zvXdlGiYvANN{2GVyW<kOe^mDio+R>{6FgbMrKXb0_(hGBj#B)V>!<c{#<3)8IGv69
zWToSuIF=}`fOrjCB(2=i-%2F+=5_*<+IDgHW)<5rT$p_FlBjQXbhUNwR@w*-p=*jW
zU8;s@Ne|mdW!|1&ZEMeMnQd<IIjzO#QOhcqK*!LXR-X?-=;8OuDu2uH_2;uho!DEh
z6B~%NW64ZPt&JQeB7^Z10Gw@f!=FVG5IBZQu+IEDf&b!ZfY!^PVsSL=^1OIC9du7T
z%QyuUv2^+r4{^f>3H(kPbk?t1EyBGxmcTZrkDYlv$3$@t#e-9EblMV)t8x)lmN7$w
zvuN$jMbKOo;>oIXn_~Uq&2{=*{`Y;s4}K*{-T}hyGy5gjg6pq5_SlV20BZ;O9lWX)
zb@>!-z2$DKrN_H@E@MptPH*qxhYf|{e;_*}zvTZ`8Y!mI`U@LP)Q<2S<OwR$_(@jx
z=-1r*&K@vNe>7v|^(I~ihtkn<$E2zRtLxwjkR(B(+E`Vv`50Ilnx`l7)pfzOMWHf*
z-Iqc_3@W4WO2n@;=AfJy4L7vo=3v7upWX2tXWIOXU%u52gWOF>lJKWueaPfHyl~MS
zSMoU9b6KrR5)I2TV`0@uqqKPig@xINVEJfX33Ck2CB57_UWBdG884o%4=+YMZZy_@
z2@(r#`>%))gw519nLlX?-kLfMC;VJKMI7tR7<}T9ywe0mZrboORC>>!m1!o0@Nk)C
z7LqI>*d#j0t9pSr_o?A6#9RxdrT(lSyoVYl3=CEn+BiC@D35!YI?8kvZpK&?D3T_u
zga<d@uul`~TmoPtq7ZcD@*<}*c$H{+fO962_<F`X?y^Z^zpsurJ(46WcI@M97Y{FD
zz%skXU<<&Qu48xX-?3c`Nko^?`b>F!FFKBjoIhkW9^8kt!T|Y=qsA-iq<XL8k^bau
zo{ky5$wp5oM#G>6FH;UitOhT8r=CHNORO}@qObC~ZuA#iY|OV7>eM4BASW|H!WRE;
z_AKCzXV#iut^u7Sdb<2~(KrZ%)Rnd_;^pq9q|C4BomFVU@=lT`WT}m^CaUXbL!Yo1
zFh%xDLq+NYLM56VtPEZQFDp{_x_2zkOzo=<^eFjvDPvZT(!vAF5dlW%>0Pay9R98#
ze=8{w87+<!R&3xKzj)UcezZC=F1Y+g240(SK~I;Lz0Aa`_M8tx3yyJRZ~d~~6|2+c
z#<oxrF+?p@MZpG&QDE7tGyjxoV`H3K`I_k$omkP+1*PMV>zsMVFlkmx6oq2J<n(Cv
z*>LXSsP)FV7!~<hx03*1DWP~(M+He=Ia<9nmim*vs);vG8<)Jhr8;$2gqDl7Wen>#
zj_puo3UO+*M5pE(&roVY%dOb1OyIjQF-o<A^MCDVLKoJzrLU@G*|MYF%l<$d(af^)
zy3{k~wm-3>24e<kfa|t6hApD!Q9_zS5VI6Kra>^xzgtUcS~l|CUXJ9?%4<o4{b(tv
zKDgut6Ekwku<D`3r0f;oSSCA7*i=SKFEoaCkVE3|q@00qD!%-@#sVo~l<Q@WmO8P|
zAhx?SAd(Wd)h)G4CNca5Xa2ygx?Koy%5u=RY6kt~wr5yN==_@Cv1diqUhZV;+NHKb
z?Ksx}qFNs+dIMiqFx6BZjtGOGT&V@Vk?!my@DaIkpn)DWNW=@{fSBD8Tynh#%5tF1
zKh=hhqe~K1%S4^ww^3?KKr5Irw^(}(ln@JX&JSCU$5{~GZK8|l21}qu|HT(FvGf~!
zlQv2}v*k^ET=C+iwbEef0WrbYpphOTt+}q3y63EBIGj<&$_u3y&dzgH%QaT5>rwE>
zpBb{UR{+}Jn8=ar_JGmbn&7ak8LBlx>e<Y&S&#0tpAtKDIWG%FYNcLyvt^xr6~)jP
z{Fq&+keP1$<cv6?2f=HZzlU)r=W|?Sv&VKmV_$Tl`3m@G29KzjX~2tEG`nTKu$Qk9
z$+{_+{o_bx2@T0VJ9W5{50=;<U_csocjg~M%4jfb#58ZRenXE&>!g~k-sU3^_`lC@
zo<oq!%__`$jxkz5BwNmI8MkxX9K3nKxX!|uL%r+`yeN02Gyh=f@Y0uUURs8K-ZcA$
z^TOD4NR%}3o7>1Vw@HVqWL{z`N9Fv-6qNL^*oKinvhE00{n`<&68MxWn)}D7UiJbs
z&yM!@Yfe!!OlyRn;|m>n#7ZH4O|TYsr${D9<4`<$Q|XxUe1febsRI+uUV?)prCFF<
zG1VzRM-RJPc#pHt33##8W=b*bC5xn$Qc&Bzw+ZX;7D)t?n}HkLMzf5Mb)rLd2AAL@
zq3o}U*{d%dw4~gPc_}xRFL4g}?lX#GE@V%|gVX~XDtjUtX@LSe$Tw1;C+HNG?EdLj
zb)uz6cz7A_zFiXxux_V!zbqq7yVk(lVl<NI@;)@RP982dI=3JdR;#$SdT1{~;2zj5
z)T)+SFBn39tE(m}|9Uuwx*T1-1ep)Y*Ye&bOF`&@XCS4?tQ$@4@)jvPfway#*o(!2
zuaD-RlSZ^<p8rXEH#glMFDw$lV$<nl?{f)_J+~o=`*Ip5EPfZKsfP$^OTT@7^4se>
zVwKUU-QM-%Ofr2QjX9~Nz0k6xop{TMuw$;r?YYisf}Y>R8Gh}fwsm)mZp*wfnrh~G
zi=~T5q5R6}19h(~VP$IelJ!$!Bjo4VFFmx)d#S%Tl_iohW_X+&jhEXU*oz3Y>EtB!
z=;E5n_U><0><8VmCX5|)h4YtGV^VxSGYmMbJ`4x0*zxz4bG^m?$!Fg39+u1+W&l{3
zKHD+_7kD?X4o_wbG(K&aztjSArKTIK`+j|N*vgwB|7Fme)8wKC^YK9|qeOwJ1L;21
z^bDdT<ZKqJ573>PBit=Hyd?9cHTNZJ4*AozYrW>KRuzX~Q-&`_+pV1v+19^4mO7o0
z@Zk%vHEBk2qUDq30egq=_C5i5$y&x}yU4FBPTyr8r*Y*i2Gp{hNUdY~Ix1@Em8<+4
z_RiYpVbuQFuKieehP{p88+t#{y&q+}=uJ*g??JA@al9iR`>ypPz_hC`SMACl8fq7P
zx%^01KH$+i%Rk05YCJ6b^RV(`UHKK|^0A6^1v#jN5?sglJU`F$+OViZ0?y&Ut~83L
z_l_p#ovTy5uNmz9MdkY27QRryBC<6RU${@#tkJtqjttwmfK-GB%4K0TilpT}IG3I|
zxN22qFyHzASl`=lG~F5({)>xp30TFd<JZeQ$&1oI)D0T3Es1RCa9@oMSN?Bb{hSvT
zDX0%2qv*ry-G{YdP9N^~YMy)bq41mUdNsqn5}qm`{?LC{3GJ4N=%^Lo!{gsoVyr81
zTzJsCUhP3!^6`hmom}h>)YI;jwG1}Ghg4$W3r0tVrOZB@hAVg)ZUx!<fBe&-j}_h=
zepesw*XL`7O5pOV2>(4QK_4Q7eOXVu<(q-8I`h&5e-{3rb1K5gdi*Xp8h9F>5W!J9
zSjSO%ye;bX(Blz$eEYkwQ9^%4s7zM?)05mAFySLyAs>UkrvFcJ<{0YF1eI5F2o=W=
z7AF>|jif5wNcR=e(Z$P&roEyec@W1DRr65WYtnzR*`E?EPeL!SaoQa_kHD>O>tC1l
za#v9*yjI^=9pqP?QO}$4;au)5e|x--%s`+fI{LVeWwL>RVG4?j6W91!9*1w@eQQ+~
z@0k><QUh!a>QQxyC&LBN!LsTZF>m={={+No7p3=%OMW)J_oQS~nhgAFi&HnH_l%l<
zUp({HzU2M<JCI~HGUm2K@xrN_;tSsrCw6+1UMT%^i2pS2$>`9?^4`qoybgNsY+L5#
zhR#{fySQ6-_IJtc1|9motZ!Y8@P#kSpHJ$4>=m1G9HRIt3|w=25Tw>prx!Ke;*xx*
z%Qp?wZ4SOjL<ZSw>lp}qDGHmG`B2~ATkGYzx$Ey`MP%QYii#F?)qbtoy=M9%hcS^$
zzol1LwU^CV-x?#AFh`{Yf5a__tRspHoo(?$?Eq2eVwvJXCI*;~^|CoIf?kZ`0M_Ae
zRjV}|SYAme>LtGUJ4pQU4GwSpshYq)yzrTdidt+{QX-V~VauUy-pw?l0~%Tm^0IGH
zvgI%@yBJ1nIdV4s#yf1;C<4HsW|m=&bfz85J(yR>pamE#9R-Cq27Pdgrpz2ys;OIp
zme5)2=%G#??@QVq9x{rx##)%s9YX`;mCwFk4KdN5fw<iZy3`h^@4_yz>Ckk%+%X}^
z*;T}w6wCq9qq5}zu(GPz%N_?Ewj7y^(XHI!T<g{JzKVnCAr{KQwHoSo(T$K;+j68|
z_y)}~;Y<`b4d`>!c8F>_3}fd>*nw+!>))xs7LGIl0~1*Nav6YxeZfR6Y-lXV8XeF7
zyH7Z}R)Cpz^Ll4u)D|y0jR#6VpZl^_u*(h&j%$9Ompy^1<5)Rf_6#*r%+^UplPlGw
z$Y$nFL#^wxwkk9_SR`MfE#s(#R<@<;`{G3-;!Ur5*A{H_cXsCY!Ipz@m)e&AbAA9P
zZ@GSAL$Niq&qG^0)<o6U1Sh!a*~3jumNfktRXGf*)$XG~fZoVO0C6<VAM}yj=S@52
zbpwI0)u4&QspT5nd5$zX*y11bJ$t+lN0=BLbg;?=1GHHx$Z!#lwP|srz5aat%54X<
zLDyRiE5Qm};zFLoMUK=(L-uvK$ziCB8a*gzEdx!$y7Ptz2J(Vn!Uv@HZT>fo9b|BN
zn&;`plTue0Z13WQR`G&w1Q9HkXod3QN)av+fV5i070|^f>g{ZLeg4Ocbg6n=YP@w>
z{SAMlxA~__Pr0{^L=<j8yOge12a|u%Q)rsd0D&ki<>$AA$LiN{#0ZRy>(CidL0Lo;
z)H%h@&ar9>HM>@Oa9@5CF;dis`>6XaO6E67c4aR|1X+Gs4ChlTU}7(KDvz?Pyzhpa
zOzwyeOq_jTj$gbz&Btwh2V&T>La<x7Hbt;CgBIyKP|&gzo1i6p!di^kD!*SZZ_C4D
zk03@oh_B*U8l<ZqQ-;_slZ<a*M-zs~c4;n*Dxc%x9Sj*S{5xZ?FSt!UUgO977V%^F
zCP*=2T2%`;a^`jOtG{3wna<p+>D)4A!7V&7{vvDA3mOq^wt7lfW;79h(cmMkwgywr
zH~)Ksw|r8ph0KwMVWzYkMY6oFBiEJ#VGAd|FBQn}&n6mB9kt^B8ET!JZhAK8?!dD#
zN0_RYAk`<^^qLk2xAL^HB4u*}=cx(4aE+U-9-uZHX!1wkbpOql9B7eiE3<n<vX<aN
z<zkg@jT8`R<+{9-0ZQ*Zf(SHd!h#R~zy&j@8l3JHq$d#MPnZW<Yz5(ye4_lOL-~#U
zziuP%X?#>Qak@sMe8a~KxygN+@%To#_#JR|OxPG60m~6CU+=Tdi3s}|kJ<MEnx=A;
zL}z`pJeD7`q_o0Yesi?evMK+FO;SnUS4Gy<%(ij<U!RSS8hb$LCN+jsz5<_CCz{i(
zu8~TQ)UIx@6?BkiNu<j*SE1cmnL-bV^}|h=j%7WAd!|gO#V*w8(zNTpmI1~rga{&4
zeIehdQOcv7%YmdfET(kW#9E5#>ukORAN#dD!c$apdZuOBKx)1*j|~+d;WrHWiEr_5
z6>r2VIX8VbEpcENGr%3e57WcB1h)=cA}7TVm(&FFDN_dOVVKakWW6p5m-wAcmvniH
zlXQ~EvhbG}4&{DA$T6Ga{B@i0H2jitIT5n!>6)M%LPdPk;-%_E@sDZyxn@pKF|64c
zv?g5C#xsj=r9fp{`UZ&<Hi;qCCerFVsvB0%3JACiehu}s4Q4%kU0PKbPMdt9vdAt8
zpS3raG?*`@v)Dy4Um0$aN(xle6nfzUkTqz(06b1MC4IxIs!ptgWLOi=U*KzxrI(#!
zz@M*OE#N)CQ^cUe^M4OMh^8)l66Vj9WYdakIK!JSTBGhFiy_;J@GrbJd)UAbP}5tE
z!_w-x=Vn%_?$zl8m=Zli0WRpo4<*b7@B440W8ny7n_`;&`#_Nhf+|MOhSl<6tL6U5
z)S@#1hSgG9A#?x%ut>-s1(NUCsdchnqrz4$JBt$;F7{a`TQ&!_C2+98Nrz(O5U(^B
zL+~BwU;HI6u8D)MGxq7dFzV}~@8Zp7ikL|9`E)78oXk?34IYY{&6lon8t>rGmpf^+
z01@KavoXm(O(a6_LE1vV0SIFnt;a@u)9IbLJ@Yp4Jc{qhyp6n=z(qSQV{0)pz>{Nn
zf<uQwhg+d4?`B)0`8|O0yb2SItK2IH_a0!;AD3(0l`c07UH)b0QbJjO6nM;CA-N}0
z(*!MbcG=bkCu_asjTR8Ml9%4{>#XN&&pOD80UwXCio1fp;j1r$4$*XRbO_)jN7=_e
zR;h=B-%*ArJ6>S*J;WGVoZ~tXmQ&@G75O`@AMJ!F2u3egJwnX=eDb3Tcxsj4oZ-Gz
zfQ5w;*W^$7u9Kix9PRm*CD;e%L**E*JFWljFjusk<=>ZUGrn*@)~1&YHCbVdduR+r
z+^!&cH7>LTk6tV%+%*qr1~5mGsn<QYUmaxKNXpv|(s<S%HFizu7lSm6Dq?wu0cS6y
zxDoZN_1Y2aP?lXZovEV80gkk|z}Li=Frwt*G_-iw#(K6<x-<X33V*O@yjN?wkFKmZ
z+6=+qZk)wYp%Mouy@`f=>e7qbR)MgJ(s4ucKid;_n6VgknR?&Z^yXZ)1e$qlW_Clc
z>k2?CIvd<v>5{o-BbP0cnxKj@PH3g>2v-y1f=y@UsF%F}(8?7Ccc`4r5@e~%#?|_~
z%$MA!DHq<TcpCaIBNH#k2TZORTbsLMUi2C^kL=P<M73jgxseJQFVe_(*FTGavI2<(
z-+|UVLU31b=Qp+dzazNq8?Kq@g_vS_kB+LXb!K*WlZAc)h2~q~SxAz$bSKM@Mv2fy
z^1%4QLn=fbR9zbhlR;CcvJDaYkc^>IKR?_UN{*HpR2l9a>XgPKoP{!y)A;S!{Bilv
zOfNF0Q*(_!tKT2>+htK7*z#B&gw>Hr_`YEi=m{Hxt1c5Rd(1vORd~&JVFHwu#QiMD
z8&ULCz;lw3Z$$lU)sek^vAu%$^ocp%LGLU$1^07MBlVFDi%u)(L<UOu4e&9n<8&8>
z$GpoWD5VB!3QH8u!79wv$JjlGJX=cliIwr=CMq)!-dobXzZ%z0#1wRQ70cV>`5`^|
zhxlo&NPR%jnb*r@&%IxfI;hR%U42`?sSP1x8#gi&%KC7~J^?=gFAq>$lS(-&Avk|Q
z89~Xptfn7Q2E`@PBb4`miezbc&F;IXHuB8hZM6ksT|LQ@hlb?uM0XFCjsf@R;MMu%
z)}U_LG{7BEZs^i1**(I$BK(S(({_*Qs|crY&)IFe#txzDHQPBT^4&h$Rkj}z-U%ej
z_-ShLiwoui7Y>8uSE&8)+hzdm3V!%?LKc6>6Q<>H>8~{rkbGGYDgq9e8+L7xiGYIS
z#&{w!p~I)j%sWGsZZ>jq0c62XyCUm&(dAeJmeMwy%f!oD?s6=Ky*x(g$vg^Q=Gwwb
zxCy>K_~j`)F0ECoGqkUpWhx_4mrGeBIzz#M+F%$Q3fD`)E^r6c@ve(^!J9BV6r7wQ
zg6$&aE_rGkofOlODOo>I8{yw+WWq*Mn7Pjy9BysbTOJEP#=SI`STLN)ja#$&<(mQ*
z29;EQ*St^6HGJOpV#?-y5?~6!twM@tA5E=Nw}uSL;iI*j4<s6o*Q^aWS(DjV(_Juo
z;tuO(!-PlM%v43lv=_(PUU$g(@Fg7_K*xEW7bq7H>nEArt;uoy)sthy;5?sTZ2$V4
zKk7$E%C;#z%^n2U@YOVtqP3}eY-kG=;h~J-kbY1;n}@XpG@gIM5)oMzq6E=4wyXVv
z@(;!&=WBxBqQD9VMN|A5NmZT08!u+k{AjF*f|`V;go1|Z=X}$cVwrbgY9%=W==o%I
z%cx|NEW#MEOc<TEnRk!v?^Xkck+SkK1~hdtlTcP!cMh+C=unoxq2zb@wJ4l4RgL43
z5z_$=c<f$d`hZBTuL;_dU|Jp|PO0pIHTtTYdQpADDpSMPg6Mz?FIQ`FyY%Feq5dd;
z6Zj%UhixJE^KTQH^jDC@4D4eHKB|}du{O93r%YSnNXS9Pt|XQ4U+d#fNE@<Z@nUWm
z;yN7SN?(ZlSL%;2b+wbjsOx%mM3avuTIz0>XNXKvg#&^38mE2B9mn>6mR>iG4yMhE
zdc8I|J$*%NbgEGtgm?2>C@^zbTuhvYe=D;v5-sApo-{aEUhXpWeq-rp&dxVK^zd_|
zadbEoa_XFj0fC7;EB)Ot=h+Q@|I$XyzJ}v(@UY*7FONfrvXQIN&!36W#2i5gge=CI
z7kV5%f))^mvtUY%ely#a_zSOzz33h_=utNx7moE7eG*WN-TDdN$#1>a5Z>3y8LKiQ
z7c&!g8Sc+=S7f;VDp&bOCiLu=WnWd6v+R#1v8ScjpI=U~&kPa&_=>a7vA>ahM)>Tg
zt00ixTl@r;2xg(NB~HLRsfA#LdfQR@x36hODFcSd9;0D10SvExWxwAvv2Gq`SzIz;
z31fm$6!!CXbPJaJq}E{kEY5qwA61dhNa+T*^M2)}Omr;C(z;;dSIr#CUWU1{@)kQ)
zX-9B(^iZKb(XL=)!_1#lM`ia-5;j-YXhXsGV?yzy1+`zMO6_{ddUS;#lU6RPbt$Fb
z7YVVy=P<r1{9aX*2j?T8)(E=R@XyW%#QF642|d~j&WAA{q_vaALHSy4Hl5wxeOujb
zs-WyT^sQ`hp=wS9XZt9&w>cwRzde-fzOL>~essGf`rX9u{`;3X2faI6w^zk)uG_<p
zm-`T!HoMV*;dKyu){(`xracCh`zN!n(!1eEw6k?CnE3@+=orQ(^mV+$9BpTlFjaxp
za+f;`A7fb}-Z$AuFq(IF=I<A1!3Va=mevWjxB5j*T7)-}0<t^A+`#xhT$RCZ(J`C|
z3XWPNY^FmOs6QeGi(i`)&%BbB-Gf+U!Nk@<#?-;nGe!vfSdjX6fjXuRdB*X+$qyui
zX`9D0^&o}Eiz-_aOrx0iG5a@klR5Ps<N~VdvcXCe8kC8X-B#NHo#(`Bj;#yoAvnJ<
zmdYn{<TyJ)9uE%Z(HX_D7xJi95OAEtvz$)s%I_u_UR0jED{EDLJCE?nP@K81#kKuL
z4I?MAzc5gq_p(2>CjfV|F6aPwpV=_A*kZs0|D{?bu@`Lvw&b@bJSy$+{z3n~tmpjL
zO}5dl`Ew0(Ux^p4?n30RyzBTj@+qG|&s8UuDb9G>oeM3*3oBKbpE->!znt7UdI@m%
zv9moj%GW82O&jLEYT2n0R`_brL|T-U+dfW>r&FWG>2=tp+*Hqryci$7cw*R#))RO!
zhZp6NOON8g1yRYntmL^I^0E;xLFqu`q{3_BO^<om67Zc_Jn6!C?{-q|Om3K(xw1Z1
zk=kk+(|o5$cid?0`7w3DCCKPpPdkL*<-TN<mOpR_w#cJdQ@YLkU$abjC~#h!uVe~K
z^~<Tvi(|4(MWzU&-~$nif5pggY!UyQ>v*r86skEF$C*#_?+70n^s}eUdZ`YVK-93+
zHRCu1inC!fgHp}G-5r>ZKcTq0&7H~Z5^g&<UaFoPYYr9RX!M4Yizu_1!PDpCGq6sF
z6L@0->ULn2qeR&Tv!DSv^#l{Gw*E!x8!pbja7SJ?;yl^q|Am<mAx&;1{XLz4j=bzL
zN{YjD%0;_IbaJC#xxsDQ>>XF$v(wiKR_Oz(M8EQBLM?MSb+|_vQYJST=+6)7H}VA6
zleIQ;bqsBBbxrb=h+gA`>K#nITCE+@5i*eorcZU@nEwJxs!NMVQ=2cYkIj9=$RV?C
zoMK()-qCMa9jeRn$IA^!WERB5GNVW(!T*gG;g`=W5xj*-_|ggVJBHb~ZFq0>aufAY
z=1;e(BVP77{#6*<40E2!z!Y|4cI0hWjeI3(o<W!E@ff_}E&9Ec(6*MsCrL$z$It@a
z{K{RN_FA2Kd_oTurQR17D5rQRtW&ZpCs)B>y~7i{kz?)1MAM-u4vb!x{Hb3!qn?1=
zIM#^#4aMqSdV(Clc6&CMej!6HmSb+i*iRzW-q;IWm({nQV$xy!%(Py(g)>3A_*_a4
z#zTpLnN=XYwMz4J&~l~Ki3ntA>Si#KUeHzHb$?j6$xoWe|I9chO;;;3gA2Z>)S!sF
zmPkC+GmV~uo=F{KDea&eiRQuy!KWw*S*3PTpq3MX<_LFfeYv!-!T&t!;-?}QLqTH!
zp48ft2hchI*&;jfKhZ_Db}P$hm{}Untc-?Ddpg78#IUR+*H(DBH*{@+F0-JX`|aE(
z3TM>Vsqep(ZYz9p!lM%iEbJkQ5~s@;Z}Aw|!&~mh2I?Mcv?ULjt;VLukYYy|-)tqE
z)^++mynDAQwmBNubgMXuG2R;lxIhiXI>`Zy5U$BQbJFzS;qnWiH9GNDFN5WJk-1{J
z;XDZsUok_O9Mtl)7`Ak$HOz70R;h%i;Po#V7gH0;`w|*La!z=q?S2rYK+^Jh|Kwuw
zRJJAU3MR3)TzMxC)0Dkx-U7(0ogHL42=ueW)8NV<NR4T4+L=7iiLRJ=26bZAeVKKw
z@Lz1<+p<hj{}sMy?woQ2dn7pXP6&p7##drHKl?@yy3Qd*Q})>rO4*+<weCZWV7Er6
z4i$OA$z^`=ipt-;7+%EPgjcMG9P|{O{}Q)JT~AFXDH3yMf`Qg72LrJZnboeW2^*K-
z+cSCPj&JMbp&ilLd<Gl0R2QR7N&>fEi>cF`7zHa+kE9zbF8f=0=IE`ZP40Uh*bsXD
zp3--MUz|s9axAl_mc>vI<1P9kRb}?H5+9Mpkv5R&O|wCpizQ(W0Wbb0<W*^Myj+q8
zT#iGge3la7h1?Ix!${)>V`(AYw`iO2!C&|jsL9AyLQV4scwQ5G<F131k}zup8MZ{>
z<H2U)(<EQuFUUU5M-hi*>(Z2SEQUuw-vrAj9Pt=aE_?JfghFW&a1UeV+S2t*6;=lN
z<PTy?^Q$EZPL$bz<kuTNKQ8<k9>_A7a{A4nvZ#<Mmv)Hhm+xA_(@<*8hwv$BJJm(k
z?1|bAj}$uhu<HCiMmPNQUPz)fc3^l4cdQhb#k0%fV<XgOiktCZi{T@gZF?#o9kr?3
z6hgRX&oICo)RPPav>1};7L;vFzVLrGDr>(sXjF!GK%Jc7;(9U(m?Lk<ap5W442>@{
zUlh>6Bac1~iE?^lT$?l>kLNeUdxN7g+jg{NwpF$fx!pdhC$k~leL7P;;x8Tw<d;N+
z9_QbB??`$^OnYJCx>lQjtd02#*Kgx8tYsYKHeDN2(37JFzcBI#A2^O-IrT<<)^HxU
zonm&*=M#mm*D85(;p1)noaUZ?(aUY3W;gA7!Cf)!Q~Xc<pEm7_4m8v0YCMFG`l{_z
zve9ZYI$Mon%Q#yNYER*!e}=(lqbhq=*VhD-t`|-^d|r_kW+#CKI#iP~ycCgqc<B8M
ztgLsvuNrzkQ|}LZ$M??_32Zx~G3HWvttt0kdBQ8()>qe6%;xkn>s|Ikj7a&tXb4Hf
zacTMUB0+Sp2CV!(l1Q(*bI@LcM&3C;kNiR8H;flgis=ASg0mmNAJ`3&w3#E#uSnTj
zEG@xVPVxLcZ}F{m{h)WP_B;{_<1Ompf+(%YjV$`)ds=&TjAZNQ$jpnJceZUr+o;`%
zrnfKk*e+FD;Svjf7aCWRns4!)86{gJgti^fQtb|FFcYb$)Jt0})E+-egO6(vj|<Du
z?SM2c_?B2-lZLfUNwmWi#5h^x)*jgc^>US9U9d+LYsb$Y&D<0gjpu{lpTBdu@9*@_
z+E-wYb-*uPRJke0Y-9GWeD8_~$jV|Mz<@cX`rG{F3U6^YSF8A6!5T?sRvoNRv3IdJ
z<|&?4=%9vH?7Zr;<N0bllkI2IJkbMk(s4$^3#wz@$@t&-s-vbf+R16zgk*5o!WgoV
zy!r|I&6ncM->R7VoB>xkfKV8<d)WbP-7;{M0|ak9`|w*jn_8F`OyfZuA7d;r{>{>X
z(IE@)N3ig7;3~fb{u=JqDcgO8qw7k4SH3y&xBL%?w&VFUxQ5&z%o@VOPeE4>egWz&
zR=P{ey&FCgQQWE;P-2;p!cV%w5q}rQydrFAKLzcM3w}rpw~c5Aa>izozbwDjfL}TI
znwcIe-Cj1s>v;ZK6{YJtu_wAM>rQ@iI2XGpUidOY^%asg-zBR_Yf``AVh9$j`S3Qq
z%4`@2p93z$*lC*obBJyao4tcjX?gGYl@^`fq)%>hW*<J6;FD(orwhUiZ|6(Rf{*0{
zH}*-M!|gpw_06ZD4)@Iu_051rAnGuNBlN(clDvn<yI$E$J9)pk0C|sGc_=t2dZo@L
z|0AA<T=E??HgRHXX=xxlcCfvs!S;Tm_HLj(vmS=zw~G&r=Qp=OmVePcOF1(eJ1f@_
zP$G`^u2ug*C0vf{GkGqv8(g&KNwY0b)Ja-}mT!~?Vh+ILg?OnP?*@|*esa4E1Pize
z4#A{xBsbjYYJ8FZ*MwI}zl7d)P{~PJKSi7;8R7pBVx^kbB`1h^@e~pj(ieP!=W4VT
zReuatC+V$UR+ilN^Bh7s$uiGIBT_1s<zL&m`Ay{ilv+BcO}$o^l?Aj0uJ)aD>^$mu
zT#lyF%dW?^h0i~5=GzskWDy22T8J-P`_}KU<pkKITDPlInT&e3AHHzATw;k)+lf7{
zPJJaktMM8ftBq~Fuduwdt1Yvgb|%$>HMYWUuSQ9>j|#dcH3pwE<ly^am5IQet-+?3
zFco&!BtOY4XQCc>=zCL$HRZVh2eoWpg_=nF3m+70%I>HEsjzeh1P9fE$T7h!og&Uj
zwR!`}#+3eKioJCAk|+@>T0ApQGye<zEL>8XO(&y~-<C#3H|HOWRB}+9rUC3jz6SrL
zOS0r4kx^bvrTNDV25$zpK={(zjJ1PwO)yCy6weuGTi<^2Kt<_q5uAqo!fDK@k|TqG
z1e5~IejoD|WI*2}8-(ET1m6~};J9kng<!oNL`eM7n%Tqs^SgSmEM4q*a>SY?(df3e
z_4ib#=8~OK;=V;(HcWQ}e*?G)1O1a4*&n3WQW(QznluCpOxS=CQJ{VWA1O)|6tWc;
z9itZ9<#s}n`X#frmFO2iraJus>m6+*J)j!aVZ<bUer#Q7mCci1#>e(Z0!C5w3?Z|b
zo**UjIJ0&f<NGpJ#Ta|3HYpp-D8F>yqtbBp^R*_8Agv4>t?3Q@q~hQ(S)-Y?^;i<a
z{qfXq-^;l<P7SEEeTS*WcTo+n@uOzvTLr`X`H}@6PJg{|kKc!9Ma@r^WY@3ZissU~
zmzy6wMNWRX?DIqcO+!*lu30lAicB)KolT7{_P+SVf#i7N)`M=SX^?-t<ztR!zfxiB
zce>9$2BWRSBG{V)sTaRQ7Bzz8X|H{Fey0DaK7Z=}kNQ|Id(<sqxR82Q$`-!7p&Di;
zEk-+I+tS*7W!;ha^<b}&JQ10FV|?a{LPDGpy6$$@i1YG3R2(>5Yl=^qT3s)7*Y&zy
z=B^pY@*I@;v3LDX8E%ruHjeR@SE0Dr6r6nydG8nRuIuFsh3C>70<+XMgk(`QmcUD_
z36e1E6snL{HP+T$T^E-NQgO`rEf^N9;B`%<D$P@A%STe{*m7`w-H{V|lwO2a-tuOS
zDQ!p|bIpnTemHe%^l$}rR_IOY1?aQgTlqM1&cXdey!Z;62q@BK+P`$SvlDoJa`Mqu
zO5ZONC-YJRJ1yt8p%Xr0BkHX@EO|vS@vDmB#Z&S5y5=bz6&$zl?Z5oxFJrFWqOY$h
zJx!&~o}k{2<Tod5<oC?vzwz(ov_ZnkyXh1>`ZyaL7F;lF{~RSQU`|Udf;>Eo3u`~U
z_tRIWUF8eKL5SgnYc=d;Nz93QdQR=++A;7--=+U3tVWZy1l4sIO@zprA$vTt=S<>I
z0S3ogZX;g%nYH}$)sJ|&Nr!7J+w1;~@xZ~++Kq$HX<Mx;%=C+HX=HtCWyQ)00BKjy
zO}p%2Q=Y*mBqQA+6t(S)dVM=aAhDUXG|xFeO6@oP0WZE9r{}CdYz|oj%H@{PvZttG
ze(uq$+X&%GwX|jSDw#gjlTR5>!22MtStMY7ab>Mh8kZ>I&dRrf^T|pt>8Zx*O+9yH
z`xCQp7g9hAveMu-J8M;^$>*4jaS>=sv=#5H{FhN*yb>>}5n%2bY_9TnDyZDDCTBMq
z?cy2f;lgG_I#@_2>1rIbBAMnzw#VqPo%B3I$Tf`igH*$BNcv>$yKTpqSxR?0__q7k
zNHJMA;=Oy<{r<nc+qNR#-QC@u->~Z?{^{L)tU5HgIB|4a@4kcD#;@mL+pggBV$0~>
zfsrTTq{#2)zHNn8FpJfn$?xsmdu;FSk>fYrt0&%XR_FJ&dB52`esz9Rd;Wp(d)W}o
ztU}Ft*QUWQ_e21GmV2(4c-+V{$8yldFQ~%L|Gmv@YPoDReC^}kZujDEbX4x^oYl`*
za+IN$IUC$*EI*ff<?4z4tXDLW(m?eZN+iuoURGkKJe2XumxCWnk+xM4#;~??7Cw3o
zihT&b9;K4gg4^*~Fw~uuZ-B?}5!AvkBx|LGq;iAf<rgOnI51hQ_SxChMhIGZLFGqM
zJ3_e?f{Xlp1Esq(bay}kOM)+PZ-fxO2IzvT0r&)0C2$!?2Al;|1rK5oxzcMX%_LQw
zx%Z~J_>Hd7_G0S+?fD*!Sr22@Ub(t=?}+iMi`5oUF@96q_?|XgZbR~kauam&dwoT3
zaBN$?m-PwOk0B&6YVK+-hR6uScPHxpEx!vqh>~W7=h21Co(?ZNQUU~Ut^*uUezFV9
zOa4^oPyVp&-V1nMy2*+@0k#H<+Vs&K%3LWQbZf^^1Hu>><_n~0#}-T_^7BF$#*AY4
z+Te%|p@u8RcC&U)=xHDSh8JJgUb)kswPA?6d%eu*445e5>;F4N97FBHDPl3z4^c!%
z788(JO2o~rl;p^jgClOfii=>8EEGrxk?^m0<%6P=+ZieAZ-N3Q^`2qG)bX2zqg6;S
zHl^;qnJ?SCAN95^?70}XOf(kzjgMbU)XiV{Ao70K7KR6$^pp-7ln?oT;uNV&#@4qD
ze8$g&l?-U2`0asRFZ8}t#Sv4LJ#NVVKla`RFskZW^glBRh$LocMT<4nqb8DQ27;mj
zMonN6COANppjd(s@<CEVk|q;AY^<qCs42wK7Ol6%D{ZZ%Ev?)ua?zp&MW8Kh(Ng8M
zw58VSOu<T9E3`u9|66<SGc%dYSl_#^_rCl7ca*Gi)?Rz<wbx#I?X^G7IfXAqeD{`c
zAoW1UenOaizNvJc*{6jc2N7&f@4IYDGLM!e^>4B>D~;&s`6>&IlLlnhZotGfK3R{H
z{oa)&`8*PMJdnSy#I;w>z20}1&bHXoBgd*$8~AHzBjskF^K?InMzF4)UTQw+CEg?H
zDgT+gHMHgjvIV*3OC(D>)zeNNrGMMZ0&X@vSVGAK(g+nYIrr0zW8R-9GSF~*^X;1<
z)*(4)k_wry`^8T1(TobE&dBfj5v6&0I+2w=?{qxX>m@^UbP+GV0*(oMX1h+)%#+@n
zo&QG}T73CGV7AEc;u}7`NQAD+IvY>I7*l3ycRf{?4x-AE0fXp=_w!&zo}OJO)2UPF
z#B^<s%G?X3|L2vv_G?dN1{!>oygSs>GmkJd^bV_;W^_3fe#o)JCG-U2GD>!c&*)z@
zQhDvZllTf39y{Jutlf~ak(SCo+21+l3`OR{ukVUnsQY%wu9NPP{FCAD!Bm;IJSnRT
z{#G=~NFrwb)P=oAZ+f<tD;Y=BFtY1!Bl7uDudjdl*`CK<nfjvV-k-A^{;9vJj-cFu
z>JIq>;o~@$NdwAGUXb0jn&VEtR-XQ2Y(yxn)`(W${3NGVjkm|gUky)3ed0@>C}Crj
zRm3wT=nGFGhaXLJA(#_a#Jo#@gAgkv_8gF8$RvK1`+eqqy}3VN?!^a7`XO__$=n|?
z_cEqRddS>wHTTDXp$uiLbQ303%A3g&3}Z+6lgrGT+<kp}o-Kq_#bs=Elz0EZRepkb
zGus{~Z}8J<{`}|s@;N!zfIoj%-$_<9{e3U`@=xMP3weogiO08>Sw_jdBRd9q-&FB|
zXYLEE@W_zP!aRD`-ThLgG%8sw#Fy;wQfhcK$r4>$j2X$4(EezA{D^ww`2-)GtcYh9
zSdSJ@*>7~a_c_Le$RsxJd1D!!ua9}vx7b~fgK+A}IhK2U`F~Q~=J@RVqeNzbslW7e
z-zTf__=0A7%QV$(=_=~cJJUn*)F`P&mk}l=dn0t<2IIEXGkNroc;TWlDFNlU_s@|^
z1Ue6aX4kwt+jWo_OkDRLKqyO|NXHeAEe)*4*YJK&D(!5OCdQ$AM0l%{b^_Cs=t}wz
z*`+7QnM+|)+PAOoInjG*zH~a=zKpTC>-ppB502T0`&PsGiQiA}Pj~a)Kov&0^AGfo
zeSz#&{&NIgzI^(RZ%kULEcktX6au`nCvAs>AsuskeaBU=lMvvz4%-Sv^{U_Pkgn)?
z?7)uCLt8TS<&F!*m+U%u#^ubL8wW%RLc0<UG@Li!UCv!;|74evr?l^nrTKp?`P42E
z7ZFPHf2>3tO)xi1#M1u2xoLWbS_PMHA|exwnVhs@jN@t<Ux>!mDBLdDAwEJzl@jGB
z2qKj`Qu5+<a1vU*`3L&;`dlYs4vVo2Cp3cbO;yY1c??@(>HVaq?@}5-Snd$7f)aiC
z$4~scq<f%t>Ruo3L=2B4UC+Z*TYeJ@rhU}Fti&mKMiiyXO;%vv$x_c_duRq0`aOL+
z*v&j~NZ5ZWBCp=_dFBj+zXnn<|2?)WM${AKsNNT=(tfPcm^d2?Y9^EPwe8?lU%QFE
z7JiT(sO}o&?lasy+X}O1<d4>J&wzYhPWN5ngP-&7c=#a>+p1C;;HDlvd5L;*DBtth
zr)UO|NxE*|TP51nDF1@}5q_c93rkLfaV@_5=ei?jO4#tblD@aXKN40F@QvjHm5GI4
zt}R=cN%vlciW9#NzvzrP$2d<dWAT*m@0_gvu29;ohJWH<pEp?HsN&I*XJt{WggtFF
zATR>3w7dv%rHUF+g}fQ!Jw^yWn{H}^kS9zMM~Dbjj~^kvaIGF8MwiP7;UR~rXMquG
zeM~H-Z;4{<amY{OIz+KuLZgG*FOkN2sH<q2r>9@eC-l#AX=hS&r>A#68CZi3x6oM9
z^5=^0;T7AcY?P<`N51}#yNI8d;HWWg1rI!^8nr-1jV_5F^Bzv9(XMGM`)t3q<lZ8+
z)DgaxJcRJ!pAd(7wts@vv7@f=M#`1>qjvT(3<UFILqPZ}3{u%e=yCL;LW=NaI*%sr
z3#0uoaojF7KA((@&wD-HKX^;~a1Nt=vWQu*-TMx!x;4BrQqQ9C<Pz5DNJ~x8LLMYG
zaknH$%!U_tA~qr}6?o#JOP*3gQy0>e?6@3Vho>{nNO1XOQGDN9lLkt7uTzPqd@qtE
z&Ik&PWXlL!W1%MDln%y*gqp;Iu~3lcDm`X35*RL;`u;*q8CG7xb_M=GU=1f`)qCO8
zYNTF@VETGLPaVj>SE}}nwW0_Jt5g6iv2TS)gU)#5K6GRXO_Elt9wn|)0k6cU6{0tk
z2ZaQtfwU%Ow)uZ6VT*G1fu8U8{fq~KQC3OcD~^hItDR~&X&hM+VbXM#mV*Z&Ayv`+
zL@s2;CC7Fy;Tm-*p<+?F31iV0!%g^QMi^;oiCjWgBdLxIuxmBXmWB;aLlf``Z>5Wv
z^%WsU=b~GeR8NKo6&6vm!tf@<V&x*-K+hIc`i?Q9K94p~%)_6=nDrpCD}13i5trw&
zy(P~wv$38X%b(K5J!8gWA54l|2f`nK31?H>&UF26>?E_wH&eYzjo#W@g{M9GM(8%S
zB{csF;9uHz+>8#CA)|nr$*ICho|PqGxQDmXPZ=c5#9SQ4iQkv?r?YnQ*9#?ZE@jq)
zVTL~mU38pMUXPJV&kd*UE$#2QUgm`2{;2a(XdyA{WprdwM3WR`9Qo5yPhHz^E_g@#
zD*olXg^Ht8r&3cHsS>t=wTDC0OOL)%J6*56dMb*m!mX%E{f2HMt^XxjR!%PcNn!{g
z?mHf(6_*{}0bvP2>JEt@BsA%$(4#yN3B!9dF3Dq985))}O9sLc8zr6LyPOs*)lo^Q
z6P27eFhUWzc4_54gDKJ`#3Lt7EX4>`n!hV`{6ui_fwb^)oLIbqHn4>oKE<dNkGxxu
zFW@%gkskvoTC_!hdEsACSy_=HGA@><c*7qT1PdvJ?}SHD2<yiv>tP<>P2h7ed~na<
zDkdWie=+;fia%W_X;W=x$a5N82IL}ogyR*%tyr{J#VsJsd|mca<mfCCaY}`00gi>Q
znoWv?E)HSVvgHz6Y+(IX_K!jz!dh5L4Z0UTFI)S64Xt^7(8Nom|2ecWF}*&T&T5T+
z?MS}({?s?WrGI<|YNeN#Ub_4*{@(98;O`rW=R3+<3cIis*-(6{SfIzptEyGf#){Cn
zQGQCEWwbGyZD_e~@4~Qbphwrcso$v3-pN|t5!7eY^Pxk(i|u#F)(X2|BDNyU7FJNH
zP1QdvTm;APA+kH`DXP4Gy8?c4_NCRe@aWS+^uw#(J3e&O7gzpXHV*c<rX1+F)U*AJ
ze*d%m6?XSu&*RHsp6%!Q`e!}MOxNZKrt?ZXWe4~s;Ez4qUt+H;|G@K;2G}nvxm7*t
z5ciPCX0#D{0+9l1ue#-^t+!mC-yybzk`Bp(GIz6LJfXPf&5nYj^Nb$lSx^hHc`@@y
zPK>-2`tu|>^an>U2rAlOzS(8{7V4vI&noUZeObr8k}d-J4xWEK5!yu#UhX{7)pf14
zV{wfxj#YmVD7vv(aytwE&(@I|`aq%5I&Xjpp2_h#Pw&TYbURp!u}XHz;~OQ<RzSu#
z63&>Yk1f(g)P^75Ab@hV>v!e-cV&e{9<{B^yEyiNSI4~vWyiai6o#Bpyjo`D^gX^@
zYoaWY@2F|0Zfma#PI!j553oO2YVBy3()N~)s%~nmt}p2;We17~Ak>Ny<@2DsJ@<Yc
z$MTG2Pq$$EeO;iuJEx}?Jg=joGmCJrVV2z`fcLPDD!+CnrwnI6BIaA(cPlTtn$jJy
zgRl0_Ji+$)il28!F7fop8=~ZuBp(pItc)#@Cm&vYri04MGtRS6tDK;@?|w!1>RP@5
z{#<(hry_%cgC}0RXkTs@zhId6KFBu5uJD*|b|HbhZnJ-un-+i3Vt@7LX@UG#OV$#c
z4$m6u+ZC6qoLm8&tDn)LoUG+64{&;R6wj`uf6${|aqI8*^PclnJkn4p+Y=o6mvMYl
z=p&erY&ozaN&*i<sDnX#{fNzhAlqwu_u}+%SFii?Uzwf%a=>*W;Cd_cjS2F!MCVmh
zpV#-!=G`y%gNdr}o~Owqs`!alolzCV-;0jJTfrNB`#7Lej6sz=qYNDbehK10-&ONM
zwiV7KWM#|GX`}D}_hKPg6O9S(4j%FM7e~VPNo*@SqH+}Wf~W-D>XTN{MkIA~$1frA
z^o}*61rb;WL3nE&Ani#XX@%RwU!-9h>R=E$5sh)iNz~Vh`b23B($$Q<L~mpCn;%t8
z!c$=&eO4HR1`DK4rjj9xGQ%HG`iz7gCkg)>uI4`Gan{GSUe%*_-MhQwi*r4Th(lF=
z^}3cd+tH@_8iTw`wZh-ul#?!2?UQqJV%bouSyiS?t%?;29Vt{muPb#G@p-0RdG(5_
zfoHqBZ&&w`3kSj@x_@)V+RXkgtl9H5BExPWf#o=$<$1;pL)%3hpF<=ePwZs6BsLJA
zA={_6e86lUQGuFM;DNiG{X_F!x6rqh@(P{v<?6*!%)qAn)YB`we4g!#*ag^rbjCZr
zW|u2?R_G4s{cEl1p6%J2acyIBNd0{@b#^p$>}Eds^e^oBv3nX<YE*QQTeOi$$XAsU
z5IJ!tvIJg?BIG=<D54^@A}%(HSYQ;Pws&E;M6^-c^9wEmyj4mn4pSSZ#WMR7I}t<U
zkmPgbV?BJQVT~M7m%YLY*##LBdIIBDVS^()Lq^FW9u|(2+^+Ur#l_q77qQlR;Y&-q
zLT_Czx>3&+?g=gZsoVs`SOYnH4X87RrwpG9y(=`BzB+5gyOywjZu#!kze;^rbI%p&
z)SLfR6D!ZYl$MYsz8qQ3=^YeV;g>EtbcOzjPAFo?J3__a)JB#wo)X!FRvCgL<ReS5
zD^z9#t&p#4KKYUs6uS-N_=It-2zqmzpbI=bKgFW7p!xBFR!D=YCQyPti7F(ft(Bmw
zcfJwSr<z4IQ0OR~PNd~{y@b=nR`@2aqT{(3!xGu0Wm}Fwt4TQVV9)h%(yiEY1=U2y
zIiX2#@^O6Y`OtW-@}KWJBxQ~h*MtP)V4lf0IngCo0UB4@oZAZZ9FU`*sQ4nH6@J0-
zUol${T|BCEajc7F8Qp)n_qmiIz*fv<<Yj|W85<`+$>ChZr3;Oz^or2y`6_*hN?#CO
z9G@Pwxe^Ld?n>4J#O`8W)s3A;#-MWKeK`fpjZjFy>R73|jQE^lPwyI4<a_j+_PNm-
z<2-av30_90sGT&x<l_E;6Nkb-BgS>~<Jtav{(<mRO4I9gJ8+MY@Z&-uEp?PpvQvzP
z(nDiZrwMkV32f}uJlz?Tjm<w0wXxasg}YQ&I4%_Z6>d2jvf@!}-_zRycWJ2vvs#MD
zVg9vPzxo2>lbdjdPko!pK9j?Psn1sNCv*`?UawQ`i>8!H${D1frA*7y`v%dz_*#G8
z?>cz4hruG1hiNZ}`l@(0s~ihXtLIyA3NOb>)p)1+BTPdXj3Z*-?bJj$g`bbtdSHa#
z6Po=Ktp}V!Ob;QUa9l#LTzXkhK3Umu;V@Uwu~1B3z8UvdN=A{!2i%YCNU68$QmycO
zQKU0WDAVMfF0z=Q40h5lLh~pz-egG%`I!2|#y(Xq;`iUl7+9{tcsaCrP)$L`lAS#S
zzp@ANUdZ~`3Xi|P?g&<^-yOQ>d7iEO3oT*!KNWe5olMV~Z*mj*_Y1-Fu_F=*{)G2)
z@^V@^{YVS*-XprXwc<L)VaAtWMx=P!<cy9Fhra>VnXg=)`4ho%KmjCcTODuC>C04n
zcJbiYA3OGxn*(VKPO}LB|Dex7^Vr|GDVb*nSF#ZkoaJAe{tC~avv1S${f<y*FA~W(
zfmf|N5|y6ihzb7gH;()BPs!u`934M$yu5$a7`4_F>mPH}AtsrF9Q_jSGwj~Q!vOpI
z`TJ(|rT-+%Yc-60$WCj28PBNwDaZk;Im{9Egk@eeyRRT8ROSc}z7tgZ`9h_Cz9BE?
zCe<YBQ^!IgXy4N(#Q@}7`TfVa3VlIol{s9m1q=U<&$GYC|LF{KD|o3(-Jxi^lq_Dv
zJ2{?KWIR8<>y44>^A!1eqs>%^7Y|)=0a3ULK!XGR{@yXdweKNYMDDK}w?`p}M0&@9
zK_YawAbn4-%<pI`tLtgWK!?+xue@LKrRr&(?lmLGzqdCJB54NcZ@q<b)7Lv0uvY!m
z%vE^v<B`y>RW%Lt=M<OkdM$mn>lhu!U5?G`NzNKs$tD(NLJsRuuo2_JDsC@6dRcV5
z>Ec7&_`l+@B~#0Myibf7;uY%aufJu;oqKuFsT=##@7CV}2oca6;0f0$%!9A380G0X
zj;wvh`ItQ~f_O*@kVm?hsRi=c0!%;b?^dN^9(xLnu>PqE<>~E!8l1G;p56*>EctL^
zZ>3!E+tXVmSFCI7DP50dN@Z&VD1W8m()N2wH)008ON3Kj=_Y@FDaJRD4oX=@zhY}J
zBAoW$5@*S)!@BNTPvd+Mb{g+rJAYH^_IZFDNU_;8jt;d-x4QaDx8V;<Hxg$}goKw1
zuki2s4c|=&`+3PLXV$KrzuD6x<;lUmJhIF4ojk^}+3zad6u9;YF+!<`r$?TGnDh%J
zR*#GVp|4&nuJW!;;x^Cy0oVO^t>@tv?%8ae%OG-hPUyQrqdaFR<!qwK#Cdvp&J}yY
zf!Y+c$q`%yC|}2N*3RE1>u3*)5uvp`R7BN?30ZpR#!Iy)%~6uAx5DR(?xN=j{c8((
z#JVuF;SwP$_H5YGcRVa#C>Y``n#5cD?l`9#$ArJf*h!PAc3S(8v^cM2;MjTSrt_uz
zx<ktI7_TFJQ~6!>@VwIL+U&Opv7Z)$D9`_uJVc<Lx!_bxa8dY1RI10Hy}b=km<G~I
zs(X4{1=XjH7ecSCinh8GGDMOLewUVvy$EA;9MB?}UeoooGRzK+C*Lp9r!tSWZoG+D
zSjdyBbvGXMYqNHRe!=-a(zTiH2?h2^OFki-RYT69AwQYpU;Bg*gnlK&sy&r(o}T-~
z-c^%+O|EECUev86j#XGS?0yv@>#9m5u}h3WcLJjav(7AyT%V%_eIwTY!oT2J6fHVK
zSv=wmV(rsGZe_gP&t2#b7dY#1bXG^-n!Od4by+M_RW<ZB4@H;+dZdts@04`rQ(Gmx
zeG#izTe?lg?BiHZT+iu}ryP5Bl74N;SUggA7nk+1@n+G+@HJqZ@o=pg2#h`QTmXFy
zpWzA%1N^Y+F>9xWUPH4K20M9WQoKDYkA%P49lnvMPLBQim2GqEQg|sp?+T5jKGe;o
zBGMsy_ee7;A5Yt9tnQZGdvih`5@Owqd1T-_vN91+&G;p`GR>&6#k{_1#u1e1TiY*Q
zU(I#?CiHsrF++mtrC+Dxi|$@!#n=o*;g`8azYkTBSKQp2n6a^8Pw!RA<lobdJ>3$l
z#5F9#koI)({Rn@joHO0%%du```VLN9_b26?jhhRPkBg@rXN1$S!UKemrX6+oVN}_F
z{}|D8_j7svsW0<(Q_3mlU^S;^?-zac43zM3d&Zc`oa4a^Jvf#S%AcZZNV*w?*+?x!
z9MN)kIosmePvB8QxAM7O5rA=HbNE_>a60gui?mwnDbeY`ABH%t1Fzk!T3&Tv-D@3(
zEG_>LA&&3BuSYxZpG^nmWz0!Ca0X?reL{6N<~MH9?U3#pbJ3f%E%$t!4rNBqa2?mQ
zy>wpbUUIv(Uom6C%(K7|^`I<`D++=))hpx*kSz#aU3WJ`#==8aXG`x@1oU3Xa+Ht6
zDCNt9dOU7mHY+_L&vr!=u93XMJ;DJQ7mP#r?fJtT!oQIG<bcd%66PznQhew|CM`NO
zVV*OU)Tlp*y>I^%q2gcW@o>N@su!xII2wX8_p|6xo@YvFZ02bG{;HhGg#Crsxi4oj
zdXN=?B8$fdo+}>s!-(!zFYJE(jJ1=W(CbYvd+u2%eiWy0C4E|Y+`B9-3j<fkB}FhD
zDHewid`@nHQbK1=C1-_Y+U(In;4#=v_Vip#R_z6Dkt@8wB{IP&7E%1tCdvamP8!%s
z3hVs_tJ%U(M6Pg!9z*XeosUozps-4jopAezygvH#)RX?#ufI~syX&?}?O3(sleOwn
zUW79MO3l&b{A^Ht`A9xp+65Y3t*n`g93oH<D7a3#-eGy2^)^B9gY!;-LZnu#{e9_7
zXPcNw_S&K>4(<(*o@%)CbmvLn0mpq%NpTYH>Q`60IHh(F%-VGdn4(-V?foH+P&o;{
z<8Y?ui_iP)clnA6b><}%kMLz=&po>sb%}Qam$OjJK-QVl>FJRtW+hU%E&MI6WIUkU
zdt>F6^!=Jb)(e87HvlD0pw_sz&yXW}{La;r(?zPBeN#%|+k~8ulqi8`=q-8A*9Jw9
zs@835<h@LxH?du@q9-^XC<=FlzBf(`XQ#?6hIILW+;7wOEJy|Y{rY5(7}PUDtlW#P
z1>>D)T#YP$k}GU#LiA)|Tve52-A18u4op>3#&mxMSun4lqXX0tnq@@%Gksb_w8CMo
zobeaM-o>o)h>8#{r1jJqsJt-YGHxdQLhTEGpN0Nxd78jC<!`fD8e#9^_sX!$`G~H&
zXp0_sWt0ksyWc%?MH4Sx2rlCk;g<tbkFUIKHnY@=)sfOy0)1n10{K4<eV)1p){f2L
z{l?|4=SsS!SshpS`!}dhIqTP%1lVT`$wxAK2IO5$p5E!ykEdrQMUI~3$gjje=J~Q2
zku8tk7&$$?JdKYFo$X?(Tn<Ht#nHv!t;JLRSl)jN&mBL7v6r9t)tvsSt2iFN=V-PX
zPdIa!er_pqAg0RCQQuvj-p@fu{>-zPTOVQnO8k+t>dfX9uFHp}29Ca_*14R%kBgA*
zT;U2|LV$vr^`{1vo>$-~*KSem#$sUaGHx-uPIUMq_UGjjqhi70_vO9CK1@+JF+qMh
z2)zo6r?MS=g}$z|M2E$QJ==BXlTXm`J{mnvGI(+bzPx`CD?KM+PI(oS_a>L(oTlo2
zswRw{UKzT?>ZC*a=_v!i^1fd>j>mLkvL7K52z~z?ZSg`S7C)8k8L@bE-@i^d8Zmlt
z1Y-1x-Wa`<;OV)BT5F@vMb~2Ve4W;umyPo)%IIr3l|Y&>6OTGyGQfNr_sDes;0oP(
zp6-?Mt__gNTZUJ0Bj0D(psFQvIr+RoZzfiv9X&m1fb5~Zb5-sQ%$+?we^H~Td2Won
zQh>jIV~)HG2-bxF<%8s2e&A$xi;DK-92bbJJJkJ#oG~Ow`G-upv_rI>yxVP@Nk0M}
zKBoYRk2ux%=1}+0+lD@5=wzKhudtCQlT#6*80dK>^?=y@1Idk+WyIot`QC9Q5CJL#
zgS_Te>gAG&=149=kAG0@FU9*`vaE-J6}~qX2kHSRd>1Be;x*nb8QT6K-9VqD;mIWp
z<O)9y4eg^{XQ=yZ;tRu2>T$0yo(N;z--Z~uDMT%m<M9?4?zZMGZR84F0zY9c`VcGq
z!c*Ex)jb9zl{CYAo{$;?6|Hc7Qs&=rIx@;pts)fCNi?ILoVO8_o}w&+{w71AvWP(c
z7G*Vo{%xu-8LT;={{oA|QigfnPV7TCr5blU-D(CACyO3!Ra=>+!{mlE8Sesh%q(1_
zV)x>twK0;qa8{2f>*H;Ip59puo76{)8BO#^ZIRJ>PZ`UE3K>TM`ClRe{TgwK7$Z0&
z9SfuYFk<M8&wmCXtR<8G+6~GeRfOQ_xfB_AfdD5RIVPk$pyn-lmjdLedukou6iyQu
z{?U%f_h{+Tp|KwrY7RX+V&)LwYuWM;`H9d4LKSZbJ<Jva!<x)XQm!*TOOwSLh;mg=
zGJ?z58fgr*f3z9VSt&sz)m)*+*e#am;YOH(R3;O?o}0M&EDJ058nO!bK_)HX3e6j%
zE1;{tC-nTk=?bWOysns`I7U&kcwI$rsv;Wp^!!mMR8=MljpKC{gSfU+Rrv#w(|LrM
z1RB4lJ%qUwf<&rGbpwZfLFbV=G4ql-DYFU7uDI^E%C>}FY^&!i@F+;JCC|SxtE1gS
zImjpL2)rs!w8uV9_!PJDK8?3Rt4tBH|7q0b3bSK{hrxih>7IzRQj^g4&=c~&;Csry
z#MR75ZiPEYiLO6r7ZFPHDF35m5&t8$75=%bH5fl;`2QkH(Mgrivo_0cj>xL$R5-~O
z)Fl<$?gFOj+U*PDovH5D>!EidS)z$fSNL_#fKgAr@)`aD$5kcEJ|W^C^*I0#C=tC(
z0v~=m>UW7&Z@_0u+nho3Nhs(ForUy{%N4J9*Av=`y2vlvr$eIEF+yxiNZhffCrGi{
zgeJ(9(;HN71QQ|=OqtNPx$>>uXhIp*GxQmXxM(%>Fx^e$`ygYo$Y+H|Nen0Pm3-MO
zFT9M($Min{>(D}M$f>yKUz8F4Th!jPbZ>wZ>B_}R6pN@xCoLM4?kpwUI@4FbAG|Q>
zRP{azGv#CblgUHTVj`~4Z?&EE$O9c93x#v|S#F}UL26VXYA<qyb2uRBsGYs5FJ>kg
z>!fc;yuySuv_c3ZyPA0(eJb8iC`_z`SUoJC{&dE;&~(jor~%)|nv&>1#0wX4TsG-^
z{TpNrUG!n<%6YQ#z7vz)agL1~ob=NCNpH%bHYVo&F({I!{W!xSZ~B&x%`t^kPxpo1
z9xX2%W2VfRjQ}*fAFql}S}}Q;BF{q=cAR&#O2x}WpN0PXL-Hjw&J^WY998b;u%ev&
zv7K+LyrDjbAc~w~QD*3iFc(AY*cB?`l9vRWJR|r-_sMfTy)x7aUuFsKq{_a)Wap!8
zP)o$*NWk6|AKWs?G5)oA>hlj`QbIM#&n(1$EuUqU^D#WbDDS_VB#+63MhHttIQ!Ho
zZ;YUt(o`JAPG>I7n!wS^9lHtgupN6UePN#el&n8EQ&+~*vk9*9hQLA;*YUEjb_m}H
zJrbpoP9>@;W;FhWTvIHf7Ui&5(5Fv-`}?LaPm$(v-XEfl*=c>_2R=>v(j8RraTPr*
z^v<Zki2h*2_qdH5-G#6{@HX|9y&QFSbaUv3kakbu<4>|IsmfMa{8RISYeU~9(YKcR
z?UwT-OSmgVrRoEVp?kO!dn&nw_s2wEn?eMHKo3am`uLuQD0$a!)BV@M+~fDmJQU#7
zQR4FtW+;)>i>bP3pg8TH2z?sX5>BxtUB&Afmf;^mmw;Q#iL<@k?;`Arh~NG08J^xe
z)woqTV{Ytk@>+rX-<D5()6*>xt(tSb5jv_1V#w5=Jn;9Y!-eO#4vKW_bC*WMT)9>+
zNgpR(5-i6G{qhjliO}E9aN2W~sPdz_-9ujhZRA0WuPD_figCAK)$4~twOWi|3vVUW
z<)cz|_vIBZ{(N5G!?7RP#nt6&GdvOcq$xXy-%!GGN>+01k+|cCnl}dWUk^<ELwli^
zUPP>xHxqe$yN_O|<uq?4{~k*VWO*aBaU^Hx`Yu#&&B=?K^@g4&!TH9>(O0APA}<8$
zx`A4}%lF&+{^IX@S!wRA(AhteQ{EjPlC`&2XdB86&Ju=tf5=q(v{YLSF)svfmm{-`
zN#7T*Cf52qFEGLsRwH%qz^WPM45`i^x-w24#n$NkeDJ=twz96bLf4U(M+EyWIoiXF
zy(@Hjgh}Ns&A$#k#+{_rS>dH(fcOzVJIeic^U~UrD{DE!GAeYVn5sy#E4Yv&dt>$%
zXU=-}oU#6=ToFtC$6G@EC-}6@?=gr2?6i*ZyV%8M*ZlxC<zJirLh&n0VLSO}8qz?=
z)iGl&FNb*5c!zXhRX(Q*&ivHfr=*Oa`_FWdlW|22FXyC`vo=!~!rKdf<e&PJjt?H4
z9PQ6jU*T;-9NS)d({YXtbi8%++p0Vs^~Q<JM3lGaMXvB8=~S~{^Evu@EFN`U_v8<~
zgtBNVR%F$HO3xc3r?uGgEQ&iMsLl>DbY)r{pV0p2J&ve&x_>D>06#BNVYQAJe;N?;
zxd2u9Rl}Qgmnbo1*!V?WUoUQ0os$wlRMEk{P>x88Z>4g3LSNh>H$mx5@kiMTb&b^W
z?zrIBC3FbhO<U__-Gn1-_ah+3ZE|En{8f><KYD=e5aummj2|0P2iR^<#?%EB4gXeX
zhe{7#C&y`wp@IK(Xuas1`Yl`(J0GQF4y_<XS5W*;_#F5>c_hg~`yZgw3E!eDeU@l~
zoEZ99G$CQ}eJ2UA)>ZzQ^Q78EtGAj3`g2cy!M5i6`@I6^1@eE#aIouin(7T_xe=K!
zT3z7SmwJ1dJfB+<8Ow<Qnq%tG4&IhC<P*Gc@0<Gb^XNq0fe8hd1Z2dfalf+0rn+`J
zx81I8t`$(*SYKb)HrkrgVmH^VY-((-v#W!49f>XVc0I%<@ASsz>bBJilPtS+)%;>b
zd8vUPGH`@}Co6UOQ3HQv;EM*98JOEtTfjd{V4;P8x$UFnW<u_SsbJ;)OhH{_T{iS*
zjpp9AY{8DUyk0NY{Pm8uii>TpWnXUD#l?cRF2DS87)^tdHMhBGwcXgvrQD9TL>m)o
ztk&wby5^wO9z;piZK$Fn*xC`aR<<<;>+Je!v{Gx$Xjv{~Mk7jbOIO<hCs?^fR_^uI
z#E$m1iA^mv)lC!IITBx|uj{PF<`o=-ueEDhnuB$#f_76~^Ri%rJwCU6yyf*-!Il<#
zd3CeawcS*`w64i+X$>~EG`Cx~FI+gSx~a9HdfK9##fvQOJS$MwY*)6dtZTDwZj^)f
zwf4MVbyE`zEMN5sO7T~(u4}huH{MalWnEjauF0yX?r5@0mo4MYx^hCHx3;k@xZ0XI
zXTGwAj$mU`yV68d(v^+1j(`YV-_%$WY;0a;YqTSq*IVD#vfQg|W`2A1vN}<zy>M<t
zW%=AWizZB%V3(B#O6QHXY&&<tW$gmcxTB1QmbS(_TbhR|!z=3a*0;1RuMS2jgVjsh
z8}F>s`id9FNr(v)Y|-N6-sa6+?#;#E{nK)1Ps^P*A$N|Qd#9CKZRakvbL;HfN;~&9
z%nVbz&RX8s-Y(T^X{~FMUQ%5jtZUQ7(OhlS(FEOM-iErSR@<JdY{U*WG`8D<nP4qd
zUB+74)>v0>nZ~y2R@F3h)Ydsr>5Q9J3i3(?ENZ)wX7plW!p1U+QL1RS8tZFe*0`*>
zrLE3OJA2z(t7|YRjab@L-F$~bsZll6?a^ekSkpkwhEgaFUTmj%S(Fk<yh^Bc%nr>r
zG%jrndK)_6zPzqY=$adYjnz#evZYMaYO1RbdTUymI+i!1!RE&0)lC*2#k;JnrK8np
zLqWv1X>*I$h%RR1ZLVHk=T#C@KVi_)R6CS`AmSOcRxd-#!8)t0rrm0*tLbQKZ(PA$
zU298Q(A!u`H*TZ@Dl=%e+NFQ%8hEQ|<aYXaL(58Ujkms|8JniA>fX6iMOp2z@h)BM
z6==1$*3}_GHA--p2CLhoJ7`mD54JV7da;s5#9ZdBX|vipT3g%d+S|Rlb?TP4(%GWO
znwI6uTbfOa7z?%#Mm0x5<zwi06?8N=(t+!g_|#NXtok7M`bMm1MIAb!W~#SZl{j(i
z7S|}&HQvVD?By7f-Po-A8Ke{N<TcgJ%`HKEl=gDtz2og*i(QR}kfK`JRx59B;joNz
zvV~l#h2raK@eOzkhqw_BWPZ3!>I>o0xJ2bC^nk>Ei~5ye58^-QO?1+Bdu4+lq+)Sc
zh=neGKoXZ6ZFbV*9RzH&Z?JK|9ma#0^5W^VySLket0~R#CWg)!99l}KFbLiETd*qh
z67z;?sP%e{GqRVqpc%}lMmLY)>ut1Y6Vn-_3)ptK>cO_U(Zh6Ia}AYcyi$5lE~Pox
zF3m-GNjuU|E-M=tEp(HLgHv3j&%wg$P1P4|dj>-fI&IUUyayAJqcpA_L)=JA6lL3l
z9y9?q1(6-~HL5PEK1<{H#Ji|rY*0tAfv9D9OGk51q83brVOr&(UMu7HL>*?7377=>
z>2dUN{xq6H_e?R!78*%9A{L6#2`5FbtKcoSZ;n^RP~Ur<q&e+t)G>r1%v27T7=GSi
zp2cRU$JyA9v!Qv~+8P;n?Y6pLM_aRvNj5eUxCjStwbV<+8+K(|9WkB=EEa(H?Y1PS
zg1j}*&9LXppDpyt#8w3tUdR2S=olx7d5lAZ5kdRPe4_+3U(?cx#{sCoX2NK12TbNW
z%#1^NzswAIjGG9g!=XUQ^wNNB&!++OWn*)Du&z29v)W?R6GoGPf!XU#@bTykr!UQ3
z(_qiA9cORXRdcVKSKLlxv*J)@+Hv^6pc+xJ68l?Dzen*kj5tamy8Wb^sV4M(TqIGk
zKva({5`EI0$lhj}Licl8!ixj&5(GqvtD9}^+G}WWX({QiGDODG@ka`wVpz-DEcqD~
zV+76i%`@hS!^g5zq$dsTU9B_}H^fCVNXJ^)g8pSpZ&%8=)oDvLn21$Gso|+qFvK_}
zU0IlKx3)E+lXy1XxL_g5KxsoXDT#($y0ac3wUH?yyh#U7+x9VqVGJ_fdq_6w>9gmQ
z%+@_pVyNr%or&61P*bZNA}&eV+8%$23bs_X@k(FfX}#W=mA6%t4v9*xn^`uy602%l
z-bi3jU@z?mI%-zLx)<6i62fuF$S65P{qTz$%dZQhWF);+b!OAs6c-^^T!c?R$@TuY
zDcbksXWNFR-5yWSHNL<ePh<fgUKk$@M8;3BZBxZ|lR?r=^fDgVNS8V-uU<_<HV3O4
zo2St)iT#UgQxlmrsHwpuopAlIge!Eybxwk5S{h1b6qD5WDp!VXp?A^3Tg!cw{zVHX
zEUdV>bjG4ZpQvqFwcxHmX=P>U&9*kkdK{{Z?=ljrC`hNOqNuzgHJ-hl^rohkl>*yj
znyj0$zy{}xijsn!bc(K`RI|*+sM_!h(k^y$$MU62wk1J+xUi<`6lrs8LoHoEk22TU
z0dLvmT1%20V=nW?Zt04F%O{CV$&Z`ldZ$q3p9vfs)>^%|lEj1p24<PAh!>L?X>_DP
z2O^Wsm{Q-kAl3JWsXAuJrjjCWDg6R%Dsw@ZDa6mkbab&b<7bSw)zB}qHChs@Ypbr2
zx!MeeqH6BkxrQi~s=7`~4bx;QTw7;DL;s=rUavEqu<Z)w2a36IC&32hG0T{xx3;NB
zI7-=Q#?7Ge*RhEl6;d}6-@pl{A~Q7=y=j)Z<9cx%#BQ<alx@$hX0EPsDWmCVwOLqT
z3en1{jA{u<G~J$lFO<xOwKJ|Hm}(EUv}(((BlcgdTy}K0o|5Q~wYk72>Q&?BDL6GV
zd(q-c@25O_X&v@nXREo4<8YOcI$~MgHmO&1MrPYLJCifUJRO1(GhtIhX9D!Fj^<jp
zc<BI)ab_}OJ2A`Bb{SuzVT%$#mFe}Sm<J8ZD!p+y11|%m$eV25D8dU~#%et#n*69h
z2CR08HXJ>!vMWkdo0^&ab?UZMPy0>5!3G&EWi~FvTK)yfnTZf4qnbcmCw@&#Nv#?T
z&n_Bltqx-J66+}zS`zQPC_k35ViQ!ukVPV?j|@esgoL0zZf<5O7B`<!EGEgcK+g@e
z6UM@2j53QR?F<YW&qNY)iJv*@`a1I=#qEk1w|FMfZG_7ehT9c{xJkLm_%~#sME8ap
z>*`vS`D+J?Cza+h!v{U8zHyZrJlZ?zxzutIae2LF0YhwOwXIgwkfgp*7K7||qOK;K
z46nFQ;fW64jhc{S*b0Gdm$bKcEGMv$RRhQN;H6gi+G|wvNo*&KO#rGVb=Z`5g~(&(
z@X=VwxtB@1E?LwxPfbL|YrQMIjaS39ul(joHh->&-YTuKB&QKVD(iEQ$dIjm<@FRB
zUC<LYu^BAE@iJCfnhQjoGWFqKa|^+*Oi|Q21Vf89#(8o4s<o++o7IE@$O+h^ORUaB
zrF2yz%Lu{hV27If7ut>WI!@6Z&FO9h_9RJhrp3Vm`wF=a;-r^0MLQ!kY4aAV`pmle
zf1oJhKU)vCP1bt<KL!88@*8<xxKhhy8Tgwk^!+{qopPQu_nQ*%PI_|!esRKmMZ&$4
z?+Syz#6U+LC;gR4TApeDhwS(BS80Cj2F^C{dIQff@R-q$BZt#}vQqS)*G)c${^^AK
zubBG+lm8<IUTfe!Q_s&Bc&bp#`FjJOHgJQ1PC4%vI`Us`@=u<q`9C*7!^aJD=pHfm
z3k?hyc!_~0OnZb3{C5L?VBksv&o$+gn{pH3SB#!hK@%b^R*{C4`j?w~U2Y9C)n?|j
zvZ0cjTXc!UiS_ox%j}C}t@N^qqZLJz;QAOrT=EbGO{}bt-z4V_%Mp|3-_M_}Zse^%
z^2@te!v+I48+hEnDVON<E(5n3c+x<Bj!wVVK!@*Eb3f`*oj%3D1qQA%aFc=ej@NVt
z47Bs~eS?8J47Bn!e${0f=3TC#Q|@MSA2QG`(CJGI+-#sjf70Af@oKsT12-FZ+`zmE
zI(?Oa`wSd6acKDs=6<Vz#}m?v3pM?3K9Z2n;CC1}YLZSbG*C4bf8I6uoO=g$nG5#?
zI-i4g;K$9yHMUNd^9Aw02h7bVliwYm$n^|!KQ#q^XWw~@Nl)az%H$uHB7K2L&rQKU
zXwoO8NUt~P$Fh^x?^7ndC`JBzOnONQ`MOQ|+!W~?(Nw?rDfq86>GdhnwbYiiIz@V;
z$$!y>4y8dDpiirDIyr@W<%aIdDflln>5rvIFE#1AQ>6Er^jA`(SDN(Sn)F2b2$=M6
ziu`L#`t`>C6Z3!Cr2i#F{#uj%aby4HHVWpLtJ5juljAP(%QE^;EdTR5*}5P_`^c$9
z`CXGDy-z1w*QemW!KBYkk^VW8zBmQ{CX?QfBE8w9H>F5#GwCZ*q&pji{VCEvWAblG
zk=|<3x0>`s{g#>Z=Tqc&_BRitNcWrkucqKX&!ituk$<g8cc-wQbte5oDbo8*x;KUY
zz0ag)q_E#=lYUnU`~R#-zbXa)FPQW|iuCm+eQ65$D@^*GCf#lB9WdWq+>;{z3X}es
z6y@LQF#0=C){V?^b^J;^^Z3N02AYvxlaloW=S;(U7ZA^X$WaJgzz|e?2}u(iL6an=
zlA>_Z6<1Ea>gsEzOs!rzy=KO=THmy~()zM#4gSXRX-$D?&2w5SKHk<oZ(6XjWB#-i
zD{q~)YTANnt1USZ6<fV?)`K|U)Y8&wRgbnNOc*_3bo;~!6DM+Nit|}E|3+KY(W?ck
zi<L;L4BYoV;d(>2)xcr{s|@Tk@W}gw8w}kx1APWscWe2UbPa{ADe#GO|5f)DM!rG=
z#~66s4NBcf{<vIe{5K*k?M&d=9@hvLSDv)-BgRinyTmo(%=`;Soaa5`)^jqZe&CvO
z+ONIo{7+46x#*e^XPtk|BG=UODmH5U6dE|rz~6pZ;~jX&;I|t5|1EHnkt-E+<V=<R
z-yQ$|dj0-h`~3g4{*8EIIY>L&s)=67YAI8C^}p5H*ji_?i*tun+tGT3<!!L)YgxSK
zoLF^Zu(eUn+MdZj+ZtU(4s`}MS6G3Q{~Sld_6=u)8s%(oYg@~*w(8~Tq@>!3S9>{z
zFcn=*O9z98?Ax<Rz+upqJ2<k&FBQE$eQW2{#jO+P*5>~mdcNRurHoPXr?#%Cj`KlO
zh4R`t1FMHFtG2pEo!I5r=ET-EYnp926{>4%YvCMUu)5|ByM?9qdiH&t`j@c35D2gY
zzHG(9!bSE<&eF89b;xqQvtuX+H&(I7+`gJKD$CiyXlj};+L}0_sc~uhM5`(2wU#gK
z;KWkfga+#}f!^ym#yFuh*k)gMojty)a6ANTak4I+cd1U7_3^rVD@MGsMrhS}>Ac+b
zd~1GXnRkj3(ePfpoU=NOi<>#-12<Ee5a^ruWZGPKs7BA5k#F6~spla3UTi|<atdVV
zz1lt*jxK<-AeJ`T?4K>|SSDMc`m8lKoII|tSLcn3mo;}xXlYx9b=eIq?3J*;$^qh{
z-1h7BiNMi;Mvm67EH$$tu;R+gr`d8`nQPnG3b|7DD4Nhqn_bip47N_2IMMK&$a!VS
z+CFhvYtw{=;PR&HCycI?bGrOr-&V&4UQ2zDL$?&Tx}`&HXDBp#K04x3HEFA><-llL
zBd0sC)S$4C%@26YnQPx#a`Vk4b1H9RON0|`Y%-x}*{S3R@p4gLt*Ec5dgX-Cx;jI(
zsMUqaM(ab6iCT`O4^gYM-;mZBN;ib|@6ZjQeII;<o`3I4UPG(s|98uAc!+*DKgp3+
zbR<91)GJr6oZvLK)0z{b)-}<xX4W-xn!8CI&9*z#`EIcwhZa*y!fBZt&1!0$hz;)B
zU#!YIVBn}9>3hF{>kT|&VBwE-`g#Mm{!rf+n*53xe`d6_u5N2w)_@nnGuPT>VvqBT
zJ=$fm8(u93lMC$f=9&rC@;VOduEx3=sylEewN}*)mn~f6Fasv(?`?I<I@o$NyY;f5
zY&j@(6AkXIr97>0hdL3%*>1H_X~m9Bs3WTmy1uc##cE%@d}#}vOU|d<VYQRDj)x@b
z8hHpoF|L?9uY7@Z2~U&IZR(g%IKSMcj?v(kc1Vsy{POBmCdE7qfV&WS{fp+J5$kFd
zOH%Pz6RxPw&CPen;xr<cT{rw_f8d6<Pj6FEGN0<aj&JvYTW6wXp0KmJ7DFii_}x}~
zv9-i%5<kf)^mdHE{Pk8ht*l<%Zq;}>(X^Cf{A}Mcj@GEhJe)O4&BOftQ?a_Z_pcgm
zJ)z-o11nDI`$7Y|Qow<~Xu2Km{I9`6L%+)8-)i6{1J@haWnhJY|EuNvqv>CITh}`g
zem?=f>CZ#ymYDh{=5y{H`u{5E$dL*jH}>P`_rFTce^j|ny^BpdIpsL`RQC@4zdPKT
zV8712W7ifxS-X_=u{8dr^KS(IM)L0r{_UJSoxhf~+rS?fIDVeSzhdrxZD6L^&v@P3
ztIYgiM35~<9)4@)Oq}<6i4-NK%*$KR!c%0I<rn5#d3oivtMctUIiQ<w7m=p!y;tPN
z($rX%n0QfMp5_`Pyl<WmT-{oiZ(nLp$(Ld!IHp*KIcFpjv#TfGEDoa8wOQ)OrB&So
znN`EM(nOTb@nVK99(}Tyf3!AOtt{yUtyQ&+%Nm0g!MoIB@y(?(7njbfD49`;lP5l&
zB4xKPCK~4nJqgetx<cWoe8=*|l4@Uno!u-KR;xO#MT9@0ZTaH%79l1G=lQvPA1+ZU
zbl|{wL+@J?(j7VnZZ_!-JY@1a(7`+OiSUPpepIh6*MSfB==(ea$K0duyB^Z8=;8l2
z;HJM*AM2lWJ#7Pv4XiLQQ4g&t@QHN)==-k!OXT=R)pJvd`fW{t|3}I3U&Yrl{V&hJ
z3IiLzqV4r&1Fto3t$}vJy@O8$Pi)fs{-ZFF|IZ9x2miRae=q^>q_0SUchdi};KIKn
zNAcfDf4_2Gkih4ZY2Wvo{~ty7o4+H+p1+g6*`)Uy*k<50-_Uke_-zfHdk2o&qVb<G
z(7`+Ku)&879|vFeHJxwF=Hz@Gx<u&YbKqIuOrHN1!@tMCL_Y8LzV$nrzXP|Mdk6l~
z-0%68rhC}Hk_33v++X#Arpq(%+1>iSA>sZhga7@2PIvM-^r_%9!>6roF;DHSR^blO
z&*JvF>b9DO#qGh4rB-W8>tb1N<&LFKmICT(?pUk>As$0ucHDf&;^zA5#S+>@*MoT{
zLVMlfr96ni)P6C~bvglN3dox`hWt{HS))wC2MjDQ(AkG~=HAY^pwF80uNe5afdd8}
zGVu2XzH6ZE(ic7h7aM4jhk<z=H9XbPF7MA!nz72w+Z_lS^{UG%_4Kzqf$b#mC>#rw
z@(6KsbtRS-eTb!oXM@_+lZ-sHtsf`1m!j5o@C{LV!PuN+XDO10gRS|^N(#c+g|Z&H
z@b)-No?xo-;xJX8i1IOy{>X{;s!vqi6~*%g1kS8;qR^V1xb);yhx*m9Hp(+XN$OnD
zR)<6#ER>peiX@@Ad6=qLMQyQ{HZF^kHD5`eZ{;qZm|HtBmmO;JQU^=D)ItB{)efeG
zu6eCQT^)J(f1oHLl^*v0_P>XI9{t~xbChX+2lgJ;^?m6#L+f4tD}BHI*BS;5d@_M9
zQI8Lq^b21d%I}?oe1A6SpE30ane=vpcgh`a<lA~s^LyyuHT?deq5Ko&NOkYjyW<s|
z-{Jcm!|$F1zK$FYy~B66k@LF-e%Zi<rarEO_L-Q_|DH7UnfgmD$FEI2PaC<Mauyi9
zJ8~8qJxwv~823^gHqfk+c{9q(tr`B3o9C5QmITU6=J61Vm3vhoi|PEq@IP!>eDFEK
z%OB<6-O4G%{YkQ39+#SQJ^k;dyUtI$cFLKSb*am;ns%Iy^l-i9nbVQi&a$j0fg8`W
zte*l8o^M%i0@K;5yJ+9($OaC@UJLB;SymM=JIk_u^~&i;CHeOsIvv>p47_?ea!T%j
z*{pU4{&+gVYiq2cKfxEc5x5hW`RCJ-!@w=TQ^2OTPe%g0?!DkIrz6`0o}}DN(s>PR
zB{2K+=}1uE;OWS2;3?o(<gJRFjuZe7^P09!pu8V)8*n4=6z~|Z2|25H(cC&<6YvpW
zfLD*c4cy5qQgb}W%R6SPfTwtM?FL{bFFD@=%m(fT761=RI&kb5^7A%(AFzqHW^Mr<
z=B@jufCYR&WGq3zF`y6F$tNFbfkk|NVgqm;a5u1u_vOAVcs>ME@Imf@KH#az&;i%+
ziR{C`jlj1h{hGnZ<g<}?+F+yySX49^IVShl4MvK_BL5BK17;Ufe_#>tAaF|w^*aYT
zU=gr$I(h(Z0d4^v1MUW9&Y(PCcIjXw^IYmt20idtIr;*g0`3H6&Vnzn3OM#d&<D^v
zFmv``WWU@4Ujr5aPXX5f$BqM5pa<YF;3L57o1h0a0Z##U0<*EZ{lLk<s+$KRmB7q-
z@CR-IZUc5!4Mx)GGpB$>z+;P%3z)qGxqwZ;bnJE~a56BnnsR~bfE$7PfyaOa%gCP%
z{T<MMgmhpw@Dy;e+&59a+yjHaqUGofSOwf7>A?NKoxo#)Z-)K?>;TvV47AWrz)s*J
zz;(c#z%9Uo!2Q5uz{9}w3z4&pS6TwI+u;jb2TZqVe_%E+Ge|mc3veB<a|Lz*Y+8lg
zTm=43<N|K|1nmht415h(&`En<OnJZ@;9+19@EEWXnE6TM0&WBz1ZH=UehK-2mB1ok
z6EFbm0d53t1fBwJ17_cY9KdzJ$vN-`RsyTKu}9#3;1*y}5A6)>1dh#x53m4Ov<5oh
zVc>4ymQTYExUP@>cq#eUqCeo4e)I**=55|Z<H3IkJpfMucLFoNjQqfC;4xqoFg=g*
zfZ4#Ez#?GLM(P19cnEsA2Ob0N2WID^7vN;zDPRDY{m<ABun5=*JPh0j?0lGVf$M+=
zfg6FxfJK`q_cHVa%my|ACj&cy0bu4=-~-GCZU7bmw*aevyMa4_hk?hwiXMQOU!(ml
zhwkg>0k{RY6PWoZ<pG<3*#+Ex1OC8HU?(u}P3#DG3YhNY{#(caEc!O}2X5h&i2DWp
z3;8F&=U-`OVA12WD{u?&HQ>5!w9`cHpFj`5oxFB@C-5-vFffz%sJ{&?0A?0K59Gyo
z)_!0BSo9R_1Uv=Y53Kqgb|C4yNS{Q$=im!m2kZpy1a1HZo<}co58Mqb+D&<ae*yki
zkbf`qz@~kq1B<?oK7hx7ldlB+ka_|;_aiT`=|{*3EIL4co(z1Eb^~sFiGFbv=?9Sm
zc<N>94=g%_-maz`U=gtC=kNjU{3Z0)fd4gofSpI62cCKryPpF7HR=m2cmsKX$ADv}
zQoj)W6u9#^=>q?RJix$7@Y8_rQeWVHcO-HOxMg%CQgAKh^1X@;0>?%ouK^3rjYK9F
zA>VnC$VTA)iIK=L;FfD5k)rFsUmuCA17_b4i5!;udGNWO{FU$lZkZ1sU}p_{Za_X@
zCGZrm2^iojDjR`Cjqn8)d<?$D+~2`xS%5o%yMdWa@R569W(oEH%mJPP76FTv!xz{I
zYy$2F_5ib+Bav;uCZL311#6IFI(7jJ06T$Az>UClz+=EifSI4BTwnq4HDDDma|ZOl
z0^ok24|r^CB(g=|=i%q0oDI|mxbB}Lk%PeO?;>X@_^pvh5E%GZ_yV&ZhhG`x0t<iz
z+u#Sx+#ZQ^0y}}bfefkY=eqM|%e88Z>-@|!My+?9F-GtVC)PbbJ{_UkMt{laEeltu
z=#PB&bfj=3H(6uKvc}EwWUL(3W!>=MYcIP}yfyOi53#LrKRF%w#F<=7&l>Yt_w=lB
z_oYqGvis9Zv+~xB@MRUQ8CjAwrTdJTS?k?tFSti%O)1GLEXm4)23qn=&l)u=gX|*X
z2LAbp*H!>6UzWXkbk?XD8MpCwW`>lvjena-zcY)Agz~0KdGI#n&B{9BO8c^l@{l2+
zyb>u77i6WoEbGwgrz3B0ZIxt=>2}Y`vfZ7dv&NKXjjG6~=E9#fs#M68e3PMn@Qu@v
zg@Qo7HYA&s@zJbNCcRSlk-pTVe}eRqjOu85ko3IJ>Btu)y-Lb+cPJ8WrG6Vo-%R=r
zNvD4OqR(|{C0X{Gbn4JOVrJHorK7X*K$JMjyD`K4@u3*WY+1GZdkuc$!lxro3nHek
zQfVK5R9`-6AAeS{yCrGslxN(ST8molfZMWKDd(@ixN?*oB(w`PNb5{)2C7+<9yY?q
zK1N)fKAfMjt5`exvRc!ge=mMwSI6L2!B-q=xTf9E`*PGiH{*6%M)aPUW?7p^|D&WU
zy_bsKX<?&xUsi?tO9_hiXWWv2@rj`bzbg1uFu!=&@Vigiv0wVdI%&r>(l5G4){s3A
z*9|H%+|5~ev*R$5UHa)3_#J`YM+Kqe*X8U6pU1p~*U-l6UA3>$yXt?ceP?DJ7?IX2
z{b6|jD-*dV^KUHrUckI&3D?pe*0?dV?zEX%HdZ$dM2XmQt#c_<sviZ&*Cq2IL7=~N
zl5dUZuRDFA&Pg}d?JM=^gnnS_>Bw0^4_g7M|AT)JJ|%*np3?JmE?wVkq)&P3bmSfn
z=`njQAL?&ReYd*OGDlF~8Oi&<l$SojvQ|-EwUmeAKbAGBI?MK{{wi|jkiL&}>EF&z
z+P4V&0Qg@4wH*Ga-y3G{U2gYJld4^ri_+gZ_*A$DBhB>JIKBI_ig7_k?=zJb((SYp
z`t@mpk*xQmcRv@+j1r}N-zHx}`e5YZ#C%KQ%W=Qult~t4e+7&KOGfaSB|(^<=*I_s
zK@xlw_=*I)lph4|2ftr<%*-0oNc;LTD)}48n9JYtA=fpk9SR`bLcSy9yHWg$vdbA~
zjV$|Y+I{K$BLeG2`n%6ayTvt{0S}edLUI^-i+5YwQGY~#Hsex4`}puj3zK(?l8n1)
zx0%DtM-5l1pZm_>(}8CWMwUm*DVK7R^*>)$m&={pk!pUT&kgW9lrb2Y&NcR5d>0x}
z^#?yDb1?FZ;HiJNn~qJBNq;QQa5w3z8PRd-F!Y<C@6~+9xZ9O-m0=6NQ^M~o;zmhV
z{naP^m0_hj-Tg1B_35vYsQY&T*PEcfQ4mW1GmT$pjW;n#Rq|FrKLGu%p>~EJalaYO
zAm0e&Cw8$8`X!#h$cutd{2jmJz9ULMD}&)yI>QVVF^Il)lW)|R!N@t1&-?<w!{En&
zf8c}MC_j<V{>m@T&~XX<^P@@or}jKPSQHT7EV+0v(kJza`8TC6nhED<BQT<&wdomY
zAHtqu2pvACeiVey=1Ye5qas+Y1HTFU<6H}WGw!SL$0y@H^1466Z~=ybpoqFtWrzF8
zZ|4j~<g1mszKl2Vb{IciVu#<OzOYOPi?oN4{*%pkQaFAv@<~(Q&$^ZVVs@?gDL*SC
z<H4lrBQTjwLiw<Av_hnvdML-AHyG)PmXjd2Y9|#xQcl`Msro6btV;eJgx{+C!N^F{
zABT;*$lW~>R<xMZo(7~qt<G5)?t$T0e};?`1(<5#<%5x#QV`AD?QVCvhZ?tJeQ*is
zABm>Vi>6CGn@oD0spqivotd@C<$jz7CjN{zFbZ6h5Mf}FV)r}Y*HthWkzwEYNjV3>
zuLA$9AgNY-JU-0tVF!;Uiv|ossdr8$-?)Jv(_+&v@e|!LuIq8ZNBT+9nZ6pmXnYlT
z+l&7dy!jOXWt}t+yhqySrf7UY7ji!#efxPl+8zn{Nf!D?pdU4HFya!u-LCzf?OrMF
z?)j`yWf=`wqn;;%>K1llw+EpQLH~HPAH?i-c--jThItN;4$3ohfLfN^a7F(`1TMu_
zG7sn4`3b%f{FDT|^zSC{h2UokG3|1nn|PsL#))<5^zSt?Z|NSX!}zE{3N1gW*A`RW
zQ_+4BtJko0t-xrK^zNH8YLj+T`IM>r0{k1xyz0TpgORWxl$?Q~ajTNk{Yh<=TGH8B
zqvm9k#AEPH_;%4pE&Qfj#rlizGe5z1f-eMrp@RepeuJS`{mi6^TwB1mLVv>a>-V(l
z^{%uR#Ze4zS><@7Jx;;To-!C&B4wz0QWw)6vH09QQ+Wtf4M}u7%ppq=flx8|^CZ6-
zubh5yTh=(@R)%F|zqQc$q4NnHOx7`OJL7DJGhj#>Kk09>zTW_Sg&>rlaWmM-jn>aL
z(jO#U)ZqLi-+u7x!QUfDCC`j#KNWe8k#0>LjC{wWce?{w2VCxd){+WRmoNJV_d@pt
zL8y6#yP3#A4TRD@lSx14>!%|hmUPMyAng<2>NxqnFS1h4VeJ!$&dZsHxYEkflD3a3
zXEH1{!moAuU}P27T5rTvYtqUjK3SrJ0NTTs(HW=1PDl@uZwL88Q9B_{iI4l#c%sIw
zxr|%4C+!fvjI?FR2b!4~^T{!M;8gP`(NE<E@NcDqkxN8w^d~C=1za|PF9u&G_#yVP
zfZ7lUV=!|~KNR|n&@X|0j?l;K2EW^#&dgOzjQZ<%Pw4kU-}OHEi+)c*zX|%bD1QbW
zC;qF7D!3#g8rA4HZ8Gsxh<q#qntISKYJNCJOI0de9~(D)K*&TdP2@ZA)!}y21O5>F
zDw&tW*-b*6Va9((NP@v6>eq40Zde=?`Pl!tK79zk*g8b4{aKH4x&M&V07^34_a;p!
z%fR@OOb9A6(3!zAfJZ%eK+#tW8%O3USF9%%H^$M=6B7`9Z9JRypEGp)6#O>u4dCmz
z#=e%gmt>7n{U7`Qcopx@WaY~(GY9>XblHz9oI4o#n4q*@sdWg1Zzg}bNS`F>w4DIS
zmjiw?c;%;6KHAyL$R*up(#J~%m3|ZHsynFswWRMLf3oyivh<L?kMxHnf6Q;F_E+O|
zsrZc>b(~&|<qv87Qq>E}WPNaof0&ZB6k4ChD95T8jC4pj<|n9hCJqhY8yzH2>Xi+C
z0Q}{GSM_3sz&hY8lqUIPzw!X-Vz$mt@Ri{Afk)j+k8=!tlc7(<_kcf?z{f|{jfOto
z__6pnHWn|GWwlByR0t+MkTvs-PWZeApB*=w_zC^SuP3T`#muZ?T6D;IVjyEh6r(j<
zlHrSDV1nl<%aAFP$>vw6S#*0dJ<+))Q-1BajDPdkzu{W@y&H|ckg41Z<@aW0RA!AU
zi;YC0$BpFcB42!bD}HVp_*LMS3cr|N)brK~H5lN5B#}1a-)qqCfc~EZ0sVdM+0k)c
z>2a3CUG8PNF1p{sK#fCUpE)05{j_p0vM(BUK@&fosCkexKXHExLj;pBtwLG*Nf;iE
zsAAOkxsGzW<_|{Rip~!RI?Vdx3}^oLHKdH6|1n|di#CF8mvS74$bA@o_N~O_(Qz;)
zcS0OIQ`RLOLcZbQZb?R3TH-)R+p>xvCMNCV8%O-Vfc-eGouBldD)0wx8;r2cWBLzK
zdb4ih98jI4A18g5q~mXhSXtp`IhENnEAN6;{AE9W+((UnP*{!M34RlJ<*4HD2f;rG
z{tSZ?Ao@54em(f}jDGKv`D}dr&A5Oa7{ia+fiHu3qUl>miDk^nzzGfMZF&)pGF1OR
z4|`uY82PjmY<^OH6Ziq}cMY|pn4cSJN37c=X%41?>?fqOBPstN<s7OS?w5{%Kad13
z=N0xP!DoXX0AKD@0x0|^gFgv=K^$KCSpa<TBK8xb_KOb9zJ>BL7?*o1nqvhhI=z)i
zGe60{j{NrRgOOH2#QL?0ciaITk0`Ul5y>)((?^9|>}@~!E66`x5VX|Cv80lWGWA#Z
zA0xes^t&Wo@mKNA5dOHeSs6D+%hH__a;bO0`RIfE(w5FIz=aR|xW%m73KG6%og@}-
z#J6j4ise63l9aOnepBE#S@@Zs;J1KZ0^W9zK#^rP_y+JBqjoh*{1Y)q{QjF+rzuWL
zPwdUwYuqTSu1V}lFVKnKEkMbemJCK7l=2hx*B=*z3oZYupdVAs`d>2oAUdXv(6<_?
zq#o;_-wOS&O+C#1f%5A!+2AQaaGNO&O|Rl!%s_4#K)ChE@MN<`sc(tiZXHT3LeN(H
zdz*6dY6c@W7{3_5Pk{@lCSNq-^=G(|H2z+(QGAM6=&|btBR`GGOYtUtCan8de7@-!
zcX3Nhtc8#I3$dRb`0S|XyNA*hV)m2FFR1;@ZkabF8)3*U{0_qJ(8t-YkJ^J;CrD<G
z;`jADXZU<ZHN3QA&IQ<GyIKE9X!km&M$pMm>{QMf3B61=ouA<4+)-f?yqrVI1D|N`
z8^KqASMiczMAKQ@z%KxQh2XHE2GzqgfwZrjUs^@F)6YN4ey+0)I&9oq;+~gGnWD#R
z0^Y6gIVP-CyQq0&tX<SR!t84^em<9sk>us4>JPt);P7~+2fQEreL|@8J4ftD`=utO
z;D8g)2%l}xZ-$=fTl6P*IhVCHfxqBiGxUT((VyT?8G5Em(Vysdtc^Xw=YGMe8B)Jf
zyz;Y?NuSa&82MZ@y)T+Bd@D)cL3*a7o1fsDY~%x<Xcs-;H-mpbXk{h&b6KN=ek1ro
z&XFaK@7uuVfge_XL!THgzGmoqEPhJAYW+p&w~XmiOI-h!a>ri8`Um_I<u3r=1)i`f
z`V)FN-zN0&b}INP@aw_Pi&ASl2!cNZ{xVlALFm_kKfcneADg5Nz(>HJ1V1539H-X(
znD&_S4nCRB{xE6afJb~i!Efkj=0-JjN*0*<hZ?kw`m|soubk6czZ$<~WED`rKRLG-
z0>4NQ3Ho-=9qKTIz6bhocc!2()nhRpUQOkMejD_D=#{<TPuIwLnp%Hw*J^4OQq06p
z=wE|=2lPtLA@p@oax-1h>z^##oP_>4X&=?^V{vnAoz?6wS15H4_r_+Ub}}q#;kT-D
zF!B|yg<rqKohGj5{Dqw7D0Fu@6DbI&tjI0r7>|=rtrriGJGLF>1SkRM_d`GCF6IxW
z9JBrw^H(YkapC|sGl?Xlh+!yxG&_g>3cq@z2Q&YKpE<t(KiNmY^*uU#&qOm4xoY8a
z=#zsHOD4)G^{M>mtgHc7+VbQ9ief1Iw!!b-?!m~va-EuAw4Q7KUOm%uX>a)L7k*05
z&iqskh)6(zJ^3;!qQ+8|Aq!m^A7^I)_;mFcJENZQaRpni(YQs55&d>TKLGtN1rcjs
z{E}>$2|4BZGiFAwXJ&8|O3Eb)Hti(#CFfEX^b!|JJCTd?L^~J~XJ*XcZ>gNy;V%a;
z`0MAdKjYS{QI(LMB407*T1UINiOH+tErJ&#@5~I@k{TCKW;r*bTqn$u&HC7(4!wB|
z8yP<;FGZi99*i&y8+jHC86Scso#LZE@h9uRkGYrmgJ4-txRG4KPtMnl1Am*~b^W3n
zYm&a3^aZ4=ctE8uR@Ib6fFjagBYhR=HAC%~cqo3~C9T}0x*&a1cR?vl<<DW^YIEOU
z^gLGlyix5FsD9x7>d+~n%C6V{$)ER`L49sV={Yw3NN9q{G^nN*``!Tk0_c~I<Ocfq
zb#xWK42?U|KAgP2D3>O>d<}l9)(;<tPJtf)|507E`YZHf^Vo0u9Op<A@CD#)@M{zB
zKJX8MuSvl3tekZmd@v3#^$UVu@Og7?Mb%Hmr?K-p_`~RV!B+PRN&ByH*url&{KkEO
zb!=nD@&1+ek$v-GIbk<sfvYrw1Acik;%1^MCYOFWHXrl5pL4z<H;ofJ|73bG-Ew*c
z%SEP(&diYYdkER3G2K#~pR9t<Civ_!e7f06DwNf0>DPu(%IlHx9vF;#Q|Qo#@w4o6
ztdsM3W?zs+I<?M6jpEn&%s3-@*bkqr@OjtRdA!}k#w`=CE=kKyZZ@)dq}Tc7eE5<F
z2P55rP<k-qY+-Y>?mjslY4jjXG8xiJ^6ens>xud7`Y5eWxlouIRdhnTj(n~EG#Gi_
zwBxYxE8gxa((;na&&JI(Nl6yaEKY_NDXl90$vO6cFAqk~|CxC_?J#T}EsY`j#>2;b
zmPwNpBJI-z|0Np-BlDx}qwGFmd{*rvVd*bZ@E38FUy^h7tq(D78Gh@qFK7PgKBQGm
zD8Y(RvA)5}+?b)Vt2pNr`K^c9FO2G2$&)ZoER}Wl8#$Sfc7Jk(tDY$Jlk@$>JRdMA
zT0a#xCDc!i%d%*lynb=#fi}Xg@T-H7Pl?FNZ^qVZ*nAeNqef*JEJDjQRV~R7J32_d
zd&&235;<c1K*>Qn-kDU*r71S~=47a4(&5Hs`e7~QS9%#QzBU+{o2KO+wjLC-V--9x
zye2WEnHgz|+@uUIN?eENdne_r=lKd}{2o@0iuaT~$*k%#NsBQCA>(A`1m>rk2P2Ph
zt^E-8Fl>EPOmm%D-i~)eB2R$)1LXfi)ShB-bHcbaCyR5LQ>1#ydXVtq-$wZTX3goy
z<TJHA#vja*{upaV<IgzfJ?6}0?8wVc{L(S_ZQ?nT1JV8xTd$!>($2=d?dZynUZN2>
zawan0-7*-tDM`Iza?F%|BJ;1b?Dwdb$Pt8}|GTmCIp#cop6|1jV~p9C(e7O8dDRy3
z9Uz~Y_r&^xiq~X(i*^Faka0zxe<^-!FfwrzH?eU=#qVn0gGzUg6j#QUMPb6YV&Yn{
z=bS>~7oMj%741*6qWd4JT{+yfhIxQf|Bom46D1j};SSllLnhT}DMR!u&*2R07>s;&
zgqAn?_+|R-rnI!O^wjnvavz4D^~_-8w6q&%9T-^I9g07ItpYdthU}klmMD*7NA~pn
z1b{z6vL8#p+``$SJ^O$3<D0T7x<{@Vu`azo?LK$fRW5^8a{JgYeQ;nfa_1St<xa5s
zS?c)*Iggye?h9Zc&lm06I~aLI_^EN1bFLNooa?%goN{e*%PChCK}bF2`J+`oVLlXX
zpJefr(OU&Udy>L^sdl^P=mA68N1kgsa9}X<PPCrM#tYLQkGs<D8JV;wCAaXC=cBp~
z4Mql{a>vGtSidrIx5}=^aHTm5siKGd@H_tRgORkT-%ZBP$cO)VAbCIaWf0z^aJ#C#
z<@v1#4|5Jw7Syoe_q5Z2^t8~Zq@t@iljuR713Sd?R;s;Y{5Xkj;tr}EeV&EqXD&|F
zzu+bO4#KbDZ}g)i^M_%2t#EHoDxFcR@XNtzZMGu%Ty9LhSiG**pG-RyyYETLFD_1%
z=i8>ZB9U{)!aT+=7I(zPM@})g(~c&uui~ieAAY0Gi9~Xvb`-PASpReE$o)m+qXhgN
zC1N2+fESu6^MND=X5w_wL%~(pKjmC8v>X-R4AU!%BENeNhQhBCegix&x96-BdWf|<
z=cU|fA3ifR!)#dWhhK3{B(jWaSr>P+V!<rEOy-uN>SLs@C*33I=2rle=LqiwKi$-8
zojW!zx_=QJSJcEn<em)u=G;i+H_?6;(|1e{DsGhcCha%L+fPM$!mkH@{`^QJBr+w~
zL#+Kwzio9dO{xVmAN0ZEApAn`^O*YFCzI^>bA9Mlk9*%4KJJ<JmUt-p8s<}%MIx(>
zT=C~7%)GMD&8FFq{dkjK+M|m6$H^};i63WO21An@`V{{<Nw+VL=<|4-gO&MVg_~W=
zF+R?<>T_MvZjV5>89JM5+SOhN6T$Bk`M`g~;ANFX@CU)~0I$|Vu=M2ye+>K)@VE!z
zQ`l_q^8SQT1rhzcjim7tyT}G#?BHpa_&BB2*}YTLnmz#ilJ`k3?cND}7xYhlh#S@J
z33e3o1GBQaMyH)fZbz!+rQZADcYH>~Id^Bvb6wI7uYn)si$u>WcDq@=GZS!0PoJ7P
zUHImh^jTb6tli3fgybs%UkqOnU$^f~l&F8I{Z0BfLD3&$rJD9P>3Nc_#(C#?3eMB%
z<A8eo3pzjLoNeg331ggcM84f7eU7A?pXm26_%8CDlg^FOZ^Ajqc>i+5<^CKUYq(?7
z1})_jOyhfIJwwm$Z3HjR2T$=wB7ZdF&9HMyFqL)UtuFVo!#f=7i!7xihM(+KFu#sr
z(K>#tG$ZXDjG&O{H9GlVm5<<sqj!azk%?mIXli_&jC`*l--B~_o>u&U6Hoc>OXKNB
zo=xo@*`T8-_tVj+O8d*~Yc1=s?xFP+ev`rPn@hWoj^kGzi_hHUno-)9)8s-$($XGH
z<lA~%ByyiP-~>OX{HC&ZGfr(yOIx2jzE$I%@Y@N$;|-C>oanqHp?x`Tv1X)tzJ>mC
zQQE`Oe}+#dqx1L7BKYw<^()cwEoJ;9&r5Ad-W|2Qh|jBnUsqE^ud6Hnq2}*uzG8MT
zXr{7^*px>vtkXnlK!%03fB1~z`Rq<XR4}gH#yMGiJW=_(-J~~=zDCl`Pul4)_#@yC
zM%$h8WuIt?9HEiZ2P{5eeh2js#|_8V$T#*n#>19~K3^I0OR;qf74NV))_un8tm39*
zQG=4J3O-xmBhB+azyHy||7hSpu7UMM#fnL*feuIM;_`D~roOd`vy0W0gxK;6et5cq
z=c&K!H+^@hx;o$7JLBqy&HXr&o}G~Xm%&JjpdNG=3s75|0`0Sk1z0i^$}i+D7GTLx
zA-|C_7V|U9u$GDqxIaf>V}B&HR==%UKF5a?%32sd8IR>BQ*rsJ7z8-x>|(i%;wwI=
z@11%LNFqPOCR#r4_EPn+3_Y*=QumHNkDL2TKTxdl|7ZQlGx|>~Z-r^sH3mLl;G+g^
zH*k-EFB|x}f$tbN@*}!F=Nfpafma(?X5cLb)*HCOz%>RwVBn($ZZ~j`fiD~Qx`FQ)
zIPwBhzJZq-c(s9L2Hs*|y@4wXTw~w^20m)wb_4eq__Beo8~BcaBQG@N8+fUKR~uMn
z;4KE$8@R&2H3mLl;G+g^H*k-EFB|x}f$tbN(l+HAc&UL`8(3!GEe6&bxWd3S20mcm
zqXup_aF2m68~D0`?-)4pB2&JBml}Arfn^5XVqm?2D-2v?-~$FeYT$MQ_ZaxHfv+3*
zj)5aDHsu?5sexA;SZ3fY2G$$6!oW2KS_!|cPb^g!r~f+1OCHyF=RWE%UyjkwoH1jX
zoyX^W^6kkJrcAiXzM^o_RfShyaiyJiGjB%qR|hrTd*#*nYNF^?+_Z}sC@NNWcRHRe
zT9Upf0JznWLQP*hzgQ*gay+&si~f~B*KK{8sf?x{v$R;HIrN(@*7uHsuPD&>_jnZ9
zus^!|m5mO+Bh8xrcE@8U<k0kI-09F4cWC-wrzH@YTTTDRPdoJXYE572c-(|+n*LA!
z<j}X?qv=<in?Pu8HT`$~#i2j`pr%)wT}iTN`pWM)^y|N*=~up|Jdf{p=*K*w={J2K
z33E`IzyG*Hzx4@CKReO#O!jP`+xq57hu)y0K=ZrmuhH~>D^_V=h*Au_DB{*_jXmwq
zZ!+{#GBw?IE-qFV&Va75vA?>!i^sT(eI0pT(|<mN{F=U&Gw#|RyI#=r(_$=#Txt1w
z&T;4m483~T4a)zIyEl)Is>s^MZ{6;6ZZGNXB!&dCkOUF}**b(k2qZL{>=<?w)Bu8j
zs3-_1LJ(0A7r=cK9mEaSVcZ7C4QFsgM^seYaTx)}g~1Wr`99C7x=9;#-ap=d-rui3
zpWK{t>YP)js?M!jRj2N)XA9%P|KIJqw4*DZzeDrCz#z$Q{B-?Zi@k-~zP2pd{^QHt
z^aDHN!h#sWZ~ip@qZKZH?3K9iE&fez*B@?13|QyC#qgs7e)FgGAE<WucfJ}Iz8ij%
z+toj&#^s;?n&$81j;PwmY5hMny8Ij8*ZiNf;d4>VfBkruf87U~zuskN^I!8XndtKG
zH2kty)P|R+=C7IT^5^e~3)h1GdVlqv@A7Z_x8}bkUBrHM(f*cnnakgp)L(d}y{K6~
zEQ|{vK~;f%dC~S=yUsT4x9t@zfBt{%&&S{F@;82_`P2Vvdq;0~`RD&j^CvD|C0eBI
zsl3DG-)8t_Q7e(rz}o*`{;SL1mPOakhR5CXJzwekW$_Bk8Rq%%d-tQ3pZ0u<{2?u0
zVP+7O|AV|P&%`~hd^Bx<nE0ca7__xl^H2D!g+EjC`~GYFzKm~O>H9A~OY_SjNL%H=
z^YgF(Ds)F3n~Vw6LOj^oqjUMK2f3{rkB$D;POgG>+nf9{7;Pt+osq44Ns^ZIcRWfx
z-XtC?WIIVY(C+OCYdsgx67N=I;<>O7!S%R!E)p;TF3)OVco<qdYlM0ia`9Xu)OV4E
z=h71>ww(GeBZ#b7O0P}IRiq?2-Y1#YCgJo_>m33%QtMWNJ_ipUni~Sidj!ux?=EJM
zd?&JqCM~Iiyz?IPCY`e#WXt&$+LM;<CCD6~mNF-0LbuNu2xdR^dEcP6E15y^+$aJq
zzKWwjaW;Y57n=#P<=h0NzM2aOIwz1`zX5R6*@7zZHLy0aoc&Pfi_Zs~<6MoV@bzB`
zINy1O*$tcoxU-WA#lFGRS>o^`7rx<l0FF7>4`TU7zk+M6Q%kt<U0mZ%7-jTL2|)8u
z=W)`f5}wSevwX)Bp6#4Wd*;&QC02lC?F=wTZX3ny1|;M?5jG@WGyt>|oL*q1T{je>
z-g|&MLyq9;-3lenG%|#z!>+jVw2I+><dZ?5zaX#`IdcS%msEeKbRy}P_&PfUiADlx
zKweY)j$Bq`P&JU<>L8TmM<z0l_eDWTWDRn4K2*#x7X1k}IeV43i|SY#eVd#IHE!qD
zMuTWP=a5Oysf|8K{_hQ*T^l`@CjV^k4z<ytG)vi9U;El<1?9a4&#FaTu$Gf|z=qxa
zLw}*Rv3c-;!)zMMc@pCOA8EAXyoP4=|3o<IJc?@Y|4cZ`c^X&$5nZs+Xav6{r7Vez
zfi}MqBo<jm#1^DBatExy`Qwy{NA^=bNsytDaZK?E(il01DanFNj-)V4zxoP#nj(M8
z0TNW-0GS=xOT$tWEuJ5_n{26qER1|hBwf*+mPB$<Mt`Q_QtFBbR}}nNY8a4}kr~Xi
zz4`&#&X4Q@$)Br&sL0ikIt;u0#p-_0)<s@o5h~ToK(34IA`%m1W8@toRf24ed_<(X
zAX_5)iBwDDZjIaz@9@`%ZQCNR(6(MG75QwpQvb+`z9G38HfH&6W+9#8ksxg%XgLR{
z<`x#$aSBmT{~auC6wUVpXg;SWlm&R-(rj^aQrVnBEpVynR$39byn*baK}sJ2*gEPM
ze7RE{HG1$Q%T8y7c&xP9FvlC{eleLamdCXhbgA?W$j464LMwaHUnEcZLBL7r*`WK<
zvr(zZ>Hh-Vv663qY%H*wUz2mD;}UpVJ}l?7M{?kuo@8>)BK$7ls51>Sgur`*vz&Q^
z-zS{!oQcK>eDDc0l%Pno$X51rBxQKf55!d9(==r3aCdQFulCxjIsx8S&-=<@=M~sL
z4sg`reH-|k>>C{p-~tDD(`|MxW$k@Uc#FfY&jk);foH1|!!__D&DiD?;;P~2oEK4M
z4exY*ZsFPOJVp8u=DR0yKkMG3D7-JymrOpzlmn4HM1m?0|GsTEpEVN^#8T~EVj<E6
zb5y%asIHx;h^ltnMij`Fn;}cJ`xDK~Q>>PJl{xeDSyrGxumaU?KZ{c&awQ6NRtg(@
z4l{?N0M1$naJC(&P@`c(<WBf_ASSTYZVt_^QYRpx$+iOjf_}o{Qq*-45PxS}lBc2*
zi>aAU0CuKAp_)U`a#le^%@wk9Kj8&=phum%kh5AsILqN|Q!N+c9e%z~t)yLS-|a~E
z6G^V3rE0YgmEe3${!2)<oZCQ9mlAfIex$FZo~Sbvb*HW%oNBed7XR#diXNw$Akcx{
z1p>u7(7Rli9_YgKOao`1KJO&UK2;RtoHlc@WuGpv)t+C0v;Qvlu)39+i(r%?bXbkr
z15A2u-mOHQl}69IoA7f2vlTcH@Uw0^-i<uf{i*|o`}t?H1ozX#{AEHGklR@eb#*Jl
zgV3Pvmm1tn@Bz{AHtXYod?+iJb&{nXDkd}?(8B^PS!AiLrKFt==n+DNO)y_Q!D=tu
zMD<S!coC`F1ROx{DFH7f_%~Wr_yBqTF5nnaw+na~sZSFum|>}B1UUU9<o_%!%`E`*
zvM_Qws&<mtX+Q4bf+d!cTfg9JOUZp-uyEe#mij<6ESx>ZQhNkk60_8Ygse`Tu?9`K
zpCtiuM+oGIoFxsNBZ5l9l(Yr3I-Ls9yfHMPlTdPVXk!<{XsHqnL1$MDp|-ji&QmPa
zLt39UJlvvaxJjm>(OL+$9it&AYSa)EjWL{1G{sevoA(tOKrND_yu*YSYxr|iky@hR
zV`%Z&0(VkqyBy@uENBjLSRs&=OX~U->J^#_V|~u^(Cc&N;OggX=;uA!c`KXj8R<IQ
zA+mh<n2oyO$*^S=iCaF?qNhlFQ{xwct4JJF;~`jBBwng<Hgl1<>a&sqM<Yezq|YjP
z=}zFq^vV|$jhPJhEv9Sk5cE5sU66xSA})SVu>f0eCw2W3T>ixRIMb{c{?s>W8cgl>
z6X>_2K;8IM+CyM3fP9E`<JS`h5_ko`bp)OP@J|Ad0_cvvE>u<Oz#p4|m8JpUHxf&8
zaCwVBF)riL<fRN-1Yv(^9{`gH91Y+$0%HIiBrp{~zYu_v0Tg3Buk=g+HxO6`;A+@g
zx*EV90_y>EKtJ4N1x>gS*vY_3ZwIg&53n)|6<I-19%=npDi|??wn}>fYo7+7Kgk3}
z060is0su~`%ku}sp%afhxgw<rDI0abrED9toFle@xE;hUQ8Y<uGq3^-R!Y|Z*i7Im
z08`L!mfi%QYbF>u11Y@|*qOlaD_a4=pQ-C%SbYtMrB4DV&jRoqfV~7>18`b<0Ph3%
z27pzz4PyH!_9aN~V4hlf7{Hm?02pS<#z?O;1Yi?^EasjIu`U>;Sfzgf8o_Y2^zQ(M
z5O^8Dc?8}8unj;(`QSMCEvrhd_+l9A`*WmzPqsq<ayufaytxfusf|{gg{0CDfQ!k)
zU*)txaRFkWUIbk+HQru;>sWgcuE%=UZ^VSI>aGN?n3^CQ<Lz_7F-G{t+RFe>_Aa-o
zI<!c^4f(K&AFXp(B>C_@><4G)b_SAOg&EzJ0hpJMI^blabPcc%ft6kZpj!bfTxjGw
zpvDRziTwSZ=S-x~s#>3rEJ^F!Bs`BULTlLF)d_IAe0iF6Cs;7cvU_lBRWQf0YuL{g
zo{5gh?s*at3kTztw0kWi-+ariW#7{2UF2K9bHeQ7jzF&P54aiaDF+E2BKuTw74E^s
zK3>3fD2sgpc?%ZKJk_#KB$!*+uP?~6rN_5A^<@^K^lY&~l%7MSxdn4AdzBF9!k6p|
z1T1Av7ZS`Zypiy&LM~yhw-MA?-A+()6NR5rq0VNnFhTV`&Ej+T&<>D+#Wka%01L3H
z6|Zi<U1fWe;>k36OyH3k%|SILNuQsa$Kjmqm*HHV3~B=!mMRHK|CfWx4(Xm8CZq_I
zw*|J^VS#h=2BFFAG@Y<B-U@%xN{6ZKxmaQ^)1#rAT5MV-<CHufE52D0^K#fqE3_d+
zgwNCP5E{Eu=hGn{@c9Dg%!yg{MFy;L!Q4C<Y+a_=Ww51TSTcc`ZPJ!R)7;wGlwirN
z36|WJV9D(QOOAK6=BPoF<DU|8)G#(Tb!FLiOQml+8dZd!d}ts4)rPg`Wol-e3a{O*
z2sh#ODMll`E&MYJfz7n+cf_RhPQbvav6a9|r0U+4)UCvepwxa(Wa~Pk>&YJy2gR~}
zkSn?i^v5L}^w@`FMz{t7C8w~h4h#M;@XEeMs3-2;4^c(vF#=J<v*p)pRgOzY_dy|U
zVO86fX{KSC03~_CG#(v}Rk<{Q-ZO#z7ehZC{Ksjf(pim{&T5Rk9Q~(fXk5y1Ie3t1
zheei?-`UA8?wwcF*@X*xbY5Vg+Iq4d%QgZPrucTY{W5e*|Mhv1>Cp;{p}NFya=gLv
zROwEY4;47faI{P>jvDNaHb*a>_3N5T9JXt|&HM5=s3_qy!Y&Ye9q{4>mR(}A4|#{F
zT>iAX+Prady5JGQ4)s2h={9PvvTw&@uG<LEKLA4)5=$ond$a_=i2$;@VjXHW0MGgr
z&9w^zSl3*-96;Z0XzY83#i1Qz2f1R~DxRjLmm>8oq?TR_AW{lo6M(@4?gg-vz*Yc%
zCh&Iv`v7#|3TElcz-r2<tSk<^JD<WIf_4gMrTq5g<p8>@AnUil-XvL}6FLvoT^a)L
z0)Q?%nVtpg?n(fi0NfS>PywK;ej-++j*5%PXk+=!U{3X5xEKtjLjgQVU>tyNDAN0B
zQ*pP!5qhT%i;L7>iL6gVo-%rOGG#{s0{38V`TA%r`3JNlfA%<gBt{tB)+3GYW|X&O
zsJjs<E!0bmSm|aO2L93q0hCtbZySJx1YQJi7lAhb{HX_kJpjG~&?O3gDg6RiWetGu
z0L&zil!_4-0RFnNuUy&~7o?H?HN`H*xTf2mK>q<uT}Ui_6xjTp0G<W#9|ErdsP6^f
z0{{yMd<Nhn0A1EWqV5o|Iy()=yK#2=v&jK&B0u|K)olpqXJgH?TOR;h2=J|^*9de1
zaEL%AfcCvnBW)FwjzbD}^H!ydiHl0M6z(hAiRmmVCYppv8n=8|xJkN<L=mUioHU<E
zy{8(czJ{q}8t=JT!tf6;6w9Mn<NpTUi(gi-PnLVovwq+5UJ=}^E%<@uy-rO`|8{w=
zjKuU6&6P_`h9AM)U76Zs^jcLn8~V4V7#uo{XAbE0JnIkO-&oK3Z}D$3?@d_SmEF(d
zMrtQpZn-@iMU<|mt_}bPQ;PspHH?o-@qX3y^yJg~oUuB!)Hs`ctbKHQh!-J^=LeOy
zWhkve%3-9G)&rQ^2f#1@8wpGR@CJct0JuA~^i%)?2rL2c7Jx3653aEaSlv2Y#6RqD
z+J?zuC(3e__K)l8VF>->aRT&@Jp||<o(2H)k2(P5Z54=roPm_8BBQ#kfAqe}+~T~e
zE0wuX$#p794^Q%*YxU@CRc<jU91CBmQ)FB_My?nOZ^l@-_p63WI)Ytpt5Ea13CPn%
zei3?$eF^m5M-q{sX%Nv>n27XAM1D2}E6hbMqfHYx04eRD-RfNAGS1K&$+X!ZlYvar
zOezL9^LsX%;W3;|)mW7;8^*<8T$8{^?lFGP?b!o#J5|1A7_S85rq*mLKQ;8*K>uq3
z{cA)23+S&V(5(r&{htT@vjlpYp}zxqG9Hn<!8ySgud1xdf`r7*zetQ(l@%uOASC;?
zBwD@e4BeZDB2?}<TIU-AHr;S70R33w8*GAeTBWOIC(vojA}H}WopF!%U4lnya5I;$
z`@RqYc&C6|WDbnyLUiBxND55i(5UYL+-iZd1bhoOL*Q%yhvRu1Sjp)|-{k~XPl9mY
zB8pui3?m^McuK%W;P`>(2-e4_tf#DPHYA}Ofm0O6RsFaa+Iq3#d!Q|p&fx+_O#KM7
zUaUB7MJuJx%eZoY)Q^B9Tk$JkVz~b#5I8LA$0(D&P=(bn45be=D&9H$IFT|^&!Y$_
zwN%3!OcVQeECKIKi5swLHMJoVRTue4u}hSEt^U<4{|p&*vP0}A%j*4$Nu8y*(od%s
zYCld)+FY!LKCJeIig!b674&0uSq<B0?{SKEgw{JCz{;Gf;$84RT73{qbo>NCmfae-
zB8GL>Zglm2B<Krkd63n>5BUW~Df+us+He>wfk}#<ZYbZ<sNsq}ZYX{>=rBd^Hk6r^
z8mQ>CLNPWkriJ4bomMjr!0rVrV%vl3=|5v+<w@7R6w*2oPV2Qcp~6gz_@e-xq{y!A
z=B<xG`~Pr^_<F3Pcpf?dwdUnwjT<iZpmyAF@dmJXPu)uvFDff(#CC!VBKvj?0O$sh
z8zJ)>L1el^+aR)k;i*<_(gj~q;(k0Ak}eVtaV|n7C#@#zb&ezbV#1DdBjGiKL(bR8
zIO!6?Q74!Dml8h8nNFU|2xmE$lYTkj9OneWYYFE&x#YQmr7dyBQ_qz&A%-sKKlqPO
z3^INL)!<7AYA07b4T=P{lM{m4$q7O2<b<Ghazao$IU%T>oDkGbP6%ozCj_;V6N1{w
z2|?}TgrIiv6pk}=P&;`lVI9;?KAx}+YA4U7$xEyt>;83sp~nF*sQnI*6bWiO64VYe
zs2#oTI~JVlUH(1{jeD;^J^ADL1iwc$`3DMk50v<a2*{|nU!vX-iF*5=RyO+CD5Gco
z7X-GVjC%WDQt7;jqKta`cM1}XGV1MrP30jaE6S+1f4BMx+Vi6mnaBI0pd`wuxBo-M
z9Al}Bdiz_W-l=bsvo-3S%BZ)$HR_$psJFj0>Yd7{x4$*&oyv7)e{0k`l~Hg1ucF?O
zZ%`{){uH~O#VcnOMQjIlThX0yAW=zh(m2fZr)n<L^Fb*0z6`qqvC$CJvGd>|?j4cX
zc`zY%9{iC-*Rk{9PlR>sJoqzV9Xk&m(bdD)dC-!&Dv2_79#n$FqU(s*g49MCI}dsU
ziAVQCOE5{0p;5-pgFZnTqvtRsS&+$5#?FI&l?;ZaC}Zcrph^KUJIdI3(8SK8jGYHf
z>^#cYdC<hpqq!(<(8SK87G+HAJj&R4u)Rvhzw@KJm}#!+1Y~uTvGbsboktlv51QC{
zl(F-miJeCoI}e)JdGsS9CUzcW>^xX4F0wVs*m=;z&ZCT-2Yacm$Y;Bi&e(a-#Lj~^
zvyc)y4{jo;W9PwJSX>=D54Ob4-$0Z395x~<6pNN%k-LdhHm6W~yVP{+s2!|^zKRkV
zMbPaHWzR)&yCHzBOo^jsN*ul2Fc3T@2p-z~Br|6aJoGj}OM>8`clN??9Rv@(OIQcN
zL+=sRLGaM~gmn-+^ug1RWssD4njm<V4uXe1{ThuTLGVyQ5InR`x?u@|hxU6V3*N?|
z&&jTX;GqM&2XzoU^fh4}1P>kh4m>&t9{Q1H=peX;br4*`ItZ>|9Rv>@VZM8!41$L|
zio*M%41$MziYW)8dx!)TKWhDL`}wSyh#;0~&medxT`)(rXAnHpPE<ryd#;*>vc;>j
zRC@-&LwSnTlCL^22p%dBtU$GA5Ij^QauNi87dH4DX6|!nPw+)ZWl;I!Xb@#(-;Db|
zWh9>;o*2kE3l;(;1c9FT7hv_}o(wL;0&fQ)j}ac#jVg2IoHol+r9$Ora#R_q9rLH3
z1#<U$z?_e#qU!M&pn@Nev8v%it7G93s;GSvWN<H-iJ)m;TEL&rp@rgt6caPMf%-Qf
zffJxUNEH-q@!4mAbXtY}UA-#RtOi1T=P-Cd5V#BTdsS+s2tn0d0u_H02laJ<I~Lzd
z`FBLV*vHbotLPL(^JbogfUGQT(zs#J6ksX4yp224o=#&tXMvb=;)yd1p2zr<J)KlY
z41_b3Orrr;x&y7fNZ?OxxB#48Pd{rR63Nc9bGto;0ke{)_<w+w!rrTy%eno4%r(d}
zK*~l#V#I_vHCa5}Rb3N=y7D<jQN;-W@+)&EYK}8yqB-7n@-YKG*@$(eEPgQvma+uu
zTILmr<5IQ7Fr@?GkFhn)bOV`gjN{UMw_)Nucpez^M65b&a@Esg%*{BB#9+CE;U%>!
zW|F5s1%GP81kk&2Plj4X@Vz)HW*QJWZM*(JrW@oKAU)QgXsVe$W3O-OaYX_)yQaU<
zy%iR5djKY7p0CveuAO|X#&hlDYc+;}tHnr~Y_Fef)l4@cpFpIyh+qO7Ynjqsn2;=U
z;~s7j+II^01N7OR&jM2EYMtSp&Vu2mHgv}1ua}f9U9oVhQG{9)E?s=@DPky{#=ZyE
zTZ)&VO!<0C`CN2%&CLk~{6Vb!p9)yFBcTM9UnC$>oR*SWeTJY3)mkOp^`yAif2~|u
zj_oW5#|Va_dH^P)AF<TyMPd{2M&egU$#xTGfejuW2t1#Sb)}@wC4MXM>jZy*_-5kQ
z3;qW1x@(OY7S;f)dM^BIG?c9^hV{b&dN~&lzk@{iSODjtyDvW;z##xtdyK@XMxq_~
zE10U8PZ?~)Zw1iMmbu>?FnZQ+Y>qDk@E%y=%PD#^6nB^$7nSYgisfcR;TqZ!<JW?{
z6WA+bhTTC~xK=<9gr^NQ?nI|tMol$e8G}26aXWO<hZpTbLWa>W90_0O1g*t(O5x31
zjX9P&Dn}Vcy0m06x+Rk_5|*6|Is7Vjn5<eD8`?0A<^6)He-EW-GFtiY;7@J%j8*?7
zl7^yy<=+F?2_Wu6EBc23hyvIQpnsFkvYrBSJQtLIGpQ?px}gAS0Nf3r@+qT!2}%c}
z?PgrZN}1Sq4A=q{lEpv3ESY+T8S+48IFOm)SF)Erw>kgVxS-$J@(;#xaj}~pjiolz
z!y6&pgR8gdE_O3);~reRb<xeuJ-Bx3qFb7KaOu`Xw>GnH7RlXEH0S_UTGicrHe5R#
zsC47^5KS6^ep5R6d)dj)06M4$CaFIUh7tDw?Z1bWgU)Xd7o*i1GH?P^x9>Pzga=R|
zR{tn+-`m3VHMz!+Ytxhju9~5y*e^h)1D+*xG)C&ji=$xWcyqI?9B;uttQ>D`w(7n#
zB5dNiLk9T|<ZF&H2K)$QhF0eH9M|F@rep6%&pj9Hoeewp(wt}Vmc=<Pi`Dc=P`1TY
zHn**^8l$Xkv|;B%vSwz2?B}lR{I;?^T|<1PN@#aBS{;?(_bhJ9-owqRgJGAfsuE-;
zxw7ZBm36bKJ7m~dUzJBq)lI>CCC}fjE30RmUfNCN8<B+=DDbB?G{8f9iJNwle)S?W
za&Pg|GU*rTsJ+EeU3_zMZ}C(Y-_qP$T-C+5HV=lcmWy=lD1_oLkkHs2#IPw#W2K|f
z1B(w<=$wg*Cs)eQXeaQ&;>s~aU#>U?{UFC7OOKC>@p0ZD6V(RHhGihK7!2hch-?E;
zxwc7j>9L4$OH~Kgo)5XP7-;mBaoBtrwuKsv@{f)3jZ}Vy`rcJO2@InAG60p;zop#f
zMsKk&_XM3chu~^~YCvXU;j^xipQz-R-%_G_BV~}0=dFmAWrx&1iu;8hxz|>oD^}N_
zuapcI7=cDGsby-5o8byDh}F*nsLcGW4AGezCHER7>!_qz{l`_3HP$E@4WROr-%=u0
z@A?g^w?WrAEmqGEt1pBavAXw(x|$9!!<niHd{Rx1xfvd0hRc4HA&9e$XiE*T&p8)v
zQ8V1QIJ>0#ppjjYiDqp?FZ7#z(pN@C`lQ1Kkv=KIxC8I8!&;l)bAH?VQ||2r=+C+u
z_9onJHSq-5>I`#_u5K&ao&5r3$0y33k|2A!D|<;>*=i$O<K7bN3op~`rXNOMSa+$Z
zEGf}l24RVwcQyZhiJma*Qli%rWRuWwNU!tzCEA}LTWOhQZ0W6jw=~v}?I?yCv(ZS*
zK(q3vHiR-UIG2gw7)}IB#^Dj$kE6&joS;4rwB~Um#KGH5u8Ff+D~?s&{fz{sXI-YX
ztxP_Q;X7d)P|arvjGwk;w5mPR;$j&yle)O_*E;ZBa$5KorA~tNow=a}2%o1Ni>3E_
zRFGonb03plvsn6D1500PVCiQyjLmp6Strw@#)f~3C7^7$KMU0&`Alav_IS6Jrn8pT
z03F7P>}3Rxb_HivK(M?$lHLGM!%&ls&PRT62Ijj@KnS2a0MGg@&HWk#*xKB0H~@Qn
zyx&CmKeY06Bg>nRH{dVE1Y0>K0JqGDhC+AMKEvMLWHkncl+Lu&Y}!8?Sz0v@8x}^|
z_+}xs%G2KOu_nbuPJ)B(K+LLqJ3-=ixy`+fvDsWcAqzP+^LutaFkLkE=t5$VCO&6~
z!x?G|Z02g$aE96fcM8bO`k^Ug9nSb#=qy%t@F(cWLb1#e$Z!VPLMt6mhJOqv4_(j|
zgyD?0g;ooA7&(TnrR?xZGF&g<Qn*lP2M2f~7;g*pR7r5T5pR=RCr`(b*8mP)EQ<%1
zLH#JXOky#74j0%)z5s^6$2M0QI9(mZmF-c)^o5UDYxE%Id6s&g44h4kVuAEUXuLq-
z3Am0dqQaB(as}FX6g7;ZjmKDxCO$OsG0+0@gopEsQLGQcGo~HVlD_T@GXF;P!-cA$
zz~>AG65tCYW4J9ioJ%`7Qr8N^YUVVG>o%iUO1W4gAA!yO2Ad1WcaU8!!pU#Cj*<%#
zN8PJ)W1agP2g9M!+*=%)ujsO3;V3TWSR)zr3(Zo4QHAV3N6{rmaZ#<!#cF(jt#Ps%
zyAA(SEmrpcD4@gYx+XSCE-wSJMvo!?0u?8NXccGzP?&Ty{*5D*xFmx(1@L%{Sf5v7
zan$OK@|zIbj8q+B+X<g^e>SrCUxn9_E@*%*c?C1+!d?W|<C1idfDu$%(rRIN7<HPo
zMyP!ABIy#L@)gXaOOK-%U%^bej9}s`m`PWWVqU>a+9aHO1vBXm0UN1xD?x;qC~988
zWIWb4@fJ`dke0lQx#>WfvxIMsN+8WSXB)`+ZA@qB#{?}u)f^3uz#{;9(U^p{GlO`7
zAgdFR9wMVevy!i*0s0k9e?<%?Ni@qJn+CFeMblrilAyez>94;Iuzp3;-*6dV{feeP
zJ`b>dMbqDZF<||Qrhgza)vsv!2UDkhMbkf=<<qZd`bWP6Sihp_Z`=)7zoO}%k_uCG
zG|NAgu#RT=k0-37S^l{+d5Ps`1;hbL$!*K~uQb3DMu6gT#^9PV6_+rL0YO&;w+}?T
zO=ytdh0-8=pEGz7Ydgx&SC{KfLO$|7XK09zAR}9$X=F&1$X4iSb+*T{(qu{e1%a(J
zMz%sPsWs5<q%pD;+9^mhjghU;YwBvGWTi2(722)7gtGiJ^sZLueNj-7#>iIaL&Y3p
z>5OcJ_A2o`yw92bHaQP!9Pe|cGqM#rWYTkL(;3+ceQ)sW+H^*?LO&b4Lv1=ETOnm@
zeeG-08QBVX4KD9<c0~>no=S<WLE&_GDtssiMG~G0AC_8_S3AQ$(taJD3jah{ho{0n
z6V~CW@DW``hNr@o6u2af;i<3^B$meTRM-}zHjUw_ut$)1+J0yWCkZk%jp3;<*8f3k
zOgo1u$%0HyV|Xg;R|8>UQyRll;h-7@WOf?EQ{favi|3~?JQYqAWMLY^Q{i-V3sRP(
zF+3H{<V?g`k!DdQOAQ9HGL7M>aC>zOw4I-}3#4$aIuXd~G=`_b#p*uL)}=8#6|Ph}
zfLxcx@KiV^$i_5=r@~c&Y))f%D%@R=Eolr-g{!5Vx27>X6|NE6wxuyV74D^GBA@Nn
zQ4CLoO?WDNGYcu<sqiL(Iy@D=g~iq3sqh^vEnn?S1I_2K5v60G*>Zc3%H|a6SuQo*
z%3ydZ+*eVeT@jRcBiXkjIdceLD@(#tSrVSg90r2NYR6m18|l8EOn)F#ro85vDX)2E
zW}(GBnev)vCSRyY%9PhUGvzhU%zr`FvD$khvjV8&%v5&lnZXncNiqlGYG*DDGY=D|
z>fpumDyAZz)}nPJP8Hd!{g5wfM)n;G)Ah@mk^QFw)-P*DJ}0}5Q$-H&j?!_e$k&8*
zoGNmt0X#ZR75T9lR_QpEhIO1u!#Yl-VI8N69AUnD(io?Tcoc>Ar7=zw@hPSpNaG|q
z5>$im@7rv~sUi_UES1eTRU}<7M`bfk6=^3bqAHtlsz|oDcb3X#oGOy1SWo#XhjFS%
zfnWtHdp{a0QY3N`r&<Ubd=4}BIkYENzpNRlPzzy08W+zaF@ddYzN{IkQmc^AWFtfk
z{e;Cy__F32Afe&7Bu|eb>*$;p0XwYl=qb#>a#o_HqNlMT9A^oh-_g_A&qnhWO`B&$
z=aZggCGSSlmZ;tgmN{dPzv{z#*vgZLP+zu$<IL&+dOcyhiAkOYmNqL-B4GU}nh%3E
zLV0_yI<6b=%uShKBYMUzqJP5(VTH;(2#d~BnGJBBl`8XrblkTp^C$GYt5ha;QeL1k
zk44&rD)Vh%7pY7xf~;1V4+6VbWpan~8kPAD<StQ}(}7*8GJB)+mw^*<m#fU-__tPN
z?u5WPm3a-s*Q?AfAYP#|-^ITxRpurbaTRQV+|?@ceGsovR>v-=2k$CYiie8=`HXIP
zR}o}ep&biefq*LZs2n(Z;m6Pngm9<Mi2lVqQs>}hGj#l(+UAJ12Cx({=%jJ0U^UXz
zlODzJNAaR*XA+^87yiI%eo_<_vP})#sY^QR{3#C`pvxLqZ(!I|Otu{!bt`Q;y-*PL
z3RcM+q}aQp&+`0(sg<Y_LnwR&H3*n=Sj=0pU?=m~?NMLQDuhP?OL7U{v9_Pliue`T
z!bz|I1eRATdPXbi%D{;l=ustHiu8<8^mflgid;TN2qKaXaU=?TJL(lM>j`#ziEB45
zG^w9RQKk3MrXzNAdK@U`hH?dI!z~yvmq`;GvDpMSVWL*ny-2v3Njjd{<#S<$Qc`R8
z0k1$S*;2WoNm$0=TYg-cEElJDJj{Fo5-P;;{UXNAO6B740S`TX7xCBOFe)hN+zV1J
zH%CbD*^|)?J~%xtb`I-?>E)*enE|A`4$WCsb+MtY0F^HocE^lz5$Lssehui0TIi7D
z`cl;tllrje!qOZPc)`BZYt7`pJN8N=`iCj(ALu5%JqL`;ahCq64b5nzvfI-ol~r{K
zY%a@UrT3P~c@ucGGb1kiuOcfi1Yn?K2jvrxA$H1Ew>K=brZ|Cxe6p%kU6r8Zm;?^L
zXI=gPQEyZYPEd7*VeD=SC#qt@4adKcnbpGs9`$bzeWcMOoEZ>>aE;GVv@-Uc;9!5*
z=~&=#3_H|8Dc>+uMcHWLUkg5b3a0pcOGtg=VQ=bLzw?|51ojV$e*1W|aA_{MzZLxc
z6M*mKP4}I6#CJ`=htZzz#e;IE0cT;=4}!l1yk|N*=0}+2_tf^(1@BdLQd|s1FCxEX
zXfA!5_x85l<{FL-G|b<z^u2C0SPvt*3!>%h_EnOX4LWi<ocN?U=vI7!pANkCMI)41
zDvjy)+|=SRd}R@82h5C%!l_1W8H}#LLdZfd>-ld`5}RaLs-Yw{*B}i<E=WwdDIvw`
zwd7>27q^@I)<Lf>X@iusTskxjZ<~P$d0T;U51q5YtMD&$63TiRyWR#dYa(#0GP3u(
z#N;y{uo~!n3)%E}3h-aS(&r%nIWtiYHyN%*T@R|ty@%}OXw<&DC}3FJrcvX(N1-3;
z^C8k^Q^%8rVZPSkS-uZ8^ku*KqDe8%h!BByDn$bzTn5oTKZEIQ>UhI&Uesy_-ot_k
zl^enGCWLeoz93Eb6GW=7niFSXEjHoxV8A{3t7fd-da7o+L+kZ>9%^Z4L}2f0LB@Cj
zFL`mJwz?#;-ifUFVng{nRGwNXHGJYM;J30TJzwxUfmh5r4Sne<G3^85;%yfQUUoA0
z1C+l|@MC~i@>Sn+Q8?Z17bmp4hVKSbJ(+Y{Uo36?F*QkBUo1IS%x3B9SkDD>bt&Tz
zQI~q(glehdwP2Atei}e+Kf{$!$9zu?olbhQRo%JSDy-r~UTWjJQ`P@6HT*0p@82Mx
zhP~^zp5wEs51EvAk>W>Xu)|&kiDOL`ya@_g>9v0|&2SiWX{W8G$3tbzhtU^+w_^V3
z3oJFv`vXe#1MIE->=a!pe;Kx6Yh|r{JhuJEu9~MAc>lpspr;;AT7C_?n{T9!s^;Kk
z9A?<MLQm}UL}ZOYXm0i02I&X3_l)feAn|D;lVu7r1x!9<=H4!tjl~K~nrLfCV61Gz
z*p$F%Rexi;Y}Vxj%_$GR6w^hKeyX7_hdp=A)TLeo6RQ7ekV}AEAxyd<{+>X;Thl#@
zEwtPZv$XV$5ZGx17O)t8kNfPfswbPfk+;@Yn#u2JD$sqk75msEv)-%UnXMJ_mAnje
z>S$iif^D`{{Zm3hxlXVbM6K%lIa=T_1SV@b?mDBK&&oy6F_};J>RjUiv}3W$+VTQ-
z^_vOF*SN`1*UakEO*PZ$9&(fSxQ<tStx4uH{e7J*?&bG9*4i!L$sYToVazSJ%ruk_
zFPV3wU~?g0pOehaxGT~d4mqe;Bhdr`e`>?^NblqETh_8UaMc5F)m1L#ASm^u^y5AT
z?Deu@;nU(G$8k?p%pmSC#~leI40FI-`-RD~5>~Pe0+?=C4IFH{3dW00T5~n#?|nuf
zX&Q3tGYP;p0y6;Qoq}iIV3TE%k??{)&Id{STwH30n`AzJ;W_fW>^;#CD~wEk>R03X
zQ>mKTpP8tM)h8P+R{A(-g{7v_SG0J545yYFMwWVM0;3*IohvSa=XC8V!^aV@t4x+g
z8aSQUSQr;`FeH$l+VCE9^}iNLzVCVcW9_|#aY-@?@CH<iAs9`f3Nr(kI+<Mh3oEOT
zpNELuX2^q3=ha&cLU-$oR9NHpyl7m>s(#)iv*e?6@^8D_D~3_rt>7u#e(GkAx*j5(
zF(|vmLkLr>1t(kTUKz1<K5d?*?h~+6ml_mR{aMCluoaU~aECYy8qfoMn)>)lP}P4x
z%;#Hu>SInj^1tRp>*H}q8i@S@|0FO-hVh?r>@{dDZP-i6fv{j70c-Go&>JX^OjX)`
zwpVR9wFraC9(ZIJj%DzwvQVMm%<*~P<?}<plSD(tJoNwAhUgRQdSWmnS+EOE1Fvj1
za|C~!_;a}HlwTGSRxSX3EAtA-GQ%Ycfpb%V3d(ZTm&6}pdPveAKMTvwKSY41$efKk
zV~(CiTfzq4(p)}=ctmDwH!cGIIjpRxEOBt}%#f)lL|u8DHDTq$_0$2?Hy^achL$BM
zpbxi?1>9#C(q4n2KJ@@PF2+i66@c2chW%K%Y4Mil)@IHD>d+0+_xjR@4;vl~y5*;O
z+s#x-_q`sPG*_pJxTJQKD>AOJZ*#exXyKY-xG*}FpDML?xLh9z7Yp$>!-W*hm1*Z8
z*d&GUEir{?0H6!;wqgIBLe%kA=}{RMRkBSm&7KE`t0&xVHWF`vs=7iHXTITD!5Y2G
zb2c;W4tnm{s4Gt&tzx;ZEAAhu+ycfN=<2rsY9@fIUo(I|1L(EY=)%lKe*b8X)Ju^1
zBT{R3nbbduGTf-?x#sC+Ro`dQc&B~_DbuY;xAdV&dl+)b$QWt1JU(GgZF)>wsFm_V
zDd-l)CTL?Q&F!T8o<li0OEc>`(J)f_cwrO`u>zxY7wD$3hZ$0fOH8$|fP}b2=W|@H
zs|;6*OB_;LU9O?z5-)z-aP488f3C#k)>OrjjCz+V=<lk7uH-z?Pd9nfaJ9I}_i8X!
z)x=HKflGY-T>#omzB25;<0g`^RUMZsTQZ)dPN7Qr`lO{u>XmCaHXGB5(Y{CD7=n$n
z)iU%teovE`Q&wPe?OeHImqIcYH-daVR-b2(cYu6~4A_i(reGB0inCQPbw3stdvO$Z
zWA#l&h|kniWZTmAB8taxrD;&B_AbN91r4nmEyp^0-6W(M^VJBo463Bgw!=)RvmXht
zf0%YIT=i2U@;mib$37ytM_d#}SrOyaJygj$TLlHN$NK0*KJ|5HakF7>spgsXtFFjj
zA)>iHH(XssH59K>d<9b!zu&@@QKPlDa4l7N&?{V=6KGwd3|FzMYpNRLauv65J>FK=
z18T0zHJn_PjVRzokSeesx5=Jk;{!{eS1iVZQLv|oojwce6}JjL5F=)*?l#=^_w|ZP
z-s@OJFWYr_uyGsckAb7lLjW3@(I+vr-wt30f%V%3V9W{t9{|`u;4=VK=b=*HFzOD|
zo%R`ozLf>VrpaSR)#^NXIB)H=I*phC8YVENZpIrfG`Rfm)M=u1Y{0jWm(?r1cU)3%
zi^^|1lJ(s28JkaNy=I`{)RkB>Xe*%Sk<Zv%Ghl#J&m*6)$3fj>;K-xV<k3NLu&keu
zhhFK~Eo^@UTkQ<P#6>d{vgH}|hM`A{usYlB)X@~-J?ihZ*f?RP;h2hKt^OlXug-`1
ziwskO`q<TFaS<s-9ai6JkX}G8g9h5rQ*PVGj~<{kS3h8Q#(?J$&4ZbKOJ9py{D+o7
z+2e-y6!7kD%WG9{H_0oId_X75H1`ujzZ&#lzL=2|@&&!{i~T0)ZX{J_nn(A;KqhED
zncc8sNB`pYtcYu?W#wUGt&3now^cpY2!8|Nc_KU+51Hy~D&iJ@?1k3n8(&)@+WNZB
zu<FXnIC+HWFZsg6T|&aO)a8m5o35WD-0DFFq2AA2k<D7<Gq+=_UYo#GRv?OxI@f#}
zr@FIe+XvH`tyPGeTIfUbJRAGzq7_=Pe;N(FE0L+sJQKzPnXJ|MJxwjSr6(jWc9Z9}
zB<Ck2U*je(ZAmUqNPfsozNjU+E+KiBn|xJE@<Nk52c}gNvZU~wttMG2@~##H%SIbp
zkYm}n*mTX7wii2mIN$*SzrnvOG;Hi_qgkqbMEAJV7_0qc$p(XwJ*FBZo8wzddeHFB
zMtfc8@>&m07X?=Jy9vp+xykXC<h?ywbK0wuTbc+>x8k>&ZWvx{H7;6cRX<?5XXeij
zMB(o9d)y49enz+0>hGy@TZ8JW)V!)cc<9;VOd6+LBTSlJytk^WOjpWj^xU?2Sk-+J
zk}r0XTdQEO=}I{V+w3NP+p;2Xnn}JDMm=dV?rz0an%?UXkYg7aL|SL9L7qa&zqNoY
zOyrxsoF#~MHZ}1N_r|JzI3c;xO@5#y`F)f88nlj<WON0s9awwQ3sU*1u5@}!&2~#j
zzSK?5Z&BVSA^C1M`SBL%kqOB!xXHs?q?=4Kd*F|BvK07cLubV*46~%^PizspJ0UsW
zP2TBd8vBb$=9ISjIfJlxV_JBBG3l;-H9?<b)!o&l_W^LECkrr(tPtm#!=8^~m)`Vj
z7&nT6DZgj7@%!OPNKuUpLbm$q@K;bgHBJ*<?-{-{9mFOr{*k-Ga2|;g^!Ix{bcv5d
zK%A>N_qaqqiSs&OgwxuuV|O6X|KJ9#0bMNi$TiCv{(cJh*A5qc_a+N<Buf67F261O
znbz=$EXcLz2*2B(hK?b+7KK~u^7pcapMlY(y6INUX&x$}W};jOc%+r{=r71Q!t=7Q
z?lA-B(49a>a6v6v_a#gj!LNQrhmIr24VNjKxqo8>H(aLNNpPfWP8!cRtKTz!kM55~
z@+&8iNxG62x<qcxj7({^$+^xY@*_i$6E$a(>4rwGMW&JInsc?w`D_}9XL1LJ-?Q80
z<Q~t+Sz26uXmaP*R3c|<;zn0|YZ%0HHSsK$_*b+;q}k+dh<=v)Ba~GtUs)rEd%(2v
zRZ#q%18&A2qtA|9uu%$=@2cYl(#UE}+~yMb>6XYPI*;>QBHz-9tkp!@wfi2lNaP9*
z>iizZ<>XG($hDettD8Ibq(-jS#1CBJDzsYUMoqL_@o}uRO>FztN6W}#S--a#PLsR%
z$6F<?r&=RVq`J+|g94v6c?i?bE|YDIypH9#`%7Wk<{DB!$@{eW_gx~F=OcgC#LX`8
z6Zlc&K}~$mB@UtZUvxFhc8TRQd8;N~=N7IDo9}V97jAl&$nWDsp3*v3xWpT&bNi!R
z$+^+!^f@bw;K2NdPUJbw|E`-Iclt(l=xSSHl#Jq@-$+l{lH&K|n|d3?-M^7K#oZBp
z&laOV?&HF4=;N(pR<h(Ls0v`AOk74Zqta5-#zWhPvrvMxeCE@L#<$Y@?7)=)@-P8x
zBExkISIUWUMycu3;dkLjK(fYmK;luC$ZFR$Os6hu>}Ajvs<eqb>{3Nrm^)Ogar}x+
zyKY?N2#*7<FXSF?HSz;E8P%*+hL}a6zL3+JFcDliwmq>7#mcjK;!1jEX(FpNiQgcK
zoT3;eNYEh0O}-SjVyEs?QHDu5Y}V5hLy*SuI4rl<$!Z^iiV5b)7L0KlN|0IS^O(d7
zmN~h}a_ltNVP7F)jQ6z`D6GYHqN1|~F`AWNPA|yoY#Z-{P3@0np&4^Aw)CQVHpw~y
zAAYTp)}#S6e2!v#$}nGv96F4aeR_;GX$x*)4pMJp%jO_`npns%lcDmfosoV*oj@ut
zC=;Xajk_R`eJ`aM@6ovvLmQnA7fSh&2%|q?*_tznUr@^VNHM%4ZeoqSfL0zY+P9L*
zO#op+$l?k7JC+(4z0oOb9$lKoIjGOvY!W_aGB1!hh<_n&k(u;1(j)T}pX#mE(gw07
zZAYy}PFI}v8oke>i%hTG0c~73*ACv;7gd+?1#RI%hc3<79_iSCFhVte%4I*Tn+wRg
zX31@hy@vS3QouiuNiLG)bGTt}Y%v&8<_ZJX?L^CXYhnOimS^$9cWiPluW9`vdR!_B
z*Ky?7$I#2B%oABo^}}Q}3K~yH!QyXw-k+S{3l&?>Lm=jojWgC(erwzrU{5RJ)YY&K
zLly<g$jZ5@E|T0GjeOxNV<J;HGu3A4ly8|bmMNT+8bu4BsIZK7b4D8GMq+F15#IjY
zY;NG?WHd~`ntUmorgIrP!N&8z5WSC5A26LjSRiqM&q(9_i6;Li;Lw)>9w5j8N8^p~
ztIm~_%BuvcT&P!DE7~}afp}-6r*OU({$;u~?rB<6!P#Hiq{a!T$D*k;g)=Z+&~Z10
z(I|sCrw|8etr&rDPb>sOU{)MvbBwRcM9gYD7y61b*~N31FDcf9d+EVvs7dRvu9cH#
zb3m?Brg)$za-!V!ZF0dTJ6P?tiqM>9zdv6o<0rNDoEB$^trL(7f63|Skp4HvF4-3h
zfEwBJZ?_)1WVar>WUm$m?)kS{k6p4`k6p4`k6p5Vb?lOzc<hqB=>+D*J^yy=u}k*v
z9J}P%#f+0zcyn;No#mW&6h!j~;t9x<N`QgK0YohC<xK1t03~=QY6-_Qaa;dyd|_)Z
z_}hMAi<{HnLrWl$@-0Al5x^s#wF;WEnuekD|A)?Ms)MQSSxtoXivYgk3A<-C(PX>`
zzyco&P-=>wwPInzZ=$}kRC2pJS+4hiB)7j1bd-^BhdT&5qX~EH0XXVp!T*x;(LGsd
z&J~>i7f>`^A8z%CtN(}<88mFH6<Dzyl;~#2r!In^^H2MA5cDUt(rCa}6mGd7<r@%=
zl8<fq<zrhBzHtz|ZW#&`<TmWxp+lF!ZDhxNDB*)pp@hSfLO&f8TX~pLDB&=rkUmT)
zgFEg+*pvpQk__&+51GT1GPvVDWDZlx;EsEIWQT0=jQzNV%wb9y+;NXD?l7e>;~b`#
z!;~_(<38k9PeV^r26x=!TRb~}%+BDB`;hq{R0en4hs+0|GPvU&-{oOlFUjDJ`;hq{
zRE9+v^FgQ#?zj)NSFb?Z`5C*IX|DPZ$m$I4xDS~RLS=BreaL(eDuX-jL*|1}8QgIn
zG9QG>;Ewx{`5;urej?^Dr3~)4519`_WpKxRsF&IchV53nKcaC$Hw2quV^-*97E*TH
zhc*$^JMKfbu(*21eW>MwP*;KGb3#xihoI4H@k3JCoI*Y9Qq!$WjFc^JN_GzJ;jAHm
zt@g6ZzP;?S&l(0o%MSRk-T|NT>2Oq#?0`>6_)=5KzB6I1-T|Moe>Gse13u+*vg;l2
zDGA3Fr6e3zlyayMJbDLw%8v@x>mBeK);r)etard`Snq&OIl_GRWN-(33O-p6;e8q0
z0iWViOgWIThe%LOL>Aw6;12kdh#;2gz#Z@@>4G_`19!luv=bFk)qy+UQ{3Z<I&cSk
zN}ggp<*RJ&fKMq9tUz_(4)~NJk&_+phve2{=01n^<mesnDHZBM<d?x6@F_8YtqyZ&
zc9psY2~F4m-wFB&OQUfI{03S$6&G(lZtif$djR^`sXyj&CF6TzNO~?(_ytJLT)>f%
zn*mzR6NJ0+_K!Q0;cby_?81jy-a;nCc#fW*dK}b{ag*TBNXk<Ay+Lv=0;~#;K;Cke
z67IxyavZ-OaA&#qt=v^mtZG;>>H`Sn$ws*vf*q+#)qDmpU*5&-bpRkvU{JNxnJ+5)
zP-VX4)F4z*-k-|zOQ?E)P{S=?VSYEN9eD`4I=xEW>>kw=k>K0eYN}XVSb&|K3s`vk
zFx~-Y3ac0IBLc*0XwpjTNplxa;d-*F;qZZuvUPSn8?fW&l0>jm6_N_D<y5}mWEJMi
zj`iEcI@#YTAjUo&X~R+C9O_)i6v@upqoj?CQ23+deNB9cU$qmO)#XPR<c>3@iM`OU
zfhQD~grK1F`2aEj`~aY96l0VClSsLHmErMUfPLjmD&;h<><2Syc?m<F@|@G-qI5Tq
zACOvstwigad=>lz^=zM2+25ppjdZM*#taHh`Sn6(r957yv>unr8k3v?H^!HE6Lecu
zSFz~#up%4VC{Y{kgPQI`S)KRrIdnM;?mkoai9QRodR7%Sy^xQI)w8-=>QBU&Ryo-y
zWL=^49t1sw&C-K&A@wx#Y%(nJJz3ytLoQ0BH$FejyUMx{c^;$*&-6sfg+P0Xk3QcQ
zD8I_zi|>u77x-4VXZ?@MtI=FLsQL-8*3viDnLIj!$e()YB+Nv5pNyp5Q*fzk%g~1(
z>OSrw@`{4zjDi>`_^E%~_DcnA8AQP{QP7un<<$9c5o}C>@SCeJ1TGl{@<wp90^>nh
zz8Wq;u0AIMJNaS&a{>H|zybiB)&N)z;0gj41E{(Lz*PX$r2zg2pb0?NEzr>q`SiIP
zl#I(j$wzfP9|Yx5P;LgL&ocnt1W;dehBmJh&C&!GI2%`+>yI(?{-7@ry6pI`zt+%a
zfxgbr5%8_wYUnuW(0WwsNnUR8d)$R^T&S#2W4!CPEcaPuH!Rdya`s|%oe$ggL!i%V
zFsb5l+zc-nRkt#|>_Jn1T=1=b)gb=>5=IeeEptyXA|HcZqUl~a7pLKgGj(QE25wEY
z>Mt;4Dw?PTRIOG2Wdiv$qaU@=kiS4{VJ$Jw<*>}^x)G+&L1p)pp7DdJK>0oRu6qFN
zg>=6M>AOGEA;+L#@kO{_Ea^>F11<a5DCI5EKVmAyyMFa@-0Bl#tEg3fyy5v48T*hG
zQm_o@29)YAGRf&t_>LrxQMDD^L+#$sR{iY>JfnY`r)<B;ou-r}pQQ^cw{Cs8sd8>5
zyFy!_VrWuC;^G5X4X}y(a_SolBhPJkFoBWW^2$Wn`-X$PT-isa$+(14-}g+NCBIz6
zvzer&_Rv{|C8X4kOF$w}B5eD})|8N9$q1S~Mml?ubap#(K|jPE#?J@JNC4)k?dKzn
zjc4!>)1nM#^o+B^>&l0v-!t@~=~CRDy-6(N)4R1P25?nAx|w6V0bG@j-YFm#wo{rZ
zKY%O1DVu1^0Iq_jY=0KH_?&6D4&+K)yY8HY47#f$<^)IC^cnW=3C0ip1m2W-B~#d!
zC!`$BHNZ?+17s?lG$C~mmnKs$kpo|NH|wexJPF#;s%Y9266HecXcGu2G;DAx@O1eO
zIq&QAmx;>LdI%RoiSj1abeXMix@iqP1vQl3bMPOKMc^8m#G5yrBLHi#4{3pm2=m@E
z#^~iJ>f;@(vl#p`#c$ylgx+t&;~+-jQVD3F^b}lRF-Jwic%X{&txZR5wN!MaKaZ-l
z2J=ySlzdX0KH6GE=~QP8=VEL|H~OOx^o3P2!WzZ}(v;H_{ZpGflB;~qM@n+S4kk3T
z*UCkGne~W6Fh)M{eO8>xEuKKh-+s{lSL+e~zc>b3<~99LwQ|d0%JPd358#D+Bn4ZR
z8h&{!bZ4~X|DmM@uBo_74TRmL2Ey)A15Gwd4Ltx#p}Evh2jo}BLI<zI;r9BCdMC!!
zKmA6%|ImAIq5sWc$zjg#{bqh2=KS70EIG{iy?a=4nDcx0u;lQ5_^f+aa+vdb_pszJ
z=lAYm$zjg#aaeK&^fZMzzsF(8*+6E86Aw!cbAIn0mK^5%-aRZCZ^;8O^ZPL8_wHfI
zVb1SySaJchogd!COmkHgkkw(%@7=?a!<^r{hb4zOzjqHy4s(9*9+n*D{N6n*In4RJ
zdsuRq^LzKO<S^&=I4qfOr*F3+oZq(|mdrw$!;%T=`Mv)Z7PswT$)7-t&tW5q$J1<S
zd{Wt*LLK5#)2%3%a{PT2B~pu^8wV#ZL2}v<z*f4<_0wgppEe8x_k+)Y-7LL1^_Zak
z;B(-eqoKz=^_Z}G>M>#W)MLW#smHHDmLGg(p5{gRqx3RD;8TTmkY$8lo_ahA7Q3e&
z&j9S6dQ5h`jPU!X9`k$I?y1K#LoXu)ekAOkdQ8|o^_Z|;MhF~XzI(#v)MF;>3-^WF
z;M8NL90+q60jD0PAd7D^xQu{PkBL|+<0bsVsmH_|mBD2MoO(<ZQI)}EgqBl}Gq{X^
zQ;%6K`Kp~c^_W<J%HT2rPCcfaEF<uk3!lTx@x2<r{<p!$PkftUMdn-V`X}>Q<KY@h
zmVCEZ@b*11r?4lJ3SoYJq{9v{tKztMdYlHW{HYDRhqL7ig~e>>Coac&#jKd6N|>d+
zKAtnL6&aet8JbCH%$e7UOwOfqsjlOo;xJU?(asx9W-;7Ws`d~l9UE{Nw-!J(fQtd-
z-?=DGL#(SX$kAet8L=jc^{z&>i`dJqSkgLF*M<bKLTo{*L)E-(1h<Mp%yl8!88f&B
z7Nsksa_?a!^kaQ*09w?+D0v8ZpAY6j4u)Gc?G*Jj$!{Y09yi$@HbB%f)2c#@RJ&V6
zCnqqz?lSH+quCb5K32hH35=52>us63!>r>?IgTLTGBgi3`BE|zVGA0vwAT+U<R`uw
z3;EIG$yWYZMxZMO4F#7OqzVWmZKn*a{{ss?Ym3P~+|v5|{F83|S#14%s1?@OY}Q!8
zdgBU$xvpRk?Ft6bu3!-33a8K&=0SzH!Z#-8b!^i!6mpd|eFy2{3aMAX74BUem#S@b
zg)&3gMzIClPbXrNz%62z0VsGZLCm;9(Mu*jR^jOo`yZ?DpGJUHSX5**vI?)#()`$V
z(Yc0Be|bRD6a1y%CX-Bmk=FeUU$Hub+o3G$wi({SmZq4EIje4pb!>{KQ8YHi6>N&1
zfyiAc7(W^+x23^0H_Lr#uq{Z#jcKs0%{dEsJ4<kdZMcy4v%!WU4Xg%hL|Q9mn(-Po
z<FG4HDeoDJS*1^-dudyxeCGyk$vvs?OZggY{x?QOYBg<%Zr;hLRlXZ1J{%Vx9%>a0
zHmPfo8bMW{CH<aH%<W+n%}x+5m*j*Spy-AK;gPQJm#%QZE|bi5lZI)z$E{*N`e&7Q
zz;M9N<fk_Lh0P(K`O9N-T!AX+a>Q`m4I5jEk9~e_uZn0Sj{#Cm*4etKt?GQpTB~cK
zx*b#(F<focxwk3Q9fmb(b@W&27)jOYR#Tn#DyZxDJL+6l!()Y$N@p_%7A2fiI(HK6
z%Ka}mV=5h8a#!wp3DhY*IlAu40DQb!3r?JTfdv6Z<^B32cz*)1R4$WPVLpe0jxv7a
zEihlb$V5K4N(mwHRjMGNd>d4RTE5;!Un=DYwsZja^yOvh>&EZG;WQ|EADyR^r7YzG
zw#~(=cz_n4tjf01+B4Nya&x3#DiH6UQeI#MpPyxeaNh>bQp?FEmllrFi%H`JysPjp
zNCEvdzHa;)pQFFV$L1<!1xXPrtulUTF0ep7OS;%8(7RgEOZXQfmAE8B<wt<4G-CaP
zIiA=0Gp4_0ruQW}2+s8KO?z@3n7@6Q978!C6vnobxf*SIlV1iSCOa?ipYkP1TGHQP
zoX49q=d^`LOUgm!UT#|Swnm=4t&wMMYvkG68hQ4%MxMQw3_$MQcaep+HS+BJRpi;5
z7<u-#MxMQ`k!SDkM4pp$<XIxgz9sZEi6r~Z+0KGH3{?1*?j^{=CVWy3hcbX!M!gb5
zPLjS%e@!mA;wV(d|Dm&yT4#32Q(I?t$;Y?O?2_lw<Rw;sW#uGK4rq3R$UcYPn$z<;
zeL_+SgSMgThO%*AW<|utf<w>m0*7A1JtXtHKtlXBkPyEOB*bq63Gv&2j^E1s4(}Wv
zgfS&DzYCc7t<3KNCVngPI~-3%wz$mi0w#Vd^E(WnnbIipyMT$`%KR?iS3&rup5I|;
zoeD(H?*b-%EAzX6iQmfn4#Vs_plylF?*fVQyMT$`%KR?SUS&d?p5Fy>RTm(7eitzD
zTbbVlO#D{ncL5W>mHA!3#BXJO7clW#ncoFW{8r|70TaKK`CXuwDn~wMeitxbObgu1
zLdyIuu!*3a-vw@AarOKz&=SApA;CU}jTm4bMzh5QNM&;hm8U%k)y(e#eK8tz=Xb&E
z(~$f>%<qD`|IW;Lpil5^f_i=ze5Wt;==ojnUBY^P7krPfp5F!EC#>gp!4IB?Ea!L3
z^Oy6x;HQV7UFLVegfMY%Up?<`InXD#pUX0Oei!_l?0S9|Ob8PP6T-y7LqCB>&+mdi
z(hNPn)3Bc3X;{ziG_2=$!6VF9&+l*~4Tbgm4(ClVMbGbWs+0$Pjh^2HBZ8Ru9Zr&B
zl9}HH+ldM@zYDryVwv9s^AxMa%<qB)f|>bUut?-&epdw>d=4}BIkYFR6H@JwhqSG-
zlE>gdfRC^7QRB#&Be^o6b55(`kcA?S(}kl+f%(BbE<F3GCNtqon{z?bbHnL;R_nRp
zbW$NP1X?<nZ&}eG&sNa0FP{Twj8sgv`IeQ?&9|(~BcHc*&So00i^jOms~17$Pi=@L
zW6p(l+IJDC#~3B=D?FstF1q%UKs(MhkGR{S5Wh45>9{cg$={xUz~-LN=4V9}q~VdM
z)`*>o;i|%UbMO+OCS>>2iL|oQe1x=wt+RZ9>@r0YItR&dxnlR(32&;e6>3rEwb;9^
zZcu%|f+5(OEMS#(5@UyK#zUIg@HU>!UF0kJRf;vb@M_!-AGS(#zXrIpU3VE%tq0x(
z#}IWFH^{jbsW+3mTCs`_0q=_U9BU-EyRHKUvwDhIGygyg<MUpE?gHBF0LGWuu%J{5
zHA!?fUynh~UFXDUyERL$*z1YGLMcDRjkjmHdEhxPm7Y)h6j{dqnK<8^RHrHyspbY`
zhB`Y#y6z>w%HJ|7x1p(aKpjFQn2j<Nw+z=Yo<(s)lC7n2$?-ifk%3V<PFlfWHzTF|
zCZmN7o`j6RgsJTqt1|suE%^j0Q4=R)+{6#zWNg4#DIfg0lq041V?pfRhhAlJYytxo
zYHox;^<>a*07Lai0AEv_sXa~tcKM9}P6N<z6M%C7{Efhc06qs$#j`AWtOs__AEh8Q
z6JXDICXYSLV~nbv4_as=^v?t^0YGI>V?9sd*5#(Obk;0FPew7=P?n!iug>(lFXBch
zANLM_YQq8ypL4~VzMwPRun~8Rw8|IkC8pjClzoEwlFsr8&{}b=1MC)#-UO5rd-ZRs
zd6cMh6bE^4_PhnC^c8}>2DDog15bXLjXoBXTAgw$F!*0c{O=&JDsErz%1L5WXd7=s
zy|YeUFvf2|x++zi&q=*J4F;)~9{^NNSsrJ}EVo|72WppTqTH~^pB2`OD?F)Lg1TFq
z5wIM~fMo^G!LiC`7>N$ZtU)C39yeH!R{6(-GzJb09pU(>$-EDwpj}l_Db`Wg?VSxR
zepYJEa8~GIf=!11)Ry+hLC8wC$6~fe)$MM32>&{w{A|5i{4L7(JW;usm#}$C?!aaM
z)a*G-TTKKNyOjBC-i+Y%W0c!|oyoFl4{WSsH8+!^%UyVln6-SfNspz0d&dcwElDL0
zz1vjsasZXvSLph5D_L&3qy?69qyt*H38L#U-KfJ_f*e@79WwROVXR^KIA5<VqcxYX
zjMewRQ4Y1B6M>ekZ`K*~M@jfAg}VBy>BH;UxpLy)cO_)6F?{Q2?UlLUs=gcKv!SE<
zj{t5Ya3z2@08~C?xSOPT7<NY^Q5RdWPPeYr(bahYxUBL#Q`F^XKJIJ~r@?iM?NEX)
zW0m(yU|K3nu7533!rIkkt-Q&wy1fqNt@6&svV*u||7;YP{RXR>k-@-(^qq<6I{z67
z$zS~{xpINYlkTtk3YKCKOJSTBUN4%^gYc1DhE_5|f?hwfWoGO&Dh9AM@KYQ94j$cA
z%%B5(hYHTi6<*%`gYO0UY72S=(ZUw=1EP~!(6al`y5h$(sTFHRl_}@NB_CEh8wod&
zYb`o=n8}CnYYAqaNo|Akjo1?+Of&z82UeaeHV@{gb0)Kz1$)&Hnu!(7`Uq;p#U|IE
znvm91FXuBD&e^p^(5i+HgPNP5ro6AoY#khBF|yGQ5!mTIf7VY%v)k*NP`f-SuHytF
z@K*?QTxk&2b;qp<h(7#Tb>CxX7qpZmguXsc7KpmDEZ@_J;L5n9^HZ?@PBa3GL~d<Z
z9b<-zIp<F`2y?dTr?TS8SQ&oLWV1h@{$vu%HL=kU`*A79znOE0eq74&-zgy9KMStq
z@H0R^IGO0<Q0%e#@x8C$=1HJP(n>eUw)*jHui)Kh;u_~#P_U=+qe0_b3kufBxTb#(
z*btm9BaCg}8^A}-0GebCbR+kC=nr@qlmXp9AHZy_{#-Zl>va?MPXpM;44`R)to~e1
z3h3n|zOgYtE|VyRVKIs@_)2Das$vH&GHotaf1U#1|JXhP5q2XwV`8#tP%^Xnn-@+7
zfXrS*E8%c<0P~WIbu@QOq;%($yFZtng0t||I(#RQ{A}F;9Q(JqSVOq<6g*iC<^oV~
zfqK7%TcEFjq9mW--%#oxF3Lds4)8FISbsrJ>a{lDY8HSl0LTTP`77hlfVYHD4g3{n
z;~sI>dVXsi=$8vXW3#|sG97~6U#tarxE5qzP>ux8R@`p(g{&ISdR%PT3hv>_1NLfR
zco;QeuMq~GJYZiURIUZtm(HOWHp^J{WdvawI4qA%%2lK!Ii4q(*CyfAZy^ZSNUd85
z`WzlyYfc{U@Z4^Xd=y6?H{e~u4fe7Y<UNP3rPqSIOZnXS^;*zqFeA`Rt$fME-v?Zt
zH;|X-O6H}Pg_0`hp0X^I6q^sSK4c)Nh83U>8Az(X1F$}1AgN&kV139yQhX_3eaJvk
z{|f=@Lk5xtP6w<H8AuvTo%)c0q~Z4i)`tuvjeZxfK4c)NaW7zf$UxE*p2ML7{z+2_
z>wtgK@q~52KWQ#a#<CEL%@}|1IRIQ1iUSFGcy562BDPG5HxSzlTKHV}&<Z=e8a}YX
z8(u@q318YC|Dxej`7b}bo@v{x@Vi7;sBk@*AX5Weg-^oO4u1=pH~cWJ4qgkxVpHTg
zo*?4E^TkRY!i6gj&m>5m#>}H~CPDJkiYL>jeliI37X-Fa&l~~dCG`MIb5eOGLGn&P
zqNzNSAo(@*1X8k6c_u-!Ic+<2BJ+4(6qKZ{K~~8h;&WiA&orJ%ki1t70D~825~RIN
z&Vw4qnFMJ(lOXw!NzbWG<Cz4>-y1x;Htk%R{IkJ3)TRwZ=E=&|`r6l~RZ!k*a5<Bp
z2Xm0uBAi2AAuY>l&f)1GTXGPAlW<P9lW<P9lW<P9qtD4sWysaR2cRKak~#*qIp&<~
zRBoGa%sJVq+%|!`gKY8C{mjUmlby<K6OK72JM|o<m~*mIxoyJnt7$N?DV5tMoS-@x
z$m~>Zn{ZMTEuNpsZ4-FElE}hTZkuq@6<u{nYA!0+$&|V8id1f!aLlq=>I`PuUY!bU
z=cn#srnzbvkkzT&HsKU2cKGX3xzz1cDmKY=soXZ<#01%x%54))l^~l_xoyJfF36VD
z{Y0vzakr*&+k{giwrxx0wh5<~Iv@F%bFv+?tmfRzLdvq5vx%TyR&#D)arLsAa|a8^
zb&(ioK4&wOVVx2mYy>K|5UFfVp<d}yaZYv-1ik)j`gV8-U@JqmN@U1ZiSRHGJl0Ws
zMc(W0{sWo*K&CLacc`!&J`m1AD|^Cn_&`_=9|+6g17SIQAp9@LI=Ef^vvN?cVL5yt
z9896O96k{K#o+_(^qvX-r+j}@*3|raSvLJGeE&YKVCXe9|Nc3E^_rUhbF%9-HU9zL
zI{NSd|JQ`|;RF6djo{I1YW^SDb?7xU4eK>E4eK>E4eK>E{}JZ9CzX39(Ct!qUn=)Z
zU`r2E4y1C=1UBwW#J_Jdxo5(US1*8ADwBIAuvv$gqcXW?!rx9*L{%pDO!(bHvNO47
z!jD%kAds)JxM#wTS1*7Ss7&se@E3_(3164!4;y?AGe>g+_8dkhrwUl!<Pqr6@>R*L
z%u!xP=td69Y3u@)(y1gna%N!}<)hAAwnjNcv#j>qVyy-%zHiXsZ`3(hK>4ELVDe<=
z@JqLZn0F_bm%CsNmQYThrE(UymODY@a@fa8l9hKg;X<3ns3E9_j#wYkXh*0lw5hWr
zmbEmLzmvIl7Ha;J=$KWJh*|{=)bqV^M-7kB68zMLub{M0jQ(B<Q2i&YcU_8_Q$NZ*
z*9@HBq5Mhuniq(j#INK3Ech3|i}tOIQ<v3CuK4B|RCZo)Cg!(MTWV_y>h?WalPb7X
zynAI_c-LU?(gm~c`YxEIEdWUxAa=e^#bZH!YQq>j`nzsH^;SbwSMDpn0zfx@&$jeg
zVBSAtCN$oN-3g@wAV8gqFz#Mz=+A*}SruDo$jTLl_>^+<xEtfNN~wsIY=tgR8JmGJ
ztYQ^k2&{_Eaj%h!V!*8Kd!BaDoN{!KV&F0W#m)tB(aO5*f&~ngtUIMUtkMZxBpDjE
z@+fc7@PMn~OKPY#jENem<H&Oz_<Q`5jd>;QN`1g+e!&P}Rxdww+e}yU5b%g?%>ar&
z`3=owF=O!CsG^mSLz^ToLgcIiJ_}vm-z4%QqE>m5ktb{UDG7*GvKu9AG|aEKc5Ju=
z^TMwCkhF<*d<~%6gJ{V4=@`Q^iIhu05uWV;q@HgudNzVhomE9f)^qeB0Ca?-0TgFl
z7?*4kYpM9JM$+}I7+m9QL;C?n^RPKIimHWw1fpLZ(Z6P^e6?Zf00$}lX96PJu5X$w
z@f?z$+VBi*qe)lLHX6ADK+WI;+pL~b=yc__+Jo6xuhr-hfzZop7so7BX|pS?U5phT
z1I`CEX7k}*J0DaH=D$QG27WyOmdSgS+*<iEuQ%`~<mqm+56?fk6|Ti%PqlOl`Cd4v
zfoo4go;{@J;L@N0^KH6XjpmLdz<b%z^wjjx)NSC!<T3DI^7PU?H<Pa6>{`4<^SY3+
z5I3Jp&#L1v#nOG?v#gh#*_L{qy>1S=o)_4O<lt7^(E~M-1M^>Ge^~ck2}EDyL!wT)
z<Cl0x)X6gEP8PcEXI#`P!Yh6Es{+PIeNDgyX1<FWa%P@^{`7U4QKv|KLl}Axd{aO^
zyVP!)Qg<Z_{FZ=skl}51<8?uT?-K0uGD~}=%FbaY{~;OszJ&)y-3w&-d^$a+?`JK9
zpEMy0dFOM>55A$xl4R$9&U}0Z5!q}R`cS+ZxrNqM)A|l?ksp>QKT;5?yN_1=L7u+Q
z;B!t!iR$ZNugdn&>_+3VJT!(swc$*-d7-##wujB)eHi%lv`R}X2F`s*xgHi_3$RY|
z@X8Z?$NvR*F*EHb`0c<Oc)Nryic`O}lQ(yzXMZYgoYz4A3Jl#yEd2o3Nm~JY2H-UU
z-vF5V2mtI5vDQBdAP8U;#+9X+04lJKRN4tZ=O+PF0=S((9{?HK01N?e7lCmA_7FH8
zz#~rq;HQ84{tduF0EY=Q1Gx0>04@PAeLH|_0bEDm76AVt!0jzdpT+{qqX7Cni%Y{1
z)X+Pt;}(B>b3i?9AC91CopF~v0M@P@0Q^7p-UCXiV(TBR>h9@2r@LpmX9k8L_e8=l
zi8u_YC5|FWRFohfD4-}ZAY3JkiHiXR3|D1Tz=W7EU`A0fC(L?Hh!G=(D_j%r_uExH
za|XHZz5n-r-+Jr6*4JyznVo9au3dHN)Tydn=Pd$p3v{MfNg1$TK`yBV(Ee#A?=}~V
z$~b6mK=TQpb$S2%Bsq#5FHh@7A01eXWBl>8fh!G1I%u(?@&ZHIMk_w|{SD$`MLiTH
zX@ywuBe2dC5etrZ##(R{09%?fteyng0X~oVcuLR2XT5sX0P9Q<(eoWJDM{vY4SFi9
zg;S{KVP85coL)H&BI1?o=dDcyI#Wz^4F@K=&I4d=nqYOUqpnAMqo6BEU7~003sw(-
z&J+<nuLB!E@4}C5{+{H2#WBT6NQ~YcVNjU5?NVqt9A|MdsF5?slja)3;X}R4a8HUY
z9(tv%D?UnIHT2->RZD}Yt>UjPF!__m9BNsIC>tLQXI^A@J6X0N{)bREoxTA*{Y8|9
z#FD+hjs;et(0y!s8GsAm)>i>!0od?5fYtzfZvrR=a0dbIRoqK}hpzN_8^ACCnePDL
zMyP)fm;|8xy8vbac$GjcfbahafLoz<y$68%pH^b3qU16F!4Cjj2Vfk5O#n6kIAjZe
z_{F9i-73&nSFnXW3TpI2H0)KN6!8`xj_&FhP`cc0h0Ea(A2@IdoXh6T=rmP)<t0WL
zKXluaXGeIdsLN_2vRRoQPj)Ne^!g>ppfgv=N`43S6tICatgN&Kh?lr9<hYM8nwf1m
zvyc&fMd39`0aB7TQ!BS@t)O(waz(nR(qgwu3XFj%TMo@HK(_N9TF@7m-bsGZU6&^L
zA1`_4$75PcK7{7AJE8eL%N5OC&RmrgA>Q|Skds#V?9w0{ByI2-4}ZAfyQ{Y?4X(a&
zSumdiIjrFXYgNAL@{vb!j*-N|3Pgg8oa~97MA=eslCe}-Gl-}zUtVO)V6(l!Bo40L
zVVd;7%NtFkSxaefm$Q}|Du;#d+3c1vyR_3~`KilI9)X{YfPdL$A7T|RG%1-EkGepS
zGuReTiY2N|f$jlQPqy}40h!XzSDFO$SZUH@cj*ltq)XQ;jM!}un{M>d*3y9<x*GJ4
zBGgk?4hj%)XJ^z0ox{gi4?dP%|DqI;Z?L+WV+I_9mm+SVWIqlWa6Vaz_ymbbL!4rX
z;qD3nw=hFy8wRMsr@}0acV$#GavnGkY(VcpVhAVnBO5t;F@zKPky`|u$xOy_9%9Jc
z0KlX96d%GP_uL80YX}e8bB_}$kJodj36+QHx$`(PF@y)?xr;@BhugX5J;!7`lg?ek
z!Vcm2a_%)07<voLi%vv;p!kM0j8l!nrU8?gK73Uk&PdN<BED!D&L0iz8lDQ}o~qf3
zhjBoph9VP{(TDo@;2K82s5+DpeHlH6?nDmh+0@8}AiTzl8p<%fj4CE$&tZ}tc6BbY
znJO~?>@OrMo8KA~B6<idW-~GNOCgwp8a@#z!=vYe6?D#!YaOoc(c~QkKZZxH5-PVP
z9oD`hSTkgXijB!+E>U{%U0RBQQ|{r=fV#6aZgYJMTgvy)!m0Z`S0<qp-=bi?_<fl`
z$M?Upck_Ru^w3iNCrS@ZNv4}!&n`~avy0R9?BaAiyEt9%F3$gn(!-tY-NpGoQF@sA
zK%e+OQF^$)a`pd@QF{A0i0F`ddYo^c9=bjU!$=bx)PV~uAMV6-hHRYZ#P9{i^~lBv
zi`BG|jT06d*+w=_SZsV-yv%oIsumw(149u?tV<bYaShP+oVPyWsw9Y*dcadp_Xy#!
zmgo=izrjy1Y_EJ5MyWHdHbOUWd@IS8+hik|tk>XFvIUTqWVZsypYKUlV8ZqaV>aPa
zP_+Qb3QV{g*w|cBfEnJ^H3bsxR$#*2@``K%&IuOwv&dc`SDVxfc`IDzq2KMHzi;X7
z@aTTk(DB)p)&p5$sOw@4BzsSa{qGbze}ZKv!G@i#f2n1$FqJS?W5idq5Vq*HbygOm
zGWqHH8K9e}owlsSPvDW_ORUsPqmg@Spav%r+YtnY#*I-s9U7x{I(njZI(njZI@+k6
z>yVd3?R4@)?K}ozXSp0rlT6f3Cr_*mUD}zpb!M#10T)$rK&(wJZ0@`diaHC#MkOr^
ziY3;@h6DAW7^8nW69Tgj{v9kFh(74tomyBO=JE=lh7g-`DIn$vbd^!ZucefcN?h2;
z<2u0Q22m3*4h^Vo?HYz@C9TacZIyNYLMp;<T>k$I(;O2{GXVAVzi^mB^xRhP@nAWO
z#_Y2QmN8o8|F9t&O|}OsBmp)YtiYz7E~h1iWQ$CO3B2(ftS}Q2se=``D*3;2utJPG
z1X4q`7<UMyhHNqJ5J(-Y5c3|a5ZjIRn>tt_#vKBwgB4<DkYfXHV)kH#lc8ry%pR;T
z56H|IcL=yP@FwOxSRv*;SRuw80;z))Vv1?(4uKeV2;g7^jv~&9y}?Y|YR)XLh<OiI
zi1AKM9jp-Z9;^`K4uRCc3Ni1&3Nh{wNDbLy-h&ll_F#pJA+TM=1L1KFpv+!qjp6Zq
zU_<6Sf)g22hLbeIqdS4^{6N}R=>wgA6Q0B>3*bakB9o~iyXhGX^p`!Ofne&4272zm
zGaCAU7IfGiBrc5}XgH&xI}o8>o1$i`s6C^BDa^)$Nb6U?Zaxh8s2tgNkRuxpnjZ>6
z>WqfSJB4`Bv@tvcQ!zY@1xm&65KhJL5KhJL5KhJLbVgc^{+OqY;b~#^8$>=Ik19P#
z3=cc=R1D9lfKxF%6#svU;h7AXR16QzNX76FPQ~yLPQ~yLPQ~yr-<`3$VJKpF$oMkG
zH5<h6kh3So*&4*~Oh*>`a=G6CF+4<+&gFgs#PASvbT0QBAclu3;yRc64H{y2a=G6C
zF+6ljLbv381H|wU%hS1RCWzr-x{lm$!0?&W84V=5m5{^NbW>+E1oGIRX0y??@`U8@
z6vx(bT*EXr!ZvbT!!%N%Z4&gfy$I=a<$e%S&!~F<^QY_Aqm=DrZ@&n%`2-`d`KMa(
z#lR90L(q---XS`FD!!Z6oysykMKPvPcMqbof##nFu^sk7$oUXmJp~yQtOI!+_yv~(
zcoIP2ek(L2jxmnR;1*%j(;I^rs&LjOp%F_&RMB6Of00Vw_A?|u#0oS?&bWFMcQj2J
zMw3QbsiWX&{&am|1jUuby<r58hOTy3Hps6cs_{HG$)5#kihroM^K+D!U&zykQF%|I
zVWPu{&iDdoKca_A%lZ=N--wPN+6g^shX^$v!5Za8`HnkLxWs&}-HxWnaS%yh)p866
zL05mpg^65*ue%tAEChMQ@sRPazHM3FyVIcNeC9dsYs>@By(S3|g_SEtf@qF;@_oyd
zY!CN9rpr<*a{|0wc(+CPh3Q7uR~GRMJWK*Z;w9_1^+tlZqINKS44Jegs#di@vt=1<
zjelk3lQ39cGXf?{mA!?mrN*P*K<Ne7CdI;3l_4?Wf{@}*$mg9zR~@q-w9ydmSO<FE
zcGBbk&c{KMww1KD?_^HXwx)8b_}1oh0)WE9|B@4}cM`U7J!5smTSCW7(>7D--(vdH
z50;*7(;6|iK1o<5sbI;#uq`gna+l%`22j}XU`oUYDaf5x$6V@opf06jX-dbv)N$=!
zbXW`Cv8lH)^=VJ0QvaGtUGY6qSN|n7Z?S$>#UAU0Jyda45I2K(VkS~bA+Dv0sRvb2
z1&+@qzZ>m^jp%e-u>!M-?Fao%XXrDd@|#$R&uzAfmZA~!r|a*-ymY&+yd$3Do%j~A
zYhOD9>)+4q1HWnyxH}8LeV*JMK+T=_BJaeLegHZXAN6}_KV+XFc6?WKS}zlg|48&y
zY#Mll=xsprKBEyk*zb=2$(FzDx+J&|CF=tXYoz?ofiLCX51_Dcoe@g4*;*u!>O0$}
z9?8^S_fMtn@v}|66hK+CCaL9InezSC5$t!TAsKwf*EH5l1@0~^u&DAjRylopw#bYP
zFHwjm$**ivS)|HO_3+mkzMs)1g-a}h%2SmhDpl!=G;~jewWzM48n&jx(b=qqJ$&Ze
z2fN!{C$dCK{{;ulLJ##Lu^R-#W)H!9zo7Fud%bZ`863mkDNvU;41U)8CIhX4OkS%5
z(0>!H1zLEMP4b#_E;yKD(a?e5(c)2Qi*4tUwp5+2+Q1hduS*KE9IaqEl-oPGJjZGw
z{d%F}YlFh<qzaGlFoo6;x)I=|Dq69mS$eY-2%=Q{>H6+5ETBs?NtWgS=nk0LRc1w+
z$rGBrU00bGN#Xbu?;N-hNAS`&m^SGuQzI#~rW@u)nhWm>=;}5*g{|0&Em=j(G*@p5
zU{HznUb1aN5)?R0uGo!`0U_~Yz64p;L8!YpvOw@{zze_IkQDI-Po8Z(3BSE=OZXkU
z%(HqM+ZiT8;0>Os!m-EdWD#dVYE+j$Z3^C)<wsc6bgvJtL2~Qf{;K?153{{6(Yy9F
zE-svWy)lX@#rKP`yJ;I5q%PcMS;NF?dVL*Io4A)kI(<J%)#W)Wm5Uec@}De{0J6r|
zVID*HjE=Qe^$gu$vZUpzLkU}Nd)5g)A!XOjI#hayD=e{>nG4~tyO)^@5zvIau&?OF
zg{{aM_9DIVvH{*9RDPu>a+iSoHc{kW0f$lGev##Oh$0UVtg<06vvDU^*$^0ZV7)!_
zC{s{F)pFtE8hs~+^Suv)!QuPm6`0TIYCio{Z^o!NCPszN=4!rIRx=}Wkx@$T7EC%v
zVsW3QkX$&zFhVbahFqu+D_1nea~=tsOEuM0GeIBK+Xk?(p|V1%Sxwa(_#SXkeQf|s
zKO4Z(w?SGU?z=#K1M#mvbr2V2ARY~PfI-yi0=_$~%HzmdR>4lj9m`d)_zg*Dz%Y`E
z@LN>$zcjtV02cp$3Scn{ViLgOm%~gXfW<F|nMeSOUk)?z-v@X5FX)5Z{S097%V8#d
z2C(=W16ceLz=97xf_m{Z$foh~3I2k-=q9l(eu-@fnb;P8V{D86=2?*SUyT8de~W+&
zbMZ@<i{o@c-K4@?HXxtCv}Y+@59z?1bTB3O#T<m<+JjI|2RZx!tPY;>6@(E`j7kii
znG3R`(x`Dc{=~!skGyo8tHFv;#&K>W*qzzE1&h)o7{;BAX0s|(b~-5G4RA-u1jB@{
zMSh_kt0C=#CzEc1VZxiyAB0RWOn5gGhD<O__;NpB6ATl68ci-Vh`uWfXF_pk$Xvi3
z!}n0e1jB?&K?xm!4pmi!s|b(uL0dAM0Z)V`i~?LEugjr{gvaCV0euqTnPD!8hi22{
zMJkPMSPoFi??W+}uj8x%$%Mq%Gg1QS6~BV^-xd<n;>u01#QzN}b^G)oxCZ^Gn;c5;
zSCq;fB;ai@&mATp*Yn+}13@q`GwxGz(xt@AxX%l0VrJZzH1B2;Gvn?M#Kg?Fuj@*1
zOw5e?jxIoM35l6;KNJNfX2$(kGe;9M<9;E59St!v?vDmf#mu<BSiX&!aeuYAjhS)(
zw789#akY;(RzTaB88={Y#LPGjD?0u!cqP|O_l-o$$SkFcVm`(}sLUNnAaP+h*)vX=
zj&nQ(i6dzmB>b<y?r_CaBy=V6Ci2TJxGg-o9U8NVya_*sdX4<fqB~(8_Z|6za6J4l
z(ntOzoEv@$nML*+_i$b<qQqAw@+P7MsgTH<h)<9ziM+uC1Jjtun@E}<H4=G)*#>e(
zO5{x>B*=J)yotEF74A?Id4qX~1P~K>6Y)mgM7)tVn3K307MjSLh&|9oB5xwz$eTz@
zT?}m|@+Q(&_XJ`hZzA5v8_f7)z-J?GA{By|$eT!|ASUuA(p3->c@ya-O~gdrM7)tV
zkzTql^4YGMaWX8j)?G%AM%J^C;o`$V+CWf+_n?v@*R!}zI3JJ1$j#G0W=-x!l{pS8
zQTi*IE%z&_tWKdGo}y-}=B(;SU(FObMNkrmwq63ZiNa|ilVL5qQ8+oAHVZ_%Zllmu
zNbp~Y!ik>nF_ZtNC>(b!EUk#X(-TcB%tLdc|0IaGXXG7ykG+c%UO@PL!twCb9KatC
z&JCYT_(Q^p@I2%a{fJXm9Z`PfX(!xr&4gR@^Vw*j;W-rhVj2q*zN`T7mzTjSPMBSG
zboUm(@$jdE0e?gBbzw#dM)&YO-xy|GNAxGco5S2E9sOl4WF81}OLX*inz1dMkE?;7
z4ZjGkfp>(tncBebgdZn;Kl3#KKKMWn6Po}Ze3OS96X1g{@0<?deJwfR7L5s_bW2XS
z;cGi&Il3h$+@d+6BCcC<!Y$fb?wnlRk`r#xcA9QU=vJI?i{=TIr(1HuEm|b$FyZDn
zm%;|e5qCJWCv6Z?T?FO!LEU;z?TMJuOWXxgSfYIL399fgbVs^?_mBexOwpzTMuNU`
zr-AE#9e7)rg*%rZB#uG@Z1XE6W{JeVKyD{fc7m%mW;#!JZP3XZ-ZbJy(KJ!izB{U4
zPxsMQJs5HcIkIEAk8mDdHw+6I9tJ{$rO78tpW@S(H;A8N#HT8Ks%Xl?e4c?46EK$0
zbA2NFQzHz8vtUXA&l%TUQv<QKAn~W`e~0cuwk_S2&K&-4jQm^PkQDAe5}0)<wa5k_
z*qo;;uoKhuueHma9a2YW6#Nq-YkgFOm7W1z{OS6$@C+=RLW7QC2AhyUVW$Rk{I5XE
z8ql3YA0m1*g)jaMXtxHm#qYRZR$+wv2c93DFx@bL{qK5EJ5Qa5<Ao+NFaPR2OFO}z
zlUM_9gI6N4S(8@_Z{4ykms8(yyfI>bK+P#LFc&d}ZQ~fAMd#WAJet58bgLVaP=fCV
zCeYxKC%2@Yj>&;4OWzH8YGZ2oyHIhLO}!09>V;jAWyNlgH$ijR-)*8`9ut{4t<v2#
zK?e}WLfm?o-?e~Z-9r^eZL*;z873UYf`fmf;QPR8e9NGN9v@i!CAQD1G&+q1m75@-
z(pbv%jd%gS+Nnpbvno*{`RV$WXy2xiMpDJ6u-8<Qpl$yIDwQPYQ9z3~SsiRYFq-oq
zC{$DH*j9LMiz?u^`1G>PHqB!V`F@6cP2HVk>TcDtO4Qxith-Kgls<>`atZS5x(6QZ
zBKPs%NqY*k(!Ew6>+0{&#OlE;Pigs0Ny&ju<tBdXRJyZtnB~!(uLzHGqoxw!P#i!b
z?&K!%vLmhRB*;?tVrnhm?nYfb*YZ$0`RV%kn8`4AQZ;?}B`oZWFAw!)S@f8qr8WU?
zs-p8OLcf=;wFvL96QG3Vc4Z3@yPDi<Y<)%Rto*4kOBL`#rFuw;)(s^7bbSzJ7T%5*
zTRnv4w8NWb(JkI=AFv3$^oq?E6=t)guU_^Tw$EeO0eyffdcBE7Jg-_`v(wTNVh=6i
zF7R$i-hJ25B0a8~d|$~RW4p;0zORwcn^CHOZ=`yYx;ZJyV^GPTuKyg5zAn;V-Nu`L
zEQ-}Jf!EA0;f9iX0qE_oLl8%ZlzwLuFGK-3C&MaSJyI3@X6Y+IFUsARq+)dykkSqo
zxf96Sl7io~FRJp&jJ3$~km-a>q1E-@K5U?9f&07&I?9c9T8ACw>Kfjw)Od_lB8_3T
zMLwrJw|Miq-y-|KIaTt4`nPRfs`ORM=3R7g%9LAE^GKz;JnY+3?CTrYX}2WBW~P2I
z#lAMhE{l2CQpT%NELD_mJ;)ocsM3ohy~qfQu=^}M-6Glf*qDz>gihlS6zQUr>e3sm
z6mPi+jZ&)g8Ota~avo3uPwPrm^u8qz1-W#wEih%SurfF`YK<jN0QpX@&YvuUcfdP_
z!KMv^UTk>0vC}B}&ErYcJ&gVbGly~OAg#rXXq)ZP%XOWCHrS)2EkttlG;pp(3+*|Q
z4YQ@-zSSr97|WZWm7tIFzD!zG^I3{xEpk4PX_zqKExGz+J`GTovn-P)FBPVFBJ*~=
z+Va?s+-`a7M_49&xTmp=j+b8YUmjI&HLCh+>Hn~TY$&CnO-U&(dpjS>D@`NiE>)Ik
z*_0L5-Kna@JRCP{>!caqSvgJ!@P|)yp{uH@#RPRyhLrz?U#e>H<u8NwP+Ik#5AHzW
zo+c=`g9NR{%s~$cryDG<F#dp69oNC<F(~bQJd)MuQsnX&=)I3evO@)ZHVtB&seTy+
z>G34%XpN+w9YUQ}*IOGMu@Fos>mgxycT3gX1F53*R%jz?OBJ=hH7UZ|1$*o^57w(2
zimIR1d|}vmyI}-Gn591gy8G+^)k@%WvR+rypcf^<p1&km){wwRAVGJ|-eEaJ-C?wk
zXwcrV8N%Lz%>M&X_dYD|`#aTtsC$9e+yS0oqx?wo%WPAD_vmmq@Q+3QcHmt{g5P5*
z9HT!IBEHI@dh>nV;$49E>tyrJffm$1ADR98TAIZ%Uq~M?-=w@fIS%bRgc+v@{Q!68
zsXw~2Z=_BBP{Vz82^f8O1SPn9k}N>ZeM6la@VANYVsQ-rIPCiGTg&2>i2N78JJx|e
z3yON1QyYC8r4Ng+ePAf;V{2JL4B_wHB+);CnKstlHx!u`M1h+XbiwBUAIO)3Kdrr+
zX~0<Dq0KP}jAN8^Jp?Lv*5SJV%09i*R8la{I7*_RY_yE3F0tGpwhA{xNe@|O?JJqJ
z#6;mBW|p*qJDJ%4pJX&0Ov&i)0Lo?^EF-hpF6REt^5g8Xj`aPUGWWKWmR;16w)r6D
zYE0XSj#XAik~)U?s^C_!q!nH~#gdT#%6>VRC0x@i+HGCN+otS!EA}Q3HW~2@*T~QX
z2C(vhac=Qio8Si{V@IF55+WfCkTDpAKe}_<q1L{*wSBjBrmo-B0u4wSgqFHp0rUFG
z&I0WtuONoHl?LV){&~cuff@W|;HKRKq}{ZLgD(v(P2_8Vcbp4n42QBFb67VS!nl=!
z0pc;izXD!1*V>mV@KV@WdX^>fQ@{(Lg`SWAF7sx9fgne#wUE5dO7f9#t&y}(v5l<;
zN|E{O=%EHb=*efR2%@ilBGo^a?e*k%KyLB`;XvMTc=&jPH{B4v?5ewxl0#IkC{}$-
z^zlPW!P4U@dgI?QnUp;eP~6J4Z;-u%vJ*viD7Sp-u|wza->9LB`ET^l75q1T7;{Rc
zM$aKXJ<oS8lQR$h{AJhKJXH;a+aG9Ft<MOarW*uRcODe4m-s5I@UWET`c`<?=zAXf
zizU8JFn<lo&{tm9m-xsFWocD~ckm_h4nB(*-op*H0ay=iMAgfDv!F4M4SY=_z5w_z
zx+9e>p1ktYb-vfIoG)b#{`kUYAc`A;KR!&jf}WxB3VMopR?u@aMf{Ue=kd=?P$zY8
zEAp&holx3%sIM(_n#mj=)$obvmnqTF%^<1<PqcDun?FFGjE=h7(UB@%=wS=%Ioq5#
z;=o<#R24c^#cVg6(CEb}Y<-oFyTj^i%Dp~gfv)d|+oG?m;$G$BbKzcC(Dwvbp|AFF
z@~8x}TYY5}*WfFO&mn)U@V_N4%eV$VG6$ZQhuAfu?@r*o`O%AOrP?xE5XI2Ipv!^w
z*vLEcI${4tJhu^_j8%r-cr{%o+{c0Sh?BeC$2XRmmcTz^i`gLk^KHa?5x-IRJBZ5}
z4I8C{Y1s<6oYQcN;C+F2T!#*0Gt%^sp6DUzAkL@Y{Ve3ef<Fel_sKJGGRz~A(Ko~~
z6S7sf`K{5NJbQOiT$)oL)g^DV+(>{b;e9+_z+-qfcie#-^HB<u<8z{8Jam{GpBH>R
zaFgQ;lH<$7k>iWPZP5lfw!F7#j_jLw&Tm7G1SQ9!Io3G#^hJ-~W75fJsh1xwTnIep
zTV0)1I7JEqa(xjjmC@lBlI;j&E2Be$UL|NZCTG|58PMJ`ud`d!Rbs1Z=@nMzqX{%E
zl-YD~s&u`F{-UMVqFcSqL;uv$PlwSDTKXH%Q}%{M_)<fKoV7ux`dY(XU>z?HvGII+
zSG^cdsDJSN3-C^x92EKK`fE_mzA|C;gLr!-OsBVh68U#okncPOEP*)lh2pY5Eq#>K
zyM1o5#^q=n)vFgeY5lu6B)%mn`3*MN!oTC&!N2mw=HJDI`R#BsNtb8vvw)i?;-A9b
zN&IfOMei3obJ}Zl=-b4VpEpEldz-~6u%-aYX(ip-+0xGey^p2C`r@&c&Rzhr=84W}
zuCaKKujHMS=AU9^MmCt8iHAv5E&P+_XP40%R#Y#tQpiAlzaW<$Q*)pp;-3Y|sSxVH
z$#@+V{8HkawAbl^-%p$q`Z`1K_kfqJwMxx18dbbv*g&hlXs+e)9rUox9z>NqMvrvl
zgcbHYY?&r0O1@)hy7YnRuD|LYLv$Ppl~hswO15Fl9Hiujl6aLNu1gWeQ_0nIwd=1>
z5#J&4rV2@Zr6msMPKoeFuE`ANPKod>0`7p)@FoGda1tHM#g*X<7mm)`MsN?bL>DlF
z;fx%PE*5a9AK;3<xDMxDi|8dn<z9>E8jgyG@5Pua`VXO&<B1a$6Nevz`Gx3>Le0wt
zc!z);(gAMe4SzUoj`oz#WFOAG7SU?W0r?09vFKxcGZQT5E!O7|u7}Hl(Gt*Qt}~*J
zI2*R>)@wvE^{yM41N2Cq>DjC+mxxE!q1(&o%swDV$D0dXJ4%h_=S*W4$_pTG?j*@-
z%yTGfyoz`0ZW38YHI_%6lEl$_l0fnzXit6uNR8(HkjVM+ikL^fT$mdkgIwVn(*Y&R
z?8b5rC7=12iwKP_M*8q<Nk1vYAEm~%Ks{#d(x;NdEY(p*Az_x!H~LJ}W%hbWu##Ms
zR2}^S8bfxL|5?DJyP)A`PZfzfDPc1Dj_GoIL^zw(=n*yg4kqp=tk216un~q_!ekSC
zoRqSPUWGKijlmjYPuS>HHTn@Wg7C?bGpA*eEVXEZqU~%T12ylPB*#@rwhA?dA4(1X
zPOCU$la%F?@qAs&RTtn&1}92HiyFgYF2diE$O#i8J!T0EYJNV8&iC>p0r85l_ejQn
zr;ok|EXR3Ju8-jwIT~U|GX6V#<SRnG4#tk=4x8|FDFI(MBnMl9(cIG${>1cv1>i|5
zU=xvcVvHI6AZ`h_zmIF#LntH{acCT*q+G~M4hI(&@$Pb*)|ea^`y9&4x@IqG+SxP~
z<r7@gm|M`SbB5BP>`aY2j(G?r&lxNxNc&ZjP$>a*buo0BO*xzJ%=j67VydSa0R{Z|
zOE9D3bR(pLQ6K)L&T*A*3^kk`I}Q?Q6btf{R^J;ln8KV!>o<|@e)BmZs7a$5pZN}v
z`2bPy0o1X7c`ehgL+Sh%*AU!CaMcQcAtz{d&Jc0x0&QNyfA=iB1_jy?gu|KRF8oER
zafzwm#bmbM3M9A+U|J=a(K?jV2_`UHQR$DOyup0tl%7toU^74!ypwR@K7y+u9jv|)
zpyLD&8;wNnt0WzMH6`6SghyNgFrb`xaMUsiEMxL9)T-Pn3XCNjaQRdYj$_7HVvGlm
zxvfFl1dq0fqRj|Tvcier)E^pzkM{^qH^LpMc?NTF-1&r0D2904T~13*B%Dk8PYS~C
z?jQ=xk&@Dk(>jp&9Er6n#OA*-)qK%Lfkk5}a14oONGi9K@R=sNd?sAXdW))zxxpb@
zAe=sc0>cFCO8ya*Fd_YVf=AJZvE$~=SHa2jR(d`jc)^+UMf%?<a0*MB-hvty(BAYC
z3M`?OD$G2e0wh)38tow1|4*RqJ4~4*SGhfz^bo=U_i@q(8B4z<yp)B(k)PeDbQx6z
zzs3V1ZCo?lT|TE3uJIyVGDTO06KXRUSo(0J4YhX(o(%P&yyF0>_%SKTOo7BZK8F_h
z9Hz@U6~b4Ba(UpbyOs$Hs2nF=6E4{W&~Zl+E@OTx+)D^oUJsd7D%<BUT~-)*=Q@@A
z^pE=h_zq7%1pE=<?xt)$$T&TY1sP?F_XpDR7RU$daVxrW?gkyVBEO5}chdObqh?Iz
zb6kMUb5uf~$)Kck?itWa2*ysv{N34y3xwsi6_Ac$ICZY%9Ohk4UW;k~``asjJn%7%
zOu(Xy0{<+qTFwH*OjN7sv#{JXQ(pvX>-Qk0XOiAV)*NRaNs+cWB(F&IJaC`<@R2>F
zX(wq`FbyU%+ulpj@3z_D)Y%Q9K|Dd*i|BV0-H*{(`<%&?W!3ad0OhGD`g<1PRG<l(
z`MA{+hvmAB&RYPQ$|qJ(2T+eGeAP-+!+Ek}Ruz9?NoS$U8g0lNX&3Lc^nZYUsul0b
z{jy|6?n^>74q5{9N)OZZKWK+9+-%!b6=z#PYTs<N<Mt{p@F;l6qkzNb;$9x+FCM1r
zUtnL#sl8Hl7-$9Whj#or)}rz2JWZF4w5;2O19E*jggTvRBzS*pgxfmLQ`nb5`JaK6
z@Ep)W&9;f%)JsdI9uK@o&k%ga(&D97=X21+Pe8zfvR9ewXT>*J=D)z?hagfLl3o8J
z9+zOP`%#bJ8%+eCZz}kT6>R1x^{o-~uYPB#>hiN?l!L)+`k-3;IJ?Mfa8{*Xvi^_F
zhas+i$D7l{1I<|E(!FeN$8iMW`kzg4*lJ6kWtu65v(0i!kD~Z_VYD6Bzio?ARJJUR
zt}E+Ls4H85VTnGf6zR)3u8dr$dDF5{WXi2jJ_a3A^c4LWgjq+@4`uqHFO!0*f}^bH
z1Rou0`lxdD4{5bhC7+Tim+t}L2LB5G(%2LD99}Cq#7ytT?CB!O(p+k&ymBy#l=czf
zPGs|fl;7f7&YmnSBDow%9)&UmI@U;y!@o3EywBlPt-xPEweEzz$P6(0p=2CjtnNY?
z`6OZLBZLP%`Nj+rd}f$nzf)+>khdFUL1bqJBD=OgA#zNkuXW4Q0J{F9eT!1>!JvRT
zrqPy5tS##PBqWu(RIW-rLfgz~__E*D_r?Hl0>;{aF*9I3t{5<*nSe1fV9X4d(agd3
z4?_)ImF5JU%c<22r%X_A;Fq@O_9Q4cu$T2?&T$F+&Ii2XaPwl|55jSWn->Fr63%s=
z!Zom;aKh#0#Q?ri1*D_Ppx}TOq{3xTaKI->mCK;ufM1ZLyPN6L1gUWu6dVW&GSWSR
zoRA>nT?PdQT->`#O>v(<3k*c`1RyhA1_cMwW!Y@5%b?&urXcfO1_fi5b1w8OLZB~@
z7J3AbI#)4GuATtoY?nd7ftGqIw4LL=!A#rg(}1jS85A5S)@OpY%4JY+pj@v6a;3|l
z;6Q~S>)iK<R0^`uWl(USt00@*-9)<a#0B+$%b?&u53y~V%b?&uFTD`?Y*%4!UJTe{
z!vpJCNQvYPY#?YNc>~w8xF(V}a5L+N$A%Yz7If-?MOdLUJGvYIsjN<+{yjy_26ZKn
zbg6vXW=#tYIyZrl5j!m%jkm*rjZ)VSgT3($XtTNl)wRgeDs$0^K+A}(C%PRXx}4~C
zpjp}XC&iFUL5|@s8<kg!EA|(atE`JH_YQD+8?Ni$Y5P(L>B?+O4>`S5vrDbyTaZ%C
zrT5BXCa(V-+vVjfgk5Pp+3a$TX#_dF5Zp+w<#2i-c#D9XUI=a?*y3u)hD<x88M)M&
zOV6s7HDEbvG_C`HGV9!R<PtL%wgc6QFS@SJhi|K+0@VYZk;-&6B?;5j?98W}`MnI?
z|K%gL7!MG*h&^zC8>#{;3EIwx_cLqVc1j`aC+BVDm`^M?<`WB!`NV=_KC$4KPb@h0
z6AO<0#DdeW1@4bJpCg}GaO4vUj(lRlF`rlnI^RRHTY*c^`IR6u4)BF5?T!8b!!N)k
z?*xCj5bla_Cv<S{7?4%uF%W{k*8y}Q>`a1x5ROOKnFRkNoEu?h65LNX5oKo*RGLV~
zC_9s&7NjD|&Lrp)q$<kJB<L3;8D*)1X@b;5*_i}`f{cuwK~6}J@lkdrL07lKzbR36
zCc%g<1Tr(q&Lo(wY4O}BJCk6hAoHW_OoG{ZDmaUx>`a0!FoJ-yqU=n9xq1kYv!m=x
zf-QAtNS_mBXA*3ytAVVDvNH)5>ytrS6=i1<EZ0kcTp49&608tpU6h?kuu_nXQFbQ5
zu7YfivNH+VL!qMVOoBbcwrx>%Cc$1hiGSO12t;VyCipsoCk%wf_d*sKJYgU-kyI69
zeLVyyz7T+4WjdkJ?*WbQ#DUOQQ&&83AT)_pXippnO=glT_EW*NVZJrx2G`Sn5pJ>$
zZXl>4++-cRo}P3f++-cRnd;b2eanOn&$yHP=@H4F)X%{a>c|u|TV?aGj<ms2KKpRB
zkJ_L!7h=t_m*+uXs%G&dggrEyr3mlCEnDGVzXLMO=gyy}{MY{s2^D#F8VY;Eet=Gd
z6HWdbDH3mvAZY(h%(z+eX$wwJ{+r(hoSWM8EM|Q{K{~623e+>{?JGbDpOL`ShMrT7
zGDntxtWTvz#O$NYdhQayfykwh(Wj9fZGQX$j9ce1X<P-ykn#MFKyo@$Wp_;>KezO@
zfJNOkYf0s9rPyNs*&w&v#5@)gY=svdrB}7i#x%>7z$pbkQkxh|ni!m=T%PUFhH7um
zPeKZb<%;z6&C>ARGY718({Ks?%IkIQ=i`clA8Q7RT;iGhqyRolq~>u$S()YJaXF!|
z0YP8ADUX|ZQYrBgQ<XrMRLO#^vwiq;9DU%Y>-S^osbCU2#7b7s7kFY6)-IT4(OK9s
zQ}km3+-`N?ZV?oP_I0N=t`rm}(Y3q)B}Luf7he^XOd-7v^q!!12s8NrR*xSikrutm
z<Vhyq1+k)8Omzs+O@&Cc2dPfSeO&Z0Qw?L4{{nhPdhQWx{77mzY%HWY(N+D5@G3%D
z34M6Y14+f-0siY!4PIZ%YatRS{W(1Ey3=s5ZiEt5y2=XV!^z{of}>^OWP_y-0=?``
ziyQ%@^a+d11hUemSb}t;nXa_;gGtGX`fhC0SNi5wL%$02t(LwR^24_oIxG2iLwEf{
z8tV4IioUpMMVF4W$*)0yTEIQ!bPt`5H(ZZqX+9JGqt;uSYDJ09vxU49W+hItWx5{-
z{j&@uEZzzC^W)<kZe(>HWh%RFnN-{3scK7rb<9a<c~Wg3NVS0`)%N_ursM~!wx?{4
z=xODr&-s~k&uSaO39YhMY+|XN_bnpT^Swn_JzbD94PM$%J^darnX-BYTP~}uqpcp&
zCpOZ{rg^Fjy&K!)1=hAb2^4Ok6l@7>>P%b;HpAv|u!0?Ht!pgUOY{y4_8ALSI^JX8
zXVwt3ld{>CE(Km_5h?Hm7GZ(gqC!|;(;nHrc6#*jfGu*VZ$p!UnY+z>$T(*TYjj!x
zrm>}TZ9AZJq)F+PJ!*swR=N&WL1XD|MV3;!Q=vqa&a;W><|jSYoNMV)y44nu(%obc
zmhQK|l+O2<F^2k@!CsWkzk2&pRkqJEc)Q`%cCIxnml%E%AzQRRfnrW)e{(a8ODwZ8
zsaC!ia#G=&En^+sGFM!(hb|#5E*WAoJD5vSi5p$=DE-O`AK#HKsqz%zEmH*PfDW^C
zammpZ5tq!i2wjqa?zXYQ*^(df=qt8d(93dccVIlCid8;#27zyS=hN98-vooY&Q-pJ
z?9o2}V!G-@<Z)%KY`<+ZFCypC_O@oIaFxl38?sbcnPpH)m40!5691qN*j8)LV%R*^
z2=B9O7E_hJV6lC`c3YiT?S(WZ#}dEUipavG6l<Efscz%&g5kT8CeO7+T*UnF)AfOL
zJnFbH+z50+A&S~3fUc$dT|g^0+C)`MfgexuFS-Od_-?ENn&^zx_01mNodG^QUJG*{
z_R!Z@I(_|=r58d?Vy8uV8>^8}p5Lc5^v3ewP^HVQ+&IYXHp+AbM9~`ZWUp4@Dl5U!
zgE7Id;e;It7|gRC)E+DJr4I;xx_$>HMG96VQUbG3qJp;@(4$IHK6#MIhjsz_d3y*y
zLUaq!=4|*|>wxwu1v-%EqeNdO+M4KN6i$`_ts%ON=pRJI`HvIbSdNE%MLx!67&~>(
z#*o~%Z$IeWFF++3uyoYpNl>tqM<0NkYT7c3nwa!Nl1$+?;i%%d(EA(o7L8!`FV;b-
z1(uJya#xH`P7zrSv}j`j+*inb1Ze46n;o0*Xr!jnrKs1NEuHl@+tQasROuE=UjzCI
zq4TVB)D9nsrQcZYo#1Y<scdDR-cZ?gw_@q<R+w%16(el+F_vaMk%WD4E;!$&GDjwO
zc^{z4Iz5pjQ!$+?-i%`32~YNr1{;=ltdCf-51&YaZ^XJlAXT!OCk>q?9&G7LVEY&k
zeWInKg_ljTbb6w6fkoJoueL&LoEW4uwq|Z_;a~`<6KC55_J-wyN0qj;C1*Q-&1#Vj
zp`oFd<ynz$m}{j)_5ul@DVw55t|_--7-xm(`*JJvSKmwJp814v0q>#_R+J`78!Nrc
z!=2;h+S<9z!@tnWmnQI(<+8xnTP_M+>UtdUu%)A+B`Q61mWvMRX-=`=t6WcWiUq+K
z-?n~0(q5|S3EZCkO8o~gm!U7c`JLhTU_Jz^d8e5R69}aG>`maEa+bW&RZ)l+ytVYl
zKbLPyeUFDg^g`Z^{c-@h?FsVvVpI`ReRvE-$Q(nlk}SDMe&knQYLt$IzMw;`eK^M*
zzEIAs;5gD4)1UJ;QJ=3LM--7$#~>*m6xF98h3ab-+TR8t=<H^uTiW9xmlmi4%!h)p
zhncE=kAM}+BZuxb9I8_TxGN&MOS92d!_AO=4%#!T2($6Zxf%G(wu@KNlf^A;jMa5u
zi<+eB$GP&XZltg;YRtA;ayX<5h|N?_T#2t~BBBOzCkXRmYZL>jXCwdWg&?VZ*Ca3@
zH>3_A?{JT1Db*oil(L!P*KR4oJHS)2zANFh<^_}-v=PP6DP{JJI<T=G1B-w<v<xLP
zvtbL+MR4MM=aWf@!d5N+)FEBb71{}FGlet&47~6^kNcuwU0>#`eP+%(&6x^`;0Y8n
zv)8E^H8U9wVww*;GZ`Lo(j1C9C&GY$FYyLo_YuI#t;1EjnYjAg8Myl0k8usSU!!no
zZYkiP+XdH<`v52o!kmHVf>a3#po2eMk1c&F^7WHRLC=GW9T1|7M^)+m?S_0c$We(4
zQW=wRpXieA5RY5#P)SN%mm_J6Z^gP~0*HOEXdNlFQk$V;x>3!sS$v44KMnfdQ&}>T
zil{_kj#HT<tO$#(GVa0iT=%>X;1o+gf^__JeZCJZ4a=*--iB<A6+LN1*RHT)smF@1
ztQF`eB3F2<Xa*%HIIM#iK6gLtKxY!g#?D$a{2QAXGmzd)(wNPbK9rW=r|VZkkI6sD
z{BL0XFIg#iVRl14D*myh{|5RwhRz*&D)U>*FlFaJQy<3c)Kf`b)jYW}J1(Thq9Q=B
zQ#Y-$bFI{1D>Vp=W>YA01ZA#;Otaan$Rk;ih24SfC3hsV7zVUCoH>ffDj=D8R-Lq!
zUKVMMyQBw{(PeOD<`_$7BT(t{ELH(2NVxv3cIzgZr$fa#ujgTWaTRlIzYJ<Heg5V&
z(8=fWSME#T`~F21n_o);s?`yY_x(;U3Zdm{CTPu0(tn|>Q?NO;q}x^N+bCNk)IFp!
z*On}=@C`%;GW-Sqg3Pt`YfRKdQ<eohP&AjFV4&)Juvs!uqS|}{Qv>})zhtfGsDOH}
zyrBmP7MLES&bp-<3ivDPhU`2&h*>WC|FQ>h_%PCKSndNe*Y*Df)s-8z4Gn)6mF@0_
z2aNm?Jv8<Noq~-F?Z|x{Xygi80H$Qk*WzmKS>Dwu{gxJ}iiz|OPmjrv3vZ1K8URmY
zdn<Mp1@Mv<P-`n1{L{|*XGbB$%x^n=bI^rN)4?|FD^n|>#+iZtW7Zp*%oNLNY-Bmg
zkGBF9<-@Mw+@YXT4O)7}3%Fu|;t?Ml=~<wNc@`*Qo&}1SXMrO26cpM8inw=yBJN$F
zh<g_(;@$;{IENFd1&X+Lfg*keId*{}ZWky9;9i*$w+j?QfXs}07bxQ11&X+Lfg<i*
zpon`HDB^a3VmP#&6Muu5w$&4WtcZITDB|7)inw=yBJN$Fi0{HZoLZoWdlx9;-UW)d
zU7(nXe737hEKqQ+KC5woBFijL&}x;91&QBTH=YHFm|2iul{G9#P=%cO5?q^M7bNJf
zm|2h@sA6V8f}V3?`A5Ulh6RZX&~VH<GL+Ur4@hevH3USc91aRKTZNbB;qGg)-asQW
z{=<4h%(LDQ`^$Pm7}*|ly+Ly2WRT?A0_VLHC{?4Uv#X3rnAZtEqg*N`3l1mlfTR<X
z1&5g&>_%gkCeZiHBE6YeaG1>nhg=mHPyoi0RNZ93;b<uKE;t-PvHAXUKsE~w^9h;-
zhZVBma20S$!B5mC7Lz6xXDau6z-_4ZnfxTAybBJ^F{o>M3Rvxq$0hhHuh+Hbh9}p*
z&c2)`KF&`f5n2bv#dsSzV8P+i#&=ksvtDM5Qz^0Fz`?k$Qyo%ov%TzCWXYed--)qw
zK`q#HpxYDE4>M0)2y_h4fj|qVD_=<+kext^;wWJyQWVd^nghMh!#j%Rg38(U4s^M1
zFq5w6g{1S8ZwQk{s<33hvKKy`1d6c@68H`sfh3(+*ki%(Oj-%O(EJ%AbbtrC^a1aD
ztDs@V?o3WIb>fz{E1*P`IyP}vxG5Jb`{GtwZs}t{?`7!z)%DBxGK?`sVumMK>Rk_S
zhBmizk!XfhhKEtvH<r$AuVt6nq=LNYK}?amJZnmmC`6I_yc@DbewjrkO^Uqhx&K_`
zxt7;h<eySS4)<n}hu9q0GP**)w2mh02~AqZhNi8f^mnVDo*8A5r#!O^+7Ex;m_~=r
zGHiL9p6Q`;Lma(E`S1%yp4MzjS<__Aq=_}ln_81-W|Q++#&Wg|HZTRfNoywS;s={w
zE!=;frPKYT>#R`}%0V-wQ4mVpY3X-@PMS=NkfVy$p$^tS6ra)d&8q`tAe>tIlJzMS
z9oML+^nFXGq9vBzpe*s7CzZ(tHof&!5?b*>i6pn0Br*~&`@%9l1*2@8P5M0%ZObG`
z>;;ovg`uRv%s;T_t}yct1S7q`(nwjUy4v}NbYSi;$gUgbA2J5B`nvNLHy0)lNcGs8
zXqbPfp%5?V#Ezf>cAh;vQwxhIAQw@!pIVk0dG_6AYM}>5&90eRV6B*ZdKTgS4zC%5
zBy?W))1X@Q>;<A*#tNo;x)bP*v7+iu)v8As*pcRGb%5z5qp8>N33RJ6A=1lCN&E_)
znUbjD*Xd$CRVczI;-YR1<G_v3#5e843rQ$L_(YogQ)l$VZTUHv{*Ihv_8*B$4gLbW
za9k-b*}-bGl3bs<2&B+#NE;C0nV=gu5V}w3mqNq|amSla_O8WMnt20v9N)LhXBu8(
zm5*=rfj4e7S<sj?GayZ~uk+@0J<YtXyJp{8ni+!nI0Q|*=uN7TGlW(W3_JU%%)a}-
z!rG{iI+0;rNcNqCIIIipeHnr(#9>{?e2gr_VO_|4j4Z@qUC4ZlEc6rw&Bw?h9M*;G
z$H*ca)`hhG5&Vh>hjk&JAXO0#>#%u<oMdD-)29hi6XCEf6cl7+gu}X!{jx=b!@7{G
zpM*tIA{^F*BAVYioEhP;E|jim@!SZ9b)if_=0`ZJ3uWu~!C8b;^?<a{4+5!+a99`0
z)!Tra9pSJp)Kb3!ZRbSZ04dZ~e*|Pjgu}W}vHk+IRS^#BLgkv3cV&dbx=@86>mnT1
zg(?Nv7~!xk)K!qp5f1A@-Sj%7c_6}JU8slHwk`51ZR@2!Lq6M8^g8?ttqsapEVQ15
z3~?+L+CWf+I2H?C&*C~Ej>SSZv$Szk=o-+%vN^=hx~18+S%w|%K@sY|QdEq^oZo<?
zOFJ-|*wA9Q4KpL4J8>sU?5YBMqBy4F^YLHzPu&Zgmf}y>-v!rYR-vQO{Rv)+t}yc=
z$_`*QeK9P|JhuV8i|9!+z)g}{+!yFHau4D5*tJBb2)Yis$M?t9w{iC7y9znH;x}90
zPUqG)*MGMiz+iV9LkP3wl(JFTdOWbvD(eKBatl(j=CNr`S4hG~8xtaAK5L053l^Qb
z>zKu8fB2svY_Id^NgB4*Q*-D*`T(K~z0bPJ3ci61$BUp$L1%sMQE*lh1rHq7L_yw*
zNzuo$zV0z(6dpS;C$M_mGHjc|Iba+4|Cj(j1e=W=*m#KIpMy~e{>3q0kAJzG8_!x~
zHPQ!PrLtC8_j)oKf}SB&;{R$!$S+~$)0@3yRez5hvp)4?f2PUDy6%Z4RnXk`Qe(+4
zGlKHK%Su=V3$V3`hS!>EIK-pjEw6^@9u51OXxQCU!wQcE4g=v7W5Z^ThC>X)mLj)F
z{WX8vqv2SuhQQ0Fcr3*^O*B+B(U6sA1=#`~GJ?_+ZN;#LCAJ&2kNSn%S@$Yyl1Kk1
zP4rJ`s{bsH{sP=_|Dod9guFQ*BepJ;^|U9W!%ceYiWN;W`oWXY<^MUOR8wv&jLi!F
z*pO9D^p(bzAvbUT)VT!cyZFQpJ6oYYo!v>iO(D9Hd#BhW32^ztj$1s3OdoYG`>2jd
z^fS^&ZDF#hM5T`s^lGBgN8Ly6>qMoGx{rNS^boCDNFVjUI_Mq(G`G%XC_DG!|6&KW
zJw=;A3-H5vBn?JvrxA;h(irg+v)Mvaj1crYqGH6;<aQXCGU92fnF7=p@$5S2z6xl|
zXPNDDUxMpLKasQ3V-wrVLdb=kBXRXp;XcU8gTYntYci1XlRY-Uc@W`G*DrKaUi*Xw
z@1PChwNI(R9h5Ry(1Aq7;LpfC6KJcJ;<hg?hc-XHNS!lhN0OQqtApJ%XsEQzEM)e5
zo#o9I31&YN_dwPfOP2c|_MpMq2A9^f^IdNR_afE%B8VqMD=VY2?)K<OgGi&Eil%y=
z_UNe;LFn1kW}ujbj^6c88Ez1j^`S@Uu}ze&urlV!ko%Pt<dZ?QHk+yW^loi7QxlX2
z^ZDSnQLT5NDxLhxfTS<Qr7eR~gVSZ8KtHr&ZM378TdDRP;7hmLkI+lyLN%9{X>r>U
z+!4XId_>qI8y3^61lR4tK3^Uqk%O~EyH%>5fbIZ3;MXt|u7Mg3g$H54Yd1>!Z2YGq
z8<zDO;E=^}=>Zd^O_q_;%(&FfGt1Pd@1ki)D_gOBD+vZ2Hp0{nY#EIDe@TZ;5>esb
zEA!g&WnBO7=>BX(h5rx2CZfXsCt(v&;onc#L{#{3Vha!xQQ_Bun1~9$PY@GP;r9z-
zA}ai8f|!U3e^3w;QQ;2>Vj?R1E)GS)ttk-|{)iq9#6(p1(<M5>L{#`Q1u+p7{%k!9
z=9q{Ie+xYnh>581=Sp~miKy_m#Oe>891>CCZ!6&yCZfV$tmh+*iKy_G>k=R)qQYMx
zh>57c;xaiVqQc)*5ED`1?<PSMCZfXMLu@k<75-lOL}Y3sD*QI0!oQw{l!yxd27)G{
z!hb!BYa%NAH?w}YQ<;lcLFXc15mx9_pwYGfNM&^jm0=q~&1Umq=#Sl<oX-0su#t+>
zd7lJsAt-5XO{FPQ8N6B2T5SWx^(PJ=DC%QtfvRKCzyoS$V=F$^w&FeZcB~X(Y_XA6
zoz^DM(1KGF_y?WwZ_=La-4Jl*L0M`U)eNBn5=f9H3{$dT9|(o`zNr%j8lmfP-js6E
zUQI#<w>FRu@E>tHy29mf_efhfS4Nvo8!O299F0H7P|$O1uL|c`nQ`E&2!pA7S!)1B
z*=zW_oeYr4)9V133k_5mJU}7PnW@rAFqb+&cn@H=k%lmhU2t(gZNa;+U6{Vkdbh%6
z$|nwgwY{ZE>0M70mhCF+!nA({68qbZhd2T-<^j<O-V7;S?E&+L?}H)xQ0+XN-<BYF
zFP<~bl_K9A{BMDVj>jTVVg#__!C=;rnTLr;bsW)Eg5pu8t_12nO|*bny$Uqk)7pM2
zn-gRrW(*iHhu%iak-QOk(HI?(7me{MI>aWr5{aTmTI3eCz;vfGlw@F|RH|vDJ9x(d
zouqV!CI@e&2_+<tv}w`q<%g|apqkQ_6ap+AVvAS8;++7@<whZ0%GB2Z4IgDyY)1B5
zKx|q76`kX?b)nbR;57+o>P1a;f3bu9Fn08!9ls$f=Rw*nX!oH&Pi#Qv05x{?rnZ}a
zhL>BF&qL8z{57@9I#xxm@tSwD*SuIQ^asjWQ}lD3X2j{gI9(BE{l;0V7@}Y}lh*Zm
z2&Fp|&*J?S>>0a_3aV)ljW7zBR%KtC0A~m}hAO&w!BHm=4X7tE_hno8UTEQyaI-b8
zxrm{0VHGtMYiN&DFb~7jaS3LU=Kt>01cV!M?#s7j1~Lvhd{Eg#8qzrR<9~zqVj6?M
z19MIx({w5}2t0HIp6a^KaxhZ1T?d#yUB3cWIw#=1=u-;ZHw^W~5DneuZ$K{q>VCrN
zlhj!?sIO^QbMHsyaA1)=WcH_$n~A<ebO3WY>QJqsstENtZWd^RNP8Hx$eR=yOtk-D
zK))h7gbU<X15Mv!oyV}czd>sT-nf_G%43N$%<j8b``3~X$Nn0~&>a^;E>53>c7md3
zQTIqIvj8xEIA9b!Y-=&>9mp#ahqj3<y3kMYa52b$;h0)D`FI>YeG>KP@!=G>7Mw6n
z-V*w!L~snLAfdy7Anrtven3<<0~pd~YL<&;HluT!u~%(It*SYjVz6rsSV8$fhMI&_
z0rfGSH?}#^cWh2OY)RHK9e&GD*Z-Ys@n$bih^LF_cIP9*lmVzl`RV%I`0sGLr&)2w
z`q6ejki-Pgm(v$$B6&n!0pi9{5S`C7{YRjX_DcsLo>Zc%d7ma<PvVNj3%P<?e+1+r
zl0h}qoR4%-IrXeB<@Lz)6*>6VkBG`R)Fx-57@A8hh;h$ei%hD(5C{1M)GK)8q@GIF
z!E<f;f{4he0exwt<44`t?ND|=+c1XpZhlIQ2RsY<!HXtClZ;w}D+$_>00RgwAZi1G
z1KIrc;eS&A;ZM-)(m_GzPlC)?#^a$k1_BIoK|f@^(;VRZu7fYI!RasH@{aop!&IZ3
z-*xw55)m-xcirF51?WUMzw7=%I3DHvuKOq9+~`xdy88(y(mB8DDovzgI_G!s<zgZg
z>73uimy3y1rE`AQ^$U_rXA{Afi^-`;=lm|dTufwSI_G!s<zgb^(>cG3!)F=KIwhU+
zyKY2tA$n#y=XX<IE>7qCuA3=e;hLY$Sw1&g&wzqO>73t9eYrTD^Sh}p7pHT67hf*s
zD#$tMZ!pugc+6vdH=XmlZm~o;uS)0qF1}oRHUzFr=lrf)A;`LP&hO&O#pG;E=lrhQ
zRglf;oZrQli~Y#^fppIAx;@0UZRwofb$iM7fbE!E4Uc;YzK(I(-h8<@#%25PL{e3p
z)%Yf$%rgP_<x9rD0F8RSWE|x(es~hA&@SVLCo_rtl5s?)j@|Y2UzAhF?goPRa0o5D
zo}P4~oH}-IX4P}F?tm6_*ghnGdPMRkRRa;~NhvC(j@gRbzM3h}_B|tad@u|;gU)IQ
zH<Q)=&{W+AB>RC}mL>2^F&bj0dm$2Z9>TRbo%S+-oC|p&rUFR{b$(ZbKBCZ1xbV*i
zQ8Lxl1X|%vkCddLd_gCIYl|FQa?XYX$k5X)Qg$3D(c?RS(2XFz)I$B;2?wH=k=}!_
z6CFpmr-(<_P;W108pjhpa1qczw~nAyGlM{q?EZ@Z<~~Agb{E5QAha}5lly2w)a+tl
zv7D&c#ULtME@aeX2FT4?ny5*p%r)MA7ogNZL%1a8k0WO!(4G3`<fTFFl010eRI0)k
zSH=LIdoAEV^is(9P9r_qlHroRc}!}<C4J9-N<9-{Z(JWXih8=D82WHyYP=cX5v)T8
z-UlOBk3O41&&9zQOHf5$VS;g{JU7B!`Y6I|NL|2hRSXXW^fBuJJ2hY{hl(_JVNKr#
zV(f+XKu;jpdhS%5Gjbx$K<d+I8Nylc$>rm85E;qoo>K{`Xe+)tO<Ms;Cn{DRPb;G>
zPgi;-vtss7<9~#f#`Vcvs9-{8Bs#??_=J`U?3ho&q@7C*{u&6%mt4}$B?vWq0c-b7
zF~p;C3+oR-Z!d0&YWgXG@soktiz!Ad?>dO(Ga5o?N<Wa#a0m;lyobr1oe4@a;TB*(
z(OmSa!u;wY&^t&6Sb&FXM*~5klaWyE7E<DP&1%&HL$INC20n>$yn$iQ@nTu~PX~iP
zU6SXEZ6}C={A;p7KT(qBi~nb8RzM+hTOi^rc?}f1^kTctXj}-OWp;ip<R>Jamc0``
z3W*BFhq%QQZc#9%jA$@rgqV^qP2))8328nfHKhx1%IYXX6{ALrqQZRf@6jfySU%ns
zJ?MNyv)H!U%z_uv21vc3g{rn+b|5bGRuo5#1-A39_xA#?c&^2Y=bi#cNVNdiRy%<5
zGy#4Oo&P(<p-68}4Hb};{B->?XzJ{`WK#2=7^##jumg$<auJtkmkLzr&(!b;ol<A{
zaJkj8ms(cCKK%$gu3i|*be`9M&IMXF7f01T%Em=z+1##5KSqqa^7F02`o;{qnD<h=
z7;5Hw5A$93mwf*L!%e>TFyC7m@)dMfD&H;4iA>4&K4Rom++Y=^+)*iw`+hpCQrfnF
z<+oU|`wwECDxJ=9UdlAv4p67-xl6%#_fp!|`bhZYa#XRA9}Bb$?elUPL|(~LR>PYI
z$*Jqs1p2+j{w~njc2gc<g54PA?OWBIVcz^4G^J4K>;>hqMw)cA2=nd=xb!jlb1m)N
zVRP%`LlXRS{ZdRu8GF~#-jxmZiu}{o-fL(tc|B-`zLveUAD>_D`5PYG`Z}sE8mUz;
zmi{xF$4HiXeGT+iMM2&Oes9vMTL63ZjU@BOfvP}U|6DsA)OSP(&qd2a_b5N#IV~{G
zt(pwh&rqWJy<`QxhtK-`(;~kD>HmX8nzh6j42js5SKqs=3wAkS{iXllH<O}q2-q_X
zTj+B=^twiRzpE|%1jzS)#v+S>yl8|PgQ3xQ8>8O4;H}TO7@0N}O!eRCNgjbyV4CYs
z?Na({@>`oGFaNhExg<@++y6D`rlv_5f&;gg;id3;K7+fALL0<`THlZXXWkF2{7UP#
zdK3-Hx!S7KfFpvqzLg{_lXCLEJ{_&D>Nv2zMars^0PGnJU;%)gW3);Z+7u|F{PqAi
zWI4Eptih$ElVu<5&Kj5~hOv0U47vfL1IOZv0h<9_2%uj-n~qgceuPEtvi6=1tNFT3
z$D^Lrz>!e2ABx1RT}Us6I+z3$(+>gAn=*qQf&P`i20aVlNdm6{=!$v4{wr)IJCMoc
z&_&18q8(go>Fm1hv2<eqo7g>;`x#QbAY3`urvKBPR16-ZwuV&YuUW3`f29y=@G?&t
zHRJ={Pqpk7<8LR$wI|CJ)cQwIDMM><tc9-Sow^wIca|qk?a@G=0@`!ZI0!Bv_fMd`
z>rnbKObwjDd-s8((KVJ^t!UcvtGpQ^`iu*JRNmGI-qiq>SKAbRbOOdZtcKGi^^l7=
zyt?QI7*=P+aHq>p*OOXufhFge)H=ydEEI(Ie`86%)-jAbie*gjwTyR$En?Qcud?Z;
zHK_Xlf<tF40*{KnLt)A!*`G`{Vm!Wbu?;DofmDr*zqBUf7BCLoiv%03!aY>)(^Y;5
zegtN}`z(XC(*IEpaswo6bLjW3rT0WJ%0Ko9Spk&v$EH+Sh*yWTW_G=0sG#0K;qkjl
zt{~U1h4+Tb_@TFqADSPd)!`Tu8EihV;Znc7Wkm5N@S2|N<@@M+k+M5h3u@XBA0YZ?
z10R9MPEvHe2keLrHcM33Qly}<i*fbbMMuuHA_w8A=4@BYDu*q~Tu4F{()7cQZidV+
zk<8awHP51<@u%ynF^o8z^>v9RICX+4+a+S%lfXtu^{tj_s+owg$gpaSs9Q}ujB3-D
z${_Cr-~%gA)*`4H!MXJ7L~a_Ur$%y|_m#~*DY+xv4f=~rbPZ>KR}Y~^U^ys{fl_f`
zl0mD$*#*v^dH`vY0c-@&k-*&mjssB9{9ThnbDPhg$H4gqMP2~#Fo5!6E5Zg#UvmZ!
zn@%|x?`&DCI>5qB`bW%!SA7rqM@ZKQq(PJKI8c5As|Y}E$`8r}`3hiz+5-5AKqmmX
zQ_vkheSlSqp?DBa9`6Hg`RkTDtW~N((=43BrTX7)S^Qwk)ktKTGue1L^nbu|7lZqN
z<)(UJ)&Fx3_pJlD<(dCXO1arZQY#KYw3(`Yb8O1>(A)n|E66^-1!|YVa9O|6mVOI_
zRQZuMNviLx1u^I(A@8y`DSDW_$&0+>bsdPsY<MrSqi8EHU@!6otgYNkFR}%9;Nk2q
zQ(TRH3QbvW)pKor-#4`2tQ^~dw`yvd3}2eNb*r@D=+xBxxmE7Zhk%<l{g|}rRnyof
zb-*wPx5)^3W8AK(^BXW~_$I5L(tI=RbG%lghQR7M?<HXnejTMSlaQ`zHt3TfP<0%D
z%Lt4E@FIZT6dSYvm~T32d7({gds?3Zt~!)&8^2pl1=a4*RRy38N0O?R0L~#02e1`D
zZ;A}!nI%5~8#CtpB(338l>GX2wuDDfC;g7I$UCecJdURz?Oxm$BjgeFj@-8+XP7?8
zU{?W?f^M+B-i#!Ar+yHrq@a&LKnmLJ1Y6LP0Q9Dq6m&hX{<qo0ENBf<vcaIR<zHC(
zN1%hIE70J08I|Wxjo|&Mq47_8RI-(mD6HtzQLCJ6jHUAYsn-yHogLf$MQA*RdX|R*
z_jj#dId*u}8p6>*uBB(U#t{NSm*?f+ZkEnAtjdqI7>8Oc!V+A~b2aF2V&SlB(0}Of
zrD;vEuI|<_qVESC!+Ws}eXsc)`mf*_>23E&TRrSVw9P5(p7%&w-9%iP{~l2ooe6vg
z+NS<N^Vxqg@S6F=f0BOnXW%1dVdU_$=1XdF7EoD!`Il7do5XPk{UX@OvyoUHV|yjD
zAAyfJc@~DE`vjkVl2&8;Q~AH;{n?MNCDq);8}?VhH-TS(F8wz#Z3Is1{av7nleHSR
zl<A6nzkiT~ndnA&y686Rj-6~ie&6&KXg)lh=S3ta?_?!Q;eGm*Bb9-PPS}<Xv6?Z=
zHrID9h|TBV>A%fN9}4NCMtztB9dF}!=?NljVD**!KPnB|7cax0y8ksc<6|NHD%3#+
z&-qcPIM=Td10}KQ|CN<m0I5Aj%5;A$xaya*SzZEm|LGRt9n~83NQ+HZxeV4#vIbGK
z{7j4R`)jF!wP4-nuy<<mbY|-~nwt@vjhr_<+H9gH81Dlk{|5GWb<7j(@qSmS&jaS3
zg3GZCT95709P^r4$O*5bg+=3mqmhVX`Nna8n#lO`EQvoSmv6Qn?j(-8BP0FjOZon0
zIK<GGC6LL5geT<yOm9z+uW}xt3EYhzo+GWJH(7GohvYKLnlk`2bpL#{2|AoToUj+F
z!n35=Oke_Dz?+JHt_X19CF4TT$ag!*OdV&AE#MnbqwzU(k>O9e5FW{VVhwWOTSyK8
zHEB57P{t)JHSc^+LMh;+Px8=$`m=@c*=H0@WK4aQ#MG0)v9w7?Eox#RvdL0qxUvng
zV{6o^CbdH|5A;4891cItJo9nyLO601AL%)q5K|L)o@Itvvf$I)qkhu2kj+@ajQJ$b
zAz;j!bRMf|7*$_Ej$AlH0N2%n;Bsnn3f?4C%;%eAf_Ev*)@tmSgmS4s9}@W-kY-~z
zQ@My8=sD>h%wjZcbkJ~3{Rwmn^2w3u^IuJl8Q{AoAje7fuyDsxDeqz_piG~u3Ae!a
z?h2{rL1gg)V^4yH$qbXo9yt~i961Q`g!_=S6PF&0_oCOQ$3ah^FLU6%Wz6POo0@FC
z%5fePPUANmoNrl0IWkqJt^zfn3I~8}jy4#8s^MbjI(u(^3R(XCk;GH^zq(e}6aMy{
zHxOz9{3?NOc^`tSaq<0Kz!-ewTOk7X`2b!Z)J-toccD-jJK>YnKD)#h@C8A+Y%&!+
zM)ey63{cU{0*<7j2MDG)Uo$JS7#O?-s^b1dEs!Ym0dnx4@gTS=v=0jXXZ{nQqnfUz
zq&X!J79~M`5q?#m><6aa08N348It;1XbSXL&eWmFr1z@_91m?qc?11f)ZEZ+Bnl+w
z0&Ww!oQ^-_Ou&iI(=a+Ph_zA}%7oQ{A=KG1bPr_?yBTmrs1(=05!-RC3RMvv`3kPd
zPzELz0~3A(Toc+#`b5Ixkt^UyglC3Mq&>4~@*?H3fEt;E?*`ygky%;5+j0Tvz$(}E
zr^A3~Efxma5~{`HCH+_1F3tks7^uOv0bPMz1FruEI~j(}1K5e5p8Zi087M`;B~1j+
zv4SeS&?B?HiOdxZGTl8gT$yXk@T&%y!5*32O=PZbkQwWd;lgI4p4%H_rh8;6o5*Zy
zkeTn1;rd*op0`snv2#5#jr{jhd^E_#Na<9->2YoYOY8O-JeA2xFc;}W)jxp;R5%Gy
zb90XEXl~9`R)0S_7{8iBP?ZPW_j#~WM4B$7ALM?jLpHuE<R-d{U_H$VG~Q44PD)z@
zX58P7jWQ^AQbMM7f)|7C&szwxqXPE;2~0Q}NSfSvfki*3<O63IdER+}Ggpdy+HlA_
zX;m#z_TVhQY1QJ4;AFym#1a*%2cp{^=muSXHBveAYr!M*^C{RAag+5`9@O(!2S#{4
z7OOg42h6v6N@TN@SO-oNqm_l`2m^H38!YE(!{JdRoN3^$Cf<D+H_)aU+Vl`4VshCA
z2z)9}cUaW;6_5%XB|UtMzKYQ{r5?mJpnga;)b3Wu$vzaD>tU3_@9RTYyWIf&cYZI%
zZeg+;nnH^)|EUWvgN-{5Fh|#u>b$@zD6D~1$y4FxH;5LK^EaT}m(t-#@csl6*=aSP
z8<O9lkc!F*M(MF2xUzyF;IO&qVh$8{{T%j}u0^Voz;{=&$0}vc>w%)0_F4USxXJHt
z|55*!Opx)OmA?rH_OWncE5<h~I@mW2{Rd*P!AfK6j30{J{7cyV+7tRs9vA}#)a!>d
zRNjRckF)X;JCh<%%V7k5*AIj`vvrK!Hr&hI+5ay#q@{LcdV&W77tMkS2_6irBnWK|
z{&Bm@<wQMEglQFgZkVI+gTHh{p=9HBaPKsb%~AM4&r$e6&r$fnKQDoZ*|;6_9EBgm
z%oiAD<2FvOCSo>j<Me7GX5%(auO?zPZsTwWB4*<@POm0nHg4l^2qI?VHcqde0u#-~
zZJb_x0uZxt8>d&(VzY4@r&kj(8@CaD#Yd^xxQ)}RhXSdSqwsNh^;jTg<2FvOJ{j7~
z#%&x9u^5QixQ)}R`TR8-w{dzkJ0P=h8>d$jF&npWdNmQVaT|w25HTCKae8$r5VLU`
zr&rT9vvC`zSD%f1?8fb&-MAfG&qB(^?cfH2X5)77dKTAg+z#G64P-8%mxC5`Sc!7z
zJ<X1CctI+wQ>bfFR33%TJ(+S8zP*R-9qr>Tk5DI$tAY-XoXDWjI{?JwLJXX@K#2R2
zl<mArWWS^=Ple#0k!6C0n}nM^LM7(piDr17Wwys9M)xS+8r%+{E<83o=v3e;dIqQX
zMkpjZLPBLLL3X$!B-D+da=0TT)SYm^;f|0{4-s*=BP7(5aMW4D%zM$YxbmAFAwKR1
z2~{%}Uy|(pn*fHmBV?rR&ck$_57<lf9t#kUrp|z?k0sfWrB2zG8F&69y)V6z>(mqO
zM>yeBF>P`N<U2YiL8l(ZE$|i25W+QY1Fmw~BU^o_AK50IGnn>p=2fFYHvx(3GGdM_
zVpoWt9GTd!6f!(T8-vaiT+<DB62Z%$F6#nnyBD98#J`(B&HmaDXj`+z@V35B8e_9_
z3EwZUYW@*~d?P61=a!b7MHb7!363MCfvmD#qn>?6@qQ|nO$qxn;bv0iUo{Ke>|-ka
zO-mI8o$F{+21&U->ev0!Qbrj<wxrGVF>Q-xUoe+8K1r-{cQYN@(eX?p`6<8TJ$tG!
zq=K@hFwGY}B6?+m<QG0lwzOXz70FhYQt~D-gJX==qVgt!aOa))mriqARZ{E<5!=xq
zc7=$w`WJcE3h$c+-nE7|mFC_dyq>|7`a8&LBMoXZ8&R9tl)8&jE!qsGw)=&A3ds+U
ztW?`#(w~vaNj)eyP~Z=XC(zwas?|tDPs1mc=0bJ(&ZLM;p{gA^!CgdoMDkYx8VIrc
zs{m{PfM45FnaPKe$u^rZF6o&`MhKZm3;a;a-8>IdRhSkt@_KB`)2E)S^k<T~kPR)R
z0-*fBD|!rwzxY0qkQ`aAr)6JDBidoJL_YG<^@jp1z<%JbB||-~0Na5rJXW=Rl}R)F
zD<QnoCgs?VKVAPe9&hcWHZ!Dw^hS2=q>*I!Y5iBk$FjUJKV{d}0{?+GYRu1D<?#7h
zb&xvB^s}j)M_ei=Tkwa0cU%Pvx*~B0aZ8?<@&g#1hJKtBI|}3q0l8Z{NXiZia8L@{
z{8%f5xdHj<F8<=fKtBuu#YX{{0|38{+mOx5hHUytHmktP+XIGCeTb;OC#CwC162<-
zs^3bfj-4*5JNvERdZ;fkGlZQ>Ep3a3w!+eQZoQT3@^4F9*8)Zc9eSyheTCYU#06*Z
z$(5DS!o}L_KfwzA%IkIcpX1sUCglGJU=?j?`$tDeju+pr+Le@~OB!nPjxgHtbiPlH
zm)d*)Ny;UT#Nf$=sJ(rS8lDAiYVTNaj9Qecy$OOJN?ht>qTn|I&r6^+n3|j-E`E<f
z@BUw$y$5(y#TPexOLnuln@u(p2|WpH2ni*X1Xv)15<(~eLkLo&i69D5nuQXIfKnua
ziVy@9I|}+o#f}A3L;<m2K@kzLW5EI_@9%eJHd*+W_x-;6Jjt9hbIzGFXU_C{XDM`y
z5anWan9ho8@ukua+i3EbmG%!Pp;TTah@|rF<y<nQ5;A8&`HaSCkh5Ckm?h2Geci34
z>;wr?lBXkXH<%I`kyHt+&h>Dm6PgS{<Vhgizr_lDAJAw1qUj$*t)QmNe8raf_fZ8c
zgP>4Nuhg^~YvbDZjww2+Rio{8<mT5=0Oc{O4}hWFYrt{AU|aTx3I9g&8%d665_ZDr
z|3<>MT-t5WB<wr$HAzuTMin4QK8vKuC|eefx6IO{ItVt?Hf5SVS<@#qL&{G`Nooxs
z?*<d`**;qSO}6P(n!LP5{C5zaBfZ3%?3B$R9i+*>#s1eEoGSzRUiQFKAuCtL^tXxL
z5483DT3jnFE?2sTgXBFdS?6s-`!tWA)O7Wz4j#O{;KOSllI?M3n>-r_J8}ubai&}f
zw29<(f_XKODaJPfibCHCD1*j#1Uu1mf9Xt4rXqvywqgw?W;*~`iHu94?Hsfyv0hsM
zt&_jX2R8`iKS*f3@g$-39#yTcGpo+6DN!<c%oFc116Cb%H#*ZxoC}G*`HMvKl4F$B
znSK&;A<?(Zd?2EqG@T2g;CM~&BHXtJl9a2aahu5MU!bxN&I}`(az0TbO_YW=V`f9%
zBVnX>o=;j5MmonZy1X7nifpmCE0ugRL;0eU<JMd@cZ$u^D**bB=Zi{QPVh0Shv57{
zRqbh3Z5ayHQHGt<9Cbbenkz1LmTocu2OG+3{vlcoG_|!BnFT?ic3Q6E3TxxqRO&cs
zr(J!l_J*>;2qkD^L8tq`rpCgCCY5>@`KaEpvB`YBm8Q|=mGk6f(R15~y!|=>CX&aj
zZXFwv*GA-Z2frFy+sHuuCU7OcoyZ?FAGkD*bit<sPyJepZ46;7CpJgg^#3|vvQTA8
zq7HpzK2f3*#w!(2Cccr<O`1?2(ZL+j?O0EtXNp<cjlXkY774dGsMRrc<HdqKjNCJ%
z4*H2U<}jsOf593rfEVJ&!H`kc5-KoJn09Ifrqn3V1v4XM)QO_NATTz&Lve69vyJ$x
ztd>b)#@K~0f~YZBBu*hNYFsH9KSNxMbd}&g0nh(SXA3`+SERb~ED7&(w1pb!C-Oy^
z>>8CeP^FPb0|nQ2fkmd#O?nT-VV1U%*B9>>{tBdaA2-o3A26|rZ#)asD0rL-e`r={
z*$FkW_ds?xnV5fQ5=O`G_HcdCm4_N;UzuC4(rncb#mB5}g*^~8Gwmyr{gcS0nTY8t
z^ZR8t0+%&WvBgDE@?zk!E-JRTFnW);td06vTpTS}0xL<i50D(4rFi$_BOkK5!8-I!
zzU11|<-*EStCG&%e}eS_HdT_75WgG@wZKJ)sdp1*aupzZ5Hv~c5pxJJM&=MLjuUq}
z=v)X7?$cs9y1oy3CU{DW;BPvfo0+F{{Irx_A4gyn1<wx7(ZW6kAMeLjEgRK}@j3H|
zPCTWCY}qI5y_>Fdqm}-xD%4sj8cn*ECKVIhC?<%xIpj!7WW{p{@YaQzZLDTfp0z><
z=8!=qKPv_Q2sqv+<0+cC&DyUyU#`h83-cV6;Wo(-Kfta%_X*)&LtH%fUxJ?`F7mev
z{>XB4FZI657lABen_xK7Hw@`g7KXq^>dmpPzqN*HkIUR}lP37Q#>MW%9-mV0ahV%N
zu7JzPV(4+3?c@vK8M6mM!oO@T=J*<Kt0t+yw+nsQO59moO#Dfq7x&q!v)Kf{K>R6~
zK)mKH5Z3~9pH8>HeT+8v<tEUG`wUnG-P-)BCD470V9W1S@umKuFzbId{<HprH|s=B
zlXG<9EGEJeFpgn+G5Ba0Nx3FrVk!2VNs?g%UkM|*;Xjb18*L715~+lgACyXh%+rYK
zd3ok&x+7LV^Gco24ULhHS=|q>?I?S@Be<YmgyO2+-yOj*E~g6BFAE}%NO%^w>TjbW
zxJIz5%2V=Tua#K$sA+LWiPzKO(>lWnkeD4KWLkU@A`%%P)7;>#aPZMT<%>R!{Ko`z
zI_l!zVugM&=rga-^cPHvQ#L{BDQMD4I;F%2ZaO>!hF0Q1NfF$4_#Aj}`;RI^wuXIR
zU=2<~H}Q^+=UP?8u~ufXR#4J3b1-*@gZJuEk*XOC_}?gl-L*J&Bwa&<wH-;DPj$Mg
zsP9u?q#<JFow|SrYZ}H3G&NOGL!_eWuMSnz5UHpQz*R*J6$u{zR~1!WQ&C6SV2Tbo
z$~;rWJe${q%u^B37Us8ZGmXL*PAc>8_?1sXGD)W}SA+#Xq&kIpg3kxu=2Oi?7c?@r
zX^a-u)-{43>tfMx<shpuoSL46Y>ayl2WfU%PN-_FW_0M@8ircHO|dAuQqSl5@U0Nn
zgWN*x!?!|Q4-qUXg8@C3)prkS-g7|4ZcavHSyZEM01oFGFB`UO%dwoW$8xYOHv0ZN
z0UQT~gC!CU#nz9nlX#ArYWvc7qY2Lde(8lcbv)M&!sYDz=X~a3+zS)%Syl-1s(pO9
zeZiLBz|{wK5&S;X?upydppv?n#eI1aBu6B0ni}~$U?Z{;|INra{I??IdjH5TNE7*8
zBDf;udjH5ah>48cff$eB9*QcDh&b>ZnTNCci~JZdR^&C%G2*|R<ezt`hWz5LYdP&@
z&qeR&T0u~s7J58U^0kgW33MW&(<i{-k?I#ZBh@c-Myg-vj8wnS8L57uGqMUNCzU&m
z$WQTZLuI8Isehp}QhuQ`QhuQ`QhuQ`QvE__6n;$tliOF2d6Wkm0*2SdzbFswrEe*T
zX3U-V^ZiC`sU*LIjPl%%xR}_t@E;dsr@#~Z>Vj<Y8h(Ch>puH8K#yNtkWJX{=a;tb
ze+b9>cj3SL9N~mGeL*&nlsJBAi!%@+>2dth7H1$t^5PzVv2X@LBtPyO{Kpvxkv?(!
z(iUeRL`veWXG)|X<#9e{8D+kLV04_mAo~p<6XWy++0?iq?h%s3iK|SH<CnHL1NjUo
z*TywP8F2<eD^<qv^+ue5><6+Sj$hj141}+xER1^(Q8)wn49L<rerby{5URK;j$hj1
z4CD-uwQ=teNf%^O9KW>183<DzjN_NKI0GTFE$$m4`saY-^aa^ebY~pDw8a_7F$Av}
z5sMR1D`U(zkyHnlWnYZgy6UoQM%7i9WplQM-_VX6JRQk?by>EmCv{nNHlia8yE$4*
z<S2@;`BqWn6(p~}kyW`q7AqqDkSERPSNCQUH2nPF)_pGx>hUKH1^fUd`{5z{JT}Vn
z0Qkg-Xc%!K#@-A>Vt)(8)-_@eqAYo4yDpIEpPGbrl`#yW4FAPA`!lmCHo~9K4saex
zJpP4*J9B3?#lM8@uq)woe8&mW{veU;B8`h~MDy~S_glO_I&K1rW<F?TQ*;B_k$uRb
z+jxxlexS3yC1T$K(uUZ{|5oT4okfc2vzcT*jikod*7ey`sqvU=@QI?&X4XcdE2vUk
zMfaVis~bjFSLmADPjPi^k==ABIuCO`Wtm;kv>HwYCIH@YoX_Uh5FZmtdb1gbTF8E<
z84iIL^#pbEhy?I0CU-M@>#>9Y>`Svod1!}5mr;C?QfV4El)^=#NMo*UaHb-<AEQ#k
z72&@~h%ycr-J6J|hb!I1(jyeRlwH9_{CM&|MLU>Zf<56;bkPcLh_?owVqG?Go`AR=
zVynbR+G;Otut|676TCq1nAL4Dh$P8!buVrHG{(ZDKUol={|RUd$@^`Jx@av@#iVaj
z+8^kylGx3g?=a8L)&Uh4dWXiDjHOpg@uGdq#Huoqq;&f!Y06zllmZ?gYE}6Iu>C<w
zy&p*dxxV2&q761-nmd#wexH=F_W}*j2R~rycSL!rVSdP6tCuzdjV5}C=+^sy#<MgZ
z5&a2htByp+Sik?44|Yrp4iH~sjy|RF#^k=m91_C+VP1nQD@6YW@qX49zbg8a1kmrn
zINur`lVQ?jBG3|BUp5VRrr>uzh&_fyWXm$CMvI3qP2UE#`^bj(albHGltvGO>^fG}
zmqOO^5qzTP{X=DQ9|-uohF&ps6Ny?&!^+$Oo22*=aR-F8@is=v_vSn}rHxBHQ${1<
zawN2!#kYccLx5eiWnL;jAvgb!T!%nF+V!XNDctBK{~?fyU16Ah$;1CB@@Usj(_Dot
zh9SK@mPC-%9y82&Kn6ut9h&Q&Ycy$(OO24Vk^YuuxC;zMyW<-B7qH3@JIFGYpUIb8
z-$MdqMo<j;mP5a*=x@oL@xU(%JEMrO0fBrYa6318d;D;kuw=3+E&fvx7K4kA={Gw@
z8AjGSNV^2($a)pPJOJ4jQs#V!lt++~QLSY(!qf;Fnd!(Y%6?W))sP|H48t6e*&WcN
zJtQ+^7iT^g%I^12c8woHb{A4gc7;gE`1(I)*F)ba8p<yH1Ko5xLaTNiwRf`lyWvt|
zxSe7RvCUwqlX6$p-nnZc+MB~XSZJ<^i2A!xdo0pWAY8*~S9#nB{dScfKg~GduY4&2
zYoWOkC<*B^boKN^w&>`xkmhA?r|)Iyu$s-~fb{GBzm*KSBp<VSMl?P^M(1|GVuvsn
zrOlPj<bcJdya#xm^d<+y&#bNd=Aj-K-?hlu33zL~cK)7lKSpdyI@-O({5xy|It_0?
zeP~sJb^*{7wu`P_xb75u{rsiKjCdT4>UK8qV;0+9C*bX7X+`^?Om#pXs^o~dMs`c1
z-FBTk0m-c;nXlDkJoryO^2Ko+qQSu}T_f#TP5ZVa!N;IWstkNTOa4odUuzlrei0j;
zpgz(^{wAf$cmnwEwBaeCF9qI_qi3$pZ9m((Ve?m&vu;HEDiCD!)QJm~D(c2uqn)Fp
z=@lL*LM`XwKU&I;d8(!0;$JjSxh)lLfwdtWf*<y@%hb$kAv2+d*~pj|CiMS{KqEa%
z+vZ_NOn+XB(SCFTa`39Llk<m8ZzrOd<2V@a)Pz{7%41f$edseWR!j05D1QJ>aTz_T
z-oH$vGY04hWHd|C_iA3|m~lcQPXdAB^=4vH{UJI&JTr~-b}9VAguRz15Ba;>K)@7^
zVkb2l=9Ti8)mg|ti2SEWE<=ni132W(G|uG<K`r6snsBBf3}P^zNs(r$(Uo%)zvf_X
z&&RCZ1&*vUtZtMfD*~mcAm9V=Jb)bT>M$lJ0l+B$-C6^1Ut@UAHQJby4S2(Lw4_cK
zQ~fHMq(tYTS8d3H-|NwQRn+Q3kOwi+3awe%88eyHWHU>QF88NVr3x(|lN#bNt4C`A
z)fC`+5`(;q;~TC<&Q}tZaa_>*fTrK0B}i50Z=tcKi*s+&33HTWh|YoW@?`cgU7E*d
z;LnrkhvK;CsZf_OL%NKyz*UzqLnJ=Nbd+tTbQq_BwT3%fD_GXkz~Cv@Nkf|ltSw4=
zz3{<Tj%a1XR~i}JMJKi#_=;{X+~`LCD{V-6RJN6A7`*boqp4Pj%ITW*`<g=C;YWQ+
zKetMhz6V(=rB_MjKN6QdVwFYOPCHZ~szmL@z*vaYg1tlxg;*nnI0H=e9=8jg@C@+!
zs0Q;6k=z4#cljV_z37(7p5#%jAU2BRG1prSk*oA3WXO0{6V&u3xD^~NcBGD`f!b}>
z2n{q6+%S@ii~Ps$zR{_OnL=HPTq$m3{2In4c9s4I{SmVGUyK-O*hupE!)4||DNBN>
zstBF9Dn|81*xXijUMP0H0fkX^UMSYs4xG-hNG$mSu!2-AgnkEoxTlLQfcrNbXHk~H
zfCu5YFO3aqyOpl#SJq^Tg{c~Mo|18=<FlwAw5O+KP#OU&{W8tNjx>Ev7?QC$3_<QP
zf^_BjXQxhpY+W|~D00>&BvnFW*24gv0Z?#26L!->^m+Q@*ZoiceDb7wIShteK^@UN
zwTA0i2g2V#(k~SLE`YS>0DJ~uJb;34|5q+F&;{A#f6^A#YA6eulbRR%g}Nwvk(;Wf
zhO(B~fGm2l)W2%dny#v`EhYU11ie^xqrh#cO4sETms6EC=-*3g<ac4SY%Y5EH77FH
zdQ3q+N{{BEN6zyhcWEx`!}-8_(qMHpYfZ<VXp3#$27y?MoV{p2qaf+OE2zBcy!tTW
zchXW1bKo;qL!Sg$eLu`Wq8U7O3log|zAQ#Sijl76-zJ4XbafFXNSspzWWm_*1^76|
znSf0hgNaGc6ObZq0^SyKTiG0M`D->EX@yQ&sL>t*TiFSam^ByiWbe($ZZ`pwS-g?)
z!ucgs)@PG}7wAerw+OALQtLLN^?uD$Rim{Zy$`i+BU*p2wQeI?2VM+m-Bz@o23)n{
zwo)-K0cR=NpI?f@I+J{sqP=}QR0@jg&B*Xl471O3r1MJwY%n`8DaJD_Mz$2ALNmd3
z@|e}vuoy6RwkYm>DWrI|C_WT;!EDXM>J9ahDm(dc2^eZMbLb>FRBGbbnjF5<Idqa7
z?ybq8ljQIdaAlfKVw%o7k>f2|2tDIJ<XF?G<*(#iGG8)YrFm|z$@q1&SmitUlGPH3
zR$1jsRtJISau*|Cb}^d2j7@WytQXkyT6#-IPIA_3$rY@Yp7utF?Zx?wS;*;)Om-%N
zw>Q)KaDF3mo6U&I;oRmo0-V@1c?IK|k&zg2Ud4s?0I({$ZB=bu`+_B1(_(y*2e)`O
zK$gRiR0L^R{Df!$fP#EYNMqLy1Ja`mih@*6UQ172GODTvEjCar7UHSxqwj=pWwC)`
zv3DT4C-wL@(m{4F=G{qDAz8to|Dl29=>+xj)0y`W$$PY>uI<AAsmXhY<Q@5HsJ4bk
zZRG<mxZ*!%qRfU{a*#{@`}D<el1YW8UQ}bfH{(^K9Vd<UI%Xj=zj2b~F5)uv8!z}j
zz?C^J6Fm2|kV=<{N(+Ir8DFmbWz)QNpM=U4V;J`!GY*Qg@IN#nL)Ae>#&?=Z4+1#q
z;<O!07xX`~@n3rYx7-Yu@|M~b%TH9Z79nXLvd>xxz_Sa$Isn}X+z;S-00q&Sm6omb
z32iJYqS_HUigGv#Ot+X*gsa4Ke$5M3dCcnHkgYP-Rbq^PAq!<Jg`Weij5S5li+96!
zSb~2ORbh*cBoM91DdnKZUM!hW(CU2M|3f2D1yGtB`S()w>7shNW<_tMRbSjFr22GG
z?GEIuR9E<yz?JGVB)$FXp?aPn^?U>Hf*${`8bPtaXr6=V>?37CSTlc-ZR<y%jqEO;
zGurU*#(d0Lk0{J?J{T(sx9LC^-YWAiTm<kh9n14`yh6amWt2TS6wCc-^KqHEMcE}f
zmaixqycIz5@fdwOlBysDF<>2BAlZ0rpwS#;yM!nsjlR=p$dbWAnIEF$$FargGjHzJ
z7pu>_3HH-JXO;~yw}Ps_{A2e08P$I+;xP5)K3$ZDn|K4BMg~z!VIhMXXZ=$UXY~6c
z0cQr2<OJnS#_}H+_95_+s~^9r#_y|BCil<!GY4ZJKg5kLIfaNQ&jiE_xE0fUr#ppn
ztE>Me>LLHgh-+%F((z{f4Ul_IB1HWohcR$m0xY(Sq$OqG^jX#b_KjBOGx*QFll}yx
zV8);~ffMB#L&Z}_|KIS>7{D)>tvn`k&a5~F^O(|i)a2?z7>t4Z1UM#hHuAdoB+O!U
z5&5+W8!K(oh%oN$i#D##GSj>0v&>1%M?E+9=jPS_^L@Sil0PzK6nJZX`dse!my^ZF
z<(DBrP8K6q5Y#7&E|1L%xFerroO)AFA2Qm!b=z~*GP3c5s;Kw60*tK2zc=ycS-^zQ
z*`Gccw7*Bc?{vPGNw<0d=08U8G}xUU0&W5B6biTl9fC84LZc#_Yt2Qlma{ekd!Ek0
za#D@Vg2y^t20&M5?NEquir{V$&MJ%sF6aI3+)sRVAXIYd7C|59F~CtyUkG%ZejVWu
zPGK*&k@Ijms>c}#$uZ8eXcn=~{CxCYhPNE{byk@%$T)f|DmLHQWlpj{%w@i_M_~Mt
zb}^8*<sJ%;uP%mRXTKnRpHm0OLAeni-q#b_I)_ZoQWAV+)c-RPkmBQuLe3W^%bXtb
zH(I&#wV4Yf!fc)w^D!xZQMlDKFUCtp|6Qjy$&2Bu|ITTRH_nThO{4vz@kV(ueW0&n
zT1sBSyqI?6kI;C09;&o8a`3W&IZ+nhv57u~I*NCE);1QE=N(S0^#h0u-~N0ceo64e
z@`tCLI6?S*)Q2GO`<(>qW3n|un{bjWMjE~zs1~P%Ah<l$7X;SQ;`dK+5fSMHFs!4_
zsU3Ar?Wl8VN1anU>YUoq=hTiqr*`x?wIk=$j+|3Fa!&22b86h#3CVR(w@{AflXd8s
zb>;Bc`#W#2tH;A<?;oS6V?7=|d(X0VJoR|^?ERatza9^tz5fu7ueS^Tz2^w4Yo5LM
zdIgBO=GkisqON)NT7sx+o^e1<vV6Jb+3ONSUGwa93!<)h_C^Y#u6g!GnIlk>>Y8V-
z*BlE(UGwbqnbf#Ku6g#x38Jof_SQA8M2foR+1mgcy;yV0HP7C7vloyBa?P{1p*a!K
z)HToe$-irXsB50R$>uDOscW9S?aiBjsB50R>4K<hp1m1@sB50RnS!Wmp1oP(#p;@8
zZ;t4uu6g$6nsbrQYexMD_mDqf{EK+t>@KHYUc>`u_lRcz8Vx+|!3{xJj|a}~QdKuR
zaCVPmmFWX#_b7^p=P9#yecgF*+Ia8Xv{yZzGJEeKXw>5=v-e(F&QmXGC}6pVfWDfB
zIJc)9RV&>UEg;<$V_O1|SealgfS|gDm+yo`^_23sJ)1z$&`yQw(JiT9T!b%mO)R{)
z5Zz2=rN=2nI3M8{gbNT(LAVg%4G0$@T#E2UgtsAFjIapd5`<+4mm(a8@Fs*62yaF>
z2jMb=HzQn*@D7A45O&A9V<o~?7$$B(H~{!6gu@Y5A)JWtR)jMUu12^3;TnXuAiND>
zHNx8w{*3Srgy#^hMd*X)+=;LU@O21VL;iY%CBUl@jzqWt;S~t)LO2WIMudwHZbDdv
z@NR^6A-o6SuL$o&NRQl%Fc#r`2w&=jBT|Gn_rQ-RAUunH;z5LyVcLffew=9-4>P_5
z$61x0M!g1iH?{!(Cm&mZ2-~55ehlIJ=(M*Y961tiK_I*h@sA^XxYRJ7K$ruk_!q(g
z*ljz)fe4>OI0E5Q2qz(Y8sSWYI}k2J_zc2T2%kmhx&#-mA@n1B9${mIFCa`t_#(m#
zgfAfsBHW3v5aG+jQSMg|Cc%EMA}j*_8p1M!yAX~;xEmqYkFO(~gYXT6HzRx#;T;I~
zAp9QTTL@1h+>6iy`@N0up{}?c9N~6^`w+f_a6iI52oE59AK|+Qk03mV@H>R>A^aWT
z`w01l@&^dtfZPuezK8G-!XpSjLijA|=VOF7qJBO>_y_9eQ-l*xKZg;1h43@RqkcX|
zID9y^=n%Gs{l7rCAN6t+VL9sMON6Tse+=QuOL21z!o?`ZafI!m$JYq&>1h}z5Ox`a
zYpoETYllf6!X15ZI*#x#hWhUj9zys7!sV#n9}&)lyq^$Og0HeN+Gz@X=Oerw(}V>G
ze@FU4guRf@B81C2u>D0lUyo(`i+27*xCCL;IJUoN=Sd8PHz8b&A^T>8dyxM!gg;{r
zwj5z5%Dn>N8tAbS;k_8qZb6tdknJzp8HIeS5dMrQ#jOaJjA8qWc2<H8gJ~yDTfDHX
z<uri=+i3(i!pR!VX-jLsZYK}_Bb`AQL_N;MfTNrrP&UUIg%Wt3`LJ`e^I;x_R_ADU
zPForck^g{WoeIeJJ4a9_an8LXFzz{-ut#0Ti&jw284H`&cQ(MYFLEv(j}F)Qt&qcg
z1$1oa{D{07IhVs;jh%krYT~4g!Z#$&Db!#yX9n!u+*#BS<DZiN-4dOFutbvc70TVh
z;TsPvovA2Mz=?(BlAS-1V=HGftdQayhYedhQ(@s$ClxuSInz+yHqJAs^R|wO9NRfd
z3b0;vOyrgBY)2c<aFS52Os6r*p5<JLTFZ6@BCi~01oG<Od<cKab!MTL$a7{Oua3?h
zl&+KGMSJV)Jk}0pUCwauc5w<&impx&xpZ^VVUwMhNg|t<4d;_Gv{C#P4-|XVaIPQ9
zG0N!#$K7Q(55NMu4JQ!=e%)|>g@xWQoGnn}P0W?xGkXlDIfAzgCkMe^!zo7aHs-7d
z-Z7k62=*Dy3IzKN=Vlc5fZ^PY;9bMnf#9Iw>_hOL;T%WszTxaft$biOX`SiDerFo8
zpO0`!4&B)AbV0Q*L^v4T%OZsL!#Fo0OoFzH5w1b8mmo}mn576`h9lgBaL&baW54qv
z_?Iyrm9re-KjOxICmse_3H&5Vb_>GEkiQC{ANf`xydCmyMVJFQs}Zh)$<`pOfV13&
z@Cms4?FiFhpgRzH;d*Nkz6-f`BD@*+I)r(suJs6aqYA4LHbvEMKp2e)^j!$gBEO9Y
zOHqzZ2p>TF-3Xrpeh<PIQ4jYbya~;4Gs4GFXZIl-47&RfK8ObK0K%`~f)66R2KIRf
z;h-Rg5x-LneIG$s4mn#8+R)=sgk^BY#}FPtIV&q8oCTm`cm#Hwk8mm+jNv~B7a&Z4
z^DRU;2_CcvVT{y6g!2yEYccS6$gQlb=lqHC&qufc^{@b8A>tPzd>48zLU<a@=|+UF
z!09S0n>g>Fe&!<_ho-UsVF{Y^LWIvDtgK9MGV+<8;JiJa=?Tt3*lQueQ{5;p!TAjF
zHzMqZ`dy50J>)Gx_$c(MtZeDr5Bm8Cm!qjHK-i&x{4JdU2p1vz2zI>@;a=3^VuXia
zw<QR#MYt5<GpP5Q5Dr3p-i+{F<g*N+341O_I1K)?0^x4hsj@P~nGJi+M>q$KZvn!)
zB)=4=A>=Fq-VOD7BSJUytgLL~JSKK-<7B`t3xMA~nDOZje*$ej!b0f30O9lSqlE}t
zqp>eSI12J_M0gnWxENs!!X*e>z#dBxJ~Ebir#o*!znc*b>P)@Uo%N!3x^ouww*q)I
z?7kA=1K_&_;UVa^3gH&my$V17=3ShKo_LI`t>k4#_Z6I~VqXQFZ+2IMv&ZLS(cz+<
z7>$d@Uu(D)9tCK3>4~0w-46t3B2U*{q_tB=1AO%dFhqWce}CgoubJ(k@EF%?9zP{A
z%^s1Dh+RDEbbFfPe;vlgMYs-L1;kke$9Fj|!8~r~6~Ix>-;nJ%UqcbUGY0OH;8elL
z==FYvEh|lDEJpH5%NfN0bL#6+0@r6PA*(^W>&Sfw>$R<qsG~0<8>8M4bVRN%347}C
zEdbXsl5ir;ID0wl=lbeeL_wny%i@srLNpP>nG8oWo!w|omeZyLluidUsR*YKu**4&
zp4si3OXo<pFoPrA<0y8NQ-c4F(+G{k>%82aBi&{=xZime@o~;9R7xFZ0$i!ClZ^lM
zoMPlv-#H2Ti=1_E-3HDi6er$^fg3e+{y}OZClZv6o$0Vd6XzO8YwA?M37a{);PTC#
z_n>Ej^CH|L(K!mPB<CY^jV+vf7^|h>y&9%-#hXu|fc_F!V>7u92Hq2wBeI#mhHnTe
z)YV=PkM9+@k1Jgezwdfv?8-KIm0^6$o6yCTtJmhu6MTK?7oAKRF~#>5dNEfQLDGG@
zpph$IkUU>Q`b-Z&@_m1y46fdS^g#u1k>d6|0twzkI!&Q@2khU(<LYNFK%Py<8Lk0l
zYg9(F2pG;a(4?C+8_pUVq$noQPcIgM%~qhmu2Pdu1*w@3;P<=wnz3~;ub5hKjo}(%
zc15HS!z*uHLrvCogeTq;(~DXSS0!^|JTWKfB_ni6eV&-jXtJ)68jtqGJc_Qvb*aX^
zpod?$#%kR0#JFk0@fwf9rh$RJ)ODG;6uCz~1LLf9O){s{Lp?lq2@<Xn*oeJq>@>r5
zwQQ?+VrPv5GTpomRDNGKy4(ztejD%Gfeyko)7%78B>0lii@UCu@~8M-U^cS_N%!$r
zwp?=s$@4|QQ(TpT<oj|k!nhU)(#O|>WQznTiRH_luEm0s`|e=M&4P^fttYZvkcsjZ
zu&YYSSK<4fMOZCbU+a^S-)6=@(MsPE*2f)Ee@lIbScJ8L+~m8SDR&BTvu_GrXPqF+
zd{gL)>jhcv<8F_uT96gKF=!&L4T7xnO-%rDm#k=4p{}RbL$jiv;PXQ|6K(9;WHv_4
zdxxNxaBVj407*3A6RumW!i!-0t7)w@R$*iC`K~6_ZPsIeJ-*-Q*|!Vg_npZDa)+gC
z-=4az6(qrThCX?xwYvcuz^&-5T<Zi$_kEQEWW6AHz9|?WUDZ~9<dg4PPv6~OHIK)c
zo3A|u+$Bhf?*tpbMnTGbi&?Fk1R3p{O!vIox)=f``lby8a*s6(NQJNdXdw4mY!%n~
zQZs>Uwnm`{mA(Xw7On@Zy+~Q=dj)-!>p_bxb(L=+Gkr*qwZ5mQ&K8UP@h0DM^ovIY
zc`zoS6v$S+)7E@j%*}&=|4ZY|w#7(&Zr6CzZ81`%Pinl$wiv0dr!?Mpo2s#=MZ4|F
zO?FsEk?juIXLLPdVawP!<jbR@J}U-3Vno+L*PZYB(%i=SniPSguLL%HnJB;OxF8<i
zkrqI{7R2wnfz9KDAn`taap?L+kOW`vG9b87A6}8-`<@p5NgSHni1Y|Avvd7y5^f%c
ze)bL9^}G2U^A<UO3T*iJ9h>Vf^JgUB(-_Yy2qT}uKNF51V_=NoCA;g4$+YO(;Aj=D
zhT;ysl2%A)EES_&u!;2unv2JG61}#osUQiyf7tUj6C}@fO+Jw3!e8QRNF>49i_FS>
zehm5=867jC3`n9fc|?<mG5@gJN(xoMMAdC2YrN6Kn6h-Fr)a$4#F*~%v(_4qpNOJS
zF}LSkWQCvi#eXl0;!3j!M;}F#iFdWN8p4-jr_8ttV~BVac3s)OrVHZnJy`-IL#R0B
z((~P(LlEGPcXhDJfcm~>)6NTL?ikM8Ni%z|V87eh3V_F-;_7CtCNp24b9L9uK6-kA
zW*+7P(nGSqcKD)!z<OF^$(-)$YyClHq3@@eMN<E8<^e+G_Z8AB2TDr3?^F6zi69BS
zK1>;8{S9F$C>M)^Umj}6|J2TV7n-AMu(c6z^zoq}a^dQDBrCPcbk3s2P@VJT8DJ?F
z#P9on{KEu^_Z?;@b%|At7M|dngt5~#T#!WH6&!I!Sg24V$w)9v*QHjsM#$w_y1-a#
z9y&iGcKn1f7?vbqt#1}<a+0*iO}_it_e_>t9`qeyKXRoY+kB%)Hbp96hwnJs$5ct#
z>3cgD$kl?p;p@dpxJHouzTQNpSp%WKA>TBXX1e5a#P>Jdb%v0g@C{`zJ5!L8zH%b7
ztRdj})2P!Ef!os;|LZJ+>TXYcvFLD#json>XMwL3Q~L8<*IPS~<a?eDJzJDDe0i+z
zIf9^vV43DhUVh&{%xj(?@xF7H0I5{1&hS3MW;@@y3euuKKwqEkT4=e^)x^p?<3{1p
zb+=d$kI$fhB|_!*on+%&D$?SiHV+e`Js8sBUCXTQlq2nAg_a}jWTlpKc~h|7B2;WA
zuR#U3hkX@()CjG`?O_*#-|Yh&72$fzS^{xSMi3S2+y{>|og1LL<;+Ee+0Hv~%Lv1}
zkH$Y>T?$f6sy?uG0%(d?M_h+2nN_V}$N7=PQ=z7_82_=wDH-QY2d!fu_Q_P~eaTEu
zqCT-!BLS0|00+5GMP_1MdS+LfV~@!r%%o@<va3zFh1jl}&EW?HNI+B_I%MLvs1$R6
zYZxL-{!1D(Tp~sjE~|xG;<dgKm$2)X-Q6A@Yt~`+lsFsJWR8?%^BKgpn06Vi1RCiQ
zDe1I~N^D6r%u8KAK#KrJ3=OxuY7%}$SH&C2!>H3Vm-&5-q-ib=@KOjQP>WXAVgN8_
zxXywGT|Wy=ux1aQyoqyQ5p#!&1F&6ys!if_0}-MYduqUFLHNZe3<&14Ldb$XrwW>~
z9*Gf$DBB(d_STnPI!@z8;%{h&*4c<f7%|Q5lsyvd3K2JfI*Gj)V9pj=vc+5fM35%+
zKKv6KSeA=ojkLg59qBPDL(~kLT4E9`W?hLHA!Hw`k$t7BR`!)H$~F@Fp%C_o2&ulz
zW-t+RLj)VIXaSh!N@8gNOKIs(_O}t7dIvb|w!f2jBk^(QWMAqfgSoCo+NEBRM%y7#
zZ1?aOz@vpQNu-VTvN(Z#n9A5=B|a^1c_$#32@;?|><L~9rT=Y0ScmN@aWh)3{fl3+
zJcrn%VQ^YR2+S^7Ck8m#uzwRm@f;0{=Y-;q=GV|56IXL&G6sf7e6%y-*F=hyb|Y40
zvL;e8VdsNHDc9Aok9}LDSnLmUWFa`WycYg|nJ5~mTl<bkcJqO1%2_MCfuB&RA^3J!
zCIr_<k7=({G@r1b>jh2=h(YfXq~&E(rW^LgNOs-O{c3iUDblL#v(#N$bxK&PPLWm}
z=*~G;st_89E;J!mj?Ia<otzNj$_eAjQGG$;E~sI7eBx{OlakF95duE}e!yE8&zYMQ
z<>OR6$q%mqjFKsjvmBqa0UlRdULU8CNyQxmrqKhrY!5L)pB8wU9-rW2_0t#F#o=eU
z;rDH>#oWT&YMP0BtC+tbwY9$uP(FX#%1UX=!kb&EPg|~e%x&y8+j5a(ZevcZ>Hp^A
zbXX&CCM;r=sb-W5nW~AFg*BrxX-2Avmb+L4Bhd{Xuy(|-eVMDlB~1zuQb2m4PE2C|
z6@tY$&&1Hb0}r)B{Bt58Ex`LNtQTXrRDkU9wBc4I`|}#vTf=0lL?v6pY+%;57&h0I
z(+%s17_nSp0R4?=tDd_>67-Zl*Os1ADiMjand)<00;dJ883wNUF0Q1YPkZQN?zN@z
z``5_WYqPgangAmrkur?LSWIH<hogk@Nl>aL^l+5G8_@kDQMjbdJ`yE4OK0?Glr#^{
z_3g)0{AJf%W7u0oSeoh@c1Qvpfep6Zv=V@eOmW|js26))M9|@k#0k*F+^V|XVpKxX
zt=Jzzgp3h#`P|kBHs_X;@N(+o(*MB-Auy2C9@Hv2u;a2CI4$r=XCO}reZYlghfi*`
zoxWm<Tje;TCP#Nzj&8}(NL)(3=87_^Wk|Q?LYXv%F56rvlO_;O(0bwvtt72yW-SQq
zL$T0afl6ZyOGy;0wNF*rOD(5q?UTP@Pm|;}mq8yjKqR@POJB|YHObA%RnjsP(QcvO
zM0SHM+^oYSZd8O|{<^n@1JdmW+^mt**$^BUOu`gl!muV-mcopbv85PDKO?RE0BF@f
zD!7rnsFPt>$K2*ewAL-`K#sYkli|D>FdKW4bS%g44L(F9?niaIeze%$Z8M-f9}(Q#
zY%z&R%4cnAbVe*<_6MEv*)tK+?ekZC?XwY#mw5$X@!3g+{f{!D44LQD(1`axKv;)M
zrsU%o<ShKu>FpFbVw@m^RX4KRW=Emg{p&W{eSiyBOTlpPsTO2xMcG`xS@u)Ro(&fW
zH*1aLmZ&V(QOo|gCgrH4uwX}3!IHfrKvUngqm!WlogWCfThRFd(-48CXmG9uYCK3T
zzZA%6%T5M|%I~z!uP<etu<X7yDJN?3JE8MynE@KxwkvA#v%~VUB|jta7kIRt;*l=m
z%2vonntzH%T<uMCib#|$;tF_!-P$7~u8h8|RXo=$cB+R1Uy^hqsj@rVQo4&aA~+!3
zNLz_lBd&t=2%4c8ID%%1pj1xn0?mscxwGPuX-QDv)b31_xk)#bC|;fKVP6X;mXx8A
zQiDzoBfL@(!X-aPCD^x0A8WqLvQL;soM6&}7}Wr?D@mHpiG-p{;-bY~?UL4aGGAbt
zrzMvs_H81oJ%3sC1cXpNd?y<2ByW~5PH%J6IRrTITXezJ7&VNyPeD%HtVIOfB8i)|
zfVrKUv>m3f#`;7XE<LPqKJJ1Vi6ce>dDW5Xn^Pm<Ri{?ME=MHvLG@X?omvTRIFt~0
zg#-Q`=P?K~5?}5C<Q1h)gEq*Q!!;r}UMt;R3DfOWrQ0YpSnE}#+xi^9uZeD|^}i<5
z3QW(fJu;C9i1u&!I7LWp*%}J){&{P^j|v2M0lkLP0yfkGB3kmQdB8G~7^x%vfAU>V
zzDua?M?Q8Nftdw>Kk;#w-bj6-M(U|BZ4|7vITfbOsgO3`*6{ri#;0J-_eU7tA0fV^
z)KKaF3gc6-=KCv*@2?QwB{h6!!uS-d`Obv#oeA;XTEq8u7@vYQ-``<;e~0+?)bO1P
z<5RHaI~T@xF2rZ0h015f)Yh(oHJ=$%Tf1hAuH8;Ge0CV0f;FEV#%G84uBqX3h4Cp^
z^SQ$KTp_-PYxp9=_!O-9BE$G1LwrYT_@cu26s-B8!uX;zUz+lGZy1k)HIFxp$E$ga
z<low%Gmo<EE@+i%D2S5ITn!jrJzzu@fvTx(Pi5PcA*N|qm)|sOh-t1l)~BNdq?z{f
z<lw8SKyF8CNaE}qFo)|F*xvxi>PZXiiAQ{Ug|y@ZPa{Z7?#W@bgJ~XV3jx3M6-35c
z?%g9nhI7dzS29s!Z%0{)2WDYfW2r;2fMniTGFSb%)m8SJW&UDylk=xkUd`B&Uy53V
zl4HvX!|EfaDJ^F~ts;{fG6BvQtiE#QW2CMm3;LpwqJK-4OMz)EuQ069Di$Bejxo8f
z&*JiDZ>=lj#EguSMUB)~DF=DnY@+QOX)SsFWUWw{02QUynI}P|@?Wo$Fb<G`2{I1E
zs&T<U<qCezNPK-P#*}?h@8$=HSL5-%7#WXc9NiZqQ#?+z?ENvaXC&k9eu-DZ-@9s2
z^ImVz928-J>oFbBFiK*-C)DY6x*&FIY-$y<LW%4{yh<LEq7bA_U^kDYGJyk~K%N{+
zSD=yYR<Sg4>TYt+!tk9P%OgoJz1<yzcg22z1UzofrvU2kU@?*mKLe8jyNtxM13_8f
zl@V-cdpM5lB@}pNjdFOfBue~e`G9+Pxka25l`XIsA{lcb#LGNTCLO&*SfCURW%rhN
zD8P3Y>u>`!F$Iv_Ne!9(;QlJZPL5<K`z4(mS%}C?DClq@q-HZ+go)Pc>d5#}RSZ$x
z1Wu3RBw>@27Py}C@E(fb6AY*!csUwG2$qWMsc2-z+RFi#p4IerWJS6QMzRYX&Mwjd
zXE@Oxrx*r}0X*K}c|ahI6XMGp&c4zDZ<3?Z;pQHn#4NN&`&YI6`?02^zpCY5-+q!v
zDQZXLlq~sFNq-k6mh=x<<7wGvq9{A?$Z)Wpk(FcM1XqY>g(%Pwdj$61QS^?$)<VGl
zsCYFekCGCK@_2s=*+N6!m}DRGki#s6gQ~hX=8?(%ttwIC#b95_EKbcbHT)<`p<q>t
zuRXGG6;)1%U{pT$xRaltrUh{(-%Cpp*#&Vb&!LjQ)0m`2m=V}L;soZ_H(+rx?tE+5
zNPLB5>lDE<*uOzq3vs(n5rnlj$#O+4Q97$7ig;6(2x^xW5R2riRSNW@^Cvzu2uA2_
zv;CQ!k+tj@A);m{7_c}wx-GMh^xrL~PME+unHX(k?1zqK8>_^Hwuc9vA&*)80HkHg
zCQKV^O9F_7Wc>w`o9$$!V3uTO!ZaFt{dIi2SfNFr^OvUsv&@pCh~OL0)yRFW1pVS+
z*}>hWiBp+?$E+TJaU@eVR}M#VQD_dylx5-JNXfl4PZoxUBe^h~0(l+Km3}TgW6qnn
zJ7hl^Xd8&=FfJ2&uoB;75AL6l{i}15=iR`KoVD)ml4FAW*9@nG;Rg~Jxf{_*T8Cq3
z-y@p1sV2tnJWx&906rXZ6JnvJYylruTRo+nxbJO!E*&K<=*_*KezHUIHzHNe?JzOs
zV^+TaXU&tYYlrMmw!{Yqc|DP@<`_X-HVmJU4Z}6W53p4$eEweGpL5Nx@MnN`5TAKY
zb}D}cp3S3j`+3>*T>Lh0X%#Psyyt;;_M?$!%lhY4i7a~ukvkFDLAEE~l<mns8Ce2X
z?ZBS^u=fgOyL}LMh`sIGQo!-RgEx3oDQT!Kyi%fap1X@#>XMsyy2zyoUCi=`sy}(%
z5uRKhE#ye6OOH~#6C{Nent`=}vXCR~dkM10i^Sv-9CYA=#Kl5h!K3$wETr&q;xf`H
zd^2&eShUce1m1x^4r|BAA~JXYMUonb6^%Xt-t}6omMT&?KHbCCTJA26^3Tcs&n8WP
z79o#W-5e{Vy!l;)g8PfD-^Cp!6L8(za}ilc8VfW}yy$s3MtBUk)PeP)93`A4e$)$g
zg_j*f1N%bf(m?0Zfjx+|S2VZ|1o_`;0+=12iNff-9Tneu(vz8M0UfqLjuUV)jELM5
z<;da_k$^AaL~d;vzNjg~C!*9=<RNAFM9Odis4By!Qij6!LS^_&$nOW<`6OLN^gJrL
zq`Z%|nt-n5O$b*d{7$HgkznLE(MnuUf*#R%aE2u;$7oG)yC_Q+*_Ue=J*A^s!k*#*
z2<lla^mGvS2gq<VGQ1OHy<R|DF_-f#pUV*6t1&yYTONa`r9gW>pk-gAWiKF0XLMTT
zom>KM0ZnkbrrBbcv~a{sBMZA(!Q1{VIup@3hjetP%6e_ihqQaRG~P#P$IfR%t>MZ2
z14E*jEBn2MSJg^wi|CG`b(0O?T-gBr1#<G_;4N1+5(a$;SIN_C7~AE^mTkhI>`c50
zg2Ib60gHhg@4%G9yixcobPB%KmdC7K4RyM)R{;fgypBUa9(!uw+@S7t2qs<y6K{ZO
z+1yt#ACWV!tB_#iOpR7WcvZ<Wvaae4ikn<CyE!8J4_4L9qS?Km&u)(HP2(RC{{u51
zbD0!1_9Ngc(Vc0$7je!j%;hc)8MA@+kvd%=(&LNP>AYFYEEIz^Hk+4S6+Ii4Qmj&N
zor_WQW?1~Vu=pck@v~LDJ<D(#!C%7?AYLM2(fJtetuC@Fn(tEvxLX^*tmY@^Vo^}g
zq8p)j-rKOK=J<|yFK_{e4;r~2L;cTq>ex*rnkB)>S}5Itt%WT;x40a(I3%0=Cv`f;
zGI`AEQOr~v=aB6BFN9F#IEQ2|a1?m3evH!fb#d<@CZy+X#?Wd8uqTfOs*``Jk$MxV
zOF2hCcAC3?0;yfmYlDMxolV5$&^6i3)7f*tv+L1$Qrvt;Yx<|S5Rn~(*;;bwfJ50-
zDdfXQ>C5AeOLe9IRZ-fy=_JMZi1-3T#n}KF9ESGSp09nxJZYRA_ro{)gCkp-Nv25u
zg7nX7dUhc+;%vyzam6YVV33g~OAZS<E5nb-dO8cb2i=_PnI(lyHL+?({W_w@H}|FM
zNPcY0$E=<c4E0g_*hfWthMy#t`-<LY3a>-&mC9D}Azw2bhtys?<1-Jj2irnaCR>7L
zeGarYxK!#SqF<nwH9um5ItsM20TugWrDY!By2-9uK5qanR{Db5XKjw4pZihkH<`-e
z84YOzVD}T~4vm4J7{IBUV2=Sag3C0+VdWK+*ag=Q%qFwUoK`@Btj)R^xeHmjb>$1(
zO@3uc18VRwt7qq9T$Ikbu1QO@{sNvYMXxW*UEbA_{Q-!~i)7Wj6zSPw3xyvbF2+#!
zr$>Q{H54BB61bS7fk}HzIc6H2#L`Vn=51p-GH?oOX{z~~)~;hd?DZ$&I?-lV$rgZJ
z_5IuqFxnK8RvY*gdbkQuEd*7ES>tBlB5NV5X2O0XWFjGZvh<>oZ^m&X@ZJ9px_|?=
zT_Mp=BD&~6J!KV-X&P@J8Iz)js{NP_6{go$DQta4(YQE;1wi+s&<){@bw%@Zd?&=$
zN51gfh^jZ{a+Za3NTU&P-?=7ZHthEliToss(c7<eXbv0kDPzH)<_n_cKTy*sD$)Wj
zfdHC}Ed==oyNBt|2_4;__x`#{S<uPzlomK$_D2%G=7b$irO+#Z8of)joKns530X+=
zmhgN{qF{TigmyhCpel=DbRG=@OQogMR9f$nI!Y0bmf8(Nel|CtOtk^k;sl1jA)06^
ziiV$E(AYhi#h)Ll<*p+4O0e|)RuiG`m*-2$l^X9ZHv0)gMZahwR@vPkpvmUIlx}Su
zR@v(+o}S1Wn^Rk3Ei{#`F-4*5TXbAYW@VhIl^ne8JRV&cck9UZTGyO>ZP{|MY~UM|
zx@fbOSP6*(K@f5yBe++moM&@XGb-CP)4*M)X#C<%5HDvG%fYUjf5y*)Ve0zUChf{k
zfQAnic&HcE^y|xlav8M9zPuNb8px9JZ{pIl6`u7in$RZHa6TBtFPg|=@;Suk9Ma-L
zwJckVW`You@bvRS0;CnMM|}2osQ$y6TdLnM3ioULZkWQzJvIjYM5bS6n-?K(JbUFo
zOHoh|T99P=x%o2`@;Y3DV?8@tI2wPCQm})wbNuY!nBKcui)pIG9E8+t4kUJOKL?UQ
zU@Cl66Uk6gv{Yl9gntKedeSu1+NV06i+vlq==eeBbUb_FCMq85lp#iu(?Au019f&S
zLt#@L&$=^mcO%6<DkE^ZPN<!7{(wZa2s`R#nWsbDymk-^4q1c&?=XF81$Jcw&-?*p
zF4JP7b(!CR5LpS>-%2(UK@=RNi3Ze`&<L*3kx!sD&_c{~_+8{oW46(RQ|;XQIU(F=
zb6&JbQy$iNnAK093(n)d0Vuc!vJAO&lULC;$|R@Xk5HX2V<LSNxLyX1odol4!Djpf
zmpciU<44Bm=M8g<yjZgV@!3Pr1)GnGl!L&7<?+g}`$SDO0~^ev?Rq+)g0rAk?Bd@M
z7j+Wzly3oy0DwaD9trCie(sc4YVrgo;4!QDB9O8-uFh;`7;C_jCo6Qr&t1N#pLL;Z
zQ{IxA3!Dwaw*A})YV!*l4l*x-oNU=O3ixTR8Au5JuCrsM!g=T<Ffsz{B#HXv4OO`e
zc%JR^i~0w^DeAZUm0BjQgEN^Y)Y~KvAQw4ZK!hCnehWsx^o*p2ijc68I}vub7Rp;X
zn{+0Qg#<ii^)}3Z)N*p6ytdN^IZ2_x!6oaPzoC#^g;;78!t@TZ*|J#HEq#9nE-TF?
zlEcYAOygo6s#0*2{qYEt7f;7@Xx9)?+46#qI((h^C+b&T@=^F#z)M*Rfkw&}tH5O4
z?czs)#p@7%`CqWdN&v4CSOB2;Y1p>2CJ)V?^HB#=8Y>aU;3l7fA2yG&_v$-yVEHKf
z!5U<c?QFznJ-9nBq^=QsIE-I-Pt=fK$h+wRUSr5TS|KhthU^MMiW-E8od$D==qLWG
z=vyuj9b6K|FTAdcm4W}gNKahAi<c`}VdrteK-jc8W}6lSzm~_Wu8XN}o}8gn$M6{X
z2AH<+c}*5!0ofIXbbTibfhN-H85!NnApM(|{W>vFBYgy=%a+|YF<dl$4CzBohRGOm
zN+VCgEV#T64axdbb_0zjsw(T%2zyFY<-+Vw*$oVy2|4YbvL84Dc+jWWSS~2&!bNK>
zQec4iApE|MJ3%K8tC2bc0`qtVg;cJg9)py^wwg=~&><Y@7mf@GM@EGsmxm)2VMy2O
z!jM`EzK<@-tg<V0BE}ne%<4y|p3LE^Yz}e0vrunEn2f^P!;m3Qgds*o9Exd;wRY;r
zaqLd;nAN9>LTlo&7T3fJAQdxGYrISjz95F<HibR;H~VR{$sS<JzG4hS-XLH6)cXes
z3Fzx`m>|b^bLF$1TqG2}+*H*cYt1M;q%j)QDEvb!#7ZiR4ofO*6OQDEBc<WUv~Xlj
zII<)hSrv}_8jiS|Dea_!>xLm+TZAFC^|QDu`sX$Nbe*_E>_|)Q#{j8@k2NwyxdCO*
z?luI}x65$xI`GaVFjDr1jJ#7Klh47xGKR17^Tq!gfp@F~(P~J`KAI204SpV@J&1(D
zxnUXw7l$EGPd2d%?+A-5d^jB09)<*Wh9Tsg%~Ir^E=P88GEF$C2`*s*9<#a_=V#sc
z(oLM3FWtNaeR9rfDpo9?Z0>~G^<_5Fz_5(Mq~>A9%??L;gdrH&cGBy=leMS02RW$&
zmG5M+n)EzdtV&F}cdWqNOAN>Y_6J$O27Vuf_#f5Dvn)h^lH~zUKFyQzo?{wdy!-dN
ztSthvc>P1@QSuK^PP4nkxo3%1>?*e^6V4vcW2%PNU1rcTQ8G2T=`M}rec)<x(_JRQ
zX_jSVcgE0b_K@`9wq<nOhC00%2VgR3HQUM<z8MLH_a!J3aRzC0JOZ*)B)f7dZq8TD
z?sbr5-$ffJJTJmBI>`I{3ZD<W=!zsIhVzSU5WrfUhW~nPD$AkF7K-K~G`%;32G^0F
zGm3HoDn1ACUrYR;sH&y&+*op8JGHPVEE&x_4<CBKBH24eK%*T}!Za63Sb>C32O!~1
zPCj-?!Y@dW3EggsubQ@YgKj72e#BI<!!=`2#61>YE4c{?T=y&NC1Sj~O5>-1=R~(u
zN{0IDEPf$seqnLzhPQ!YL5kWvDxY@nmm;zg#~}SnQDZ@*rCvY4wfwA2wN>$zeEWDG
z(t;UUc+F1B7Fi^6S+9Ox!Z1qN0G>%yN}NO)%yZTf6t{Rf;@^Of;)wt}9snZ%bOq3v
zWM!4WrUNTm4q##wfVBV~C$Jen3(UnjCv?P;Wg9S-r0jVB^AR2VLuXf`);6fc3&Le3
zxQh2?W2)0Ftm?NyqnfIBvl26~Y~+>MM$r?xkeoTcuIc7tt$$L-(=F&Qa0zr&(1<hi
zi)4nr2inLi^)c;2l}I)lsY!Oc7iH!odpQ6qWG5&q(HDa-ca1{UOwk|86t>bd^tqyG
z8sTDTObvrkcr=_SQme@&*y38E;12Dc%kx7y>D{qMK&0PXC=WC-jGdYgBfLCj^{1d1
z)&WW8kYNQ3N{0?$FvuvMj4&Ztm7}&3%*3h0u%$vWY&HV-Y5w0B4wtP#%x+ksY!iTQ
z2y6jR9u3=+KLe;zONGI-8e<@}_+2Dz2hk<F0mwh2oZrN3)8xx)$Rn|27&aA2(E0`j
zr9+np)_bR>g*<t_qhOMpgWzJaB>B*kE+iXH_MCm1S(O=%dp}}(fgVpzlU6Dky2(?v
z7KsxjvHV$p`8s`^PRGvyQ_HuI1T8;gP@2<E6D4V)VkU2dkYW<NqNLr28R<4nIK4*N
zc1n8%N#>woPa$xh=Kqc1aM?SE`3geHJ_gVv2EcIucM<pnz-a(RxzilqyQQeY#F$FH
zS)B}@C~l0Trm@f_3&3mw-2iMSPz<21-!g^`1z=Sf!&)J9pXUFK;c(eF#1w<DY$||9
z2;2bR6oDlGI>!N64WOF9MgZ>t=zYIdXsRyn2ZLe$El7>71F{_e3IG%x*JM1u-VBmZ
zyBZ|hbLwX{aL6lrTf-u%)}nt1dRwcqlIP#(xABa)+^#YZfC0DVqxDwmTv&k?>_RSe
ztjT_dUC9XAp4%e9JHlw$bqEFJ)sPs8Ut9{}4E3Tauenj*zhs1c|B?~*{Y$2N|01t@
zW&60S4z$k#zk>N%SB`pTF>wQy3Fc(=3dVMdm8tP$nHs05mo28rVwkdU`|K#OZFzD6
zoK@T88u4w2slFI9vf^AM-3&Vy_W)3*E`Wgmwh<T(Ag>;PX#my{m<M1$eR#y>0Nkhf
zf8+3F_+QHJpGtHNJJC&AvA%w#XwqLIzW77@OS=d?K2yqm0`?{_aM1(fQ&nA^Bv)f!
zQz|tO@hJ_EVGjVK2;>4-1E4d>%7z2m1FUQUfQIn^t^qI*z+f8t8Z9!R6GV3L74sO+
z-w@2B5mB}t*f3ya4*=KzpoGdlrFk#|mB(Cc7gPDeAdmvoZG=wbLMkat5mMBXvoK8+
zCP7CGT?@#n$`7v834GIqzBP+ph2>*82+Pex^wXMPjpoGfme3M)kaQ*F7dHbC*%(@<
z>X?qaO>|p`=1C+8%^?7tnKYb)@YXN2;LzdSOy-!2w9#$4OI|O_e>y~etYeEykrdMe
z(nbTALf}dO?*JIq2Y~xD|8ES3%dSOCyQVPD`&uNXQ}UGEh?GG{3I3u}^lpXiykUbP
zcO9FXE0%jM>213U&qIn8>NFV&|C9F`T(N}LL6ADhbj5Pjb`ZFFks(sj^O{*k)|{@8
z=n;ulRiEsrETB=bt-$^^lCyiz%c3MXzB%V*u+#|@TfH98ROAdmf)Tt%>%(ebjdAb1
zRBcRimk_`6%3fz$$_U!So?ST)w(%q(pE~MmUY04>kKGz8L-v%8Xn9y)%VSnwaS0X|
zvWt}A;+t6yBi}sv@*~5=w^I8g0GHhZCE*}&^+sxzoQ-G4T?XmdB7Jfq(y%LP<*0AZ
z#$AaQJ{6pOD`ac<Q;?}I$y8eDYAD}<+pBm^!WLFfS2cXH_zlFjN<!s758zS)+ca>=
zW&oW@JM=w3oVyiWq9xE)1z@MWxP`Az9K!517kzD?_T42vQdj)nsDqossQ;&2^d~G$
zNSD!=R$0AVR}9moxg%7XFGHmvph`p9+R{u9D~%uQ|1;O3v0?gk{l8HMUks!EpK=YO
zFH3WS)+ICrv3k2sgi6%Dg|45A39x=<0+15rT*y~by5O3y(w(otU>WhsF`nTmVeWTm
zS~NC!tU{M~#+{*@=}(gLfts8z<f+Yh`+v<@kL7%yfsINOFmkzjYBhE(GVyMlHrqn2
zh*=#m9G!!_)znzFa3foW8cSno0rvpUmd4an8WYnyNn>j!60NEcMQzi&i@dgIwcnsI
z(i~MI=(gx2gG0hn&r31NKZk89bn@{UmHq{liccabH2|xe1@Hub;hrQM`@N{CCu-{J
zNK2B%$)F|ELjZCvBr7BHUZg-oaz=MyPS+ytgNU;FNN>;zE9x#fRZesYAJy4$FV;xx
zH5!IYQ!f>q0++n9jR<*V`zRuGVp1>UV6~CgK-Bl-?S#q5eR2#Ec8cLf>x^EdQh4y*
z+^EoQ+D_@0IzgYj&nR}M?3N!Q{&YbN9+v`qerMn>tKD?sTpR<>g~SEGvqh~}CH*<#
z&yio@U0P$MJasa@<B`{v-UXU1n(q?!(o~FqM<71C8UwubhRE24$n53V64!Y1G|MPu
zg}thalMqCj;f@)JdifObuY;g?KY+gpyaphv4djxn>;$k$z)&gvELABS$NAg^eswYs
zAzMltK~~gM6Y=Gyp&+0)anh)}M@}k>I%*oa)>NV4U}FS_>Uh@Mg?#K{F#*Q!&dE@O
z><foyDt#!X=sJxs-+lij->NW%uWR!y`X-E*U*Xs0&1vx<(b){sxrNY(&P8{HmACLb
zUO9jk-aTQwmug<NIw!lf0J<e&9DTYsMw$)L><ZE~!OvoE`rp%+YX1WTUHTQ+JnuC`
z0_P!7Zd>4PRGfWRG!KV9ApSdAhQ?#@l5C!QqIXv`G%*$d&rXCV+M9&_FW?<VgMSTV
z((&wjqj{KC&>pLp7qvQ^weuNH8ul~x)1vORAPRn{iP%zTNVT$%>XTIrS1+iq>aen3
z2RS5F!zer?_-9z^c`5keJe|a)J&mT;EYpk;T&UBHjKs^kpgd7=w4fO|8Y>5R6*wx6
zXRPW<hbZ+TxxB!t;IzQSn7`O@k`RzH<T`P@#|1OU{@_c`QFS#0Liw20KaWQ98HJ?v
zD0cBo0H*;Ay8?jwH2-f5hszcqCMzA2+LZt%0T{jxK<8Dkb=d=eK0(xAR__L#(|)Ab
zFGdv~L0roWWbqz=sRZ5ta36r)86A{TSbfOzK2$3E0jZxLwd^kdbu-al4%TGSUj{$W
z@=LKX1KXMzv?6aaMoIal_$p1kx2B}K#-OC%BB=wU75@(40D$3E3%G!f|Kj<tCH{5v
z!}J?TPO4#9ASd5j06H_Nj67Ykp&a?P5Fl^k9025>1)%VyTvaN*u2I-JFANzPhQM|e
zl$ZgwAIRSYK#LCG|622_cgJ%3;#kGHReGq=nty>M=0YV-8Hb_uA^Zac+s{=Hpyu7T
z${U3D0ax?VTV;5N$OSI*^jqC*7eU~v4_qTT%pi_M>}^8*BCxFVu8@Aan;&b~csE6Q
z^E-q&Jr9lVRaBm}R`82~m$rbtZq<5jLIJHi-CM@Op!tYT?g)cs0~iIM@KH@AZ#8v1
z0@?%=B+G^V!+Kojw`pE>RS)1#h&~^Ht*C!TWl`4kZ;%WhpkAtrHj2_asbp4q9mr$z
zQ|p0w=yOYSsvPbVy{<*E2kx$DwWx@y6L|3|_>?9O_2}Gh#al*5L%*s+^y;KFa@(<+
znkYTVNzIpGhAQe(%>SigK*5f$c_&na+?p^^I=;EYrK6i99ob>x($P(ljxN|)SCl<j
za#&BC$K3XnLVp~1U<Yid@hthS=Bj8_ZJXvvz4$sS+ptRQtE2mm*Y%Pf)b%m}Krls9
z>GfaeZOPGK8iZ1)?)Ey#^)t|Ci?r*b`I%F_E|$@kx6qVp8Q_rzKUH>)x%EKW6(A}e
z2w>BBz~zYfoiW1!wCRc&)`ddKrXgi4Q?AqEn`-f8l}Nc0DP_w6>;r(OXsf1TSDp&Z
zYh1y`P7;P=J%{FyZUvQP=u|xvDT$22dOAU!2JY4p1uN&x6X`mAzShL7J_PpS5lF(-
zXxMWHumV8uN=?{M6K*FNQ&aLmM*3m^M&VFRN9zZtYec>IH7H`Xytta%8T;?%^${E(
zc4~@^fcco!4^BXrAopQhFLzE%f!I8`cj9`vYofe6@ClcI^ajD(7toV%|HK^mw&+(u
zaZ;hs@jb-PLg=GF2NiZv#$x#^kQ-Z|yi+trCs6klDj{+XUeHOx3p#~~T@{yfi~Yh7
zBQZM%+N_i_ZL{m;deVysne@tyO)K4UR{&pHF>jGcZ&FDsf%)<<w%yDs=^+C5VIHYr
z_4=^tIRo<Q@oLFJeFbW6mOCcoD^T-3cg<Bu=KUfb?HMo38s=FSPufRobqCrZD;Hg%
zHv~Yz4S``jb;k>wYCi)!PgMU~E}N?C1zgnsTg`lXqidBSoRdqZ%t3+iLy?~$Dylc3
zO?eaAQ^*=HOiK!w2CT0Izh9<RLaUR<jCN;Z#Zp`sX=6cD3p7Vei#}*I7qXP4A>}os
zl;r{#S;SV;`y(wkw7IqoLgmEVj1$%7gRF$76~Ai2i$V(2a~JcB;%N{R^UUI7067;@
z4d?kqFshsK1)hMg<DM-t28-+Jq)lC6jd*wQVffMC6nOx^$i4t}0eF<aGXOG+F*K95
z>>FSUfR+6UU@w7l0J`=A;Dt{u0nqUX2w$EA;&{Y-$)uJ5Qu+f(2XHljQXYY%=PUgZ
zx<QH8-M4|In8zO9gP<1RiAeGQt~5XvJgIqj1cMeKzv(KY1$M1RklC8+K{1PpyDQmj
zBwHXDv}PY8c(smZqtauUQB<Oh!MV<7iq`T}Alb|?iYDtsa-7wPp`9<IsIHdB*ZUj6
zSt(P^H8Bnrwa}@2<snm2xy->^MLM1x9J@=z;Yqv*(<^g?YM{@7TvnxssBNGlR09={
z9w~41vr%3uKC2qyXqjNBhBzj?Ay$Mn#H*ztqVb)~LXLZ-@om#OInt{mx;pl%P~+Px
zjc++BL49nnR~p~<z*XaWTN>ZAffyV`wSCgqR8!k8(p6JC;NnLIe}axp?Oj=iHZIXk
z?TA(YGaz})PhG1gWA}<pP5omN%ejzDn%7_mk>>R>05q@G1*-O&X<7BJ3^lJWM4jkC
zx_RYkLi!9J^O#GTR{;p5d0hq|=Rzvgyz(`#YF=2wcv$<WcRYjHbB)#nqv_w@xQeeq
z+!GW$0l*0YmjGxs7`{!Cvbn&@fR!x;u!+DL0N()UxC!Z%C`8%ai0O4Pk{$)H5`a-O
zRcAx@-2fVTRE_)ItP|<J&*{X_3jtv5q3lHWJ)%<8mJ>I8xTu9^7R}Q{^x{9Y2rf)_
z==hKqBMwjQLui@y8F9m%nqsS@(5H+kp$Xa<aqACJf^PCr;~Dv=qeUrj-mYVx6?`gj
zxv1r=IQetH)!Q`x2p%~^Z(`Z!Bu5_k=lr6x?V+>H+Jy~5+a0N9Y1o~O=&6d$NyJ<5
za#)PJwnkAioxs-jb0|T*1R$+is0!O^Dw&@cxvyfBxA(|=u|lWZP}7K7T#b2xtSt9L
zKbeG{5(=vs=^mMpZXlk6tql7und`-t0sj!QeU0BpTxO_m$qe-c;OZmOx1;%C@+so7
zx_(DAXgd@Jx*B7uy-(zo09T)q?vLgt=hJ|v56?sT`_UbZe4GhaplQg5_a6zvJ_^Xg
zSZgc1Z#mccApCMFmJI_jdfI1d=DQuYA>mde$R@x!*#y`NhN28^KjGo}y8!8E8E#JC
zTg20==BahKit!jl?RqO}I_YIXjr!o^Q8R(0n<n`@5!(^xkwBVJ_=!%IDk-{JW30w!
zL&VjT7g2RYRuyX6IX8?e_^3v>Lnsa*3Q)Sydx0*_T~a6<*TQI7i?KmxAFr`R_Smk#
zzm{6~2{y=%A6bJ3hQTI}hS{VH0@zOVQs<B;h1RC_C(x3LUeeT5XNIEIHjzg8iB9Iy
z^Z}Ku%T}t$uyCs6HrQYnz86{(VHAC<IXL;=t+SVH7iEh-bh215I9_9F|KvhFXV>a!
z1h;9Q=Rq+nY|lAlvW`I`=fiVgvc$2NFWNEcv+U8==#dQ(GP21HVKFgs)kr3U*s(G4
zCi7r=X>1JX)fESE@*ZeQ?l;wm;kuf)9n=-6xC|r&Ayvf%#`lAOdXgT99s{_33~%8M
z$b#^q7|wOmf1zeC#^^h!n#xP5>dv)haucAsxU+c-HouJ2vuMnLG28(vmi&#>7$_H*
zOGmgQMlK*pO{j^vO2woF?uK{Ui&Wm<v8msv^<exGp$fzfu7!KD`Koy2>h@6S+`9RQ
zY~f?Ezeoa%Cp$_4bgLKL5b9Q2_-NDN@Hcsf6&##de+^vr`t5+6z}sjB7=rC&xm2n7
zCFmnyK!yEEjPJ9zk|Xw;hQpP;eUN#IWd1sFe#&RJ_OZnEMgZrkQsaGzKbHYKRp=ii
zzLX_R6Z|*es%F|q=GhJNk=EA7FEQGT1Z^ian|6YaCH^pZ75*;qvsjjC+!=-G{ln$J
z+xtR0C)wgc?R|8i0;Fe)8>Rc`Mz@gui*(Ru_-Isme)D;kz>0ZxmhYQsc$-$Zb9^+Y
zF;ZAN_>zgl8`-3^bA3UepF&dlJM5;f_LZ`aZ_on8z;hCTJ-|2bTFhn35nu084D<Z}
z3?PsXU@3uY0Ph3nO!~6%z>-E|P_F<mnZOMIRuZ@oz)1qP09Y~>z?}e20~mTA09It#
z;{a|MXBnej0Pt)pNW@cG9jMhRfi`Rq^UQQ;^$_BZgBra$Vk@9%*>3Rdy9~151rRj>
zz-Iv30O+_1G#}5vE`1{G$8DRTZ3WmgudE}0B_!?z;9&xT0K5&LFF(W>n5+~DO|9&k
zV+tThzGyfJB6(M=$K_C@FYm-Vpvglkcl+*`t4Tf%X%j$IJQTo9HRRuF@@Oe6RJ$i;
zQ;7Unh&*c|q!&eMi*R(=1se3bQFDww&8l|Jbtj?6Vt*P;(L@|y*fAr{DCMnz`&+1D
z9DyP17BTn)%P8K5_%g^YeigtvX403}2%0SwDLh#oJ2_?`$$v%KPLh8O;7b5G7gCm;
zLrT;n2vU-=w50kWNo`{83`uGWGLcjQAm>6#ku+0D;<bf+w4{0=N$q1^qNIjMTSv0K
zysB`irqUgXVRwo7kyPD~c98jH0r;ba{5DPQ4hiiR({z?5Z+e9$?+(D|{iY^urAcoD
z-SD5_UE-giRDS`C+b?Dqh0s4QCvOSO|F!0?(QH7Bn12(qq4{4UsnOdL$d??dbw0Zx
zs?3BxevR}JwuOe8;v!99kBpJLhD{a$n|1PfogB%AQ5OPkMY;%hR#U`<1XL&iCq+Oh
zow#4Cd`Zk_d7g~PWG_Gmu6rf4r2{Vopo+dqlU9)Q*_cw2vgm!U0!46%PSul<sM#TZ
z#a!n@ou;OrvgMeZqVnBDVIzDmQW&>_uYxey3O)xQ*i%#KEk~X@DP5k{3H!-D&vzuG
z%jZ*|OGiKE(H~!j;YMbKi=@|%pNdvapEpuf&J6(au^;yJ0Im3ZDTu^VmjlSTkWxJL
z38bKjwr!nHW`lE+5nz}37hWJK8mtqzU-f@DJMZ|Yim(6Q-A%$KgtDL%0SP5Y6Cxd1
z5K#$BER?u_pi~Pef})5>2_5NJu%V)&0wN;zj=d{(v0}%Ly`lWxpEGllg|FY|d0xN$
zW9M_`oH=vmOucjOox31p?3kfmYj@7vMlz3{1gSY0qFeq4(L;jdOBte;)xT(Lhgn&^
z@5^C7d6juVmmu|fMio?<YW8MnI0;fUyeoAv*2-}rU9>F9Lr3cDj2bw~r<+OD2F3F|
zN0nN<I)g}U%plI+E3cIIz4E&3Kl1uAgL~KBTo$8`v~nI-elI$%_J@j}&4@4lB!fu(
zm_bCC0&$!xbMl`Ij>b;(1a`5di8DSMYENJv&eF{3X#0<`wt0j`IQU#f=3RdIy)A+~
zzsTzD=qZ^G>rJ(zivS%b0<HmE0vNghF!V0{ZPnlN`g>D<AM@9>=MlW=FAb9aSqY_~
z<yipf90BMinY7fbf=Wx(3j$IXJsTjET?C}|WdW%^coMf&^7=3z@Y6mkhMnul5{qQI
z{2sx`!1P}PqmfT8_X4`zM03cRWP8j(=gW_y&y21#7cE=8NPl$+ev#GRGYh%f8KWy{
zSvMa|cAtq9x^MfLXgfk|bS15KCY%Fpr@oG{6Nf&A?(o6!<Zz0~_c}McSUlBo{2sc)
z)mp`zX6d_5W_`3V4L#OhEU%f_b>b12f+6mX#CTIQ0l{vYVRU#y(q~)bMj|^j>jFK=
z=tk$!&U&YupL8LS;#xpu=fDMbXNOaW?1INGRf5#XURKRvoXLilf$k~R)JGZ0u5<zn
zVy2Qu-0fyjs8ZK$sVaRdGJodZ<QYWV6_=!2XGs6Jx2d6=GqgCr#OZY-aMxWp;-hj8
zEwI9mqwrnzu-ij0+%2R<##jTxc0afH?D`=TTU_ZP<ZRRPaRe%Wc0ZM*o5Yf@`!s&{
zGu*4;T1#7>&N{?4Wt2o6GTg7!b(y~h?q!n~?Ijv+`*<O{G7O5p@-kN3!4XFN0`GuF
zTuY^?Zoq>jHDK+O`7Hq*rf{G8KtRr)`oA_4r#lfd9)WaEz&(IceSe|Et1XjDva^>-
z=P$$u=kpX-l>?z7{Pl$DCXsYqsL4?2Lcsk1%HGZE__mh~QSQkCZk!BYoY85?J3N0?
zx#_#hP`nUUkExh`31E%D8UQc01tl8+V*o>@19JY<|FxMoeJ?TF5g7CYAUF2lFtX;?
z`^2MNGpTE2z=wx@M%AYIjQR*DqgevV=zhQn%EJCS?yF*`^4ce#<Yb?ZUUH?nb7L(A
zIt%C-xv_@j1TVO*a&Lo%CSq8skx#9W>?15hgC4`Bt?;ho08Z;EZs{d#Zt9Xj1cP;e
zahZ>48+YZ5tp0c*1ziT~Cl%{Tz<}w1Er8nv9tIpb1CKrj&~x-R5$61<|7$aG`b}a^
zL@>PraPVwy@ZI1utK#wsR?cF;{{e3LZ~j&z!jT}fjrEG3*@F1R{JpMtTh3QI#??u1
z6gmG|<#ohtJy|dZyR@D>0>J4QUM$S!cd5Ha>K^Cs6v>#nbG%%U)cszi$!xFgno!-N
zrtYSF)D<H)^n0oMi@#4z=AM0IPM6F<Es<%@U;VjZmLGb#5z2CRl~rMury*e_SS-=r
zHI8)!4NGvp)U{BS9r@c-uCAAtTOoCSR{1Pc_iCu_7gINNA9cBNP&ZuGoz7pKdCGF}
zJ~9VO<}%6Lz+X}_=CnJ!+*V~7R2__%)xkMPSP3pG7ya9d?vm&~Rpx}E_lKhIOSE^p
z<MuA>&C2;@<@_#x!Td1iw3jRBjk;*nS3`A8k+7VLCE9z@KI(pzx=O83SChYS<?1$h
zxqecYRkhJvUyx;?y4y|N`}?Rn3b~<&NnHtlua~Qf^mC;sle(O$6GL^shwADr2n*7|
zi*9zJSB0WIkg$Txk!bI;y;#@?9#PKcDd#!--Bhk_m6zKgb@8fSh3cLQ)qPtoy3LDL
zFE-Kr=lL>MU+8l_9uV}d)_?CB>5AOY+m!PI{7sRJwT1RxuBX)HRUH$mTOF!<q+IkA
zFFMhQE)PXN4n+^T5UpL;z`j|zeWKjH=dZ8gEw?wkifvMnU-i{c#hFN$+g6r~<_>TL
z2>O`l-=XN8q39pwqQ`jAB8g^IZ9d<-r2ZnWbtJ$Uu+oc;kZ82(z)*B<DEe%<=o?;i
zg+zm@GeXgCLeWDOhg$0nbhd7l=s#7~hoYrOSh21s7d_F7?vm)ARbCH89}Gn!OG2&J
zdC`ItqPwf?2}PSCVOqzQi+=7!`$_coDlHdy4=f2qUnv)DQR*AHM1QSvd?@;JDB5)?
z2J}AFi(#hyRw6fOBqLYkr1W@#VMrzCd7*GoJ;N5&sW1E-F@bBF^`z4hXfoF}d4A;7
zK{Le@GKqIGiSB;PF|kdV#P69zf8VQ3Y<(uNJCg`|s)?=ioyUl<CmGSkw@f3#mhQwd
zIbo|bPT1~@2wRpBVcRhxY#l~~^>0L2!$yR4Xhc{`B7)BS+3t<*XJ;yG_AcK|ynd0@
zOP2VH6eRQ#%1mmei+zP)zp7)Y$_C4zuj+_~{q3CeX`<~p^;$;%B3j?ujn=YF^&ZQ)
z<!8^O*RHB(KF)*gU|(6NTU8(byiK%yX`!ASP*HgW7cKg_T(rJz^~ZSQ&0epL9%%Oq
zP8I(-<=@c0=%Yn#hxKis3#>$2;2)=xj-r#Rj!V17X@kWv$2(%PT58{_doJ{iy2DD}
z{)YjAzWVCIA}?CiIVFf5TeZs~)^JVXb=;RZw1`*|>R|W{K4HT!;lQf1Nm!DGH&gla
z1zZp4xUXb-6r3kzLD2h8ucg>)IcYJ=?;BOb5mv-65wn*kn)&k83$q(rwI#Cl3Pb)y
zWcOer?uiI&1`HI?%Po@u9rsOJ@fyS7Uh9)wX}Z3~!qe@~*bOdTE#&4ZD}YA-U9jSf
z7}bxxLS*|0sc(FP(<a9S*s2WT1!SOyGych7ULG?0dFJ8XD_Y<0@JzekX4j0|+vZ;6
zfY^*@P>F??b9<1NA9c@+chMq6!?YT;TWw!>Jt|)9CI3;x|6+M+urI6*GHL6R&0xKK
zwvV^fw2x;KBsDcdet3rbr5W<)Rmdl=&XAW=&>alcM*%i_#`0`e%aPT0te}pcg>{8$
z^drDc7qj|)1CaBl{;$o%>2HbYe+jGZKLGy#hGrkEH=O7P=^CKLm%=*`aP2DEmA+hX
z;UL#l4stmL(IX<`my+it@b0{fE1HFXl4<<4xSWf(qP}Qa12r6KfW8=brB@&hpC>38
zK-^6*i?8*Jxl}*Dt|JgQXc==sTk?;s+&Vqo4e%wRgO0M8jnfD9Gq8EOnRfMHXIh=m
zv_X+qmwMAmuD~5KZK;6FyB$Ck`80ar{vU*KFAo+>-@8@oM1bi*@mw#v90QXVdqOA8
zsZRVJC2~9$?|J8XLq4MvLq}n1`V9VFC*zKx$Otczo&x8DEAjShz(s(5^7iLmQ?sy0
zV<P71yAY`G^e0dqzxSf~UUaCu-cKIimlJwD=PJDZvrp!|&LGx)h;!p9Rt*@v9E&<2
zo4yJ#2++ICi`?t;YCx+S^aNa0)1Ykze5Ks!McaoZxF&M-a$hNTqpPA6HCNMKR)p=P
z6O^@=7rX*-Ld&PaEPll^yyeyeTAtu+FCU$6h`bTzwv|NI1ilhb6R3K%n!tLmM>Y8~
z!h6?dadofKYQ3Q+{-xGCmU!N=zNCXTct3PJ-E-Q6oV&cM%;u$@8&+I&MdU*DV)dv)
zu+VHiM?f}TE}N4Jd>VgFga#%a2G~ry?XTze2hbedZ?HaJ(Q}yd%HNto_(fJ1T|@>A
zU_BtcEdW0YbOgL|4dX=ukn^Yhug%2i!-;wHTAIQ!fRZ(g7efH)lll7-YWM_zy$_xC
zS#G7)V!72utVCR|6yJ9p+320<LDy5;;@WG(zd+IDgA(4uM>IVRJxgyOpZS3KYhiY5
zexfTx$FNym1gq_h$Xo*$Ag}>&HK6xYFB{$pdsjN|hx-NG<RZ^qOFwp%jrxatB#TJ<
z4SE`J&1R|AC%KFtM!Y6|Qxd(xta*=3s0?n{a_l}MS{f}l3>~%YIg!Y>By}&I)V9Zi
z+?Nt++mkqr?Ky=y_LxxPE0oA#_tk_0?C~Fa7^0p%cT;FzkgIP=-SZL$S{{Y=%uazl
zr_#!O@S&+aN>tdWGdc?`L94?4BO%)5>uG^PyV29$7=`*?b*zJ7jPG314)R?4Tu0C0
z&IMB|Ip;)H54${k*y&vR7)atKmUj9wH7WE7>Q$nf(dnVJfBmcI1}yPolZ~#n4tj@j
zaCGza&~GvAczPjpJ9`*vvV8}Ytt0m=)RfA47HTJK_mso=W?+nC?mO7CR8vj;&<(5{
z+Z>BJNB=6?-tKYqWw$_oA@dyl#zttJFB7|<vi!36R%ok~X_d9zzJ3!cORJb^mCGML
z7&Hv|>6P_3!^iO534k*y<LY3}ZR~TZlYKhEd9EidJGQ;@_DkspCllXeGyPx);AMeh
z0PSxF91ge)&`t8`v!H&0N>2wIw*{~ea5-SmC4kt<-7^NQF~H{i3Q|0W`t+^D<lces
zeSm?0-uH}jMttUKFE~bGPr+R+u~z|)2z&te4Unoj%E@nUOaf$S*S0^LYU3HYbzV1<
zG2Aos7}jASW4GPBv!@F!dGV!QDvO>Jq>l1d=_twZE{&T-`DVd%?ysHV`O0j5s8e?e
zH+hEEIu9B{HyXm{s@&+uLeJC;(->x#gyT<kg|f_xFCCLX1-+Y};>a=HLxb2eb_a*f
zwfa5uPU^Sv2z)-z+SiGqbzXIBzR_jSsi9tpu2H+7fFUBwu2YlKJ!h|zHfIEr-AS9N
zY~M(}?ZpFNmN4ANpGk3F@Lbi#GRM`u&>*$lyHgK_J>nQyD>usz%msRZhX=!+5y=}h
zfu0M?8|_M|M>BuT%%@!ZaxZSl@Sr6-*e8>DwJxieAo03YRLb*p=eCFAt3Rsv&KwR(
zmc1`!=oyx&Cpro4C!VYO;8Q(UPhz^)Dl7Z?Qdu`RZdg{9!~a>-qrALqdh1_pvSfN?
zg)<K`8bd1Aw-epQ`o~hb7n6civFFHr9T@*IhkLUCZ<w<)y;nRhqunKM@q`{wQF2$n
znQ`WdA})Yq342gFa?TauT#?AOukF}J4jr?xedI9VK5}RuLadQ(9}cvGOKX^d#=Cl=
ztcLr<w~lbDY2QtB)5-qX8bS3yT`d!~iKVu^PTaCC8M}w(4zR?9e`)@%=kWEN!1XOn
ztHQ5aLNql(-^{U3`W$AYd#0{uw%!0~IYtUMj6^nN%$CO!Vc+12_0OgWDy``~p<I=b
zr+G4Hbgm|i^X&EO$WJ7;??9gCz5{6^`gtbW*phi{?waD_&0SM6z6m+SO5^6usixO`
zAMyf|=VQv67G`80ZdcBozt<ptlZkEhz4)#2S#aYTW<kAZkA(0I3<K^F;G3-8vhRYn
zPrTk_A4-@i`r`h`-)shbFZze1(R$o(%-!6zweQNTx99Gkg0>Ic#5S05HqF^w?&xm!
zFfCbK-;y0pOPy5T8_hrU?}fdfGwN^6)^{##Kg7ODyUDV@1b&CU17X}|)&DDWsb=<f
zPjv&u4$WG-va4OgtaTUhtL|ftS`X-YKj3P>x(5I&0o@-2%mY+^2yi~&4uSE2^utVO
zQkC8c^#@e?1;8bb0Nw;-ZPjzfNAt+}YGghq=1^kNKLXws_y_QpWVRx+T{4wv2WLEr
zvFa$p&Tz&S9D}j#vlk*zvX%H}5Gc75(CIP2I>1DM)qo8GD*!tL<^fthj*ZfgegSF`
zRQheet$^O!#=8vIII>@nO!y4$CvcNrdamD@%$**Y9yz3G<Bm<4;#Pap^i)Y7QmM<&
zB>r9>uN!fvSv*4}C(|>Eh@X7Q^TT0c8v7SKAkFC9vpy!I{v7Kp(irui)9YWJM2~yy
znW4q*cjt&ERq_b0(>>>loQ?JNGJBA`#w*lZi;+Gn4Zf4euiFSY<^W2Z^8}7*2Dk>$
zbu-bOu7-6oF*iJkGfGacFieF}>aIHwdsJeb5!;Sf*8)~%D;1L_=C-GpJ0JE5WxzBz
z|6xRO&pxX0Q_%4i@BBgt{nC9<_!$b5PkGKKtTnt_aop0=oPAnzeB`ppn#{xMl9-O;
zzZ&QGT3S&0*bMiCvz|O)5`CM87;HVE4HzzT^fl@%udyFRioKfsg}O>D;_E+6%NhWv
z@(iFiV7|bifHuzp+5k2SGzPSIj@Bm)>64(Yhw5GAE$L}l(Iiovo&fi%=cClf3JFh#
zd=oM?!53ETX)A(wuY7jYJ{U9DIv!a{uFQ~gZIMETleCi|yRKVNKJ;29xv@hj)SEW+
z%zS}-dieBu1mGA1EFT_*GA(P&jc(@G$qXV{LRhmN;#<@(-S2kK5*2qk)A`!11`qT@
zj=IVur#c!R5u}!7#4q((PDXc-ddzcF=(|FWGlov2LOZ#qeGSRz=o)AAWV4E|3fXe0
ze{AwXmP-S&Ci|ItGJS?U!ko!?t!I5_w2}nH4Sh$E(Wx$;*v2H;B11C|?)lDUV&7yC
z{k)hKMm${RIZ`k#<WPhlRXxKwb3=}$8I-}fCX-V<CxgTDR$E}!m_TD`G;Ac*_^2J5
zAE|L&xU_iG4y|?PA3SPj)4EGikI&S4#Nj6AObB9+nMkX`daa0ms=D4VVHfg;HatV&
z^W73rl(rY<Ur#THw&kodT209TfH5xungPBMXa`vE68j8Q0Xcu_|Jrm9{u{r{mO@`Z
z={;+BP|Pb1jw8!sD*uh?CBG9t7^#wP0QU;)0DLF#I^fW4fM)>n0UftZI6TmAw*Av%
zvQY6EoZ>G%N27MC=|m@{<@t9=(42Y9u(*$pwg$>$W>_&q1yeEVy~5U&?6$I$LRm4F
z3aH>u0lF#0P!%h!BGq^`8uVD;^X=8k8X}Kh9FJ|ucYH~;NuZAD-rJg7U1ytUXK@HS
z<hEJeh3bs=#2p*mH!_#p5LV|#_l->Z_~u6Y7G-0d8;PK<zunSrlYK9<&@Pm3bKk4{
zYydJ2yJgwtyklal+4g8zu*GCr=8{R_xRFHMm8T5(imJVb^qARDXx{;SJWr<?7k(hy
zp2*Vy#)VxeTI@-e&4+_3aFb*?ZaGG(dsC{|w!F8{%yQ7aCjO60HmDTN9^(|+*FS^G
zdY6M=PW&R0*4Uqn8ZGOI)IkYl8u^LX#^-jo2wCLX_dyxwdpPXcaSKb-s_+OUXq|D^
z$H9re>nNMSqo}zNz9IZtzVJJIJvBcGRvDE#WF{czPyJt;iPMXTIqx-Q%*z0`3ETj9
zP2g5Qr`LIq|31JYXSw#*ZQ^mXmB)xV6IS{qz&!%*0P4O0_#AMrz>k1q-UR#ucnvT#
zuShfPaXiI-BRXnB{VIMFz{IxzZ2>O<x{l~aFF|Hdk{GQBQ?(|$?DdY^Z);t<B))vw
zNR@g4T}(A3DJ?X%@?T!E8tdiMVTxZl&uO*ZlX~D>M}14XAM8}vAkAZFT>Cxd6IL3*
zD_?ta$&A^{<`(-9Qfh~nRYh<3FS0>$fX`hf|EIZrsw>qvHQqaa4StCY&TFEYy^Z+7
zx9Q3^02T;b2KXA#O=9T>pl;fZSDywnd<XCvV3oj!fYiHyuL1YH$4q{u&!AB4iC^hW
zXxI(+J-B=)flm6@I->F@&>o`FwE$<n4`>Xi^#Py_;2eQN0iOx<25kS3>Rdzef}2S`
zh?tLeFi9^u+qqgRpBKrC;#ZObIW~ZS&ESlnagch@%V|c4p+VzL#Z9w}8JvaUFb#ED
z%_TccaoYU==2BP%u`1btF+)$rkn~ynt@#K;rvttR*eMn>Cb`61(%CO|K;<XN*-o(-
z@G)-IDHeC{1@yjA-A`cY6pQl#9rsmYr&zop&aGZO<AD9_6pMzRVuenzSO(x%dKnhw
zp5qMZr_rxX<&pTmWGnG+AyaZEpvq@}b$}xP-6WQN0qT6H-tYUi)zRe=^j7U{hr1eX
z`ZK`mfaD)u%wHJfXv%NTiY?jPXRiC4INcw((;RK7-M$2x2Nt7Nb)xZ~!xs4;!fu7l
z0$qdDsa}a{@6ilNZI{?$HC%s{*WNVrU!RfnXD(Hw53M41av<~SH{s6KCU5t#xX9&?
zWywo?D|YYxvAncb4p}^gkK>Y$<XU+-b@cKUWfvQ8JNMR<kj%9sAbdmG8iB!&GcRvp
z^Ux-iWUd|u_zf?*tLdbD6?ysR&{0h!-A%)H(C%vaF#9_4ZC`LXYg^+z?bF7eLHGW^
zXY;AcC3tiL>stG~@-e2Q-cAzPw_A?2Zy=ux?RI*Pv+pU}HS<dv8;-MYDqkh}Q!D6K
zpi`0aU31b1+L;U}xYFTR`Uj62d$xRXoMWpmrH=FQ8l=wg@oq=R-%VV@fhps?kS!%|
z%+PdgxhCZ^ZDx?XCqtinzpt(!wZltjp#5pD^p>ObW(~8$#x>TqX*@_qr@EqPxRp+~
zG6|)JY0{Hi(CF?We6-eH&5qnbO}cv>YjY~T7QHs7lv;I*%p2{U?#3^3r4hT)PFiv+
zl$&$3IaSzh2=VLe2n20ZtvBgbg^!&?^qoey9jCi;h~e;0-UPkdj!bIhzAV1YWMFlE
zods%aoS9YNixP{uw!q!;P2pXPab{=zFKJ=+_33eD>#5N0mFqK1!%xuew!wJI`24S+
zZ4>HD%dqy>G#)F{g!1#2j!O*2f~#}xo#q@_s%D;jfg{#v{8^q8$BvTz#E(Eh$x(oJ
z1-b&7egildFdooN^63+yK88w<1+@AWa4ujfpxX}d%b?y;^b$b(?*NwrRsecW^!efx
z`_;P@`L%GLf}6b3b9MGMbsfHCT=5jY_4OfYCENj1GdZXs)jy+vQB|KX|IDW^(%SKn
zoQF_;LS?GFq%D7yzNa8f0IdaT14aq#A>HMGZc3EyM)a#t>0&^`U39HF-fg-f--JS&
z!hYxVa(88}35%)9uGa?3B3+-eFRg2}(|uCyc+lHAdh2xU|GsGoOK4wnD<1Co5>MXZ
z3GGMh-J7MV#J42vRX3vUyae|wJfr9l-Vk#P-(zf(8Ury`Lqm|d(OW0c^POnuaO=1-
zDikh$%nREf@Vh5;xpJeWbl>iB5Be8Jr@OXg3$GE&+A*}Yo*Uu+pxbz|+78Wby^$(w
zG3lJMVQIDB;*68e1nNTJ;5wa^z@Q%Ois&W8;NS%`;>f|;qikVcs6ALOsf^V3*dlGE
zd{hrMha*Kw7BuQb<;Bi&*PCO>)C~n^x$8}R6bz>NZId&Fl!nVnb?qtDDULLJt#$tx
zJ3lGXY;&k#Ox9ftON~2e3K)|mV;XPJ!u{kdZGgK0<W&2JySqL)%}#VGY&rs&v8Jr>
zCTc7;&f%3M;L{zpdw*xxSK|vW*CaLG^cU*z<k*=e(^en3k})!_Rbf=AuX8Cz9R<GL
zq_`&0SC<;y(Uz#FO)-)ABx+(4Tht~t=Z~mOYK`rk_?QV6*6m56>|EVZ)FI}voZJ?8
z!+(*!sm)KQuG0gl#ZL8`<*FBFs9tQU3$0K~O|Vtd@gq6gY=upXg;w&FhS4{#5BlD5
z9~tX+d+6+UVsf@~>U%L8m49T#6MNszSa*(exT$@X?*mg%_+Sw-AI4OK!Y|u^cQ|aL
z>PNAAX*NYRBDTp2n$;POz?SNfapk#gu|^VfUS(yp@3R#7_IzP2e8DfW`jdykZTH2|
zjcXX%7$~}&crdz_MAe*Y{Qy0#iqUFa$BN$86MCtA9b~@f=PT%kMPJ4CuIKmu5!$xx
zm)RFX{(x?0+xE+%IqaiHSH{~}GhQB5GmfsT?k0(qX78y#h0BtQqUt4g{lX+sstN64
z%YEgq&}Syg>0!S?e{u@+C8qA6-=VFIUm8^#|4{T1vUZj6NB+Sivr+B-GSkP7+q4eW
zt}i!w&Y#G4mHsP?PW**ElST!xD@|Pqq&2RqOj~<9vE=ILNG#RUI~|T}54bL>do%ra
zlaenku8nF8SPbPRvu&}+d^g4%cN-H<tX}NLxsEQ?jC#ckM~u)k@N9I~9n1jP3<G`t
zX1xCsfj0%d2UPtB@G0O*0ex7v-5$V8fQJPh2b2UcHlQ^*R7c1CQ0aPrp^;cHdP_k?
zZo3ePbb3db{X+DtXe>D4D?rJI{8eGjFL@m>U*K85F9Ht(W@XW0l4EB&n?GV0(=um9
zz^_yz=69a6LPOH4(R1!ZWk2GpW~1Opz%2q@0PS;PLC5N4P7!{wUwSB<yWpe_@f_`N
z4nqss@Un0FrjzYBw`89THY{Ff<b@n;&;WYPET?p<Y&a$M$bHyw5%KS!w`4w`M;tH}
z&^H%vNi2PhqVr<GpbY@NR68wwH{dm5(vJa-&j-8&xVZ}89YCL|fX@M=ssVlkY^zT4
ze*n3$=ZE#O;&k20;5gx4^yf43WYs{j4&YTlX)D0AInL6uG?{MB8h#I!mJ&a{CI<Ea
z?7tr%33v$5O=9U0P%rO~rZWINYsG@zmn?Hy$jg3L-G$f`xU1nN@A2GkF)6I8(xZ!b
zHqbM+D)ao@6q%nemU#OsIT7>->AQ)YJ{Rg2s6n#;v6VkhOD_e?s11J?{6UvnblLRu
zTEKTir#Azd)&XdUD;9VLFizlgz#RfR0J{OHi<Y|*$i}{Rhjy}f;V!~7_ILMqzLqsJ
zJl~eq+{c;bZ$~iu(+=GohncK8idHzCy7XS1snaed=6J5ILGE%~Zo5xsq2U=a<+Z(&
zu?%_Ib9D{!N0{vAY3|a6y%*C_{I-{}^~bW66=iFRk6j%o1^4lj>pZu7=Vf1I)M)aU
zi=B#7&Q@}NUR|l?$y5BuQlN?V;jCv>hc^&^!e#t*Q*8P+Q17}_R6kJ<LQR88KLgkT
zNItjFDc2?)wyEta4_kq;ugfp>ns25O`Hn316=R7Tq^_Fh^yuB(18DMLIk`ut=ZUr2
z)a#BW+toL{V@cAkTsBDF=L=f?!rrWbR0BUO+UJG6Te47E(bMSqYgtF#Gus(aMp<KL
zW&MNhk{5|rw=H=Tu#+N}+y!{=0Cgz2WINP^`cOMWeGZk?fHwKASEYuqqufRe$yvGW
z0zMlRB>!IIGApk;=efydajN8^3V$?Z2&(Xh?oYA`M@x`e;-z$nd3=VHZY9#5w1uG$
zNVqG^X`J`8!zYl7E_DfVWB=Vv=kDXC<aa*(Pd8MURFRpxLM0#COk{y80P8dR?IAa}
z7jRC@wj}UUvcL<e*25CoV<JJR7F)-AcF|z!<AT_{2dR%Qh@V5+Zi-C*1oa_QdJkag
zfq=@lb1p<fKyAQmfhK^93IJ^ZBO5Ucbpxoc4KD_io^S~FzI{%cmD4}5+wLc)%ZM*-
zOocB7tPq$9cu!ywps)$xRKS@4r=|EpSLPkk(je=XP|KGRm6nE0y_P`&(z0AYS|WvL
zNv-g9Xx^&wfOE<;;<seP7iPqVcI)z_Z+Se;Oi!uy&zi0`cTz>Zk7}o2tQWHF3OC;L
z^lTe%)_OuUa!H1))k><RFQ7y>dhR65YnKuKM7bG3>INULoIlCXre~&j$otNWWX11h
z5UHI@ohNlz;z3lq8i)2l!nS6YYc?4C>?LK=VO~-m%l0i*@q>K4Os$d;KcPZC*(@Vo
zxgpDju|CW398&J?>_xU5KZTk~uJyfFPst#jwQ|=5x-;trKDOXAuW<1hXP>TXKa}LK
zjJD4f#*(pb(Hv=pl9&AOt#2|aPq&9;5AkKKtj<$pL0?@X^jxxcSBkwBI|+3qC&D`s
zJ*hrkK%W~u0*=$g7vX)pd{8_pg9wUmFLOH8&{B>4U?n?NmZw*7GHgjb?T2XPvc6m@
zD9-V-h;m6a@`OJ3`cj2Z@=#y9O6<)G8das;$9mhD36X9ObKPc-<Mg&e85-LG4883D
zg~oRHLa`mb;I1}PmPp%GeeL!CLc6j%x{^kgpiviHWR=C|M)0#P`Q0^OS-fI<tSnx!
zJvJ+@>lT;CthjD@xeKv5aeH>lt|jN1vchjpMDaY6FSJL%JYLd)`1x^Na1~}1gBO^L
zyZCx5-m365%_u8eLVMD7W!w(!wHtjG#dU+XRpDRV5W3b0+0lV(96qZv@z)u)-M8!G
zx>RvjoHxX+$ZWo44MeJz`DLr02rC|*%6>B3e5+MSUMQp4xXriPmE?&XqHS}nw)u0$
zLC{tMb*u&sX&&?2zXw#3SAKzZ&ji=A9QAl?2dky}R!covutwFTW3x+KJ1e6P#F|&y
zvXyq5PgP%wKuG}jM&M^8JGRu6irAn!L^D9lOg9CbPIS5r;CevcCXKl%cezv9f~wXp
zHlR}ft*Gq@FKC6f4uB?r;@7;S8aW>h_onE%*~uiJ87i0ZW^OCH$zDi@Wvq5WHkY!N
zwEJSVeU)r^g)?D0IjJ>IBj=!0O}N^nj<Z?i?Ov(d;}|xP_@Odv4B%3M!GPZcjs_gu
znu1F{Jq_wqsPsa>wE~v_{uWpRIO|~Mu8jb5&b@&9i8<*Bz${<VuDj5aOQz`;iLKOz
zl-mK_1wI2@3+UGK1o%Hfm9-`MAHY`vdGwS8MSxm>F9jL_8XiJT-bZ`8`!ZiLQpaA7
zfBPsU)A1NX5U2n;SmR=1x@|@*S<9Oh9;~r)o!rfR4DNEdqcwKgos86$RZh9~11miy
zr*b1wcR5m@d5-o;2OEdM_Fn%O%r<)rCVcYNHt~20rpz8FaSvUwcj~eWcTZD|d^xn+
zI3-kw8EOZbAddEY%~@B3e3zm89;7CF0nJShI00rNhWi}l%w3(-7B8XFeC;J{_A*nn
zFe^VUMCDJO@7+{FqoX;6kC#Pf6ws_voqUth-JsS~ErwQ-2mG$=bXF->dj%STX^0b>
zahk1fqB~SwZ7Y591l4sT@z1Kd%E3d#{GgcI0kzrzt^jlsSPB>+FbgmT&`qk+&qCb<
zm3{;8y}(C+k?r9Z42Az4)JCZEpMZD=E-+v6mN2^6uO_CX`?D@w2seEq;9)>Aa;0km
zI-f{=%BCLcd#rZpdze+E3@Vf0u#Tjx4Oj%|I)dolQreuDs-0kU01N^Iz2EU#PxqNW
zB)ML&?}werzN(_xO@pJV!Jnx{8S$4?#3#G@_)Ht!O+Zztt;@~QWZAz6?k$2n$(u7q
zBpZz~p5j+q3_5?)g=?Pg?Ec3ZuW~t_(2ozSKE<HkJ8csB>iaH=)Md&sMsF<OEuqfP
zc{PlV(J-#-${;>Ei0;bK(0OY&T(<((J;dCgFF8jSRMKaJ`|fVY$rG!cWAc>~KX~g9
zE2&#RFHF)XssN?~f@Etist@0)-ew}+bt`(OVqVkH?Kt_MlJYD4lX+&57Y>G@vs$J7
z5GkqMj$0zqSs75HI}J(PbQ7pWQ0X>+=K#8Y5917}mAU&@n0xoW=I&o<kW|aup*_60
zR{(<Kv-_AUHy2-hohz=rm)&&)x!g(e_6Hq}mCsbFR#QXn=9$T-u6AOYO;uF)W|F(q
znj!mEkn$x`y082_RB1JlJC$v5N1xQa`Q2L8I?vv#F1p_7d<9YcBCD@^nrgLboL5!V
zSotuj(W-f#oufKVv{mc8s;bs!p*!g?=jZ~{*u1B!=7m+|_Gh8`-Q1MT6Q5CS<-#wz
zxN6A@#P30%WGkTLaKN2_%K*tKUOX(TZJ78@Nf%+2b;THzEX>vS2O|xiVFk5?)<cAB
zZai$X;Z=oTvwdN%nrLIQ`@&q=-MG3GTxdJvwqp<enKojpujt}jz4h+CA-KdcDZH5R
zC%QD3eM)W2(<-9d^DOsu&!Ww8-=3%3Z5;_y8eHz%^D1(GCr`P%9N)=Pj)nFf`=^yv
z(S`O-{AZQ*PJE%g5C28w*)_m@*yxMyv^P)+#}!xL>tu+JzcU5?(#f23Yz4OW@V~BX
z%eKt}iT|du3@@xs-ABK*m#zw1&}E|EnM~2MlKDHo=sdNPzw+&F$h{O&g>JbNQ22s4
zt@1yWmey*f9@kgO*7*-fW?Faf!G`U&L9~r~b8VR7+q#$4-aQmt<lc0<rz`l7e0iZ&
z;i!%fbMu=~bdmPj`*Znb_2?sDxpT9bt<}b5TYNSk5!6s+SciWxjBLnB#q2Idk8qFC
zt$HqO2S?-?Hjf{f7q3pddHkq6dAzZCxp$uKH#N5M7Ux~1v{v3eh712np}1cjE99WC
zd$)3|&(R0bk$KCqiN8yp9hIlSt?*cteYC?b%KKyTK5C-^HtGp6H&5j)JT?RGFQ?42
zC*;VZhMG=J{5s62A>TKPs14r}i+o6oYj*d<)a<x4iQX4Gi6oq%93pNrc^EY6stVlX
zde6nrQz{+)>myuS-ef(=Dcxkf!L{YvGJ4W&){|UYzRh}%>oK>x9+OfVbXW#$ad)J)
zsdx@I)ra82_|}8U;|urWiY9tTuG&J;4R|-&HZSP>LVv*KxEewA8*m=KTKieRuyw?T
z3|rO-H^<cpKVcMcUm4vT*D&zf5#cblIj+vQp?5fp-5!@$KNf96!tHjcb3k#-A6RjF
zT%Gi^RLl<zcf{pkci6<8W=&ZM*9IEo9`<G>omD~f^xWkyFtll)`{QUo(4BaUALt$h
zB;WN({6NRzQg0TqNZqQCW#}`!AQzOXg8%fQTN&n~6LWK3L33;BuJBkC767gh*bi{n
zaoiD!14?$2ZU<D!F2JmQ%x+4Z?gH=8{>*Mi0_qP0^aK1VZ~|apDc}^qF~<YW1{{(G
z%mAzboU{ng`es)Jr7C#88y!(}BBp(pJNrdn=!JvGTBG|{0vg?i52ny(c=3G-ZR^<b
zB46By-EA*8LV6Q<&0a$9GsHiN7CYAB4}s0Z95sX@uLX3ItUtzrCm!GN8lGeb_#Lw}
zak{M>ZQ}Svk+!QiErNUX$pT+2$^S31REuof|E9yOx;M+lMtN6-HZH>=vvG@nY}{FH
zqh!l%Om_7e{w+^!$_%j8oios9TH=%JP^N`>xi5RiR6fCH+EzfB4g@&INVX!=)BkIx
z?wh~n4%TBT;!-c$Ds0!S@>Ya7P7ZUtGR*OzFvpJjrmM*Pmj9YN^}o$tuCvy#SE0M!
z?mVq03Zi>*v$y#|{}P&T@K9gq$pBYq$yQ{0qSx?mp0*XVEiuAOQ)Ab<47Jp4OKvm>
z-!bW+)=_<HO@)m>-<CekNm`{Lw^?tv?)2q7mwD}+Onz=`M~=&c!$N%9Q+C(<kJ){*
z*`<-XXZBVX)ORczw+_$^eI~<pdP!Z|c*BzOyhp@Wd(Yr$?-1`D{3@f}(;9OQv|;@U
zeB0p#Re_^FhPIAy?K+opnRu;p*J^xHXRR~Lw@FD_n@kepsz<UF)$_R55LQp-s?Y7Y
zs_T|l&#VmbSIJHGXC$dO!$nsGsn9$rk5Z=pDs5HEW%1pvIR9eI-kJj&0zdM`Y*p!d
z<}M%y8~2B+^cn)^3TOyi4@mCz;`<DN`;Pls*;ZNa4A~{kZ^iF?2hAghe@O~U0mUZ*
z`T({9PDlbuiumh#62rX`4LSoVrY)^0fGtF)=K{tL2dn^mFR&UgdIVq{;BJ9CJ!{Zb
zK#bRl(k}pJj)e6#AT<i`Dc~Z3U4T`inHzQkcKb$kQWlG_8FxDK2jxTL#&(6bmnRNq
z<^DF-9Y{PEI5P&dG_ZBXpiTxjmcEw(j-@{qaMT#`IRS8iz$t+3fI(-Q%(fY&TJbIR
zz6wU*t26W0yn!zcVCuX5WL#7gQ1=u-RFk2=uO#_F;48qPrvg3zJP7C}4e4eG7Mw<I
z?Eqr|T_+Mf7p>{Th`Cd&zJLy60cpSrz@Sk8o#Eg2fyTV$eVZ#jOBwq`$LCFXU2Oy2
zH%J#x^#V~XLoCT<J|-_rG9mAlFiEv>B)KLti5+Vd@dLt+5tRG-yf-DT1MS-(ZpXSE
z58w)RBsVl<{RB*$LR9(!z>|QX3jnDP?sCTJLFVen**Kw%u;ecpobuQpb*#@<Cua1v
z1ng?MgSRK6Z+Hg#6vqxnm=)5x(>D|)r$73n_KH8vdV<fhKAtIFpF!ZKw#`w$!CBif
z^waA6!``IeN5lI|1s@DJ<aEFoz*z!40XG9W?wd9}5zhN?`s#rC;a;;}UIx*Z^IAx=
zTw3#t(4~MN+24!GNH>6DjVXD_a~g!^P0v3wR5B%0@|u+Nu6c(mNhdFQBXa4PG{s+G
zC);~&`Qzm~rsuR{AW41UTl<{@v7IF5!p(LTgT_H7C!3`BTFkcTmvA$c-AOGcQxR|3
z&Fy$T^({*mE<9}j4QI7Fw>YzQm+{#Rlk>NjqSNh|t?B-lt#vc>l&C3pCu~i}xcDZQ
zST}oTyG(LpXY}c1MWhMk#?}o82@bK{l+Qw^Vt5Er&3t+px!$FZ@rofS_p<R^FD4(n
z7m97I5OZl<$$73m!b$NLWoX7_|5kKYgQ+d92$jMbte0QJh-J;7?s(q}x&z#~Z_|A}
z)d<C($e${4o%=RI;yU+j4xr<{l6LOfO;W@NGcpJ!ZKwX1QUA{oH}pz?&9MFbP`VkB
z=*Rg1QZ~cZJQL+Q<*l=TR(&S`+zcz(iW&B7uOXb&Y`V9d>%AA5sjLjaw&dfQww!P4
z=873m^9tM68R94Xuj0x5eP`B=u{6)1;CANTX0NAww0tCgBkJ6ld;2o|nR}_`z8mN*
zi)Vf2<)_IVn!)@$WcH&Vw1m_to~brgm3dXR*a~9rc{r8j8-na@=H;+CmG9$q99$0{
zueLwQ$4l=i|AXG=eQ}k3Mn(GM?hJQg6EBoZ&uKCdqbnII)5n<hsRBlkOMQ18>)YRJ
z?=mxeM<0tmVb`hCX%x0r2?ckk9X%O81UXx)+@a>9waVK9TC4m8NN(_Y_gSk@Yc|HX
zE7Xf=bx(T1f>G#wI)0P%K0|!L1m8Yofwj*giE-^yvK8&~ORwQS+o!)&vx~QI1(*yo
z{1@>G_qg?3P^z8H_ck7G&KV&KUyb*99}B-DeyS||7;vY+n}Dwbo&yw21Uw8lL0}8u
z20%Ay82TqvI_DW4;wLIy1CTh&`}j+r(;DTpBKL~-ypM+>U_Ra~ARq4pBontf!}jrU
z*bZ}M1U-*viYsj#c-S|uUDADBZgrJHer|j=Dm4!D7SK2_4&eMO*$O{@;x%~3{aXXu
z>oPFe%iH(L4nJMk{)8V5!g<D8MEDx(Bstoe+f=^_C>V{oyW^{6uC_#$%1Sl2Edp}I
z8-V0BUfjFFl<Mso8XJoTbl${LWs6^(Pn6CBa^FSg33m|RO%drwK)<6a{VbsVB*1Hc
z8v%6A^?n~kW#8`uE6%@_Kcj=W7L+Q@Xq-p7gl;vn@0jT2NBAb7j3ztz*vws&qck>i
zpDyfEtjkET?*EkHT3;_Zo&7PF!e4Se=H006z1`kgIWfFr<aQP`0Wdi-zA!oR9Ep|(
z8#1nZI<l|!zmGu9{Ng8lLU)_tr=e8MLK}IC?m1koAt;Pkz<!<Dk=w6ZX!~`e&k6VI
z7TSK@RifS2z3taEIXB#|yU_OQZV~Oa@NK`Y{p4`J?n2wIdjQ()(JeL$jyMncvZJub
z(QiY$t^OsppJ)B*Z*S%rHL9!PW3bWsRii1sUmYc&esvna^()Exe#JeS`uDnm`hK<7
zmu%I3<#a|bJ2^Eq+-Ij6T1{T~ncK$t=0$kWs%mF|+X%5XHiX$JNN&wY_kT<ibl%a6
zG7UFhjPORbE3b`*J`QVRxYfpDisyDuhg)rYCE99ZxYb7E^TXO0VYM+!wAIE4tBw1h
z-EqGotTyUQ4ZS@oWA}8lS#ut|4u7bvIQkE0tBqg1ncGww=fr>f$k)cW3w&){FQD3Z
z65wh>vK6&a<Gy`r!#Ov6%gJ0C)`o517Wf1WTr&-#<Kjo-8XK*4DmRT*sc8U>Ru=)1
z9ek2-w943kus0@=U*Zd*J?i<Wqt3#spmp|z6I*lWKC`I7)=2c~RgnB9Bjx`&RnX{*
zo_MU(z2?#TlknC+soffA{NX5LZlZ{VYm32YdnBxIzmed<u~mvch->rc(3r{Sb)D#N
z!>zQ9zbZzA-B<8P_Z1w}eGiB=G2QIoH=<V&*Z6(rM)+Tg9qyH+KH8smuO#(3CKkSu
z)JKm&9c=F*r7GS-O6jJRdk-m9@g7o%GzN|K?~i5Otr0~Uf6DY{`~Tgo1-n~--L3Vy
z+kV}xrMjCHJ*-u_{@>GDq`Pr(xG8IT@`SU4sKbS`dXS073$zQ?E3VrTL8HYdKupWB
z!i`bxcGGcMmhLt<%`>v>UX0$EiOw`ZbKp|{_E4i%Qhl<$ZWy@}4en;k$vH}84|_#V
zbuU0ZUW(vp?yX0A0xdexQWa*iZj7E~FCb#kAHATCar$DPh5C*$eNFZK-RN<quj$w^
zQ_3+fR7U&x7b+(YK|wl4x4gKyH2+wr)>)Au<*Hg+f$Z6{Xd5eq8bsSHHHgCELlG}>
z?^1n3y+;o*%qb5l=3o=T$P<;vTdr;XQLgzdYnz1^s6B4C=NzTkBRvBbb#E;d{*y%F
z-I$KRYUO<NjeAQ;&$UIrjoEW;?{)=$Z}BbPC6B`E)t-Nj>BbMqZc{FMjNPj6l_Mac
zRy!(n=h0oDf3Vkk*7&adR26Y(!>i}~z&L63{6kdr{4OIvmv#VBs3|`*9a^s=L96pz
zJ0lz?f3)qL=`;O<Ytf%AhuF$*rrUeX(O;sf_2Ff)puM%?U!ybGd|(rP#&LfSLSJF*
z!6)5dR;s}|xZe@M7<h?T{!Rv|cZmN81tl*5>dw+07TombQ0GFWe*|n5_y<sbHXx5a
zIStTt1cKwgU_o1(m~<ol-V?tSp!pm<r~!YV_??OAr){n5C!7IsIffsd-nO(BBc80{
znJTk}tr?O?zW=x{fWPPqFVTY3mA*83Qtm>sAx+N8x2NZH;PK(7Jx>>RYaEYnz8Amc
zquY^1>I+YFhj_xv^axVF`RIW}f9ay#xSJcB?DrvpWc~xrDhZVjvAMBT{^5NLFVzq_
z#EWf}!yCm0e2K%C62FP^mdpke%>|qX$ejl`129ZrB%tzqKpL<K&`lcBmqUHO(7)F-
z+UqVlnKpLJ-Kxu93K%^vB-vMhj|DyiJg^AxI-u%ez_WnlQozH2uK_`-=Yy^=OM3F2
z4SFb$nh+;&KH?a9>1k&sV~}SorC&uTRC$Wkp3#j<*aI>dw|K^d-FQYNgONPK*ROxE
zN*S|~;Vl^5!Q>SOihPu}Zz3g)7RAo_nxbwee%UgL@gksPIp9&i4uQJ>udTpml23mI
z^}<S;<qv>17qKz&Hz1w+DR1OJ4cZ^T8z9r|nxn7JX`6C7GG6N|bnBYqA0%xSzvp6r
zX7SCJ&|>F#aX*Vojh5+Fg#I}*_qzD<qD7~mxljCIY1YM8(^V*Z5U^E1%Mt@?0mCk%
z43hUtld>79ue}y66jz`^O;0;3e&x6C)oZfn(}&|kmO9A)FS2Z<Tui3F`5ZLn=@;!A
z?;(H7*2^)-Y<*Bbwtfh(B~-_K)0Nwttntu)vq5h!*>wc_jbxR)&F8IEzHd<~nr#?3
z-}+Up$~i=%AgM|<hd1|mOq6#!#+rSH#qEiYUan?9Wco0u`=Qb$faDd7PCJPHfuf}c
z6ElyPRQ|)x(ylc3PvDSwZftWi7wOjFe2~!(sP@=m=@`=9>yuSKl?-ppI`11UD$gap
zn<CP)Kn<=W<E4NlfNnh%eI-=2t7v~W0b)FanflSId2%EV)S?3q*acF#3#_IGumM&4
zs_#th(aE5%mH|z-Iy-O2C;CNi&-z7{JPEJkzRdJ1#I_^*^!tEm0$&2Y1#~R)ii(|{
zApHxRCaY=gn?2{{&gL8J(J$4<J742))o)$ZofmLLI5dNCP$pwa2BT*tV{ry!NG9W@
z48|nK;04I`jPxgYx9O(lmByjccC;<8G}{XaQs-reJras-ZB;I&*(SBZ3#kEo8VdD1
zXm6qGGK6wzXx2*B)ZI%cS=+lxKA|FckMoeGoUenyv{)^TzVZSS)o6Ogc70Ea9Y_2S
z9NkTk>B&&bq0+MfF9HTF0jM7gy4*n7jIL`CY(&!Zjl^VKjqvS&g9IJ|OagS>flRh!
z-XmrMF}=4x>WnQ^_3?X`Ql!6x`y$-r_nzyY6L%NsL2{dq*7Ly{O5EcRy42L;<#v>$
znlX)SrI)PhwDT4zs&}Cp57+d(k|y*Ij0zh$XRJNujMA%Rr#g-wPs5FScUM9Oul4t`
zYX7MzegaX#YyKsnT?nh&q*i7~KJ(ut+p%|<A&H558RGTPM1s=6xNx{Prr<Pc@`%_m
zyQs;NiEnldHL1w-Sx`qqrKbZX2wVtw9#DKiMoEg-W)LXXVm#X$(of2hu}4vULUrQ1
zDI#4T6uB0C%>l0pv;*X=0rUV|2k3p8AFtZ_+Sr1MbP3$T>!^|9Lp}S<SR^b^xMW<R
zJe$Q1Wc6wVN|B(OBCS9ZpsYX_38+Bd0gB(v7#@q`Pq{jE<5cQyUp~EO(;2PiS*<hb
zc{wrqWiq;XhVEgV=@@ROJsRH`Bv13)TS%rRslCH7OA}cAp_bJX{p3fxuwP_#!H+?3
zWIIfC0!^=v1xMPt`@>C0OceQJU${FY_#ou5b`|!?TznJ1ff?c!uTqyFm5@;hev0&G
z2+%=&bOnOapvN{ZHW{ZPqUoxCgz+gSz5-1r?~#d>BJ%hSFIlbJ#*<Oo&Yn1pn?&UJ
zL(PahNA(L%?%1B>`$bM7$u6I~7pnA&tZw}i*BVxc{Ua(x56pJg3biA;R=674Ug3|{
ziL4^UYbw_GXAZaI`hL?Ju2^n!K|_3MX$JSF|KQ%5!A+34s|amCkv92a26rz`&}at*
zh~-9^OM=KfBy{Ii=SB_NVG6l+m_lPatU1??Drn5zjv$t22NM+La(x@iH_T;Utcpn#
z{>7DItg2yq1ocH!E2~z8%|^m$7Tp}xWhYlhv4ae&S}q{Y9txGTJrtTB)OZNo`Tl_j
zu8+J$zCE9HUiwHQ8NbNtLw@tlMncZ6zm^L(J7;1;L@n@X(RR+nhKM#QR@?}^ttT39
zF?z^N(8uN)tsGk33~lF3IR0It?R@H6%tbTS#b_HxAipu9Ee_6^=&-y7<fe$4=$Q4?
zt$FUYh>oGSQnYz*vt`$71GIVVb}P_VqV1fDE!LWL-U9u+%)8s<XK#!Jr%aJ~_eFM-
z-Ki7K<*<inbf6A8QQ322xBBNYO4aU;f6h5*D`Q0Lhsfw(88}7~-{)4Ai^l^#5=a61
zZ31)$Yy@<Ze0n@o{5FP?^8wQY<^b*h3|bDzjjahE0Vx{GlNrB|<Z9v@Z$@%G-~>SG
zxfh%T8ZWLygpO(ZV?pw>3{H7$kb2{Jmq7FM^OnGErt;mJ3{LS%pV}sz+dZLM)P<Ch
zcAXo$>c76W-8pKvs6+FEWFtMp%dh;E@7w-s+OGSgWx$SkC(Gj0VV=<WC{H+3Y`N@8
z&8XwIlEd9#P1o$#Z+2g{QXh|=7pJ2VRL^D;Sswvt>kF>3zUOsn7&ybnYk>N>Jg*=*
zJ;NR5il_f;asJ{CBzNn>M#J;SItr)r`Tb}wldVY>dEe|b52=s+^?TUICR-nyPCa+o
zpiX|C^|9>Rp`S?_tv)tQ^cL}_82>xb+r*z@je5%#(LJHhH@d|g^eO9u=bHu5l|eh}
za_3u@(@`$gBd3})N4dBTIMsK+I-PV%Qf!*#bvwFT2b*rXzJTteqmyDYEOmoBp*ekh
zrVYLGpj`KwW!)=vnJ@gSH0K!<TLY#pe!_b%T5|cCjI9iG>m|0bx_zU}UfNAv@6)U1
zR{8Xkskt|Oyqe4=AJ3&z>N_8=1Cn1am$%+gzQY_Ob6#@IRZ>`#Jvo?U2SqZ~4X_qQ
zYhqICTg-U$o{b{~K1H>NtHsFboqvQoVDCq?1NJLLcROGonB$JW3wmj9G<;|p?u2$9
z?)%6_w&dM7)+WV|Z5q4+I(3@QM#Y*>1{fF1Q?Gc$GxTuHHI8A+`)xj6v-e{@-fg_g
z%kFLQkGzap`8(w@LGb}EJ1^K$=H&B>FtxF5))jfi`Q<G(>n{pBr;|x&lKur_-S%JO
z=*Bf%&ff#wcqsfPc8bn@qHD1}gVs9a@Ovrz_(`X-__FQ6XQ4ZMeI)#Yj9=qER`nAZ
z1h4s%JM}vcfzibnLt!Krd3$_y`E@!SI7p55EG<huAT18l(xkM2wM)F9X}q9W`=+s;
zC-y>?fi)+#BZO}Gk~-6;mtTK%={3n0U+v><4SCvO?J($)=w=^@-S&&D9w)yH8x8kT
z+XlS{bKTP9GTX+C-Ou{*QJ+j}y5jAgkkgC5${>O<%RAG9Kb3ofZLVf+b@^yo-pw*k
z8O1)6znh`=NSl>E*Q7j8q#fS$g}nW{NSicwYR)|U0Z5w@zm)P1Adj`TslV0?d-8*^
z;3ykBzR_5-P^8W8Mt%mFI@FsZC)LLgwaS(KcxtW8Gc;BcX{*(f8;ropqzx9EJ->i#
z^`qC2+}3ij?l$z*dx(Z&1?geErc|_Lf0zv~OGTS?j($qCjb%M;EZYN}eBNiHK}NRO
zx>d{9Qfiri#q0prwFkRx7De%#7IA|$TW}#2oP1wp%ubov+q^#3miCLRzWwje?7n99
z(GQ1amzde}M4Q=1o7oSGHnSc5n`j%6kFgwz9)Y%E9BaiG3!U8ge=mkv&RAJdkRetO
z`tZq9I#Q6qmd!4&k>=|Qa??LyL55gC?v^1o^_*Y@`Chb5JwvS^&9_3^)Z_RgMcdTl
z_*WX;lN=rW8nl~hhWWXMJ(&*WY^I)MgI8SR?!;>Af2pmCVybu?BA`OrJi+9y2?Dx~
z)!roKaf<V;*WbRp&>Q!Jg+A2^o&RW9=+mswM~SvVkF`S25N(Ba{Ch-Op&fsh(JHi~
zTRaxdx8ux$^7;1kz2{pe&3v0Y>HpgYzVvv(N{<(8x~!u^eop)3Xlxo3o#?eYKdaj%
zm_yp>5-K)0s#SgDcvne7?9wDs+V0>ycqc^JAPOS=+YRjjHPkL8A_LkzGp2$X?5-&q
zqi^hNgeOLVaqTq8&FM@OyHtLBt)Uz%X)rn(V3!}&gK=}w6uobxNrr=RjU;6I{u=U+
zVd#~Tf>6n~3`nQn!>}0L&Cmm<?2}Qb41zPJu*j;mZd5k#xqRSy!SN%RhpT@Wxey7>
zpuGfo$%tV5a}1N!Uon<GAn0RjAHb#3_=rTJtOa^Ct3d*dsK)Q5I4-5uV8)q)Yw{sb
z<O(HcimxQgUUEV(;adjQs!!@>ufCGl%kKJ)*YPtsXPfd96uSz^UV0PG>78&1eyci<
zl);4ZL=#uA=Ey3YN<>clZuE`+tpF`!Z3(f;wD1RSH9-v-HZfh76#X_@ie8w0=Ck#k
zrFs+CS*kp|r6U@V=>$b+t?n#6Yg-kb*E&*Dk}JG<0Jl3bI9soHSN}LtO9Co-FhP0L
z=po!OjO=B(n71c%ZUVcF*t%Pl;VxGhKb(TT*Q_%16>H~gm$LO}?7QU_3N}|9SrSYf
zR)-=EkW(fs#+0g$$-!&IH&0J!sYJIae?32Kk-elMm~bwUIeHTzcw3zEKRoyW5j9jD
z6E4cZ+QTKJ`*gjmUhU6Jnsn>2=$IXu#FAdwX%@7y2ICK)P1IOyHLTlj-rCUxly0%o
zj<1H&D#f-W(rvX~*O6T?enUf&?Ppi{T3=N7JUAy!<yMbI&pjy4^VRLG#aLz7pDg5n
z_3AhyXx^V|%gB&Q^w-vS^XCJ(%i_EJ9K5C9Wn~m-PcDD2cY%z>D?LZ{u}C}?C5To!
zggjzdm0q^UoNSBCejHy!2cRL=d_0M=va-jX$rW-uyM7jN@k*o#qEUommz)F4j_1TL
zmGVeVJ_@2)aI#8f6I1D&@j;iYd7UXxd<%1H)&l7Z;tLpQvKE@|_z8-?P&gjHT6mFg
ze*7nl&RQ&7J>Ed_ON94}kCMz%;X3hUieDyNKYo(%a^Zq_1Ib(@+nUEqrRQRqP(+1y
zC(Jct<Jq-cX`ZC)IdM5Xuk!kn@#W-*w8WMYlfM$JJ|h2Qw0c}+5dMywZ-PP9q*5g#
z%Sjdb|8TH=k<~SENwtfPDwi0=L{VMOACN*;-6Gn~q3s?ym=wQ3CwBO1l&AGm#ngC?
z8j19@JP&@HK2h`SP>R+NRLzn}N0}AXUv>FcSaC(U6;5I}3Y-;3nHB3qn-#syil3nq
zMP5y4#o}@+Qf5WVCuBu)FV)nnD3vePnvM~kabImK1HQ<m>r}f!cCL*G4?{uqNuuPt
zhoP$N6!%6;-~LJHt+k+UG8-?2u71wMAaZl0I*ET1$<7U=>g$%LV!?iAqRf%Zzcmh!
zuFb}+@^mbyF^HxRdB$|jgx-H_5P8;edixnD6hCKnOn4URlpylFN#6frEU5L~sib@(
zax?jGH{iV556Y?wvv<7dJY4%>mAZcH!Ph<gH<MhXYOL%7N7s2pmMo0bo+i0Dv7T>x
zxmu!U#4h%9o%cjfjn%HCa7nCRDEFo4dtzPQ@##j3?ws8%%>QTQHzE71FFe0Q`JJ7e
z@O0g6V}szws=S^#apagF@|U^f*_Uuhdnwv&bemV8D^pjIzm4AUD)iY>^pDYX--gyr
z$H<<@F*su6cIb_wgQzNV?K{vjMMsQ&_+9A7MMtBmpp)K%eo%BQs)pa^edt$}e^yjI
zvP`trCz0%^n!_*92aGzGipYu9LqG4sOs+A2(Kb@q^o{xu`9{*0Z~5KvG4x{Tt77z|
zPoZmyUp1<Z6?_4`O8jcZe@Jv^@vED@Pri%=b^DFujj9~prT$(XEr_-98Sj5?5NQ;X
zSx<gVd$>f&8ppaBck6lkThD0{Q#O0PK}~Qvn}Mj=e>mq$cZ#X_jlU(kdz8JSXN&$=
zdK~>LbiKK6xC(4bU-~7RVU10actL&cMa|^fI}duUhLn0}ug~SyG|BLw<m4Pl&7eO%
z`IgghEIMlb<OvOC4L<z5Lc3`$@|uGNRlVxdNrc+i%B|-i!M;NlBJzBF9idis9&3bx
z*PNCn6iUCXVL8W`8xQ#|ET^N77j5ON;0JX_;Gl6#T;`x}%t2Gj6FU0M@`R4=^gRyx
z^4*Fe97y_d7dSVuD>^wRsCU47PD+mIwU^WkQkXMqj{nrj$W0A4?ByBn)o8qkM~60J
z>7D4Pah&QdnXS4!3sY*e5Z&GA4!fWyiSA+acF`rG4>S7a9~mg?jyNL-MlhDvm@m#^
z<HUZ71qW`1VUAd4afcG;T8g7ri8c>9`Zwr$#lB+IQW~PPqNPlxah&S8azJ<Ex-z+<
z-<8oq8hn_c$TbQISa%mDRc5#}vznP%?S2l;a`ZCMW|pJBhpsnddqw@+{U2s6@?4qq
zUWQpT;H?!6xRM{WtO1|u32VTUzpT(6+FG|KH8PcHy2fs~^(kvhEq|dCu7I&TEW`U2
zzlnI~T1S5_+REVQBY&j~bu!x6RMPL|+6Jw5{)-J;$?E4YtDTnBE>yX!9Nql4Fe^vT
zhpsp0vkGM&mS+_-c=KNhn&|2qDI=5px>9JXpEoSSPnCfUFpiG@9%kt1p3p(PaT$dh
zgaYSA-zgdd|K1M@;IrjU*P>-m)Jx><BQ$mmw5+d@>beDIGWvx!Ey+SI*drUvCP#Pv
zBecoUmqOQT^?rpDz6woJmU_XV!N`Agg-^oOfc-|WG&|r7R-2KLSvM1-@oRsU2BWf8
zLmmF7Ms}?0i`f25fD_EPtBDR8Jn2;}uNe6l<ieSIo6{c*-~!W)^3`pW|4J%1qcS0e
zM*02B69s>T1$OiiqOE~B`eNvM)jzB#@Ee%q2C<+)v5(hcO>r~%*Csh*uMKSV^|X8$
z1M`sVl@Ct7B&)u?XQ*!#2MzA_OO3tKMr?r3-SdA?P<ID~xu6R5T0j*<t~U?;A?w$u
zo^LXG$8P8?>Si|^J@D^X&~OlSu-RMQZ-Vij#3=>m5WgCMg3|zf|6!aHw^13?>rgb9
zHP8*ovN2V%#S}J?ve7#ZH?QmBQ$Kj7EV;)kI~&k+Unx_3DI9)@hrEh8qWB$2F8iN<
zeh}Ge*}NjLLgn?R@6Fp}_^mFV5-zRG=raKaietK0Lh(zaK62)jisH8>)LqGj$$KPL
zH<-u+RAP(^A}uY?Ln4YVBECsg-(=bw<9Zmbk2v}r(bi-f-6fh8)H~)Am#K#Ps-)k0
zOgj2s`bgaoWVI~JYOBr7pQ6fT<>>mcFe^t-g|64oPmIdy{Qt=6;eW}h>2#lDuJefN
z5RX}hXqFXb>FB<qt#ppw2;Jb7j4c0SMz>)nXz-_B3va+IWNgNuqer5n=q)+%TGhC)
zQ`c{%wWOA92VDTD<!CL`jOODD;vWs&Tzncri|q`&ksGoPhAjBXxw#2gzsPExgrrN9
z8?u)}e}c8{62-~4&4#v1l(pHNX-*eF+a=14*}6n|TBI&fZnUORGY3+aD2^Ns*`SBd
z(f3>RSbOM#;g6lqQZ2jK;8oA(z7#!Q+o9_BghRNqu3eGr0W~o)Ctlb78}gq!3R_!h
z8!5X~yjI$($?36_SWT*}1zL~Sp9&outbHxTY4zur{U}UpIf%6M_pBEss3Eeo++fLC
ztH7;Q%%Iivl6hKV?OMs`4}(-4ZL~j<vpAykmV$mkN5~464dja7ZC=Drb(<Icyf12^
zSig1)*iG=e4%)-Wdi^kBIm7O`YzVh25p`P`QMZ*5bz2$Hh;3y=qi!q1?O14=f>kt|
zd~Tb<Z2;uNFD9;%G2)fnUcimS#B;MEP3{8Z{jTvZs9e1nNuOW=9K^oiFMpz^@+Y1N
zvZzS__Mn3*#5^TX6(=aH#ua4{X{E$r8QFBSUu5+_N?V-?q?IH$(k2pIi5@K3%9ZFV
zL%dV8_i_}XHQhay{l@wDcEktO68uFvE73$BUy;EB$^f0lZi7zc)>*ktRR-t#1YJ>d
ztIL4Kb$m^xo=I%DEZQrd;f3VWTluW;@qNMiMOL3jM^rw>-mZLbO{BM6GbWxD>@RPI
zsa8xRMW0%4D`D-IyhQCM0ZLd$?7AO8eNVyzw)(7?RqR*qJ|7|1oj|VmL?#FIU(aCd
z_l_sbL-^>x=494Sw(szq+FoH~_1m(Yp4m@sIXV}&eCcJ_DGwfUdB`6Pe)I9AxC<Xe
zifUR<J)R79sih222Eo^d>p!4(+Ap&DSXzMmK13PZLI%psh)*F@<wKRQK^|G>`qXEU
zMNiWC;*lGrEDiRn<N2=YceN(h)0Mcu$5T%GMOJgm$*Sb^Yl-NIZsmHqOt@AVb?^yP
z#_L>0R>nR)eu*oiYYy%qu%Ox}jmU43?hE(xVl~0~@hLkJ9H?7)kx3d){!u1FywrMl
zwC=D0HyG{X<(aSogNE9pkG&F6aa6nl*%~xDeSbP%r-s_wk9}xNxxc^)Z4!+&!ikj6
zTzqe+0@@L44DB_?UbA#6k|}kX8*AuOI$7t^$yF|06OCQjizCXRK;>cmOpD73j-$5y
z*j2-iT@%C7m>5IiLXA|mW9kR2m>aON)-}XE2X;el-!zfc+<gwRIg37WpwNkxv!L2}
zYCTlWM0f@H7{N;+6X7&6Tv}-~@r`Q}{|i!;M#C{`V18B*U*b*ENUfhbU8Ui}*@0{!
zD=tJP$i2!7g>~r!T1wzs2?TlZ0QHr#`ST-aUc824l&c?wgViL@3O=uJ&!OHuTfO@I
zrHbEdx#wSpZa2E`J%W4Jd4FcTmrZpp(N1`l&Z3Pi6~xPN0*&&EM7mKv%gr0ToPdUR
zlxX8O>t)Q&F1iawrRRZf=lt4<ULGI7CVI|qgNP2|j}Vcwd#+&owMyW>g{#LOppEAI
zBU~r0AuDH(a6#^|7?2Z0L^RLsp9K*yq9}KTh^P@=a&N}woR|?kbH7yjY$N*Q4iqQH
zh<>?K#i?Y(;M^+8GB<K27LCY#OtX3A$T<+F<$fW<szhY*#9W?q3vv=hoRh1IvYeWc
zli^IsZ9o}wYFkq-%MFyKP9z0qcJ63pS~oHkZF6#8SEdajiy#)}9!iVJX%<l*T9Nyr
ziqJMP8{+cZ*F_W=u_pIj5r-JDF85;*?Tpx*`=yBXk(H#mH+KttIH#l8wl$Z%#vrG2
zWCi&=5#(J<kaJa~nb=q-=Q<TK-t1_it``jAyQJm@6*nGlOhI#QR%xp<xpr5=xGJ%-
zDqUvh+p2|FRj0+S31e#pRaDhE$%s<$rEnNkl`bc)5x!bh%g(fhrlveAzvb=BH;H1L
zR8|&GloHM&97#Bv@JzxvgclIbC0s~2kML5$`GhIL1%zqBg@mICFC?5uxQK8%;bOu?
zgi8o7BV0;&cw1KOga<LNE+;$|dIjN7!j*)l5ne=iF5$(5vk5ODTuyi?;cCKFgg+2o
zM!1LYa>6P_9HC8k1oV}JEzo}zVL#~AgeMYSO*oG58p87kuO*yIxQ1{g;dO-95MEFC
z6X6Yny63!>uo~fwgpVA>nbd@fj^Jz|!ri@tU>)J<xOP3^JMDN{U-A8z2Fv0#jv8=y
zuo3#7o~%9y+Z@B2VT5n6y1k9?#1px?B)pXP+X*+6a@+x7N7~07guU?ForK2`-bFZ!
z@NUAfg!d3mCcKw$4&i--D+uo=%szoP$Ox+wK1f)P@FBuxgbx!QLih+_l5i_wG2x@4
zDfeT9jq%^(gemAJ2-Ad55{@Q(if|&~(}dFrpCMdC_$=XNgwGLvL-;)5pM)<EYOnD{
z!u35k%Z%_&!j}mjA>2mz9N{a3ZxFspxP$OD!mkNmC;XN04Z_G_d}oaC8T7tI_&VX+
zggXeg6W&k#yhAvT`gxb|H|pm-!c(Z9_X$5E{6O*4&xeFVhq7EEY=QqjBHTv3d`vi)
zdijKK1@WH}E*s8wFbU^Vj?W3(V#gPR*B{9{c7)xzSNSF3o;JKBLU?Z<7D<HfAIr&K
zgl`jmOSpvk{f=-3`o1SDBVAcpexd>P&LUhjSp6?Q@hki}gh!FjT*Aej)c^7mUyM@!
z%TN4HxPUNswEACu;w~of3kff7ul|>xc#ixR6aLU${VzY!j&d(0yaYRz5#Eqg|I1G_
zK2H5FKXDTIt|a{75cR+O#DbCPfBA`J$OVaNhcY84D&yN|qCOg8i37k{iS{FyWD+gF
zIf*X(S4#9B5CrkWKyYs2TgsM~IEfNePRzp3`H8o>aP^S*_;ALh!~w_KKe$?ABKoT*
zc2FmY#0|sPq)D{HA2kz|=>_{GM&a}Q6Iau+Yb6Gb34+>*pNknu6BDtqZsI%gIv{Z>
z{;HQanpE`@txjU0nfQeoJTP%C{%)9<+m-n%QGjiY635|*#);1;cay|xc&%w-0wpR;
zRKs)462Ft<K?!}Ksd?gaeApr}0S~uKv?Rw?iAj{Vb>cqi{NO}{9NQ!o^y0M0M1;JG
z5_i(a4@oqpT<sF|D0}<F8Pr;b#Bt=+F)@t1IwjtsJ#|i;$0*SyaV~jvO*}{G4oy_1
zzjaG&YQw|#iJ_$Jp3wdG9*HEm9G1{w<XeNp<z(|{ka#yu9}N=oG3@amF?EpUn8cwp
z+$V#?&3NFcAkl~dKOH1~!b8sliH(@?Y>?1p^K(I>A;I%Oq9efzL864<#UL?~;H4mO
z9>L2&VkyD4AhC$zz7iy^BX~7P+)MCUka(Hk^&s&%!5cy1DQe}-AknIunsN2SB(k4H
zxS*q&arH!Zs(lXO0EU;jgg4=wd4!Fzc0S=H6ng<-bJQ#(e3XW8A>s6aYR1(Q50iee
z;;Eb^g#TDGuAZoaLzY4BqGZbnPe=a>!s_I^l5iFJFCy%So{I^u#ATNdPNcD1O1OpQ
zzKXC22VF*3nWlF+;j8Gqf^ZS^m4scWuB!;2q6$|NHlXUSCd@C<G*UgWoBXaNETtT4
z2yZ6-I>HB_uP1z%dbok`Lb~Bv!rQ5{8wm#>cN5_{I>gO{U(f{C5uS~I))V$mY8t7Y
zSdG265DrGqM#30&+)9|HIc_4{K{?CHvJ$hAQ@8^^&LW&Z15@}9;cP-(4a^}NOADGy
zSk>wwEAbM|Yd&-x^p=(Fm-wCX&mz2<dYDaEO#B?eSFw98;h%J;d4!MA=*r6KCtjj{
zW)Y62tIQ_sM|Yk>sF$3}$_f&P^c24!@!}Zq3lgv4uQ`Oj9437Qi4TaMM|d>#JD>0>
z^erH~6}!sHnkH^Seiq>py2@<APQ8@AY2sMIxrE#C>pa32sK@z)Z{xQGgi{C?65dC>
zUr5-W`dmc#D)}rXjNs2DghOaQO9`LCPi1Az6VveLEW+t@zS)G=SbohDb<r~y`Y`Hs
z9$^l4mX)<mY%)K$P8@<?W<#$Up!lLh1KQUt!eZ>7P52<~XbxcuI{RG0lh8kp@O|oW
zK4DeD1%yrT$3nteM#=7?#Pis<h_HV**<F;l%Iq#m?56&fLa)Z}%Ls2K-EzXWv2O+8
zM*P0AtSG2CwvaLVFlsA^y_nBny7M5>f~*QR@V|evQyJUO-x%e8T@{Ad(Oj!vAhLF?
zF=P3X@GRjvPsHHQHaKEG;GDUnt=owNb<U82r7NN9++Pp4%-}hSU9OB#bP7A**9rqs
z|Nq$g67Z~wtN(lNByT1g2}xLG2_bAk5<rk83yTUQ0mTJL0xF0JgtBI15fTh&)w(2D
zm#=ETrPWqIyH`L<S8;8v3R+uhTl90O{S>vf*4F>;H_LnHO@i9(d!Fxk{%`AL)-z|$
zoO9;PnR9RM=lFg4Ucx2^2&nHuCJ(Y>pWZmQ9b((QrF~HN10vOT2<v~S@LPqW;E&j{
z_bMC%RjTh2R{xlg^iSEv^iL~mdA!&E+97CA>l6RZM>YSpXL@4qcsLg=KBrntO@*6y
zJVCBf`R&LLcm^oHXij;D)}gL<P=I~|nI80eR6c=LgB$+<#>a07$i?5FKcZ$~k2o*;
zFGxg=kADyt42lD0FQ9OUw;sB?2THO~GA9l0c-|L$mx+^+_#Y&4eriDW$^Z+X?NB(#
zw)XIHUN+^UQGUNEZ$d4<o;4JgOIxtD1^=VbnS(a$*8-G=%*UWTf%>3H7@{N{XzWJG
zuhUU76D6N#$;&9YizV|=lGqdYR3Pyt5<|w;;R9Ew8g>avvRC7Q+o<O3jViINWzcpc
zIx^7XS|t9?#LY-tm<iW3PaG9*X_R&YjQ`X6G;Fs&K=D1O&;9xzb=`#yx~kJaGmn?q
z>1X%aPH(f*lcvt?lykiqWiuchLUT<PFXt<!{6>@?SLGxMY7<4{vYBehH0_3}cz_l!
z=Ujsm$=?Ih1{ovxJTCwEPR>=P?(3)<uIhN5<>lP!luy&;xYz=)D-EuXqr*}S3^5HD
z-h#~ihH3FCT5!dhfm6<0Q}|~TUT3;tDRU1w<#u^<CYdRwW@7I*jkoA2df9r4UhdBg
zh9l94J%P2ClWlsIpztHpQ*o4-UYzUYzGV7X)SA#Ix5aQ_r3REJstp-Q%aNl^EiM7o
zZv)tFR3_-|_d@^^(pQ5uOgi^e(|E1Hsh&t{0$9Pj7FE{)22l1(@K-%d53=`HbTQlK
z40OsLHs!!J_bjK}68GejDd>%_p;@AseDq?4=V&U5F$}<szqf%&2H?hjmC3yHjvmWa
zEUl}rZpdG{s&;9;mrtLbd|LSgD2xT|gfW($w^k&GTmcgW-$nO=OIfLI4HCbgJO||4
z0*>e9e-+9)a;0`}u(SaWsA(SX^P7QY{KEkiBbm2=i2|j^^GjLvRn?80s7e*Yao+g1
zFo(pg)Qsf00w&C0bT-Q0D6F}n8byWrDU5}czw^m%s@NM}gmsF4i(`_l%(zcO+sBXh
zi3IsbqoijtrWU6EQiT$^NmY5{pG9f%UP2+eC_GfnI4^%b<{(cAh#%Kq<2YdqFi7=I
z#gm=5`nr=EWFjL^Q)a6^1rL*e-lKTNd9B!djr;O)fMwk1Raax%qp!?=b|l)_I8p6W
zGjXCe4pe*AYz%34!J{TrG@zp{xCTRb0UdS0wM^1OcRK#nZa49#RN$oCZsG$ND@fDr
zCO*1?N#%AEe`8v^-NfIS)^0cPG1J=ZCOn@R?RFEs%4oNn2vkP9-30!EH=1d;n}}B#
z?RFCpmC<fDk)Sf#?IsfaGk}qHyNP7K92xC)6RAEi)^0b^Q)RT<O=S9OP@~;$qK^+N
z#nWy#(U<pj#_cBhVIP9wqug#{puZFu?RFEx{Y_}5-EN{lc>%TCO^j6;?RFF6R7Shq
z#CVm_ZZ~m?KM(-4+f7VVxM{bWnB*_VIL7TJjN47z!AUB&o4Aun?RFD)ak|>=Chp;E
z>2}LPSwvogTryXZXr~k)!BQ@#D&=*MD$OK2(e(<pP%*dq&Nh|mBko?pPo?^Z`zn*k
z=Ku;FbE<0s;=BigW%@sY5`_L6-I;bLvfdA%HRHU=Ag5vG>kKoeQ}dc%-WLpG$2|)Z
zzY}A}NtlOT{5)3Z3&e<V(#xf+sA0vYv%89wjvomVms8{&h~oVCYrcpQ#rg5qGMOOb
zBtgm@{ek)ExXQt#;!?*B@u3X1^Z|<mNmus8KXFM{GbfX->4$&PlUDPe?4)+q9rBWX
z#q2geshEw>XCm@`(j|BXNq<IJT+(;&l$PGf9CI?pNP&^;3DSV85hu?;S!xgC{U(Le
zwD+5Md1>1F{Y@lgn)ZG(ot~z>-%R&S`w5<rkD1O+H{Ne%My4C@H#1|?+dvU`znPhw
zZoJ>jOizCuPk6tXnUik3-^|QU-^`i>Ra22}yx(QmN0y`;@ArIUR-_y6H!)t9ZoJ>j
zG^88v_pQimOgG+dF7&o^<NfAF)0%F)-{%9`_Vi~_1n+kZGFPS>@Ap?w)|PI(-(N@O
zmUQF&W@dM~@qRONZ@Te*GxI>Y@qUj&=6mVJ`%T;qr5o?}DvSfqL|npxS3&%YN#Kfv
ziUzdEsAF>RNUV>SDHF~~K*O|mSau!(cxiuO`T{OloEHpc=0bwV(vI{V#*t2Xr465p
zIo-)5E-1MWcad^3O*_&FE*-4U4`p$376w$@LJBBuVQB_3s&tDj&Gh6ILr}HUC$_;5
zBCwK3#>xM}GyW=+_V_adcdWSMRTT7E$CrukT7+UR?S+fMgm;rFGVOjq5npDL^j;g5
zdEzS%qByG;qkhFb2#Cc6s)_JW2q2nBqt(aju{j$I<gcEJDWz=%7=JCncxn9Wv;Mj(
zk&a8d0d4&CEKljRtPy9mx(=k%z2IC{JVtQ6PbLZzd^QqG0jv+unBY@nyuJ^y*%omv
ziu-+yV{Bov|Hqh_-*!?a4i$GH&sLZ@p(!j`riho}#ovJR0D|o`W;$A-vwEWcZG$0$
z12>{-&}uv)AM&|ta0{OJD1cFP*#)NC50Y>&;S2fsb7m?CLuiucMl)vz@@qr*61wdP
zEAN@%w8-PQ#4j5|_??Iz-oI@J01m}XV=#=XGCV5|IsAP<m3slXT-+3Uk0jz4b1SrJ
zP(V8K>+!?xV0Ns|wzUlB+_K)Dp}-zOmtf+bFvbW@<{Dh~jbzy<&NAh=Zq#XpC!c}3
zg$6(`jU7(UZ-6)>&PP>KZ#+hOrt@!sHD5ddDHt3$rl%<nuoa9MWHPD9jGkyRBakW7
zJw*F^&7cuGj{dv@kb1`gOnOgaSwR@rzppbS{x01pQ7n$qyz>Iw7rOwXzv^^<$#y^E
zgx#-;?VkPgpY-VWf&h7>C!&71RHS%6L$LXfzhL6C35MePK&+80QxyNUnPYbpU-FIy
z9#VWUfso?8xkrz_*C9{?sz@Llg2wDO<%;5un2e(MOD02#@6|m-`?p$1adaF#@m)P4
zm+&VJz>^({^T-D5r%2fI%T^=8W)hkAOdvGoMT77fKp)d$U|q{qy2{B6LQi746^-67
z<*LV7W)x;L3AdP%b&Vk5%(u`{G3^cvHj-tEg#FACc1OZn41kb?y9k6N{78{7-E`)R
zziSX92?v>SMZ(c0LlS0BHyM&pab&LIS3vX%xa^jrb`$4m3f~ERfiLq4-yw!)y2JN}
z26%|?SrBi9?_B`mjqYVS6W`^iA_f~k`r)Qr;d_e7s3o6cGQ@Y6>Ct3y9{mLe-gj*+
z;5}r@DP#EMz6|VZF=jr38-h|QrWb)vKEfM<GUj^rLk<BBLHTMlpRIDJQ@J+e#=dQ&
z0W?;>spvG0Z%YMdk$+x5n=$X3Hg|H+@jVPT*&e#}e6}9YAFVS@y=v`^@l0n$fuESn
zHwh_DUX8(2bl)koXXU-zT~DDsE5FKQGWgkh0Bt6C6KTrAVn4_pU&iB9zH^y&I_W)$
zT3A2WL8ZLOA7o==tyOm72W-R#cN+W?&mC^cGBil}!YGtZ?TuvOU?#a58WeNhWWL~<
zu-a#4F00f-jmM%%=jeHG=Z%wuI+<ZFNncPMC@&hBseD5+X$DC|v70o_w+}VSRKAp%
z{6m@uB-$h<yeSM%Og(2W3gYAqM3^tCrp|v@6{wBuo!+SPMl1%sbTHsWEA)x<=PdwW
ze%D@ywdCnEz8fPx_H-IA&qpV^pFfM`?wae7Yv@Z-=6d8>CKF`5BphX~$DgjkCCm{f
zk>x+de@TUSL`~{=`3$njDRIdSKFE{0A9InZky<`)ROw_q(^EfO&gYd(d)od^_)}{D
zUZDM*@IfhnX!|?iquY_x_IJYHnAY}p!rz(J_IJX^Ol$i)!Sk8X_IHA>GTQ!52vkPf
z-w8rxwEdkBuQJ;HPKc<Cw!ae+R7Tt135k9@R#4mD3CVskGTQ!5NL8fK_IE;0mC^Qh
zLZ*K?(9!mHLLZ+iuI=xHzACIl+usTO{GNcO?eBzv{t#re{hct}Z$lq#e<u|9w<4qM
z?}V``qwVj6aVn$j?}YIxqwVj6QxqF(`#WKx!cE)X36uO07>D+^TyO`7uk3GGfyL7H
zw_N-kBw>HcbAHIRq5Ulx27)y0Z+QWi%-G-ZLV{5CcfzgO{!X}q^iuYB!ktWN`#a$-
zQcm073HK0OI$R>pqIW#MZQ?1`A_Wv{vGhsQsnSWdG*jE$awQSdhIZT?SEE)L+HrTy
zS4h&(j&ls{xG%GbGPL8qau=FtLp$!Cb`(bqZ8g#zC{g40@q*ii0L<Q*DA6`|uo^GQ
zX`4G(ONiR$4%QJpZF2|fS*~sFppIRQ%^f_3Z*OUvJ8pu{Mgrb++T6%ernJo+Y!O8$
zRyKFAg-K;|2ioR72l<Dx(KcQZnnIXm3gHYdG85?mZ$h~I9FFj^*=`y@T>kvqHq-Kc
zS~Vc0E`r7%I2h~h=P*0`BxJYcB0H1~_aQq7FP01&g}PI5xF7sD&Hs_xP`4A=?CDMT
z+6smogx5(6+2}Az2O;iXWikfhN?;wD47%9!XJbXY#VCQi?nYT2V6f#ncH4>a!M`L{
z>xstyF#9$Xg<r?)<U#0_^O2d$1K7mRKxaB>VPNM>`d|jyKqaC4B3&NW%<qWiK5A-S
zL``nlpLH{4Ks~~ZmmGT-SHYe&!XwJx0BZOMRE@xta75vA*T{T46UCurGtm)tN2xiY
z`~g6LPk2O8w+8lz!dnCRHQXA6JrOqW0_GPN=Zm4(TSnibGb+6TbU?)@lmkVwW4tUt
zCc@-^nWz;bxVTHqjQVhA#LvI&3~aq>am5JE?`NQ!T3nrdX|P#bF_Meho~;&FoJ=CT
zgv{XI0tqpiI9xZxthE@!wLZ%1F%Dcn6<d;nrGFV~c%6hv$HSqRM7h8{Ml+UFOeVz7
zqfs77`>H{6I!t&`crLo+la}|PehAA7NaX+iyI!461Rjg`>bx<3(RExn{(|kZ696P0
z-5wi?N6z!6b4qV;0ICdU<o>~w=b=3JuO>4YnVfzfYmnz4bF=M{jTKTHb*ZT(y!&k}
zK>SiEahNo~B&RaaJiw*@t8SDi><Opq@?RIb{5cnz?pJ`ky+M<4qzMV=joRQqR!n7&
zU0tEx7Yh~E9ocrCr%^jZiWlYg#)1a9up^U@C_!S>U(7_dV}c|WEOSWZ+i3m^paNkQ
zXK@LyLtCz=%DjWjkg*$;FpEWGk~4?lsQl4iH6?cg6kx1FgTKPUVYeNG@c<f)p=688
zHH#c-9z)3%R~U|IQA~2xhZ@Yw=r68)E735?tl=1xWr|5E%~;(r$rA=Z$Rw)>giJD>
z43>ML>8zMxrO7B}Xf+u!!`ILW6p6IIhQG5#hKOUz%X!YUAxr#Nw=p%>IL!BwTa){s
zSq8ET?}mWIEe6Xan=s9LpM~HmS=a~+hp<dd^S7p7chmf)Va;%w=MspT=12^X^9$3N
zh^|HzCKK2GXG|gYRa2t~@V?0?0%RI?AOY^veIo2*2*BPs8%-O+{YebmJj1Sfnx`!N
zNU!8GK4*=<HgLn>ccE9sZKIIg2rLyTHko#ZNQ&LRK`TXy*HJ%&Wr`Hpf78IaBgLBr
zKuC%U352A$WfV!#({v`v8&MUKVwkB>q?lkbiWKLV3`y}F-KPsF_B(KY9s_rP;RQ{K
z+~cO<_W{hy-D4`1q~u&{wBjSE%Y@pd7;-mz$&_<98>`C`_{W&!<U!u3X=cjY!`NXf
z;7<59w&Wi1aa7FP%u-y3TU7r1+nUi*?+D-Fj_`93M(+qJTQ?etobKkjEU4N3wOEPo
z8?oG~7U?Sn;C!?ZKTPjo7U}R9EE3DqB7JBYb+<^5n7VM01kQbGk;dk6k=`;5xJW0V
z%FrSAV^gk{C`D+6rj}@k$#99z(>+A{-CM2lUT>-ia8(E}C#PqqukX|4p+oCaHEZsd
zOn0UG6Ei|sA6QtQS@)0XVY*ZITfNVv9P%<qI(Q?M<uACw*MLHU4^de@L(wUP@iF**
zW}jttK>@M_Z2TOvy~jb(4rTU;QM6mfJi+YqW<{ITinbZ@EV&d_FP#fUQDV1zJT(x?
z)QXOmdVbxlX#Y4}7p~}YWDAPjUjf9+on$(zm78rcYUP%j3|Eft&S9;wa?M)HZh?|{
z)HLAQova%`%d%!=k{*>cr@J+|-%i&xTIRCTv6pS{X;sb}q|7O&7?txqGxtMiBmOWq
z-OPR91gadAsku*&Kk?ktO<g$mr%6E0{c-@o$KXu^qWOlIA-|iSdxoh{L|I@miYRp^
zL!#sYB}J5DWM{#iIY%6j#im|?yw;FJPh2hT#srP~ba0b+I}c<~i~A5K$TBs-Kc<~{
zg3C-@IKgj_N}S-?6FI@(ng*QU<1RMunhG^RVb(-VFxzA}!FZt5d4iXjdV(Be>eU1{
zIU<K3*}Ki;CSXbV8>2px{O)`t89+059hv<-%FR_kb<_dd9F_`(jB9^;3*vI{wS|}Y
zFTU%6m>V8NK$d0Dey1uMCGd^xG@rVS;DpI<YnjCD`?*9-Iu9-qT#bJLu?LF4dobV-
z7AgWiZx*II>3QBj2nn1?ASCegQ%T^%4x=+*1gLXg$o;h`SM+_$WE6d6vPO#Zy+rqb
zRJB-rh+tt-%OiQWH~^oDp{|-<iGj3^)64KzW}4|W0ka`2RMWdR^~C%$CPmkU(>rdb
z_nw;GEv7TENdkOMuL;xJYs%I19x@p<y<eLQr+1p}A=-~oX|Q9?89l=3Eph-(H2kQg
zLrrg%ncmBsUYb7#tFBgW%p^>Yg=%{LZKlxO>Ro9dgwuPPG~(*501z+t52mx4#z!Wj
zrjg-HBM~EW;*9P(hnslLdQ(fX3^BDVzt@@Fl(0NEHD-3Xd4?ZoXyiU;`Y1aiH^DHR
zwa>xy>wx}bwabiGZiwALeX`nSw8N<9WaQO8GeJ3!7BR0jnu#j^TjobnJWll~ebrOq
zyeSuZVyg0Dq~UrjdpCy3#W1HT89iS$qr^>CLb^~5dj=Ygx-p`cZy~5hl5EBEJS=Qf
zLQnabX>qpVV!ZQ8?3J)qE3hj7X0j628kPS7^4_R5rq{1Q5x`Zd)XTliF)F;N^jRm~
zOOMo4`m7Vb%4A|K#@U523cVuwtmDS{_aPVgA|Az#bC~v731{z3`#MOGJd^G@+GQo&
za=hvHv2Yd-hb64>rqkb@ayl1Sb<+<HrlAynkPXjRt#Z=kun`|P_>aUt5qg(qEJK4d
z<?o)>8_87V@1|5}P-@s>`n#p}cW+>odJs*8R>@Wk^ezROP-ij{jR=xI6s9FlvUMRI
z-Zbs@E=7`@rE65R8tk<5VdAF+L2)7G+T(G-Leg7L==7&ysU+=G9OGc<{WTFp^?q~_
z@YGK4-MQN7oo=k6kFb9HEx8HDR_6`)pqn?~#g*tR7*GvTb^lIfcdx_8ye1iuv(VkV
z8X1vyBa?8oDp8>#vK~YD`D|k`JTpKBKmWF~fNP@qpk00k3LXIOCEcRhPeAss$R;jB
zcr#z@^41liQu)>j*zM2Ewy|x&0%XS)#d*p6g04TFT~{zm;qgz|f$VW)Q(j>0q5Lc@
zF{$1*+(rPCWFD^k681W?I1caKr~5Ouab-$sQ9c7}<E5)liOpDqalD=lxLovSEI|vz
z=3bO>EnA&N?D0pgF3LEa+0zM3wBLJC>ey|N9}JSQmgRGZ3;t;7MH%JHmg;8TyC}1+
z8t+z@G5ax4$oi^T${vYu%c6HLNcI*y`FFG~>c!3XUi`zq71axW<r0dn_qR-sN$BDA
zIc##{k>O8|z9M$?+St)oGMiI^7wBJeN4F#UV=*ot&ZrQgCEE~V4>{0exL%XtUPFd9
zJp!hyX5X&I|DKusPF;KGqSW00G73O68E#_v89*efDN`>M$#4?t9WrqK{A3yN*{Y~e
z4=M~ZYpbZx?`qS10O0YrF*?N8ImD%$>ut^uQSi=Oqp-c+7aHI*N#cIRCTD>^0pQ8w
zYq6?7CaZrPz<bYh(CIthWXjN;BQ>E_)?A0wAGtF`H7Cd?_h~LOI%E|(=+a%$4a!6w
zpQ-k;UN>zQW55}@ty1H?KQtAJN)gFb(Vv>=PqAHvrYC`=ypPj7xhEGBdWtQU81#>V
z@A>m@t4*-7`xKY`S<F}o>r)ig)M-}!{>t8~nEfHC^ASluV!9R9zcKqWWHkf*-N;c(
z#<^_#F>Ar>Edy>~cAKBlTXRI}&$r=-g5%%7FR>z`-c9}(KSZ=%hPRJkvkp=`H^Arc
z{5!#e?q|z^s-<ZEUQ6n9G&~LvgO%_NRTam9N$NUOd>a+nnb>{&JXJ9g6wGcSgnX4R
zXTF+w9bdTy`M&YJG<J1~&dPAzyxvc`tT4;8Q{oL)ARC{D2n{XSEm(3QjAbOAFlcrI
zA&uocHTc~aEcIm+F2X!DmglO9UlJ>Y<#{UqH|7<V3ltr)alO&^niFGrfvF;A^!;IX
zScakzgQAz3-3rGZ(P<`8Hmc!H<8beE84l7DT}RM{zrVAmlAcz77V<UhnPnE+N(@ez
zUe;zq$ZLUOA8;TfKz+U=>o!wCb}!Hs)QnjVnsO3*kttUM52s>9rgxqhQAtKlM>b}1
zotnvXQ}F~);LpE};D)N5>pGuIdlfLweURd!^Yc$betDSx3G%7)L8K3XL$=zPb}G=<
zoDNM_YvA7nsDCg>QlUNMB9yuf-QShq1@4Kr`joRDqPK>2n}Rm(3=H!C+FgKlnxYRV
zihdIny`OWy_5HocJcu!^LhAQNQ#gpT#P3dk8Kf3wzXIbg?)|O{#P2gxwX<skq`j=|
zro~f$d<X!dT1x4#n@ueh%}b`X9&Kp0dVTLPwJuhDFEE9#MNwsQ^24yrAh9@^dV-5K
zoHQ9u^I$lQf-vQcxCUMpIldkBBWZWV1;HqW;>Z2YC&vt@3FMvp7<6#l(>^m4;^Bnr
zoxF4yN`IqD$#$x(sdB#Z!L=JsR`5>F9}1P)D}D#koQEzQHoO+7o<jB}VHB#~u%}o!
zjA(Oms-<o|n&0|J$YXP-)N2ZW3oit%`S&IOFbY52tV9Hp<8S3HFv`*sUO=_^h)Aq4
z$f^BP-$A+p9b><Pl)$39@t?#Eh$lE6gM<^~M8oqaNZP*wRY?(GB9l}oLy`(*NK&B;
zNjj7v`4^aex_|25&>>~ST*%R>%}9DFnJbz8B9hWe<x#;ujTLsfWCH&D+it?dd*CZM
zr;#I%fZfyjvg;gXm&}Uu(z6YP7O*{j{BX|PZAknSwHbM)b`GoX+X`@L5ki<x2syLC
zPnp9khyZMkKm39Z2MtX}Z7&{I{8eqHn)Kk$zikv6_P{u+h;s#Cr0+IuxGnIf$JoR%
z9z=cGk6=;wo7wMcbI|-F)10I5mzGSFwrxYQXDLKFr7wHp^IPa(Fq#es+|oH@0w2>+
z*N02v`Ci}mu?&7m0g4jE^rIKE)az&Xo{b5p|4f#iWaOhii_r;sDbBlQ85TkxJa9*)
zI4|3v@T}py!v6w;FybaI=DXqDy$=#Es{lEI!;JSCV&&b4oA_&5(a8kJGs%b>!m$DJ
z6e$~V!}7=QU(z%dqFC`~vWZ?l2QyC5(d+EwrReDOJCKwqI(nVy^b{Sv&UD|DpWqq!
znCa|P6TQyN$W#-(&dk`<HZTpM*O{4|YNFSfnV$MOo`_y&W=^V!UT0>0Dty?CUT3Bv
z)kLp92Naj2n&|Zxky(*yqSuM>y43rixA5&2W*SmW^!ioEY)l>Kqo$A2-P=-4^m+qo
zT2q%rP}9%<Eud{reHKNCUVjIfD^pGMI%Tdc^+`^lz~6<;Eve5kGgf7Gr@qL{IF-3K
z^>@sSSD6P=UuWhN_1(7brJCq<;&v$2M6Z8<aej=?jwdWwk5rnDUSEwCX*zm+KazNB
zC*ho(s7}$*>jdDX=;(DWSu}c`AbRTP_2d>z7oUM4y;5}aI+I??+r;QDQckAm=yif)
z^vvBTi<eI$mq<1t1r(dG^mb%aDdW>ssfnIRSV_c^O_+KWYBO}0`gs6>ljg->v%B+<
zlqot)olVj+RG9ibD9*~zVd_g!97fM@{PlLEK3?+XY|8HHeJD!VIt1LlmSEtCJQwM8
zDrP?A2DAy*vpgk(Vd_C0L++y?GX$4u!qnMFJcmb?3RCB3UayDPe~a)zpWci_2(~cU
zhhgeLTVIB$_d%YmKo3Gw^kA8y2SR2NknTqpM)Kq8^QN8E0hAy(t-t!R*Fe%|DfHG!
zFSkNuQ9eMOzK4)jZ=!r4aqx3EWt??e1`*xUjD8ur9aX~y{}x4y%3$^|KjaU{9W@Pd
z@Nr{kwU?L81T>gu4<cJ_>R`&NU$FfM@Kv7*+YcaK?ypP(+S0kNn@kNd!@PbP&NgIv
zU_ToUQ@#E4;p#x<4Vz<XzmD4BrWQJV*b1k-BrMPUk}3ZMLI2QXUPI<;-6#xx819DW
z4`=Mlbr>|9mpAN1r~9L}yN&Me+Wl*>-ABCVbjPH^YrL*q?~CmU66WSR1RJr<nHA|n
z`){NUW_>Y0QU|j#nYbENWti_M?_?9qdOmWIX?ToYmJR;>0-0b8eRGL}nIzrw$S`@#
zdHE(5m6<QIN<E_WdH10VJWBD3mlTft53<2ywMr{K!VY|(?n(R;Q4Negk`TEPYA~;W
zp2pPE^~ehRYSimG&+q9E>yeo(dYsgwr=O9K-Unim>m?_bpa?8$k`mgfH~!@2)a1hC
z(oBq*h9(%4|1gi(M$scVnbkhBGBw(EGMXh0#~%fTeEEK9CaaT&AYXurl;J=m6@aA$
z+#?Doo-NZ1p!m{E0!k0F$;qk7DakDCX%U0YLiCh_M&?MMF#wa#LP9dpOM#EKc=itA
zO$OKXL6(?sG-Ufm8!KG;<pVftNAxSr%vSU4AFt<$4zMneF}<M$CODaa$xz~hP@=lC
z?O+2dc|<=ADce9&)Er_ut4xmRr!qs6eUc^DMTN^Yz3<I4`>|$Nh*5y0gi&vCVs=Eb
zzX1P?3{hd}sDb{t%yUpvkzA=}dUCusE|WF*3a3ttVMoHxO9sPaz;Mdf36>RH)#{^k
zoLbwlSGVF%AoOjY*%w#YwgO>D`KXV<^ptQ8ngkQ_{b~I|3db~_7}Az_ol1<^z+#LK
zcv|8H7<jV68;L2vz$0pK>9Y)8e77sUpA%AdTEC)xaOsDTbU}%WR*@p|w0OnO)1x(5
z#?nk(HzQi8_(T`Z%=f~nag@`dt<Y7sIUVSFXGF_QZ<PJ7NGMochVq-F1s2Sv1vbSB
zY$^q|hbypYu>$KzsFKZ4z(Rq|aKsGqn;FV)mPsmk>J=-@y{$0!vBDh6rxM0~;aHU3
z{>~`Ko)k))mEHk{sgz_54C^&J4ss=OFeMnD#R(M^Wi+Y|bE503I3XLe8XB^<9WOVO
zO$e$1rlv|Ujp~LGQ64bBC}Sf-^kM{KR5%9;1|-*FW#rdl%<LFP&=tuLa;xP#pNRoL
zJ1WaC_FYL1rG2~>>KkYF(*l2rlSlATNEQm>M5_Tfhf_n6#LQt*NEc#>#dCGml#n)r
zI5m{$!Vq3*tZuPV4dN1FaTn!NV%69*t0|^iRX4+`x|v#8o~HE%Za`eho`I}U_8eiB
zLs_LlXS<6SGut^K)|$~u9gU<`r7RputDy3b1iD~u6uP5i=4q{Trdy{~%UM({^P@b9
zKGZ>HM;kio>zuG~O^;Bko!iT2hO2lUld)=PL7$%ff5vdI3Mk1cpyY{4^}=xAHkwLY
zh!m_@=F_O2(p~k`GgduO^%y~;dddv5p?b1P2=%>OebhTvA5je{<D#$CNB!dbP=)r7
z8V_ns5y=)E7}^N7h-Dw@s)5nQig^Z^S|}!B31h+R9*#nYH5fYcR8A;TP(@T;xgo=9
zD<Nuf!Pd99z(NRFO(~sl+p=10RKA%BO&7WbbvCN_Mu)h>@coz&B}z<QI1sb>A$rUf
zSRou6io3BUl;VLw;b<qLg0wz@8KEgnhK<2sqB900;#6W#nmM5#)ykw$!A-V03+97W
z6H`0OccImsMUM2U#Vgio17<@fgGZ|xOirm9Twy5?7<;C{*jZgD9knKEYjRXi7YiX~
zg0nayZNG9(vj;+{Te}Wk8IFgbL41Lt2j$;UGi+^@42CpH#z0dAY%wncKTQ$sOdM^!
zv)od`ogd4tS_K(p!!?;;44zQcI7;kXx3lhg9)|W7bk<(yhYejtwJ=(&v>bIqMYOBY
zbNHZ4sLra~TB5(mg+Qw=R@af>|GcgX^+V?)QddnE)m%z}q-ezl1B{AJACsczm^4@A
zrP~Fz2P0)-WQ0@B)XFl8%CeWEmmtl(jlx5+PprD5mQ(7kpH+7>u&genffcLL2E?i~
z$GozNga%er3E}Ef0aFZ5LyM4ACiXByRo2}hNN=S){X~yo&e;cgt&2F0v=ThZ>Y9_a
z<f=mtjHOWX<Y|o%HF@$K-9v*3Ck&&N#)fKSoGaBaVmdyYD|Ou|n604$v*9sFv1?3E
zdkg|$*i>mSO(&(p96*qn$&O}HEHp(cfT>og6<U)==`f=xRLf$k0x3TwHiP(|aA7z;
z6qzMAvomzV8)jngnPE$<O-^&=OpDd&oh6N<g(n~*tt^}sZJF!}yD_p{r837IhO%24
z?HW}GWzixGp><3-bxe#^_3xE?*DLYqlCNdF8|R24agb0-y%G~`^B7r#LnKymGpyv&
z9iqG-Sy9<ktL^Fl2r``_Mu=#e^l_<WWw);@yZu6b#<448`xw@xcf`mvdByri$jPAn
zz>r;7JIL8?6^c*~`k<1n#f=-;kdQBP9D#&(;J{=XYx5X!8D=}MZn!(G7)(d#W=5i|
zuLLkOBabquLaXY6lcSKFeQdPWv18mi&1!kkq8MJzk20>}Q<y+xNrb*wyL%jy|IWSW
zlXy~d;Ae8!{omlpu6C?tNVPi-2)VYC(Ks;Vbj6vmY&<w*N5h$hZH5?tiY4^sM4LRi
zISma}r{>eB^bX?|2kunTqPoX&X9$J(U>DO3^^QR1G-I$<?P%n7>}hT@xbv)xn7vKg
z&Yd?l<<$chPVgqca3jQVdXF6M2&l4pPq6|D2Y{B;iEb0@Rq6x>R3?R_j+q#IcCLb;
z=MKXga>9A1=4B+gFv+y-30igCy&OmoqR@c{bssaNvz=*C=7we#LKk%J&C{}Ne0c8e
z)76KkWqwvvxXq>p<2+hq<b6&k>ZPAe)UEobK^PZ0>i@02dG|=$!)_#<%uVZaSB%gz
zRv$PA?(l@|di-Mds$O=B>K(g9(KBxrhI>-q*ewd4`S5_Oh0S{A!7wmQDN@dkgZ&0f
zsBA8-p6)To6**l*qcke9)+kl_!V&Knj&jc3lom?4L7Q2-9{~ijkaR1B!|m1tOV!!S
z;PvZth=jjSi<fJx5*W=@C9V{A3bk>2=bu2_3XI|~5(N==1#FxnylMkh0#9t=aaRSW
zSgYCf_yG@k{6c%!artSII=(*TrVr^mB}7y=rOcCfY6-2xWATgh9SEFyu2PR#h7t#T
z#g*#p4TDu%z%!CSM5+$B_}CBr_;4(mBlg72g+i9jK7)x?3ywWX2GT-4TdM{5_d>jM
zO=(otmBERlx7)_{FLzsM3;F+Br0OE>f6XE_i)<}Yr6IJe+S@xLE`uEgQ{n)3oR&*k
zrAG8}tVlu;I6|Fkiz%tYqMXoqb22KyY=G7;hw(KFTDuf1stZO%At|Fla~|#kr~pSt
zS<7rT|A1W@Zc7E9ZCeU=qJQPexT`<JoQlk@r_^va*HO+!fg@6SAIBwYw<e`fGBTZ-
zPu`G}+k@9n>hRPjc4y*NWK=wNCSF3BErVH{hQgi6?lktISmD7-sHm2U@sh-7H0L&o
z+TQL=h8?*#In3(ZO|fxKXJ#F0nKjCaU_^&Qhr1m@pD+i5HXNx<z|d{t436s2;jZSo
zP(tk<Gp~Ft42H|2w@(y}vEhas(`8(&$&0sR>;e!w>rF9xtlgbVcA~o;F;Gv{a%&K=
z_sN*DmM&|ZM#T-=RjB5z3ZJUQtq^#4MV)0XX2a6rSrQ7@w9h77C$jmhxJ2wlNrH~h
zkTyaiQL$|_LL<qrEhfk-hGf^}@Sm~y9KpbV|G*`SlDdEFt`~E4ZnJT?>nemi*G1(n
z))g6Tt`w;@M(lNqQaeM?H)<E=xXpEA-2H|F#&DUv0yc6>kA&GQI;nd{8kM|JAnf7J
zbViJLROl&pMh;ku>=-8t9T0oWvpW#H46djvsk6FaTnHYwEn4Pr%Ckh{7@?~Yl!}=r
zuUd>&qz1B%N=hO6;Rxu;PE1c|O-oz$<n6B^HM7QdNknl26CDCDi<~SP8V@EL8viA{
zm!Y)55ahl%gC%S;(;<U07*BHxU=TWLitXX0>|~hFQgj0%v)PkVvau<1+yXcxL(;$y
zjL|wLyn=~povv3f1{zjf-^rX6RXfq6X3T|*Ry=0|QSZ|)V60v{PcN8z)Lr1Np$2+>
zbZBE`EOZOBMOzW=7UTV@42!iveF8_9)n+y>4Iygo$yaN!h^r*69(1?+#8~Cmjhm~F
zJ<}@VE;VeAs~6X#V0@a{cwuZ<ZtAJI3nqr^W5df=bl_#_i=1A(ed!HY(My~@N_F#e
z8}5}_pU}Y?9fb~7m9e2?){zAk(5Kv}T64^a7#VYo2{3|l_d*%Vj%9r)I~^L5qjdnz
zw6Jv1%@_|9hZy6*Di>DJmueIo&ax*IdPcE0>cVO^stX`Q&1Q7~#*LnI!%JkN^LUAD
zCa-txg4i)No5HRL5z$4ss|gjhWqLR8>Jx7K^m4|#Lz6mgZxY{yfM`nL@~CBDaPvRt
zyfKUkLU9*QvOuw+TZ6z2-6DhZAm63A^NnGRbh8qqC`jKkoEEbg?%HNLdsJ4q&b`7e
zS|jy#3wW&(-YBRIRxd$cEi;ZQ$Gz$4?`o3HS2O=g_=#)lNbBFS@v5=%n;dEZ5<4Z9
z_NlH~=n*yrvF%c%TiXmlDd9zMM!0D97=q=5p0L-mM)Emk@6aT+hlxH$H>f_{YL2Kn
z=x@EI@Q86ucojbYJO}%z(`Gi14ia3$*gb8qm3cb3m6r+EFV6DA2GW8@<sHLMIBHmt
zBm>d@G4o-TL2w2=W`|p!l5^UnERA$Dl2XWBykOR$qaxghfOS)Kv3ra*Dj@dbGTUbY
z{8$&fa&Z#^)fdke4!Q_gb=5@7MD0OCY2g!?Kd94sY0?k~;U^p^l$(eM*aJm$U`JxY
z14eYG504n8h%ibz%g!_xnwGxl)L5ajJ7#Z2cnW9jZvHXht9oPqBz?y~a?9mpZL9B~
z2bI2KSw!#McDs&s3nyC1ObQt-hWg2tFFD~9hci=kg*n#sh|XNmCk8}XET^VB9SO82
z@`iUZVwpHIJn&}4@-tPT!#=%jU`8LO83+%lb=gX<2=;uECB}iEYY@q5nmf$U>5S7^
zMRKO@4)jl~NOaV$q)Ut?T~h3{qifS?Wnuy9xw&zCE=T>xRJ>tJr9HddGi|I*^yF+`
zNq{g@C3g;ZcDDh0`Jr?|rmOVb<1hA#{~IdaWzrbYp^|s_++K5F+Dge=t!@KySPr&#
zl{}RHe_F|hGN*O$IO<@>d8A8YRJ`WN30e|E*O4Q3xZiN8qB~5AD%_}Ip6nK#P&i#3
zi9g$=<89-t)es-PmV-ZJ@186YLUV&GseC?o>n3!>CfRe7wPB3Gh>s8H{THFMTL1QN
z4WcxwcGKNy#w<OKI_?hsnGD2Enzgsi)8KFwBUqxZ*11M`_X}5$?9-oHma=2?9g$wY
z0bEs_d%9{!7&BC;oq}ogie*Qa2W!ja!Tnw=1VDw|W8akOtV*@7E!N!~Qvb8QB^7H>
zezGwi(n8O>hg(4MAQYO@b+PVl69}=4vpf=SPSN^clMtl@m^o(YrCm2}kBQEno1~YG
z3!3brMZ%`I;Ot2&RWD7<?yMIkjf<S#d38Q*QkJVpfX=oCER9$cV&;?(tI1?6cPECk
zp<?4aqgSrU4gpd^0;F21;@m}aVoqLm{y228u4i<fQN5Aj7Lk6LvB;lLm4xf+x=J*k
z#=G<hnKKr03|UAAN5Ox}ejiJv6zw)JhM0~s>ERG7EhJXDrV(|D9S!TB0eDU}q=2J`
zvor;Jx#ary+NGaD9eauazMZ+mK_5($9LrKEPA&SThP30`I6W+ffpHv?h3eRl0KB6K
z@M)3}vPG=2(u@)Eg1ZZJITjoC(Kb`;PGk?o#yGN$Gqc@vah*kvrs;OK>uGnp6W-6M
zV{z!o?X4%?$NJv-S|i)u#2Hlj$DSx`v@&Yd0odKewbL#3f}rcc+j`9u8F)QF9#xqk
zIzYj`xT(rw<GmP<f}3BxbMj!NhqP~ED5Pi}8Mf!08}uM<cx{gu>FoT{mu4EXYmRaF
z2BC)*K&NB6ef<I>Q?o_y;cz&%Aria~h^`l2=d_SC>ZgRh1$7d(z6E;{CSdTly$CSl
zOma`&+(zL2*VpKH^MY@x;*S^UNDUpU3<&P~7RnbuPro^sMI)673a8voUXAJDL2U*d
z8Y=!nzt)QQ4?Qj&{eWhO*C`k|hU#$m+w~#IKH-HgLpbmO8>-j6!nZOyg@VKkQEqgF
z={YxKG6LdVfZ;i2&(zC~=xfgYES<yK7$h;F+Utn39h$4Fj+kqJnDNg|1}PXGbDlE=
ztib}a*zt^^IX^ls{&Zc)BibyfpgC3<_SU6UQDv&kE#lkdtqT?|j<$<&NL&yW>&pVR
zy|An5zsPN;?TIDPR>sg<8ZE${%iZ*1x6^0aLOw~UQoVeNwXQe4M5_UltOiVu#Uy5B
zQev6U^>UCHo%dH*DTbrNts`n<{EJ&h>;@2tJ&JsS^%y&Y#85U}_W_vgMDByAVHHaz
zV>jwuA)IY=qwIEvw6I)TDO^=+5W8km%)~k=(@(J)jo2C$m>f==wm?+FrdqxGsW!l8
zT1Xf76U?%+4G_Dqo!?scM-D5R!+V6AHhgUq4A^_HT<p%BVfGZYRC-szn@WlzY74c_
zHI?ZVZa{YTge71VGES1*Vy!zI5H&m=A*0)LjBCvT`Si;)g<gy>+Uqo<rrp>u+~%ps
zFq|m$h6bZRZ#33t!cO4wTvtuQIIx#)FbQ;f>n$;Zgh2t8Pfpf)nBqU$+4Ey#a60XX
z>a}kU&uCC*FHs(G&e3ifcJnvbns>mtg(BVt2m(YH44@b?hC+OA$+3`KD*!#6U>j~^
zlU;$10fQHqqF~U_eJN9!0`9jRR6&uZi9U3gkN~3y!>I7C3p&k=V`e+u?xnCATq+sI
zIL*FJN8{7n4f6EP8}1og9&`5)Mv_Kh+@!zcF*{TYb3(<SH_$Mk6ur1>b+RI~68z_0
zYH~G&JtTk-aMgzzF%oM`Cs;p`^*mX9n&h4%Y>biJ=u+)Qr>`Vq)s1zlLQB%6WkdIX
z2(uZkm({++ji$IYbG@wg^=<Uf@#J*kDx1gs(hF*>qEMV`RE3cU1vOL^idl3E8^))I
zW5f7VCiFi!02x6VwdZl6W;t1Dh%jR#%exAZjV(7DhgBdZ>qZtqrg*bvMx#vG4@{WG
zBV7IrRf*|?Ij|3J;VHBx>&EptH5e<;>4&Td>C-}|?%B-eV7k7`O$FjcmaDZ1UnQ}s
z4TlJ=1f6j5PJ1rn${hv9C?W^<DV;@ds;gr<fx=NEN;*u3fkl>*$i`f;#b~D!z447s
z;g@0*|HO22lnM?cTGbdG6<)JNm4o@rkJ2dwLj{d+B)eVA(z^^o(Mek94gO;zj=1<h
zrp&A!vigF)YuHhgItpE_O}czuLUE|B>o(}9(<g5}?G11Z>D=hh20SbT$MM?TJy49o
z3UySMND8ZWq}4l#Mms64OR_pF*}zkhoD$Vas!?ZuMrZ_uFSpo`AoN%FLq;K~{&+Lf
zx%k&+5$=UtUw&4s0o}{hboO&qSUFfYuBPj2iGT=X8dd!<8x=Qs5-OrvXMh2wa2be!
zjKtukKb#3%<O(CkC8>tl7$};t>dDcARxc@nS*@fp_994S>|MXgIPbS<WjZ2y4l|J9
z^N3{y-Hwq$(fQyV7-jCz)<Z<QR-)F{!?$fht%|o`Tz|fXRX{<oj*78XC3>EHbGx(9
z+4r_F1IiI2jjfJBR=GVwbve;0FB&_B&eW>*^*1%m7)8)oXHk?nJ^SvP85Unyqh};)
z+CU{a=ALnZ7zIK@#u+;_WI|JXrZ&Z)YApFWsl(GlIuidgLhZpU6b>grJZD398ApsY
zSb#F!n5C{6R_0o|><2H0*6w)Q#o`b{80+XT`s++XP-cO_S$5&*jEM1e;1f5FI^|I3
zxch+Toy)n90l1v!xpi#3K+ngJ@_f4o!N;Ku-ij^`Ca7XvRi*XsBCUTHJNDiMp`c;C
zy$h{>>mnU-vm_*eJ&`O8rwi{yNPW*+=3uPM-Akfe-qm`jj@EVMyqZ|yqd~bGR8^eg
zc`MwWF$+_xG%2RBGDM4{{9KsTJIpG#fZ$iVFzq$S8eQlHnyihsb9S3`QFNnw#Co@#
z-bw1BMVPQIst=3Y;If7&Jk`?k8l&x^1Gt+IX`pTZt<t4B{_KZpCo;YBp<3?<`1%^$
z9)=UtYH58%r;kxM;Z1>3r?@%OHKbk464|I0Dh~(?!}}bC&@+@?-m+M2hK8A;Fyn3|
z+6RkkgIWy4-cCQ%;!n?NFqFo=HiKQsYP0@mZ!tjolU&s>z)@raZ3Q+bt?^>c)f7;5
zvgWLYSlOh@-2lfsSFWPL3EL{<VUE~<cZXZMV1%^`Mq0M+^h#9>Ve#D~_s)P!jV~X?
z77<B&_K56Z-uicWyVIUT2;Fj-F=;+6WXJs)r{*I`KC(uRQV^k$(^bznE=A2<B&4!5
zdO(GDzPOB`h2<)vkr^~<I&*bCQ%r!fCOoZCe{$zQbfexI`f47414rlkTi3K<Af=^A
z?*TDd+i;Q5;nq=O@C-u%l#pp10jA=54RM#3OM?(cF0Q+P;cFhI|EDitXr9K!GD{3S
z<Bh}_JR=T0Au<V07UY$o3>zmZZl>)4+?=^TjjtTET%Fd%gpM^;J8LgzYs1oga{PiB
zMr$w4uKMF`u7%vw+T{F%i85!y%U`9LwO*uxqUuu2+MQ!CB$#y!q9ob_s)>x#>5Lz<
zAU4dz=)3_Aw`yBjb0?1Ynmh5iNcM+{QYBb4<^JO^(U(G*>Griyb$I8wE#@^mHXmW7
z0Y`SiXW1w-6-7yVWGCZb(9t@C!+8}*yN~it#TQy}P>-^p!~gIElK;ncW%qID!tc0t
z)p4gp3js)rk>d??x7sd2RIwuSFYKz$XMg_{z6=>dlj^g?)kF`auI#w>fR#pjkr0ZT
z4R>|L;RG7nZc}bR|Njq8)E^o)%9*FHE*6kIks4(RGe94!?0MA4$|njN4_u?HseZC!
zSEyZev^7;IkFLMnvHLq;usa$Ay3+k@Sjd6gJn`b4)+F|{33N4QP8b5&vDfR6eq9<9
zkf=owt}#k<=vH^6eTuuy>D$gut}zY6-9SE--9z?1QFM0<yIaN%FFt9vq_`VFs@({}
z&x0$<|6h&8)tgTjR&_#7xb}|6m|4eX%q;dk&B*p<$>qY%8;d!YBj%*j4bX6X?$kRA
z6g)mFppUSlEI5ARGkUtv8!kR>rHy>@m9x8WQ^|8Vn*yQln1FDB6(IL^NiE|zM^M}^
z3qdmQnGw6wg<DEjA&>F4*kcT^aRW@$PVKyOK_X6pwAs@Lvd$+*v^W(~$egbU>(bB%
z?1)l{7BhsMblo6B|1ZoIEm1SNN}jn-a!t(et9clSW@wjh=EZKHq*dqORCibECK}Ri
zP6_7F5Q{$nMn5jkxIf3RPYUfW($b0bWH!Yd{*rkT#BH`_R)&B@-*|MyR|nEZj~wn1
z0?TL*r$$$2npHC@oiCq(OZ0_9FXs%&$YR6!xDVEPlrhDsu{x7l-s*3a&`I{}H^81<
ziN5_j9n|cAh!#wT$tai(6FDCWA|0%FM(Ns>d+iow%u9QfW3mw1t{jDXVG3X9HjR2J
zMn)OSuuRM;Rx=+Y+JJNzxXbbN-^W^(x?NoFold2(=Znt4gi)l`Tw^#B?~S;enHIZ=
zrrX7L*$PXO5h@q@I}BT7IUI!3L`eIX5lz&(Ia!A9?m8obal_Xc9YW*VR9w55_jpct
z`gf(*wJHDQP4<&%9ebAhguqSr7Q%jT7JA!$;~yf*TM(Sv^o~L07M|LS)WE3}`Xh8L
zgE^unH0x9XpuVK9_1Sl#Zp`|C$QA&l5T5|k3W%QpGk{rcCEIA0m=8~?H>34|PHnc3
zWxIvxFb*uR>ts^Q%(tTLZfkjp+u(4AtIQWBdB($jYthkr%P8(R_8b>A>%tHCMCCmE
zgpVoWD7f?>YjuCJb9q_u+i&3h3cSfsaK8UnytC@#N1@06^YaT<)n4osG}hM@)UH{!
zs_~NQf{SY#>U9aK3YIThR<LpMsTZ9(A+N6bk`+rE@>bQZY1~*aA%AlIMB66@0R9?%
zZB0#m_4@o39AoL4rK>h=uFhYEA-#r8>#FNfj=!r@-*Cw#)ip@tFWxlNuC7K3f7YnJ
zVQE9OzIF}MD6OkrUcC`XfCEmoYjr7yK?*;>vW3f5ufw0H(rq^`UA1cMGM%n(sH<JG
zTz5osfYE8fThp*gXR7P!*4CN!o9Y{?S0k-{iNT?w=_(~25xz*0HDY7Y)H}|WbIWIo
zq+q09I>!s*f{4tHh_wCU$*pZ7xuUqRSfmtPyIrhoEf;BJbHrO-g}9=n<7$yoBR*Fq
z5-TcEFB;0kJ6@5vzNKP`NI5RH`)#{K#r}42SIhq8a_GDAa?vRBMgJhzFDw`9<#E}&
zxP0HcvbyAwMmbOX#Scc|FR{e=?Q+Env$vJZ5d-tbGB0Xn$9uZu3(d#&$_=l`heTR1
zPC-E**{8GwVD2NBT9Fcr_eIK{U__rFzt^2pOXlp9JKM!(S+QDdYQ5-<U`3`_6HNBS
zfWsnre=xPz+!b|Avg&}?+^|~q4Mt@?BGw*bWeQMzp;;EKy1)E=G33}E#Rj?mVsTwi
zBc4F1m@V5@iZ}gM@yF(1tpENp@mlj?ah-o$43-VSu&e{izkhj)*ia-g+GJBS)3Z%3
zdVZ?tXpu+cxGCaw@9@4$;sVj{@R{qzS04Q0qZfz`4I)vNiH1Gzh>YVRRTjx<d-DoN
zg-B~eeqJQD%K2h*{z8e_betydnzU(xEU8DIR<Rnu3uNQ(t`tA;gA#vw<tvwq=bB}i
z98y(RyjQessSt0A2K?LbMR}3f)KGl;uf?XaZ&o$6RPNkcTE1|nEXVWE@2hUB`q_rY
z&%Il?=uNSy;-Q`8Rbpd>NGuZ@DnuQKa)Xeq3ZWwr@z$1LgfE83j1Bk8ERigW7X3yf
zwsGExHNnu#-+zAktmz`XO>8>8y1ej0vAJmeV^iB7dmJ-38)J*!$IC@i%}$xMTdb}S
zsYN2K?QzT{gQfdq)o!u5LfqHVAScPsojFSkkVOEuQx+^2xiw-<#pkyI;3_eoM(k^;
z5Wn<f*}38?Ee+yrucEP_eU;d>zkR2C^yQz6`Xl07Eysz<^WKqN;>SV9Gfi_UH>_V&
zCG+N%Y=Qu6-?1qVa|$Z?DCeUvB5NX5JKk?8ZrU)ZO7;>5wg$ue9rs^0dWT5P-?wkp
zMPf~j=vTCRdFkp^vIL|n-(K1zHg||BnIQ`I%g0OGE03100Oxgxq>9(&*yWYK5cjvp
zJ>u!$u=rW?;q}FhjT^<LHj&sNhsjsOL2$(z_m-EJi=TRBVttwTmM`~{&`&C1Os<%G
zwVXVC%G%R6P8REnM8C4S5^=b>M*Pv=bMT4-vig9mCE_xR&tg6nTqxcq)?#CWs5r6?
z<6U~4952t32gHT4BN*COHlI0V-X$1uXpvao8szrB416I*9T$)L4IKGTPwc8Epa>US
zuqd7wMauYyEXLCp=gT%R;E2eR$F35+Wwu->9%?y)Dad@8S&9~>a|MzjazCHT#03r8
z!A;xG<^LW%cbCYl*aa;U#6zK<1SJ`GGpN!#tN0V>cB}2{HyLGb3jR^eZ*~xG+1fP?
z)f*eMnz#BG_*jkaB%%C`!iVaQZUdq6M^ge&${#JP^2aV_;iA;;14z320QM&XTQ#q%
zadSrNb5uvW7hT*~yQ(3tc1?-Z_0ty^U4Mh`L($CNg9SUqh;I=WCm5a)DN(DmCxXok
zt92|Q$CYj`eWd=!H&<5<MyJ^o=+r;R@#l)<!!O8!XXGMrx!*DOsiX4#g<z$(vD6~b
zhkoqH7KwYXrDOn*FPgaIzDV1{f8^IieQW9F*;8kX6YDEPpH{IcU+ma=<k3no5V~uH
zEPJ)EJjm?_l~*ATiq8wcOlcDhHLo@{&6|Jjj7hco6toSpLO_dF&J#`8xsn>hnlh15
zbf0)=YlG}Bm**9)y05XY_~<JOE9Ihgxof7_+<M{iS1X(3ipqU*xh#+??v!H)Y4y9M
z^2#sDv0`n9=-DdPR)}5=XizLytQ2XIw80DxZ!eVd7e61i$!ZYaXgMZ+>>U@&TE#^j
zXEract!xr6d%;kjic9|aK@7iqVf(Hw2oSb{UkRGFHFG82_hl<Jj^Bhw5NU{fota2m
zM5J_-%N1z%-qs?tyCx`8=?0{)3nZlvt<Xap-zxbh<k|wzaPtw7e5_pVK-1S$w_8-V
z*S50TmtwlTs=M75?e@6%Hl{T~X4Jo{fagcr0p?@X^)dzK<E^a#(+V(^r3(th(h5Cw
zH6=_7t#4?SoYb1&R$NaM4qZQO>cm}g>>#oE*e*FyY|6&cW^3q};B&zdkq$*!S9IEM
zH#{*}Y=FAkT5-peMwvBE4v_=pP~ssPkKmtRJ0GQiviI;uZ3Ax+1n-m8L-)$Ss)~Qc
zFtqAH$>=f)n6dC6<dATy9ke~DY&b}#Ep?JwCuoBan!-r6>ZS}v%5?2=n3}NI3^1iX
zknTo*pw#LQBt!kNyt-lSI%9uUZ>(*oSz1egP$lc?)&jb+Qjv=qmRiYZ!_olN#w0S<
zm_!?*TfeTFrYLet>+7rQ%qW-C)`egj*VID8=^4~4ivmKKHdg_(rgl|z9_gb&#p<r6
z>bm;cwQKUK8_Y=cEArMiu5B=lVGA!^#Wdh7%fmV>`<#XXOxMt+1`(?_szZP-$E4R)
zJNT_wT6ala6bk3=s8QTO2k93Z#rbi(zo&Tn?Zs7MK!vEz7ANfy)eY|#&zsX&T7LhO
zdE>~YGKbINs`7nR?N<ysSSJP?%PbsHDPIZ3WQlM4d%*c^l2(NuIUEr^+C<WRm`In2
zq#Bfo1AK6&6l@~6s|xPqLTsWM5|{EZ7iQICU)v$)m+U~6IzrwcOU33rvP6{0j1RAs
zL#NEUQ+zq75cfCB!*8ygJ4>}|ja<)vp-Ur&Rl!SqR_<%BoLX>RrOayIeo2A&hF>A4
zZ{MjJKG58XEnxev#O5~DK0k7^$Wmqq4I=CVdH&CKsTyn)Z;Pa&U|iOdDqj&1iHF5&
z-tmJfdpIJe)z^!6nrR{4*CLfcp|#d6mv#W9H{$Z4HEz0;>glbxjx)s<(Fi4PT`IFt
zbX|PMcJZ|qSQlw+2QCwR_f+0?nJ8|1?~wy?MZ0*~lQos?57~hSc3dhp)ht>sch!sK
zIA2t@Kid9-?bE83%6U`fiLbZFisHu0N($fIvF-VV?=P4(dy(o`6S*Jb9o$@o;eH&y
zU!@PLbj88qYOd1xvH@zlP-coJq4G!Ve_W2oANY+E?R?NQibP1JNQ3|*%lKF%zS*+p
zw@3w-<KahSek7Qe^&8qo;wG4XN5A-vxW#X47d`hM5~&>*s79?3O~Yf6U5{<A7T;>_
z5Qlu6G8zt7isi?}$ugs|S}gAfhG$h)SKb}uWTDYLEgk3^FAjP9H;8mZ#1A~R$l}fx
z><16=ar;);&|Z7Av|J?R<B0R#)RKZbW{Ye6{SCAb{m7okjm75$!!pIT7Fkw)aOZ;E
zK|iQgNWktKBLR;k_``w}T{wS?Dcm0TXRU=+FB(4?6PXITxBceIS6<n*;rzXOE4iEY
ztPrc!l8Zijf}vSrF}CY>{04D-Gq8Hc-vjnO)~pu#1K;vS<oSa;MdPu?t@xj~PPFdZ
zAzt6o(I|F`)>n6km$%65MsX{PIbZRsEyww<tbe*uG_^JY;J2Gwxq5*2ylgByDhexP
zW?`jxDyWcSFOfNMapK3D)P8v|B9A?`SS~KVeMR8{IYO*Ij#Dj8q^&rviC=EPX?C;j
z`mm?~64z|)Xbf^P#UFzT;IVHrR`M;sp|KEKUIS8lDq+HIY7I7KiJKsQ&-gNfowjs<
zZJLe~v5ysE_c#;XDJo@Aqu9`@FkD-qrXcECpFb+r$ch8NdIQQDTA6C9cvn0bcMLGU
zbZLjY{)Stpao)j<ero#4(r;mM10M^-!ebaQ`8X)CQD(d#`-s29<%`c>T7!Q(=8|+m
z?6|b%(OqH{NV}%>c^E~F;^uh5ztK$e6;4zRz+~GYjExXgF2GxxkG=bwMsb<nx~p(u
zm1v72HJ(C)r`BzrS|!#2;jyh)x~m#Rhu?amNICq3NZ#|<J2&mxCsJEQJx+LKuO2Nd
zm+gg(XRX~-(6nneu<=EoW8cPcv2kH_<MPWmn>gt8xH!sL91mr2^Z1y}2i2lZiH<Gg
zt~l|EppuLew{EG3)I=uV_+0VAaq_j|((O3>{7MvE(zN0L&f6XLi(dt0;_j^-t8uW;
z7WZw%LH*d1;+H|kI61iXg%_Uxb>l)U5oHlspv)A}qg9s3>u{jYuc{OeZ`mWB4~{8w
z4Fl~JHOIt@!Ete2^D&WlOqSdLECR9Qn0N`cmAE>9o%+2k$Hh|uN1|t7a~~1s9D7eB
z;xq<i@4EB|=KVYWn0NxrB9`I5pL=-RjU3?kVx8Rcs=P$J-P|S~Xz37j9XR5mK5c)H
z1VMZW+g{++!IJo7Bj}$obKFA~+;YmP2D_pz*6ZaOF+c_eOMNx%0F)bphGvZRfT0Zi
ztCbO>`)M0MwFnPK(Kal1c4KSapg1&dFxtx1>-2!pv;k=L|EQY`#i1<#iz{mKAWh)f
zI$<m0GefzxBY<zLVM5#B<uyhLw!_f9{)x)^<sy9#59~ekmdR((5ZNy3%S5Iu>LvOf
zm!BK8^K$W+SM#p;P7Cz<qn<2!SA4HU9t&n=iQ)=+np(yGc=EV7-n{2W+pnl?FRWaB
z{)&(3yU5%x-z&d-_M(FK#U>n!lG>o|;8LiPyMHl#)<trz*ia*SbX1CCUc*s&v7A`@
z6U9S$GN1pd&H9mO>T&T4FxAjwmDtoai{*zGEf7f^PsyhDrZ$$tjq%-S3&e|F!}co{
zu784?oWGHeprkMVfzvHVdFbS>x!cChDcOcX?F@)hCwrWjT3=*CSt;skL|XoXN;!#*
zM{qW3m@{_Uo#K^d+C09v3MNOnEJPZvMu^-Bc~lmP_7<5RNOCm@A9$~L|8WlYsxSGZ
zgFXyaZK;FFyJKt~<L&95X~TQn^Q^<vU72cnqhYGyI7rsuBwHYc=ZgytFOrSWD>+o>
z7b){-2<@edW$Oj<W>Ql5h7xO_eMNd1pE#m!q{-C)4U_^;V#NdK-%B1tuT*(>rGnfm
zU#vM?h4Na$?F%D^gDfZHfwJsEu8QR92fyb-9lsWCkh{>Pl5Hl*j?XDLee=cV4p+&8
zv{`|PGFKbmKUgFmbxV*I5vjH(d4LdIuuyWcEEA^7@k}w|cxI4><(~>^47_*$f#v@v
zeLh}o4cB)WMvA&*z<ROgIeUoH%B!=hpXx8F=%W0fN;N+qY54(3M~6B5;OHA_nCwl4
z8J^`)x?Elf_v__i-G2P@1NcqPhO-XI&0=$z*a-h&+4s*l3+@#pHqQEjytGL?;kEq*
z?YIVCA-y9<BD>{~>-Rk*dc%I-xdU#R8+Xr{`}wsq_RcN;YGwIywiM;EEEv^KJmQsA
ziHG6Cn@}Wrz!%-SO?<Uw57z#R&GZC)JAmy}{QKesXHB|!x!8+#nR3rwTo6oRo5#1(
znEnDR9ocKn^ht}hRW??wRM2}W(=-^>=Y|Dnccht&^fk2mk#b)5gr7QhR^{~b-V*gV
zFBMgay2Bryj|rY$_b`ky1)=QNPR;UdkypiNY=;ZV#ONBafaWjUPjF~v0rG3jazC=Y
zj*B1RlH#G3GTDHXqJ@}2msAj`h|Gh7vf@m%{!$C))DPS9FVOlMEpXNr!k;hBK(C@A
z`k%{SxK2W<Mx2Gz_##-c8FCSfs2}?5`Y<NKbd5^4M$5n7Tv55Ocpt7tV9+&)UTsgz
zn%;b8Wnu9OSzcJY3lf<j3t$B9mj$K8boI<`gWjw;^MWr`Rbkl6cUD%43YouHZWlev
zMBNb{F#O2zh|H8{Rc$L@*tmC*ScvPI^2Xa`X63u@RR%+Q&-$Wrp+1cBY~b|+yZ$ek
z2T*%Tg1QqFu>7YfPV3e%`?1lXp`a`?UIHiuN5{JRd-STT)AsJ#5$Fmr)V=}A*t%9D
zV;>5?v60Hj2V-n3zy8*n7wZ#jo6JUOT;v;k7B9pTdlk2@Ao6HcEe@w!+RmJOg`B&h
zarZhg>BtRtivv8azV6A^KcSU>Th-3;`o;se4?7~>^r(}QkIk*$dr+KnWZrH2<WTJ7
z@8PIcBYxwdTT(FE7oR)QDA$TPvS{bk@`W8!n<k2L8bkqD<un`v_mXM$HZ3d=rD&VU
zA%L-XE?#!LI%Y@R<@@SND&c*tXc4((;GMQB#^F?Q^yu^OHs-&({k>O2CQin;w965%
zTy|ySWgF!*d0*k)!uI+bzE#+m_v&S`__8Z-zXVrY<Cf*HSoe#y4ciwsigcWDnvb{F
z?}Akiq5EBP5$x15d0+9>&2oC9SieW~MDf}Nk<ltgl#9lWs$ErbY;iETpS%L%fh(-y
zyka>7w^C>Zv4F6YiHDlY<fA;QWr%|~?4oF2wVe0Z3%E3rgEw4u-Ko#r_<r$}LNT#O
z%<X8L+Em<FC&nKUXIF@^M+zHP{18_fTmI|o!T7A=+jk-VsCZ|~F>$@%Jw+g{yi_j}
z40Dy=z@tKNB_C=N`YKcEsz+tj;feAUa32fS@lnOcCO#nf{71D^JK=g}Rd40CJ)c?C
z{9&e4Ew4F(v3yKbwc-W8=6-QAPK&Sl`yUtgA@Q7_FZN*PE8UK*50^2cGB2wvgyP;`
zS=hL+aqfZ}L~70UU|7#`-XQipZ!w%j8{~^n$VIP;-8eXlm;8!yaYu8T{ANKZbaoB=
z0J1~2mzINQP^L{{$)0j~f91mR)na4El9iKpFPvK{29}BH4slXZt!xCPZ-A$@bVrq#
zk26YBIZm1@Wh<<*k>FTZqYYTO@lfvBxb`g*Cmq9Kv2D?U8>UPf52NBo7d&&mSlaNA
zEO=$x+-+4;#UH#q=uxA4@J_ftI;@R$DErX`zdfH$f%#>3pwFDSQ~xYq{TdF0qP{_%
z{WZ9sfx|wLjAJ6MJyBXDFWm-%857;#a#$1}7T5TPAN#3DYY0a4!Zq>{7&FJ_PA#FW
zv}mrlaL)&eWC5qtzC-3tZF(Tc&lElOix=qOzHe*my2b+s4jvHC1p8}uOntucJ&>?M
z{2aHpuWyA8y{vL?$epixZE{?DP}ozXR>=EzJ-1jq2&+`o$cF9pP4!K;HZ_VK$7sN}
z?G$y#;qPh{OTooUD(K~S1Hy5WUnAaZuDN|LQVrtu=A!aaoUe5f|CY&Vh2^DUXG<$+
z)+)}~BYuvfB@V|Aiz6cCh%$d`mHGQRjFSJb2KUyity>LOb7uqSpVZ`zdbTDHly<1e
zU47iu1b+J#qmf7WpXXJM=#vj0g*JePDZkBPm=)V0l0#`cERn6WTLQ@wPK-&pQk8Tu
zHE}z87@bd2_QC16vC+onV4xUy$Nm?HU0-{Ni5{_p!aDz3NxfkiJllGY>z?Y|`P#l@
z=seE<U|myF0cbKtwt}MP(SjQT4=4!gi^^b%zX%1n^i^CU_spAeXYm=kHtmFG7*@>=
zF#(J5Ds(@+xO1=|s?#cYn0wN3XoH*K&V||^#48+bRO$k6CmOHd>h*<SPLVap-rvHr
z$uki3sVc`CuO7k4e&fPLV#SgAa+!-Y9tY#7MLg@Z;UfEJd*y~8H%rXN6<9qQCkAKn
za&rUCv1h%Yftfumv_qfqijdyhLXc0xzT^FL?M6fmG&Y{OqP%eX9V;X}MQCzW3+=a$
zuya=(-Fe`bDEUwsyI1-!fG?4)JgCBnei+tRI*w9-_;WMiU+K51G~L<P`Uq&5R`<M`
zZ4FMeKV#}Kcp4*>^5|tWAN)m7xaugr2x|6`#f^;$Z0)hCC+Z7}3rk>!c6?v17*oQd
z--WW``Jdx#PG?x4ZV!TwnbfDTrj5H*xjLn}<xTJ=6)mh<xNz?ErE}k4n@CWkoJtWj
znpF1z>M~-X3KhV~j8?IT@T@NO$~odM@EK<pS2aE&GZzgGGNFS$uPn-|{{f5A-n2pD
z|IvH+Zaq+q4Y<Gh1TAHyNT0hppV43zc5_BUsWm+@KP!?bwYm$*P>QS-ibCrsQoX`p
ztf*rN<pdE8#)_Jr=o`Hm({R*n73jKQX>E7+XrHVw)9*HdJl@YPer2%8#bE+BJuQpM
zr!1O-^TQ@(_rO)8Sf!N41K70@2Mz9?^1V4bFTrW6WK7kZ61Gsz8VNJ3sje7?Aeye{
zg>FqS#?KV_$6q-3!a~Jv%Gi;mRl&?m7??{ALfDSCH&)8Zi?WL=d6)1UWI403ak)s`
z-%Gsgb%@(rYF6WFrug=&;gfDakCL`^zg&5TJnap*H{0ata%g4V^4b;cJ6^p(?u9bi
zb3ioh$F|zgezXu^8nC~v>VV_6^-JO@Z;!Hkk3VwZ&5y|&UR12B8Tdg2Ahqrlb$g2E
zqSWVw2*cY}?}ytAhvN<e5VaN*j-86gE4ZWKjDs((LHrKEHs|eO9M0J=c%ClAj!r*D
zpp3f%^KPJFC<yDC7VPBZ^Hl6xTT4+PW8Eg=ggSwP$&(q?rOv7Hy`Am9m&L!I3Il>w
z@9l1X=jc0A5h{1%-bOh?7BoIqF3;W@4C~ka^v+5;0og5(SFmwJb%6_-MUh}^MnnZ0
zB(^Spdgt<|#7W0R4NNOWMIGa<MMmr8VogV_7}UY2A(`!$JmHs!o`=Ux`EOibO<p;9
z#%8g$Mr0L<RYjtAzBpySEUs@a5GOZ?^UK7^MdJJpIeZ!v;>IR1WWQK)9J?cVq<xD7
zmk=TG48pxCUptDzd$v$<|4QJZOx4`Ir6vN+7ZI-sSwwHrO<SlGe<#2&YA*XD%hh&$
z+m=?8cL;{v;TmdVQC$rfjLhjrXj}t?y6W^N&Xx1j?S>!8$Ko~Ip)?dXkL@zEdT-uQ
z+^3vz!5c7lWkcp(Ft%ufR&KyOiAdd#2qLjUXDh_uibZhU_m;<AT>Cmk2-G-1L@CdD
zEX8^C8)VL$s^SkG-CkKWs&ZlFVmWSMWw}zeL2jmU^Owq!_Fc->JSmv!kCRnj&O_i@
z@ss0ZyEq?5DUsGHFSniKUfXB+QPpP=49oFrFZfO#vE6f|I2f5(SS;rrYOlPkxJr&_
zD26XUogyOiU&KXdv&7MD7FR0!WEb-Ys*fyUGlNT#TL-I4I4a@58+k%i48`+LM7lbm
zvN4`CSB*z++N~PaS{9hN%GcfmP!ZcO1{hdK*RHAI(Oy?9UDkm6{b<%+;nQ1S0&A%s
z!@vbtXYPSNszm`hRJF)p$hCFVc}+`KH8MUx{St!*zHJocmA)_j+dJ-yzcyzhh$$cc
zR_v^Al#RIMZNydj1Bl2GJ+ehzK0NB8spzWhJ1ggHUx;IT<%5k?=Qr^L)3_g;*H#%M
zVq+YE0RnFbo?Q&}5PL;0uZLQ=C%bE^cD#Sv!i5nYYG7<W-7OTUW;`v{`3UmaO;9Dx
z&W3cXtsdRZP(ypt`|flmJV6f!Vs?tMMRL)p<Y%kScF7GdPd|93=+UsbNmS*_-O5k3
z7E2s>n@`BfmihkmYb<=f1EFyZ)ijOqbD}|(F~9m^V>Tmg*$-GnDF?1}$mQ7BvE*8_
zs(Q^hJ%Y=t8?5D^h#ESfVv0j60@2+jSUVbBgN{+#0w~5X{6-Fiki{lFaO_H{2p7&x
z-_D^gqh;!rEv<KiV{guMRABl3>iHr+TiyRd!y^K~uIo7e=t3y)-*_;%;jmKv);snc
zC@fz2hpF-)Y6_2RfaCL<$|3q>v#hzG9exM2ole91O=X1N*ix|^nICzr?^XrFdd*(6
z2Da@N7q;(}eJ3wQ)BkE=<OTL#9y!qX{>v(>rdBD(G$Nn>fVz<kDnRAzido1NGkIEt
z9M2k=f4@6^*^TYR3sF6v+tIH)2G8BC{Jg_jpYPnT{B|*hp!T*XD+yZ-H+&z#c(V65
z0Q3<A;Q|U~WuY!7)SoD*2M~9BdYSmOm%kGxz;u9FMB{4M@pdt=LX=j#+Ih6%`_SfG
z0(e1D<(`&`6<<Pbcn8WatT>NJOtU6Rp~VZ^+Ye1%{HR#G$Dtcbe>Hir<k1ZwG8%J?
z91-JX>$@MezqxB6FaO)+>Rk)r2_Y>O%ZkFv0(t+=UH^U4PVwCq9_k+Rjw3i64wdL?
zw7+rQVw~9)2gChN!yP&gNK|*U%d2(~+`00w=!F&gGA@jGs9qzFjomhPOitC*l5zBp
zY}_O3FK;hABodF0J%1Gp44fC?OD~#xIYQ4{PZRn3xxf8dWXt@W-$y8m%>EE|!ReKy
z#g#{~P3BD9Er%|cw&P~pB-X(BUL>-M5T+@MZvwWjz!<<g0+riKri!#0n6laOjGdRy
zo`xv%c0{Px$ofUgroF1Fm+TP>;K&>!8!l6hm6yTifp<NgUG#O#vEv`q$X+x&P3aRA
zskXF^?`Yr`)df%~t{A)Og=+NWA5CX-PYi`qe_>;BsT|&ZaL1e#V}8%u(_IJUtAk3G
zeb|0*d+GAL-^(p!#V~g>N~`8nE#9|!U2$pE%9#(U=zv=RBk&sW?0$~_+(x73p*5VE
zV-$O(D2@7pqU21r{bV{5o*3W{DJ;(0Ub%Sow1M*;DGmfs`UV;W_#1O4Lhs+E^`X{7
zm9Mm_Lj2#P>~*9hG;^$aCn3gT-4#{3)%7RR>LlDFInzluPrM6Noad<GLzbd=+ocy|
ztoC)hRnam|Dc@om?59;A0;jM6a@in~+ins|=?p1=e?^Fg5o`s81qF6Nd$BA<<1#9s
z-+FZ1>{4pan&C^R`tY^~9)<GwyNec97FHI5!>Fr8@{#ivBPv)mK{Sdo+`*YVEctN9
z@E<u7J%`Jpc99{EAPAac!3=Ik>8NA778V!M*K(l>2(Lt79J?IHBRCwnTq>uXk1#8i
z(%%v=SQ0lX4Lh*OOsxWp$34#H0iW&`&gaJV?bJp4m9OU=rIGRO5&K7=nj)eYqMy-V
zCvmFYaN3n7yI}vj@@#5p^xxT1Ay)$Avk1RX%54b;NN+_IlxwRJs-Iv%1Ml}(n}4TJ
zbz^pWZs@CG*w`%{a;G(m=CJNeJI5+<%oZ1}(n~RB1o|Kk#sx={6SE(m&V+}{312R6
zht~@WnT6%v1HWGl!a&#id`~JlnBfPf^;JPFm-C=g1aEnnx{i3TrQ=W7?!k|^gGHhS
z|K@Z5$G@!)i)nx~qfAUYCT4WJDJIKfVosTuTqEY>i^*+bPOF?4%*c8@IJ?*D!O~th
zBp(CA0#<r3$M5z3XnPa*D6evXdom}))6KSorB-c27qvnbpsheM0ZIc*CJ6|knMtT)
zNM@3OY-DDVKv|lZgf42y0<>zI1X{h-CQz5FHld5xr3tNF)COAHs@KrfTQ!K=z3TUW
z&ihUhu>C&2`}6W^Gw*WVvp(n9pXV6h7*D}m;4PBtqdLAyBsUWy^=O-#F-~tkF*9DG
zkC*BNSL?T&SI^eRE;CH$R~VGjaX)|muNQJEhD>mkXL6EL7HZ1sqzA*cM}lLw>FlQW
z>}*0-v*}8DWysbqpD8&_t~5ZCP+n2##G><97X7!+Et3m}N=x!MKX!?kuQ#}NI{Nwh
zubi(l!Yr*_;F#oO4cJeez668I^qtA>P7z(El2#c^*7M8gG=rIwG^cc4)_j4FRlPNH
zghP?*FZRAV<=Tw(LuQkIn~&aotp6&~lsTalomfEIf^9~g0G6pcoRKFUvqLAu-!qkn
zGVF&F!_H1RvHHp{&dL5{Zl$Z&r)CFp%iOMjO9gutnyrFHYbJqt`M0QAv_7#}i<Y4~
z97MX^^YP8P1&0pHVckNfC!NX6$x&tof$cr#2RQp*=pINCi98~)1L-wY4U<~l3Dh>h
zKrsn2#OHpzOfDSivZUFcSl;VCsE?Kwe@Oz0@ONs)96g@4j3GL4ZYB_v7$S6{PAB~@
zHUj5b=Jo$}eH|I1yRgC!%!-~NeNJUSrUGpO8_>PPQlA9@i4s77Y-wA3pCXS|mxrs*
zVmcWz^Y<R2=>!6x#;JVCRG#Kc@-szfP3%27DXY@(lVx(@z^IS9xOu#=SA}&Ne>dv1
z8Gkx5cMas!kB_AA9;rfh{W{}yTWWLK@|8!#%uD3u43Qjbyz2eJq*UveA=OEQj%_Hb
z+M}9?G82hugGgI*@=*lJ4H81od5ta1h=_zRGeUu86qYJ5J_Hf#M=*kH5pt$mdGjlW
z9y=xSo>N_IgeX<kGt}nW>+-b`mu4v_E%OyG)U4o<jRewe&u{9@c4a+$x?(Br4TK@j
zxlh!JNzJ7LZKXcHI}-!hpH`J^PsN{eya~x@dfDA~Zd99dEH&&WyYKX;yV5bzXDoQ|
z;m@WmH(>&u0IN<&yS}gHRvG}#Pbm$38@6Zg<;PIwU-u>ag7ek#7;z_h55}T=m5Z1C
znEF6R94~Qb@AjAqb*P(S>U@0va#XeX%ciK#Kk%^5EgdOE&x)4o{Enj|2UHdgf-K0K
z3~}L@>C8;hS0bpPUA9!RSn*En>=(89Ht!O3P7dPP4xCgzo^*Vv`fHLm?smnySLasZ
zcO|xQeYH%1nEr0t6&#7Gi*qRUR+9I{lP;B-qyD-R6Z%-vxZZ*H^PhI+s~O(c^h^&+
z@J><(j%5S_B&(o=!lL!%>3(NWyYS$@AOmUfZWSI*)IMW0d750S!5uM6`TTt~XqnM!
zbw<qr6^W?D5#t%=O`fLq?-1ViKU9qC$94!z{fElA?sY4mFLZQ?jpVEm>!thkH9mcn
zCNB8f1We$$h2z$6XL_dVJ{SI&%@LQLxmZ<ol-^`)nYe+Ua$W>38362^j#~cyvv_3!
z?@vZS8ALH<<J(?ShUA&RF!tFbA-7Rs->b`Ll}-2Iqz|}C9&J9tKYS#xji;Fz6A*T4
zj0gmiZyi6)KchtM<rAl48-M@*c6h3kY{-~{NHf#b_vpW1Gb<+oU7qv=6O7UE^JVnF
zbp9iV_{3^vtUb^h{ev@wZhey%PDcxW-@S|fTUs+U^2>C2DxWbC5oS;CbBP{al~m9q
z&Orj<Rq7HWxu_~5$gmI7)Te_g&5B<hGc@MWe{sLxO;9k%-V6abx3L}{R9mSxbwmk(
zGGO#>{>f8G##ti3FP1S1mWMnMGY+XOUgx@*F2dd~iuv4|RUn^$*#dQ;D1UytBZ-}L
zx5|&NNv%?coIS)%q%S+NbdNn_Z<IcxN=BodU^1`TG8X@~nmw!v^VPx(5L)C@>fC%(
z?II@FMal<Na8Ui{&cPYE>fG4zk>ewJ&WOakU+8U*lIH;Ip@yCPdRaqJr#f#KyJm)J
zgtX+4RU*F>Bg_4(iB-;Usm)&WiaF7^I*F0*awJl<Ap_T)QMV7He!eaUsh4*JyVXNU
zF}KUJE{-ILcba3|Mc#yn>PsRr*sB`y)kPV~-LD?p9!vE+Vf{C&F-z=&Nn6DI8gHI$
zgM<LwJ-ab|ekmSFD?NpJj$1{&Dz#&-@qYcd6mHq4@;lV^8LA*(MI%(aPNn9b*rI*r
z`z0MG^_BPL-m2eRU0wOef9C#;OcozW>SH3C^)h=RAK4F=bKSR>%5;6eTiEQ<mwQUv
zK+xB1KpB+Lv?TZ7Dz}J4NgHt$6=SUcY$w?JdAV*q02XV^A^Ljuq6O7^N>>&&bd`SV
zv&<i%IpccvFRs<I?k!qbtlmEg*-BGOg0of$uj~|EzSGF$!W25ig~85}P^RYLxBYwQ
z=z?O5yXa$^j$+u_e9D6h@vzFuS8Kgldd@NDM`sM6G#$(K%pZYxdg8Y(^W?2vyGR@k
zA@6EdtPR3>5Ix{;P(6&P%vf{Rc752_U6|KE_eluB`eyj5;-Fvk;huP$Si|jfLlm_t
zwf{Bgkv1N8riUADf<cgHzn|#p2Ao#9E_Y?CGH;(LZAO;;S@MqP@gwTwj(lRv^7%FW
z)mNwkDyH7z=>e6avks1Ad#ZivLwJK^s1N0+%HT%#O`To7PBjBRuuI2$4;gmZxV=BQ
zr%Ut}(;06DP(6y!>s5z#MAQ>XkHw>%ot;o@)w^R@y`pgZe1Gt3`&2H}+cWM=zZlCU
zk<jB$;j0!aad}F!#jLpo`>ONWi|?l260%qLwDXEt>SlbE&+pK0kzryCVm?;1*jK6^
z+&QLx=<LB&kLY!=@)JAA((Hp{*<9jNnL)L_=XQ|oT3ic7qkc2NP0p-~Hx}F^buW-V
z#b$OsqSqC?vBX0ZRXOs0)Va*E2G5A;pE$1-oNQb|H0b?biJ#vM&rN7k4X!(jW1bKa
zCQ2FI#uT*o?ws-zR(dM4J0WVQsl=9>DSYo#ra8d_+w`LEcQ(p=J_)mdzJaV35f#l>
z=jCI?XOkV-?JddPtHxQNH+RO=-A?gWP2$?<!tlh&Pq`yo=N@-1nsK;YG9&cpPY*~D
zRAJ7mFMZft8b;N)45UnoXifv||I7p29wWyGmbB@4Wg9Iv#;P#I@S(>4z-iU4UfF5f
z=0PRu%T7!MN2L9e+OS(zLE|Zr;%*<pvDZX#GKT3XdnDz{H&6<q8=9qhFbKg+eeJNS
z8IJ$qH@_#*$@t+ZEvFoyTHI`<E$3Qmh$$!J#>Cb-&lpsS*hk1Mbgt+PlZa~|5Fl-8
zZU4l?q^OUL>Vx_PsX^tA9nx#NtX8E>(~GH18W-ZJ4^l`9M?tsz@qF^w<fo>PvqUJy
zIr-uw1M-zZc9mph=&=@4`iOe+-z{Awp~X@xDIkCLD!0y<TFQ78n99uiyY%%Xs=^Bp
zUDN|YD-8(O41Jo7F!1Q^p!Su-Pw7VO3&f-9QuJj@4XYx~zNSsnAA8aEXm{(z4P`3d
zgl5u-0D;n`vS%e0@v$V`zw$A>_=05kz;mO7^gx6USKm+2vefkw>@Os0Y0~4n29`RP
z%~aoDo#h2+51lVQ#N+CRNnUkwr;}W1QvF`#=_w7|h4;9rKs^qQG#`93$@zsO;)l%I
z4W`8Rs-J?!CVKRNh&9Z=D;(i-dhcJdbxr8*?Yi%$eNjD9x3X~YvRt6YQ?}RT{KzGJ
zp0G#EVs;eyzGPugetnCmwD%|HI2T^hj^G(1);Fl`yrm-=Z*`r>y*c&xwW)yA%y@b{
zyDggT>U(bHkSq6R1xK^1nmnEj>Zhb5$t=;)aOnWfA+7BN;ub9rn&<WPxpx=R#0xu+
z1Zm`9h3;|wOkzATy9m>Yq^ivE`IX@-7hlOxo!a<VJz09fH*mNsek8qD4LiK4`pwio
zirpM%%E82Mgpggx-d~bqxU=V|KP7wR0j+cC%t;#33nS|9+k+kzn-){I-jY)yuWp^j
ztGM2r<oZ$S9}CofY>!0M<I^(K6Wgik@o70r4$o8H-!AbjN2htYBCK3J%J<*Hz{aod
zjnqG003$J$sxBNq70q@Q5Ltp0Pk7eF<EmbqHph}&M&vnXp|I!G?}`2s0?rxo!lWTT
zp-G!ig#GjEJh~O*wdcpbPEtD93L~CX)DseFh=eIXk_vN^K;889tPc&TNT^RlP?^l>
zmbe7<Pq5Q)_ND?fEVhTAXkhrRuEw7z&s|M<UBcIey9w&Tb%N+vmkinZd_wbLp4+B0
zu7z@0K7`zez_fPSa=CCQgxVQ`cx;wO^aeIQlB=H_@W2uRlLP0WdbvL?j80Og{Bc)(
zLuk>Q{L}K&<Ru`=kPx&oJ|b8Oh&qQU-R4yrBWl*D$K@jkVNJ0rjqIP7b#Ud)swU>?
za%UkEmrAa;3%ru<YFqxN)$<obW^9%QzED+&N@sLy@bK!Yu+F;en<@jcm!E&5`sna?
z_Y>F>{K<(pu_Xp8Vb_PFSC#paT4Q-Xdix$#11nDi<4oA0n|sQt)Vcjb_vkVUKj){k
zS9ie+jYCXFJ@;keA>L#u1_p5!>oA^i8LG5jeI#F%_Nb5K;A(;=tv~gR?tQ&o^D;lR
z1htf~Q;p*1{MBva1`XLBXe(sqB=ye4mPJc0tG(*NoX&#y^|$qip}8rivj}^(@WDxo
z?c!xF-$K<S_M&^6V@D6Xj?1jugQBJA9#5uf89Z95wglC`ks0VHA^AgSY5L<~S7+&c
zc<YU77v}HjFD=$r4gBhjQ_hd3^52kDj=y5Q#Fsar4ax7;uI@)%e1+fGP^-(Rns7&a
zV3o&Hpz2YaFcbpE2EtgytDPT7b!Mivw^PU7TXe@zG~S!-S?J2FKdGKfj_4XUq38MW
zTMK;I*1G>Z*{p;SZC8TO`{JjF#qXhK=ME2Ks-`hK9*>rK)ZS>1x?pTX-?+-<UW#^U
zVB`VtL|R*AE_$F=Rg$5u$x$UaYF>uNs`yjGDIy&^b&o~tjCtm`4DPS;N1|zxRxMN)
z_8bpKGvg}-kUq@PpRaSCu3sZB#R2e1><)5Cd~mJXT}^<>`N3YukgM9Ki$)%CAxR9W
z`8w^nww2446c9((s#f+K(rpCO4|+V}LYbtVK({0p$FN-mTchpT5JEz;_i2y1VAOMO
z?vmVWU)idqAw4Vphzo}PT%FTaSuo&s?fp#{abd>jJ`$vD!mJt#Rk@=DZ8sIbzMFoD
zYS3wDcZ#9VBjmt)!eMwiBV5Ryb3XEU@<{~`9&60a^t5&ESyk93GQllx>#BmX4L30u
zsVZ8gQybLQpsrq0a0;8{h})CtDJnM8#IBQijIUs8wfci&P|rAqy6lHL#Ya;;;Ux7_
zgjmo>7Aa}6qggLXy0>#X=yYUkBfD`wdGoIR{B2Li+n>-gN?U|CJE!C0(LE|O*tA4q
zEP&ASgEy)cvUqvb)=~9-uUeO{zFIrhyvo&-*%^u#eJZm)nw^<_g68@OLGRjpNIYw;
zmEIO)X1avY^^dAKIp0ImcEmWxKc5uwaC3N<sNIew#Xe1j7Ilt+H+=PF)L5#`PgFQ0
z?yPrFvtGE6nTKKX&|t3;RoBmWes+oWUa>mYgV;L!xOrjn(ZNtP7>zCL&^_d(0ln?1
zUeY!%i)u)YB9*16O;)>?Nu|VrzSl!%ieNLRNJ0XLZ>pPP>dFk|3l^oTtMVDt_XA>y
zzVFf;u74HC;rjEJ#uli{Eym_%ix0Xi<7TNq)mWq4YW40y5S;KNCpKrSSyiZSz*R=g
z&rtq;ceJy8q`kLSW($W|r}~x>u4QCLew^)EeRsUpC5*;Hs^^qC59h=*kfSI9wvVBb
zQ4JaP-*X4!s(73#`Syt&qpo$f$^I@Siq&84AcUVF2JsoVPYu5#9sH5$WvU4Q8QQ^*
zX<8m`P=CExkEXfq=yY8U(v8e`dSDmacPc23x_(rrGtyk0oyR)6kZCFL*!ID++|I79
zy&lOM_Y_i%kr?7BGIFP&YTE<1waMr99qpBWq_HGS@8)t}Z*SLWfhgxu`D3nD$yK5J
z*|0^m<cod*xbv1CFMTH66=2eD|By~=T2i2|jHa6p4olg)CcZNJZ`bzTzRo_?kYmTk
zr*;essMj{@>6zJvx1KM>b*}tfEq@B+k5PE&4{zyam=ClJ>(DcuZ3P4Ic)jN~J)<#q
zOW7d|<HN6SU787k%<g{OL&QtIr_i(7v%G#yR@0K}*hKM6wSN~lZ8T}z_s!?j?WAfv
zNmvZgWMgkt6%n`{-AjOqx3LS2QDfWwXQBZQsCCfioO>}JcC0E~@zsI=_$eE)9_3D{
zSP(wz^j5h&)#^9oT8rwh6DW*~`TmaF#(};irsIf^{V6U(qOyECwDRVSQG@E82W43I
zmA;5?@*tN<WD~;0l@Cc;sxwZw<32#SM2s^Zk8pL9Y}${D+WaN~!jD@rgKU^-Sk*2Y
zJ2s#mM89)E<Vh9jAYQvvXWn13r0tdmr0$ds!C1+oDL34$BIEa&X=WQe&O@h}?l2iy
z2grjV%|AwTohNWiyA0*97G9^DYVuRaoYQ}#&HY94*WuI6WbRKMpXo`j(TjEK!S648
znQI^-ZDnb+B6mqv6@RY5W-zqp(o;_YfibF{d55I-Y0Q7Ez?1FC%pGvYExJ&ra~_R{
zCAv}_cf{cS2Rq}Pdx%~=h02jcJY;_Xz)sB?pXqvfWhw0ZSEK>{T)%Ydg5o1_)m1yJ
z!MZse&08h0=>v-keGiqU1J|29faGqEzT&3bBhD)>EhCDFj?Xrf`h|0YOzHhK<MeJU
zRVMo0n*6L0=XDqJ;8&@Uvh29eqa;1USnqL`y(8X-TI~Fu)uovvc@3U||7jY0jRpBy
zO>Cbc9%;Vk1eH8U5XEbqdM}mipAmT}-m42Gl(HpqXZ>vy{#K3T)#^yqk^KWlxc_C1
z7|)(pda$e3bIKiEICt}I=an-tv&2ahg}o?(jGb|fdSSZG*aMc)GvXdkb3DGYU=0SO
zPiDG&xvDCN)zzibT|Y$LBiCoQx@Z)wrp`pW=W4+j?}FhavWSz6lE?QcJy#O_?W-Bo
zvsY%97H;VzL((6nqlw+?({7(OkfN+)qba}QYbBtg)V^Aa-fC}({>YI2z53O3G$ZC4
zmcgsunV!!tnNX)=h$8VK>fHmi;{)oGgO9ClGmzv>sWHDDDRtyYM3<Mj4C*MqOb5o2
zN87ujK2-S1*P}k#qbeitINiRzTNZlM_CbBh4WpG)rBh1<s=h+dvVI$5Vo*O<w32|7
zpen){Z+=Xz$yf9HokcUML}8~=d*Vf&l1><;tdq$4F_U3nxlVJtnisd%xdOdW^QJyu
zrS*@%)0}M6rRoMfeaKVdj(f5@@rCU3+!y!#1wLpHD7dlza9k~pxiguOznsrVe{Y*8
zRYgSa5thw6P@tPaq*<;VuO0x5yc&J)o7>PaN;2b!Wgka55z$>yTqxB~(es{1?D4!*
zy>zeoJQ-}>cz?dSXDhtkaHe|Z{bOOzBfhe-lH*L$JymF<vz8b>2S)K2+YV~p;rZ2L
zx;hghoyq5We*c#|C1kMO-~N<9k~c#w$xs`}oqXlEr`0q6Ie3igQH>6}+@2x0$`9#?
z+g0L0O!j_B+=YLvP#HaeERQ)TLYm|Jmj!r9&*oIerU|d}@7wcBNsJ>!rv;0P8upz8
zI%Q#d31Uk@F>$v(F|tPmbk2+Is71%27(sPq&&f8Id!$<*&m=Z3<CJ>;cuAF*4GK|H
z=u))R*=T#~4Kp>kU3UFF7c;we(B7+c`JJ~?!k4V174_wdgMD$-b>k%DfpqNyDP0gG
zhiDD)(YVGEShHD^%Jzc%AFrYG_v<pS@_Hk#c$cdaHe4@H&%71xw8eXp&|mh9VT#3O
zYVkofKVr~j_WYCS>O+=#@Fo`T+)?p>{WP$`-ySmR#HkTkMYK~%dL@5Fcq!FuJ$qqv
zGd@)Sz%=UVrSWV%;|=+v{2l7Qo!E1MO!gq0-ZyrSJ|zt9^NtLirBC>LLlTv*zL!J>
z)(SBn|A~ys<WU1M^(D=7U2fIbp)Sr~EmaMnq1~l$@9G;nC8+0Fa%+8UXHY%o>`<lo
zCrIUb^dR{t78O;!riMwi^<$^=x}@W6>Zx5ZNg|LBmhgN{x0H~-7){d*VzkJVl%f6x
zdHlvMNftES^bwJc?LwZlIm{JF?|jw2ktETl3DZ0&-MXX1Q@uL(Hce`ctiDs|-TF@X
zPCMt#R*@Wo#mK%LJlRG@keKR}z>ZgT^;fCANs_Q*AGYYFa|>TO*y%2vSAd10gm}4d
ztgH8n>f+H%HF(~r9%<UzTUrL4#}cvvDfS~eGNNC^^^Itp8!(Vid%i9_eW0_I&h(Aw
zbdRq!lbjzuEe>kpi-y(J-G{J+9zI8(vH~I`uln}!k#vt*F^nmS2<I{3`0lCG`Sa&m
za_(@-kJzxIBL%B+^;Iwu)v95X$WgbR?`vbpJ3NngeA`?s|BT>^Y9nbH(DTh5hY?ZH
zpxJk;f*$Sb^XOX{=yy_jH2Dq-^u4PN;I8-4B>gkc44m7sc(tBU(0KSJW5|L$dkA1Z
zPJnBp7P*F$zgAklrE>EFNn_Z@9#&<;>Z72^p!%rr3h&%9SV|+GNtQf9r*FwO*T@$r
zmNHe@n3|FQ{pISv(KCISop@th)r_kdF;$a+fS-X0vG=69B-lNqg0X6K2~lI}&ZJ-=
zXfZQ-->IR_;~FGp6dC;&$)sPPBLmvAkzWjJfH9aqHGc^5_fE(JA$QH{FgFrZ+%*dk
z`qGX}fgqjA<6m24_RShJH&SLFWd`&NEmF!G*6Vvr6>o%uUfv^B6pxOO51RsSSp^Qv
z!U2IBDR6)SFWTRaS+DP%HO%WV^ZH(1|CGDetXE%{)o*U(%P*KOrCa}Lz3iFQV{YVS
z4=<0KKL5gc**8mE8Gd0Z?K3Z>$FGJY4*8II_i9MSbBK55g_(^*vxIwlH8g6y=@~KO
zeA#^UfEmThArtHO08w(3OuW%{$(KyYFPr*bGWCDis{bXcS6?>uzhvs?P0z^d8;(=W
z3G>;5=Cc!~%MV(gov=Q8(0rCCrDfQ>5iLfadGibNJ;RhYOn|)UF>n6UykT~%sWNZw
zHE+hu8|GWyuoCjk7tEX2%p0a#-mnnz=74$gmU+Vx${Q9}-rQr}ykXw3`trtxi+$$J
zugzcq8+ijj$v0i*%{%4|K-Z%xNQl)|>S=X-M=ilk$t!9$GKn^MI}RNvy*GE`qGiZC
zWow*QUt)IIxvY}8_+kh;XRc1l<Z<OxUzBRi)yY`^q5aG%=Ts+WMfT8<Cqj`{%KmUx
zaDcmKLXk(fdt{c*xT`eagSsvFdgm{FWH5Zj;r+XhpcK_O26HRP>A<Di``g+ER9^m3
z{{A))(@Ph>-UL&2IZ~p!phJY5r_tnh=r-~W9m65ZmF`3J(7#&%^#zBQ>xYP}k!#{h
zJM=f>?s#up&((dsC$|<ZzF((zo={$?EJH^QfWnn0XxAW)T`xEWQ3g)eA5vGd*Q)Z#
zr;kCEIQoY>RmX0U-1zLm;=y%xbH7D{)<jgU<jr~8F$&(w(CfYuj!PhJhKeN(I?HG5
z<CF@}_wOC!PIu~)uKRc=wu%3A5Y(eo-=)rQ(##fS?S<;GV{AF44$juH*?wL<YHl*j
zweD!;?iG@jUlc48GmH8qp@YvuyKauVqkV4msSfeGl80lvf;T>mE9Ks3;8|VmA*O0v
z{ZZ1jkXvBz6VRrOzR&j+R7Qt7^^IR5eaqNDyPlO^m8s_xmSED?H~dvq_Y{`YfBkgf
zlP&Efz3SF&gM^!s=)5`qt0(V-Q6W>->7mZ`z=9H<R+Y$~BKh-U`6I?TB{H+cJBuW!
zGO;mRijt0$XKhz~5@eCEEk(EAH>3;V5W%Jz+%r00PFjwLDIp6Nxi(Z}g|QcfwfiJ^
zuAuu=Tt|mWwJ$xo{nTwF{?(^PSf|L`=5HL<Bk9pCEHL#DONsmFmZ810okS28KTfeB
z7GVe~`by!VmS&xq9<A2#^r)J_78%o36bJW{)dk~&`YX9vh;3fjGjd95Fg<_8)V0lM
zYz##*iqdX*YOd1De3BwFO&^`tr0(Syju_JEW&I=S<NbgLNqlMRdB^xuL)c&~@^&F7
zho~EgRq(y0eK%*XE?feyKW>`&wWH_Fp@2FZ2BPHP6Uj!iW>?E!LV8BYUEhpqVuzm|
z%HCdID_JOBwH1u&kmQOW^gV}ks^@iZ=!qq?z}|hABuFn}sLVK|E*~TXj3x~vV!pAc
zpAgDwSyY2552>u-&SOKk(~k*Hi6Z<s$()aD9XRUS<6JVsqx-(NL_Lqk+;zIA`PlJR
z{i&#&m(hcs9QKC14QXnQ9(>A^UC`=remoUPpo}cDI(ou5{SCFn-2-IH$VLH_#~y?I
z7{{|d2OCsAdPqDbejoP5vwd(wL}ZQP$QkSG92!#P<Ige#;q&%8V+fWkQ|B(((<IX!
z;NS<a199xPB@L6+4bJUlM+|nPd!G8>FlM$vA={lzH>t-t7vNe1WrXGY2l#zL&tIp0
zhw!fMh>og10^t{S_`(bD;^`6#>id~>l*!mB3I^!U8<CD^cJ2!*24hyG8s*fNwg+Ay
z6*O#qWJtZ!2*<u6uQ{);tW?b>Rhw7M?~sITy1nnFrX{6^LWhqoX>(>@g0LTHxp(zO
z^(DsrGl$m~a_g(_Red=AoOFzr?S9mmHS@9JqF0L5X;S&@#ePZb6?$S77H~-&mfJ-|
zsw{Yj>>*&S>21!;+0CVh==zYPPr{`%-<dhX(_6)nBi_EURmeyhR{3v;<L8Z^>{5RY
z_o&<OO8ztW_s;XZt6d)T2a^AIV(Mz9G~3tOMIg@x5ZGJ0ASTVE{9}g%kGFd8-XQIf
zUekNH{UKjKdq#5a&F$WhMf$khV|;RcP`^00`OPT8@5qQq$w&3Ec}=`dkJgdHE{%1+
zGHFRyNI-Tvx8iW}A}jR=j;;BvBXTg_&gH23@&!cu>kyGY>fgd}j;GtmvrNZyb-~u=
ztN}?JKoT<e;WV_`!>yib&#`&A-_!?(p7b4Bw7E)*h07M{s~+5FObYrxexzs2%Uy8n
zc)BY~{dybgu@u|57>~~P_O{VEQQIZG#7R9mUg8SibQ!$Y-EF7=-c#odLJVNvoO5T~
z-0XI7q|b;di=9A0!xnoenca2^Zdu9RM?oN&x;NYB?o|D^I9DWD$<}doSC@D6dZ;c<
zEz>zi)dzZTg~feOE$Uaxdeonq+2FZon&JFklOJi*N>tpltl{=0rSpz;60SH10vz;9
zM^iHRi;Keoen4r$%U>XwYNFA@NA*=aOx7r8<QMz1*9eWtsyi7CntArt#Ipkv&;IKc
zqbmdHS--c6cw$N)NRHXxy)BHjdA5JzyWiY`*4aGkOh#8{u6}ci;M!!j{h})wjqlVK
zM7xU~FInwLGQVND5%xbB&tdtA%bz<Yu6D|mC{U6`XO=9qBw5TAQ?BllTj~|XcXGS@
z5rt3kLHQ$sY_e$bl06~q8)=PJ^+HBFrp0cG$4{t(9~_JhEou6co_{=hpffwJUaA~Z
zhd&sM52)uVV<G*(2+z(9hHoy;jz7Gp<@m`VJe`8uD@J--yB4ZPmGgQ6!bl0OW&_xE
zc75rE!f>|;5pzzu$I|)qr0BQrvm79lA`DcN^J<U$xlR74BGDiyl`eCq)Ov5b&Wz)@
zcHo&^`$%oBN@HR5ngg7-Hs{5H<Laaa{4W~R?O2Msng@LdQ}6G%^J#&}Yg~pNsYiAU
z4>*@y%<&`Cm~>mznV!1Zr!x)NLa;-LMN0UqF98o8*kFnn!JouNDe8X3hL_Y5oV9dL
zPB{s=b1*8fGsoLEw3F}u$4TtYthh)0DoOXeKA?Vj&R{Dpbo#P_2h~WEpyNAsj`e-H
zL>3Z<inNrY@qkAQJ7BD6K9ZM!S|ojNtWeL##oD#yL_FK|ihAl&X7Ul7I)89!f4nXJ
zoi_FDfR12t^mRd7^1-rcp8Gum>NDrbY<H=zH=z!qTBo`nN2UlWroT8i)yR<(hh)Xn
zV;|J{ZR$AnJ$PyV(YS7GQ!fMteXSnf(U(Ws;;=~qZ%L0!4f>?{o4qmK8h!kAd5jMc
zKgmV~m`r2tadjeTu<b<Ko)XR^(Sz_Ozy`L@0fG|k8B7^cCw3Xl_5e)By|?J;CBAUn
z>;w`5P7}iJ#8zl5GvcG9eu(;$8U53261y3<J#~L2b8s>LzlzJWdTv)o6s>KnwOxD^
z>vexO2B$PR39Z)j9rc>jNmQKt$b>t;@+s~P{+`PuCTtLnn=CssmK2n#)q|3D0>{1%
zvEQ5!&gY&Tti;wqG}=AtC9QjW`%uBci>V)>U);3Expt<gmDiru1-jc=e2H$mz41u4
zZ%Gr(*A|?&j=J`NTG94p#r3ff^|PI%C~0zj^dg+f#<As%=^di}EmNJ1AShkh&RJ!^
z)qr}2)%lvFT_pA)&7)u2==+SS)%mB=qw_y6&hw{*S^W&O9DC65^k^^WzekP8p=!E`
z>_UHwn86zztutkfj5<&LER#XoPXTNq1UMNj8JgL$OE1_OE<J4XpQc!W{Jly3l&X2b
zpB#z5j{B)97*CHbfZXZh58qB;!cAT3gQVRf)=>7Rg?f`x{v_8pir1>|I(6E{MJ+$x
zNPOy+n~tgr`qc+Xdx`F{LpYC3qA_U7*ZcLH!>bF96^gQIEAb>fu!O{}e^LjRe<CYh
zit#85#V*NNoFAL@Yu{Jnao=qtPkMZ9UAny;{V<JvWg8O*W_T&ZOIA(MdOWv{EV?`y
zO3^*8z0S3%J~bzHSdHz_Wa-_{8EgMz65;%{WkP$X+TIu3eMEO-qJ}D8qssc#ttby~
z-PNz!oa0?L9o6j|!KSi;a<s$owvE4+lr}5JC;*V$<s2tjP${8Jr7nyD+xx{rd(Q9(
z$IM~V;IICg&T116=u(LKWjgqKD7u&!9|pw8@_9+&hMRXSmx&vYKklkm)L$LJ0z{i{
zHcPQ*jYTL~ybr&wUc<8FF`^9qTyhS__gVmm*-~!ceLWue>dP&1_v-s(xA9euNs#J9
z1_Md{W!Jd70F~|?Nursw^Q9)^qx*MiGd4P*>VIJ`U{1sn&|8IfEP1Pq;j~J+*SaO!
za~Sr6h?8dTY0tJ|NWQuzqDs6~FRH5}xbIex7Ea~lt2}R$#Coja!KI_>vV8pF$StR?
zizp9|Qn5zola_ItRBE8lUFHcBU8F)ria?3o?NO<mAmvr%J!*agrg20yjA6lN7T5EC
zI^onj`eX-Y9xo@$jj3PIXIRB5*nASUMntq<$LuVMsMX%8yH!>MZ|5oz1%F6EoXHUY
zKRBp9#_4Nv$!5Pcq6(zsyof5MWKD-!8o>#Nml=a(M^TM9!ieWv1nsOmB@5P1x#>^b
zkeVIN)f)m<e&`s(QGnk6Ld}Zc>HeU)G@^oDwXI*x!4@xHUpA<|xZ5(j8pJ330B(mZ
zqX-|DbQW^FpQw-?nguqH<1Zr7u(&Fy=No#|zj5JqS=xSY%FP?%qN`41QR>u&&}rN@
z#?=E6Sns8)eA%zhD^;HuN4fE{yVZHaWj`py=U9#2GNxV^uQXW&<__Jma1cg2`h7=F
z=i?gF2d;Oa&iHLWM&}R?hq2c?_g1Mt?;_96UPNm043^FH997o`QJVhuwqbQ=3NAo@
z*p|aZezpDpPWD{~)%|#_Ap8HEB{>M_{2ashdHwpR+Q*qRzn0jj?sK3`@9?_o9C*s~
zxEkmBE{cv*6f*&_k9VHa^Y^&=R+Aigv6ORuVjA2+&0|u0YRw-Ga+E~BdOfMb$cHFS
zSLc#!3Ka&ZMdGsjK}@&?Z>jV#==Ahq<mXW9!_WDijGhWFRd;YyqWU8lR@Lq2(XBsY
zaJvou^Uo-*&lyt>-_oIemW(9)B|QIr2A}&l-g==PHG2>RQrTiy=rP^<xbeF2qT*K1
z?ue-e)G(+TS><u%-5b~0@zOhW8I4}87IdhOjFYT57C*%1-QOVQl<$cCbXGrygS26o
zdeTAuED#MgQA)gC6Qjg;Q=zj9W?!>V-PM9fOHz&+Z4qYzM;{<#=`R$Z(uaTiFH{b{
zL4NbqJFw4PGOYiSVeMmBzh+qbBEoJWFOG@B?gs~*SI+kB)pO8IeJwtO6w;&NLAD$R
zCFl;k77_pVQSXD(dJ5DijzJGj%U36$DFb*a{)C-4Fs<W|j-#n2X)Kluj?_4`XxaZ5
z<@SJjDkY-sC2HUIq$kesF6f8@7RPRX7Q^M;YU~!Tx;Ht(Z@)9+10tEubKWrHWb0Br
zD>+4d9<4Yde^XLgrl`B?WOKZAagSd3xo8{4*D|<)4i^*jRD(gT7s_Nk*C3u0N6q#3
z8)V`hxlpG)^}Bc{FTdA7)>6#Snwh#gS=hQa>A>B|8TM}uzw#zu0w{u<mkQO^hdz5k
zeG3p(#{_EsU7+@9AoZI->eEd*Eiajwd~+AL_EpE|N%i(l44scab3P3Z_IbQSJCY)8
z>O^x)J)1%qEC+PtSgm-xeP?>4_dd_bo#X>n@muhr&ZtuR&((tuLD%0QAf*eZnRlW&
zThzC~)!6sn7XkclEiLU*8N)Ar?G*LAQqwQW#V@A@$zNIZwX$#PIq^8Up1xi&DqaTh
zB!{gR;8RC9ZS;8n<H!yoRTv}Az+dP8KRZO1{%lQ#Xe`H4`+xMExXuI)aLE%*omU0N
zjXFo|+0N4bEol^&Q=$)go>eu2q_c>XZ7ADacI@8L_Sb#b6^B}HS62+Hj-6v>TVaJn
z<*(YKC=gpz_jJ(OuWLK*tBUKb>RB=uNEQj7FWulD=e(K58x8AQfsSupzZHK+G>8%P
z#q+&lKYjz5{2nwvZ-jHItFAY5UN?p|*IZ$;y|_c&FvdYP2kE>#yUm#)e4vEe6zCE4
zgYzT$a-aGxwLDHO-wj(EAdHQRozgC>=f}v7_;aK9v20zYX0d}|r;8xJT!QTbL)o3}
z%Mi}mmZFCWqP*}*E`IS?0Pgc)ghn6ej%Ii6TeK`Na<DgC_-XWab#Uz?dd*`Eo3rBT
z12N&~glTz*o%3G~G5nuM4oY?ldBo(tjuND(GLB5KJ>qX%6mM^d@5YFqO%kRY%#=A{
zE+RFk7()0;@b&km^{9QQweR2QRYSrX^qw1ArrySTdH=bHO84)KsGq~y9OU)Sof-W0
z@SDSL2fr~;@cD!KNuSz}9^`FY4fcm~_!Z6c=b5ZuMXB%^XZ{`?bw}gwPMj0sus9!?
zrAdoDA6-WudgwV%`u29;tuxU{i&{EWJq0Q%VmD8JRL37>T(5-DNxe3rT4KFz^!VRW
zjBC@I+Xip${5kir^T*m;pyd11{X6=d=`&&T)FBK-(d@Vmbn7-e$h&lO_b=7!+eVp`
z+i_SA7Tnb4j$*Z|JuZN<nN+elsC%Y&;h9Ae+2(<&_M78@0X?(T=Pni3%`2cWxl0PF
zano-t>{a*e%D}lkUmZ{4Od;2XPp^s(#MSRXbe}`RbZS?u^i>f$EXTLK_)V!l;eD?q
zZ_0fwI{ze{e&T(&JaqlGp!BAKKNJ_C2mYU39Vh8H>Y?Hw=&ECf_>_DxS>(gxFab}>
zJZu|2#lyF!4XcZ>*ruzW64Dm(LQ$vd?Vs089KKmVa-?B+D|Ll<=`SV<*r$4SviG`^
z`gJuu-OxGIiAd+g$<&K}uR}aFtMQ<4WsU4<j}OJg{pU*@a-`Z>@IBan7mlhtF&t#H
zMsMm<KYJf_{W3bN4xBsA(tBm;f4oI|bJa^NdK?>ne~m7zK3u?Au|sP1cxqGA^$Uu#
zR=buu*Qau}WU9^_;lGmwxT3;vcPBYNO}<}F&&wCjVTlOT_)yEf8%*iikE;{T74|lK
zohU4hfxa@89a`hex}<HNxEbSYOu#cD!t9Q&H+5h92RG}^-=R6~I6AMOrm0uq`!FN&
zFw&b*$$@N_k&L*9G&!sZ<SB#08$5>vU_M|`_s{M&5+!=7=`TG`fJ?VgXsIROo+`9~
ziw8Li5aAJBI*@xmM&AzHWd@;fm?1dAIfo;db8e}TtOX>-O!b0AmgM?ew2yfdBeqwQ
zu3{mkZ7r+&3UL`(^KzG*&TU*8-^Gb{Jv*{Jq0@Dq_Qjsor}V~+g%Uu$X}EATJ`NzO
z5pl^}96N-yAGP0-T%?`(w>_-tP_vUe{w2p)n#)CQrf6H)>NX#;vKrno`hjSP_=Il4
z<seq4A6l5FZz##sGxbv3QSiY-q=H?`FIk{mqmTf4$f-dn%{<O)W{8&wYUddoiAMfc
z8uf6%8AfxL$7I()7C*=N%PW>S<e$3#QqG!*z_JgMga;3cEzpG{ThN(d#_ZvYu^cq`
zV!-@asDo$E&*(qGP5%~9nNnYxm5<azrrFMbt66NJ-wnx!j~k=ocS9LmKQT*pRP*Lk
zsOL#;J7)EV#5(z3q2QCMGRBj^Svu#SzLIB$IRr<kpBl?=KSnq#J+p$?LVC!O2I82e
z214R?dVH2xNxy<gQ?A7@bT?K}rQVs<QKM2hfJY3=UkpL<m3n&?$(x;5UF^zkU8@7G
z?CO_!cY6ral2U(z-9DlJZeHPjQLQc%i}GvL(upr%VuBUr)D=ynV(1&%_sgY=>&$EU
zv}ZQFj!rFDraOzYFmpeymd9U1OTo>v_Du!{^-NQbSIfM8Z??R7v>II@vz7rS(}M#g
zcun86Gxk*PkzaLf15KQ&kwJehRXl9QYw}Bvt~NIPRByUx!CPwu0DYpxb9TueF*jM6
zg6|9Uis|gno8{}<W)5Qs6#M%#W)W|nnUif^N(XNz(Fnd(l{xA|8LBEr>Pbq;NvS?n
zEm}G`TIF2C0?Q>GM}&u~^<m@9D89Exq;M5VkjY1ncOIka-)zqKJ9WQ>_sCqG|H`jK
zlox#j+M^6Bhu<60Rm8lFy?uz&__SQwKebfOS*7AgTNIie)DM>tMkQ$+Q0*<9TPhkR
zr#U{;X_90+@7vgi2PQseNyE<R#6RAh;vg92-vI0X>sUzQ6RmTgO=QbNWD4;ii2xKL
z5htVU6QM6Aip35r;aXxzo_OAlC3)1DgeR=_{pz6JVqXZN3F>>;?q60{2i0XcY7@A~
zxi(2n_g3AEB2;A&FNELuVXRYTat!H0+E3*WPq<o%A3F~#GdZ3by%LQ=a^4;e^Tpc(
zHZLFf->WaV*;7!!X^-tV6xWIK`TK)NwJUYU1G0$fl2Idks*-;7t&|KE2O|$~N}5--
zO+zs1L_&JNnKRGl3mnPSZV%#suu^19zCu)oNk%oN4T^Ra$rERa`rb~{S9MC6x9W4S
zruV)N)I3MMjE9P(&3Mhx?^An{bp#QMCs)TXv~&_or*XP1g+$^#W4V*-@yS-C)+Fa#
z(~2m^oGH2Lh3&B;>WkB0;Lj2I;M6i0r+V-f^Bo+RXh)K`hedzMIi^nU#A>lTy%={g
zkzUep^ug~aqZ`ah_qN2k<si=t^*LtZ6yZ6aL$!<L;cBCSh0T}BtRY*SF$v#ohwEI>
zSPXu(n^|Y(9^1jdNP?k$0EfQKtFK#J)ux;0dUBtU9wMJTtZ%`IDX_E)x~I#GUeh}D
z#%jTN-SiaawKF=M*AnV~uGmAE^pDEmlf>TXv?e0Sxfm7e>(GI2_1X^ShNLc%4GonX
zH};-nQ9~vFPX4&mw@m;ApkoGMsz9TJ5HTD_cHQoER;NN_#L-!lFi3&t=6vCXdvjOo
zzIiU!2@U`mHd^15r}ZLr9Wg{io2EIhpY?H3NG57EQ{%kKtPqE>&L$9>8T|sfwQjN6
z%1Pt9TGUSwA0AA}Q6~sf_$t4nXc)el64{_$+~#$D>|%8U{ogs3O;-Rb*_kO7PBR^!
zmZC<?d0W$*3oe$Y>QSTApH^{?UPf3?0F^b5g-ub{qd6xCL(i|kD(x9kpMgK`#%Gbv
zyuNF^P4#g!cJGc+)up^Q0Y1cE$M(s$2XOGSP|+Z_&J;1nSeW?9i7Uxo-qXz)f_k)@
z%q-og3A;I~fEYr!w?8vAm}zm!L{BEuotU4ASx0@*t$t1MeH8yMDc((Sm)EjuJjYZq
zfWBMVelal%@x6h!iSM7@1%&-EWssvUhc`<Bu@0*>W3^Uc1N>$&n1*f6bxCSozXf2{
z;@A*&J)jeC-k8McHO{;lZXXF)L^C+Cxvl2JT!S`iHe$70sbjmuf$Yhh=$xgn`bx?;
zinK9x`;HFvC*?&QmngZ7O?QkppV<MIcbZqP?izJ|>;m-!BFYnpF5lgWSoAou3%LM%
z1VJO~Ai$hXGGk6+JB_OjCG7HDqQW1if^$dP+SIKybSnb**Db|QifnOC0kVKZZUB;J
zOrG;;>T4EssAsncdYDGsKR-$8k!eN`ib}*f<XwG1d<r6BYyScU`9@2MJiOB~K>T`_
znSJ%36S?(!4(Sm`DCeu!5r;gw%P?K1LH16^XWx@Foe`(`&j(>TS~xX^Y$;ZR<ykTL
z6M>Br^vPr&nG9?+v5aro^k*(-7x>ENqVVmvFU}WbMJuNO=BgPPuN`!W;`IH4F6QSX
zhjQS+l_YxU-|wRQ$mOrDJw&dDVGi@~kr(yPX|AEmO|Gx?X5d%9+rTH2Ad_{?8iDkv
z;cdG|q!q(fPjp>#{z;sBu~#>AkUZa+1bJ5s#p%GT`W~b{5!gBz>iW-5>eN_SqCe$~
z^F;3E1i3dkzi2!`?YTU2lHV=G%arg`!w5{Kd6}B-U?Qg+WfDiWb2%lNmAf;Off+s`
zF>7x+k<2oT;c`sf385wzlllct6n*gWZ?iW(ue|OPdat`o?0sY$O=)`WQ90B(A3gCO
z%WHL<gwoZ=<5fuJqLZJly?yg?Yk8=y3aX8=@Pw4J@SMpK!~Gn^-fMcGL=QN#XH>7Q
z_P9^#kKUt2RQ?Hwi*kE#WajQKCjM*>c#M=Laip&xinEyd)~><dwgF+BJ4vD6nbThO
zQnL@2f%r?Rw#S!!96b=xIziA#zwh?kO3FRItH*>t_ZjH=!n;A2S;ha|qQ6`Ai;3l(
zvg*Jf4J7ivQ6h0!yU8Rnub^KJ$41uc|LqvSe_0=i$UZB<U05=VPi!u`S0>u}|9d!z
zcx-w<Wn}N2!)_wL+WLS|p%LKv-FROjxF>?GDI)MYbKWw!_{Z$$zxd5^>jfg$oC9zA
zfGGThfPn{g_vkssu|m=s=*U5&kcrgii6r6H`9rrRiL(7xoQuvKMjNH(dhsJ7y)&rA
z;uM7<suVFlLraBHC?YG)30_BI*A3fA#E%_0yMg<tG|_-)tZAUyRACrii|v)f7#6wM
zU{Q;?_MNb7NouaB1m{Ig6`YYU?`28y&H0w({+^mgkH?JIsp2H#HSNSqehyO6m>%ou
z_LJ21631Lv`GF;^un;^aeMmFE8-!YOD}5kSpW%tQ<11INw?s?UUEbgZFKKh;Le5s^
z6FOoF-)uJX(!r+FXH3J*G{x?;`a_`D2e7wqloayE5k7P#u~Ty3qDe8|sVao!YS6L6
z-DlNd(!_tu<PZLX$%lNW$rJx9iP1d;CNVl$gM;J}^gXds@}GBfeixV25_3rHv+tAr
zbqV|O|5)l{e*ymKTg-viz~tGRjh7Y``xkAriPY8>jW1_E@o(zJd5_)5_F~IU>_FLG
zzxac_i>^!>$PT*N)jKd=`w#(tO_EGm@h;;g3G@quC=Sh@<;_~v{`FeI57H!}|D2vO
zj|y^fO~;QG$p@PWQ1g~?v|tYAexHezp^jnH*f4$`k|Q2hb9+3Vy?cnxAZ$lCBCifc
zv!id~5{yBerf*HMn*N(%)DmnZZ39uSvc(m#iQ?bPk!0c}JOFrD(D?&L&r^6ieFGOQ
zJ7eX5D@=*6b9xwr#$>17!;wPlbo9Tgy6?(0L%aY-J_)<QW)L*{z+w%@Gg1lxO46X|
zv8Lv^`tsawH=*^mB3=Pk;J59xX-<%cIe;MU+MBGFarZINae4DCw%F{#@su`?#4~<C
zx<Zz-i+f}X7fR;tjqZ5o*H;$lL=@A*C^JpR3eiyF+BC>qPj7?RRgZTMx%m9k7`Mj;
zT%tIeE!E8w_0g6{^^c1hxZBjxea0l9Ow_I>=YpB5noVorfzCfQwCF0n!JtS(5}9<I
z51aZ2o*k0;A|<AI97{0{39P*^_g78VF5|D0^a#eRu>rog+<WRDD^67f!>|3rIy^$X
zmrG|akf{krs&QW7u13e=^!6PIWqQCD4f`@}m!SS#!exS`u1xAAybnX}nJvA{5Cndj
z%v?EBVssHjZpMIUEjN!cj%4&49l~$i1=1S$?oe3O50b=Sn2*jEkI5QdtsLVnH=nWu
zEr}DmEF<2*AlSsI3+99e$*iu_MM7S}qE5R2iJcaSm6Or@$PvS~#ce+)*%1Kmkn3-t
z9#tF|I;L8N>rlLGH^Cf_kin<1BSeGWFlW;luo-f-QuGCffNhEBFRzI`8$Pz5yKXs*
z{@mdq&ZSUz1W5t6H1P><^=}I0oaX(zJDSg^OjbL!R93s)tadA&?3WbpImJi6l}M=%
zfxx4~nJzV#?0_3_4MSN(J`uw3`c*~#Ya2`TkvbiEO>GvaODnji{SfC{HylJqL~vOL
z9KJc^{K4I^P7hV$sBfr13YMo7_PI>wc;Z=%BRX_Q7wjpp+(=C(52a%%60W~g*t(PO
zeo7pYxqd*jAVKGKQ#$_Eu010*I3Ov?mJlBp{qkw&RTny!rM8}G)y*5)`S!ne#mpp#
zt=F2-DE0o`)GM(NsE-}MnNxjkcWj6|9KWRKgS$zZMO^HNO#ky7&&so&-Q%a)a57%i
z9+Hx$OdWAV%0^kv&zMEqv)cr9y?DmN@3&TQk3l|PHjTdIh!s#JhSTXo>ccVRj_E7@
z;iDI*_73yW{RVnoaR@))+{_<5Suy6D^th*Xu@NZwIn#ktyT)a%=1!R_j%nE=yg`uO
zpEZXZL!xkvF?@&Y^*78+61kFs>H%iLp5oh*WJy{He;?8-Mq2gBR#Y1t+%gqZZ)T9<
z9J5L1n-TeNJ$M&r8^L9bStXnp>;?on=Uu{5s({5ZZSIMu`&w}*#shBXZ8P~tlf-2I
zja|de%b?bv^K+b;@51<{80qc@P`iI6Nq@Iw=TJ~9sd<Ia)~Q_a8M)4FVoJB<gE~1;
zWa3(mnGinr%oBYQ8R=~H_M+)GNCOU)iFD>w&E)v#kiX`PE0f)~8672ItUZf;CJ91P
zBI>lVe~+H$>)cp<R9!OsLtkfU-yJ`)wg~E(i!g7__W5oq>uS>*<*8($_^?-Bap*B$
z!CaTRFb00Y?;nY7Kt;##SyWe%i)R#<MsF#mPa;WYn}e+}VA3n;!ifT$Kw!40SG?)7
zx_l+e_TyVnyAG2G`8o&nK0No*be4JUx1LrH;(t3QsB`y_1~b5k!&iFat_AFfu>rOx
zS^>-12$$O{+CXY*V-I;<<{w7xLsXqPrt*8#^}{OAKhP_J>&5v4ZRwV=O3vwWI$HVr
zFNFk0f~ES0Wly|FNJ$nK#bOH=b<u2l6~E_5T2{auuEQ#`ps*RuV!V~45jZgQUoV!U
z3t}@q^)R-+W4aQjs+DdJHao95z~Uf$s?+hefAN6cMPfD5V3?z@5<KaYgSY-g4C;Gk
zGq<<MS$ybJ&Q)eJ?Gk%7Kb+M0mgG!$8P-1uzdGTwpy^!SZGzg6_d=jH5$<ffFXu|(
zUA#O04xYU27#9ouUAw(<sLIdqtw>bDheS#n8OoL)tW!rejt`m72ZdIga&X#+WTNI+
zN*y=HZiOR$&c&<cw7l&BQSmrh8Usep<_Ol5SNX#Y<rM)3B7R*}APh$EZ>rfMMXk&F
ziY;NsrrJ=YV?)u3)ys=k<=rT^b&g15d0n`M^uUfvxou#UXs4d^X)O_dxS}yc-W<Ps
zjXzx86z~V?Djh+ogg<o-zrQL}>5n+pY$#s4q1eBnX#Lu}74DU8s`mRE1OA%&I=V#{
zC_{g0rSno%b0bIZ_$9BugEAFcByn2UZ-zoYDkqyWMXVk*R)iD1sSK4@h0$@;ZHfjR
z{BH*7uZT9%?V4z9ojI1(zrZiqv%~bHGSDO)s1600llo{KN2G*!v8iQKARKX&Z>n#M
zI9i$l6^=-CDC`J^8pDw+>u0`0vc^$7T+e9fd2M;)mOvx@_1A@?n;e@$jIXYIOTeDC
zP>_tHiEh@0!eNlIzb?>BUm0p*LFkOswbEUXNB2WDmCTi#@DWIS$y`O5W9zg+zACTV
z;+HDI9PJ>-CI%|gM3W<P+Q{G>p}KIOQ6`Sb2nHGhm3C=*9tp`wiVjYAi#GV{qmhPa
zgj2mE{y=>V9U{RVYQ!3U*sK)Yx}l!uRxy7#vaJT72-F0m>XsT7Z(DsZ$n5e_W2L}I
zFlt6<^-abktI6;-$r3q223-99+WJa?0C^9<R{9$vjR}weQn-_2bmc44dw)$uZQ}L%
z8{I2cGPnL<ePgq<$<PuYX)Q$<oLRRmQGVTu^^S6q{%r%~s-tyVSj9RzYPJL_Q$Ii(
z0+sT(2Iwr`6sWNmz^;^aZ77dO;y}OEnM7@1D|<Cej=zS9nU*zR6C^sYVogzTp10WH
zmmL{iAa5<`OpM(?w5=X@_@i~vaG-Jl+NhR@qdE`;&?2D<M__9-)C8=xph%}~e?1_=
z%(I9V5LK{4<uX)P&#$aqn)$=db!-B*gG^a{Qz*>JGgy0f7Oh!VxV*rwyMk?Ct%$W3
zWnV}6oHnTuxC!u@+Re(;2EY)0?rivx*^})e3(7QE8yRRosfR+CNzJl;=F^QpFw|m0
zBNfP=@iWDhS=P^d>t})Wv(Wmv*7~{5;SW<gJCLr19TnxQ3EM7OQ)6$oNm$5?W(ES8
z(W=Js%FJ;6mWt{?q%pH1yzsi3%<AUFi!)^uazu1EGu%iQ19e%Ba6>@035O*GY&^kI
z)d9#`Xx&;CHk%FVfWPdSP3(<rGVuCHbpT{zz^c+wUO53`)FJy(OzbpJ;Ru?20LZY@
z>LO-tCs%7?FUzv|Wr1ZeD{9TcZ)(|Quv4VI-XCab2(a&)1cgY|6bqJzS*r$rc?D=s
zaJSu=ti;89hmCgp<#iR+^@6h4c@{>j4oz$XvxMapTR;vLIu27dBGX<O2q$3P(IVU4
z^ziy?X?&ZYf=vRRwSijnxCx99hJx@g0Tvdm;DLoh1L43{kTBJ!$$*7)u{i@RU^UY%
zzrDf{-hgoY<zYVwF3TIYIU-G9TY<NxNcko<uDum%m;-^daAbZ0#@#D#%v<R&yF6NJ
zQwVEdVQ>qOxG6yLO>6saGPp{n#j&brL)wb8Ycm#QT$i>WYyNdv*DqL@_OW%K+12F{
z>v{UZ>#s>muZ=|O0<Nk+T>$=^+w#VWYFEpm>(j5lHZ8p>Eq%>`H2CdGS5;kf@nS>r
zKz#yGhD=(7ENu2v0*fW^f=rg#_7E(Yj=FkB&<25^O{c`7W^X0XS}0td*pCzB*CM@@
z6>{hT)Z3ozGvKT-D(q2Jq}nW#wfO}f8?;fg4FugF<j}%?7VfgT&B3`~&II<YtDoE(
zcAtQK@R4Ji!C2N-5<nFMoItxaI*_q)1TS-95e^|!vdFT=74?mc>>a7Tt}3ytE7z<m
zS-$Q@Kh#3z#$Q<;DVNzT7lwjaDX)=j0r}?BYFYL`9m^k%Hqc-gFfs%*P}>jzmJ-~K
zpNlHKsr7HKhd2v0vGGcR_X$Sp%rV4r=2|GY&7ZjU`>k61<@T@OG)TQ+bC?*vp%eyE
ztsa5C!8gKJ31a4Fg1xE+`d}yO5Z{dBj$@(?o6OL?T46neo3dMw;jx6K$CFLTK(+<o
z34(S*%m5$3C($?AQnjG7kbs`GB!)U#ov}fY3PRyZ7@{+~Xi-Unb|AvF<*XEa626fJ
zE6cZ0e?1cvtf_C7!#-%N+~V|vMRJ(^mVi?jAh?}KsLmg>01sG%UjVy8SY%;YeZzJ_
zZRxs&5E(ev&_x)ev%1C*H-U#I7P6`~B8bX>+{8o*egLCJDysP!%x>nuVh$qp4OtHU
z%$KoL*GC)Ww^_#YE>(n?T<SREjkPYJN}-uDEApu|d-Dxw%R>R`#)cZRfL0Y&i9}D%
z7zFUzB;8DapjjpMdL+cw1NkLTsg20pt03xm{-QPhlGX0wJpcN&%U9$%-~b!zWvKS#
zR)*l8WZS^nRLenHj$mUT0Ef$8A<^{>Orm)nsW$~3^ojjxj;J>484Ww+U=-o*%2_2L
zZL%TEG1`uL!|FIz_$}tQs<9qoVu1=$NOb`A(q!LfPz~E4PXRbYa3o89CQHSP0elmi
z7NP;<Con{m^(&t;CVS+?%Wv@KdDkv4TJK&{<N&V-DhoG<C@oMgD5N%ACA%e9QB#k&
zVSi^P%5RB5ETT-z8C|teBn+3I`GK#fwI+z;Q2ekAvZogKrP`WsAg~2Au+7gv8yss2
zZuGBOw`RjyKPankd9i=Z+G6RM%{!V^keP<oiR=T76UN;iEDzN<rcRu{zQM5VE7z?l
zG;%_sA^@X;EhrV474!SouFESf_W4&L)k#wzr=q+Pe}TIw@2ozo&MR1(sHWJGJ`%SD
zc`J+kE7lZjC@e}m3f9${ky@v;C+2N=L4gfqe!o#A8IUktwT~$D2O`1*vgd^AgIOW<
z_UO%+8-n2O8b3=^ZB41LDNN*qQ2MU($2zZfm*yopXSfKa$RIbi8s7uM0`!yhT4dG|
z2p1$+2Gh8sHVP7IU_)3)7PL|hS0G%}`VDKD&-Ls5Hxw){^7!)#*D|&C8p@JDxD54X
zOR**D8$-|z8$^W*v`=-jHjzBA8UUFIQT2x^nT-%z$lksJULq62(AC3UH#>~D<1frx
zw<^!SeEoX&`UwCEHrCf#)lMKbt8Q!8z#*1HXTcC`IeT|n;v3LfF*&RiYYGd25rK~N
ziE#-%vG;2N?1F;C9l>Bt6eeQ=kI1Q!22`Vs0pTta!!-ogt^u6UP!p=4ppC+W2Wj?K
zOb}1QE!*?NX0L_r3gMhOn6PXRf$*>a<#*dplaz#AUQsQQaATxCD%_{FbBuW64?<bY
zMzUtf?+<c{BqMVdt#;qwF7~h9z#?1IZ7;H{F4PBvV0Jf>l>svlqA)GcH*SG>@QRJo
z1<GyQDq<tx(P;LKEQRP^EU7Co*EhI}mam(Ds7aWAm+fkIT+oUi9EKP;K}8_4Mw)O0
zYMJOw(JH1-08Eq(K%MYB;Fbifl^KFZuL+?2u=OJVUILXzL`A@NGT(e;&5yxTM#EGg
z_#cE_ZgE18CL148mUh@k2Isv?|1Bzq9271`#M&ASL<5efTqn>$bG0aeETxrQ>^dR)
zh75pULsiIEl{L_&2(#$7F}Em9{6)(P^ZYB8ub)H+kw#fBYtPpPM5qI`3OzC051>&q
zaUg(Qs=B-;2)d{Q^NSP%X_|_FEoP}PV1~_x6>v9GBvhrr4;L9?-&FZ48U@0HB-k*`
zG6l-f7TIgIdd)g_>DfE3KCw5XbLB?bT3@`*z1Cm6Zn>MOT;*S}E&(x!K$XJFSJu~-
z8;x6dexfORw}$CK03HZEfq!!?avZ{&NHs$ICZ2#AxMSTZVW`J^hhV1)nYBdE%>XT=
zY`(LEZ&822%CRQ}sDv%3OWd$Tg2EyWLtBA->a-+9!H*WxDP`+XQZ@2%ZFzW$zZnuL
zszftUmFA<6(Kb{X@j;-q9uZ%@TL9M~5Ma$bMGfE2Xb}!*3qs--^$D#SSmhyGvmS9&
z-dKuJp0S;UzKXPO*cU)f*q0EXZS5I)W;$g0XC`NXePS-^57`u!{OS+ZF;r>9$c!kW
zWPe-l><JPi=-(>U+A2At`m$NVvlu-Q1L%{br9vxLF^Om`Sst<`nkYx0QV`M^DzGWc
zyQoFYEu40iu-o$;(S}GpvJfI9EY_sFWAMDy35Ug=`3=Mi+a%fow7pU!Yw}W<L+Pf)
z*qK&j?mz*SRtMOzG(vux-8J=vt&J46`)_lJn?(Cy$q#})?WZ)I<*2NuMiGw8%1C#F
z*K?Rw8F~O7OGaY%**s<$szQ)|6p?kJhhgF6Fn54+YL8_&VUaY2EA+e9!^brk@es(K
z&`nvIFvHeQ(r5Z$gbfIht!&_P#7UL|XFAb*t*6%Na*>lMORMNeA;7l6LJ*1&rJ87C
zgH@J!cT`0|h60ABTYL$l&XSqm`3^KwqE_K0PqNs-4FOAc%eHf`ZxC4&1woiig3iQY
zXe65#LEh5Q8I*#a%m!BQU){E5#1Z+#+6pL&xIsBmDO<{P2H0la7cKy<fpXbIa3TnD
z;9T~KCF=-ZA*TTP1LZK)(s${PDI^yb{x(B09btwHhh+CHu|4eG&<C^E4e^+mkWJen
zfv{hs5L3N1BTSS9XCMJuw`2`75^Dmp98+$XzAb{5jXs}cDsP-n9??f5|H~Q~RAw|I
zM%7XQpDIYr8u=zOW{RU-ZA3ZlUf*J%Og<FVkzg+ei-W)_jHi3O_0~+Jy{5L3$(q~1
zRx=t)sbepjePb<%j7w-prRX21&w#GMKNf1SG%jZI%PzDPFlHOFAN&pVVN17Py9wT>
z8KCsnZW4MT`a#*w)=m}`D^8ORW6o))rzV!Dxx%7+)^0JR&~z5A#cJCutIQ3bZnC}w
zIzth@l-&kip`>9-!8HPsu=%Dy0%y#(XtAjkfq$a2!WY3r+50rXq@OA3O|h8RdTM+5
zW!T1mgOi&XsnurI8MRq>ioMLt3DaYNMvX-g{ZqM)W~l?&)`m)>{o>kaT18zf6#(x>
zm+xpU4@DZ_!oq<DgPtk_!g$%b6N5eyMjT#?W(mz^1^6h`01gt}su5FcdBo8KHp4nm
zDa4H4`=w?$izbott*s-1tDrU}PcV#(3f6zJLw>Xt)&~}g%{o|EltS<$^X1P1`EzYz
ze1?dlAh!0Pxts4`uQ#H#D;E@LV_1vZG$uv+35&`wfQAH53B3Y1L?A$aBJ!M}g$U9{
z&uLhG0S+^6VKL~&!pQ*%!v*62(+*z%10`H67D!ZgQyO(tMjIA5HW}3Ihruv*C6sxl
zB{&asek>ohL$L@X_)}PKKs_8Xd=)F}-x7kC;9gWzs6ORVIAriANX>AUpb=r*W!qS?
zuEp_6NwLAnk5Mji!F%C<<TqF@tgqoxE2^>1BsysH^Nq&qg1!Mj;XqZ>L{rpJAqruB
zHwnYWuK_7jHLGB3187E2a!V`0P@u-pAxi^cNw_wv%(wK#n9`&_4Z<_oa<+vk6Sh5R
z#9CvqyKq-!6rpDR%PljN19gPVp*=AM(J?_3wb_2EK$PNd#F`O|RA`YXf(Q_)Zv>&3
znXpPv8LdngxI$K~!R|2lhjkZ`BB3?(PmCyRcgM_`-Sj_i+QB8lERC#(xscPt7(=Ko
zC{{87R^bC#lSw$X^pI>EYlcI0O|Xcf&hQ%*gT)NL%Uj`2%~x_Es~l-GVkmIl#0~?5
z8f_nU!BpJIUaei=2tk(0!?2#9LDsk#&NyL_-iB?0?G~`~*=UFaP=aEurV4{`jBdkN
zv86qs9K!R+wefhEVD-e_OP`^qcJHh%Ahd*PYay%Bs==bL&f+X=swrn3nWY3V6isgJ
zCSy}Kb{>k+mfvVj3~!EnRS^nVyrLmsNREwu<DE2h1R^QnT>zf2-IA>;!0?zStWKIq
zW|IXM*?J=(FxFi7BVsV5`=SDcG9px1++KN5dSl*NT!4&}DXU|fi?KQ}&kiX9?Ue-)
zdFb5=Pj)dBZZ5A8PVLNfF^xgwfC)SZ9L++E#p)`$P}3dROV%3k+-gx4rny4M7CWXQ
z$}XujT2NUvOECk+fV7BaRGwMVe%K+i2;y^Kd@F|=OT4x|nW{_`NV8Rz<ux#R;j_vL
zLX!TyXAR;KaMoMuYyf!A{v=%<7$~1m=1vYnR)&e0_$V<D^9>b>I0~N&-C|0>24_}2
zQOe?oDqylOd!AJY9ugZruv*?Cv?KxVY`a?Gs3xFNz?)|*qQ#SnaBb!iYEuick<wE^
zed@;+Jl6TkqY<=vNHF+HSoZcQYE6g>8w=DWN({SG7KT`{X030Xd)4Y<zb|k3I<Xgt
z={+4)C>@%>b21yq(&Y|m1q6^NCn{55w_#f&Di7I$SPunsU@B2yOzl8ZIdTC2B%U~?
zrr>+@6DtrDdQzek!QE76^Z--(mmUm@zRL>HOGn)024$omAA#x?=FVS%WG-8awngF7
z;4pWx1&sUwW=C{kVFY$9_e3h>dh$cVC?@JeRAO5g6@{@Q8|I%jjZ|G{WC2H=xdC*f
z1llXE=$LR(veDCPsu~23hs&F7zG1b92uAD|qXsf_OGQl-rxV+m1MR=q9!x0<^9m4&
zR?IG7Sge)>v?@kc(eq6a$Ny13;zx&4Q;#AMJR_bWmPlZiqhlC+jXjKRGnL|LF-2X9
z7N!bqqEIBOlUAE3+{H+h=(5OMsHbWw#nlE2Im1fmTPG@LSs?RddYq`suEmm>FjgC+
zhay_E#@6^PiA>PFRY(>M%*aHrbs?DMR$9l!!DvzzoYA=T5o#7(2F&aE))U)EB`Ohw
zJ8|!56v?BJuMLkY71~tKEQ8$uxIIBA!_{<T3kv26>04qta2lDM1-o;$P?_kf%nita
z$piCG(sl}0gd4<8DsQlGvlwSimh?fC70n3IcC&UTChfK;n7|__(=1Y#04M}5O9Zw*
zpZp-P64tt#VO#E5iSAk>_g920UfwYGGC5`#5wQfJr)E>pePH&?A<I{G1C}$#1h_Of
zTDG4#I-?U?ZKmCV1JPfm%Tpj!7&v412Gr$R9&Pty{WY8&msohCh||p?QOh&gvS3uE
z15{8M7DCq~+BYorhBvqCk*y=e>w}hQ*t|4C0aU#*-6Bdf2A73_7vBzfY<7pWi@>XF
z7gozmoaKAQJ`ZB37e)d~!d3-Dk*Nd<=%T&-;8p=W^A%l~C^YfFFdR7N3E%FwH-^;)
zHcwa|(QZtB4yj4hYauz58u(KIm*K5ZFs~`eFjmX-!p2mf+2Lg)2<hzoWr^4#X@bo|
z6=F%{8xSTcE^}#QM;R2#nuc%)w!q$S=8-AV7?2+zSP%_(Tm*6RLWXMCA~S^+YBQQV
zT7^TMC^LzqM82h`f{)CM*>#E|g2f$)AY}DMMk6(_8W#GI4p~GAy!Q_+B-X_=YSmya
zp&Inkp7M#gvV1r!Yq0&Uu^yTc-fsGaUav9)LVve0SV~`0w;8d&9wAW7QD(vnOJVbS
zM&yS5tOv18uo{rG$s6Ge#mn)N%l&x;?i(>JY{0~MgReMm{XY~!P^lG+Z^*RaQ38`?
zOf{y2jP^{9@2pbnY507<#o|rALy>9miDz`s>}jiB^OYe^XE8_tm`oIvYzDN?!mCXg
zt-&e)c*WELlkD46CeX6uPt22%Ipl7lw6L>Ns<yfd7jMxZ7OQe{G*iX`M`kvG;W(w%
zMEBt}?MaxJeq5RI*7-lVVT~++a38`9gSpxGmf+7?V%y6S`;4#(woad#02ugC@isVX
zV%er=jsiXmMq4^!Axtx38)6Lp5>>c)C}6REZ2^`-%rmRjEnmBOJxX2E1M{0TIo`Sn
z7GA0sT(k*J(P%a74p}oNlWFtFmj29wKhqpvPOZ?M->s&$L;-)@WD#p#j1UeC+mr7{
z^AF9!Z*a08S|_ncO$B`O2q!-aAxiC2dN%o`^_5vZBe5DQqBS=YJu*vb_J(k42tr6y
zP-K5mfqzA@Z!Jc;4aGOQSGkK9`%6}soeFa)`b>Th&@oF2c0>a#GbUcX5JvoF%riW!
zBLbtiUz!Sw-GyTLEAZdwUYEDR_*S6Y5YldehjC&wq(a0JslvZ$3;J90amn%<#QF_i
zLf7n@g;Q^?oqB`+>146%r`~*G>dm65H;aWo2hXz+P2(2TN_54s9MAhT>#Pq<PvDcJ
z4RdXG%Umy*TIqbdl->I?x<4P^VfG)xtO$wP)M`~K1(_8U;}E!Fxp520E5x)&@939N
z9YDpoiegj%k(!xL%#yWc?jo~f>*xCmZ?G-TRYn12dS;fPBrnh7pTEBN#^pX!vCtwM
zKX6NR_}AsF^53xh#&v6p*}dZ7F6)f$!CqDA;F+-T34sl~Sp!&8MKvP5LW2>i$Giuy
z;A7=jv(~?%c;zDh+Prn{H8)z01Qx;cBZ1iPWW$T$_YJY3Q9}_0+$>%YeSZr&0cfZw
z9dI&6>a@F@msfNnUJ0A<VlcZ?WKPk8;BZ%KhzWgIvo^2Dzkb6F_#Lsl;zDIcn^&}E
zy>Gploik_9K)pb`xKM+qtxz7e>!wEFok=s58*YugBZ3rsp9Riln${E)EXTKN#hM%Q
z*5?&ZSwc${j}(GggB?FnU5jBJ%_d~N>l?-XF7s#k4^$b7U=iN(Ml{Gq7PGo0JFPJw
z!ZNOvj^fp8HmuKEJ7q|TjeMOf)+8($GzttRlpq#bmChIDEnmN3U0xxeI57ZuUYu8u
zw|4a!e3ZEIyLr2^u-H=nm~|41v&@yDr6vMH#0ujHf_dE0AfP^_UkP9}K!hA)K9<M@
z@X=X*8WRvoFDy3#dtS{V7OlZ)YsG3Pv}`G+r+gcn?&L@(c8#!k#xYX>*<PWNJW&BK
zGw5_%Y*+?(48}86F$5qdZ!P>q!i$Q}m*04!aXG@{XceA0H&_a7j8M{Uc?F>WrhS=T
z<0V6f3`(;GNl)=Ciu^y+oq3#IRgw3fP9TImARx+O*c4ebA&8);2@oWj!1MI8&`G-c
zVUbPtgk9(kBRZhYNDLx_$`hB-j5-p<B`zq4I5;kY8zPP)?l|g*%LvZs%v*I%ee2vl
z=XT(odH;F)1G&Fbw@y`^I(622?tLyiSK>xJdtz74vn)Bbf1JFCBgg&w&6Cu-VwBXg
z%)@m~ry(YBeC*Pb+Kc<g3@<wN<q}pQ)TZ>-3qmDVPcHTklY<y1_LVDcf63#IOC+vz
z8LrQCVoML3XHo}pidWx93WCi;a*S)~VzEUJ$;Km@NiB64VyikT#4VoF)a20g)ZH>!
zTf9u%sby<Ub*VQ4ZL)GS!FosS1*Y#Etqwv}#hpA`a)*)3LMX1!rEBhMA3epvvIvq#
ziE%SXi$t9sds6qrjvV;WNNb#Yk{n?^e#vlK`b62hOjV|*Swbu>8*a-!qs(vQtfD-v
z)wP1GRzizVsiJmqN6!x(*Ol`yWzl2QhKX_5!;epLV|TV%1j{(2Bc;}V>}mUFUwM(7
z6CiN<OOM6!ns}J6@gPG$*qE-?s@9wi#xhX&z+TBOufq&4>MvW=l<*1Lw5nh8XCu_2
zrp&bBXeH15&p1Dhb6)0Shfh3qxg3+BMuY$2Oe2&mbe!@ESn!s7(@4TbUN#doG|%?(
zWykbSSkykDuSW^R*l;t1Jh2x-Udbm*MM;OGBTtYQ$|d7v=ts|#@$$k~TuFbb&-rA}
zEN%zHu2?3mGRdO_aBeHU0m2691+fv!qGh#)_K7ET;_2O>KK6&&Ok_zIOps?;8tHNh
zN}6>0#7duJ({HU>oh8e8k=2*Tu8VA8$qCDFLfQt1Xq8M{bq)|7)`$9%BLioPxX_WP
zSY5#CiMH^hSl=Hih8GI9M2_9cl1bw_v>bv<i{SOvm9tyDMY6W)cTS2;VCf=h0kPlG
zdal%iRM4^AVTqLyInQ~9yhs+>h_3B)2p1QK;MBC@co^=6BjE9V9DJppTGT#v$&zqN
zOu{ZqEM&}8AH?>gGnB={`W|Eu>-L6GZ_$azwL`ZeA#XE^(5=Nu=+yB&v<tN?i|66R
zy(QsTawtWd(YY3F!7>(jb;`IeQw|+B;=4tPbW$VF&9zR{<S-b<tt5GGNsqRP&S*+U
zP8`duDAb-TYjo6<o-drVwjo~j4#NpieI%{Vb(BlPZqd>(qp&i{!&c3BUJSV@3YMO9
z^5WqI#Fcek!H0|6$1aiqp)Y&iZEc^in+z8EC}Yzl4dG+kdSv<7#Zr5)N`IisYJF<1
zcE+A6c4imoDRg~pOzGl?DdVApYIt2BbQjXONSw$~gmYvw#)bw7rs2M}`;+9oH(4J_
zpzC{FI*QAIPT4FhYi-dn$7sccNwe%yi4(O}blxh5x>j8%xkLEKqW7|JBMxIzt4R7;
znU)9lYY!6kYiQ)5v0N^PwzP)BzIc$Qw#R8xAu3E|ZBDA4oSrt6t$CRXL{H0uG2I*v
z{<4{Ywr@R%*OvBlf;^Cr#<S|we%xS|jCztVi~?GI4@r4-vA1|wBep**6V685=FlmW
zveE3qEF}zQDg2I=7Ts=~El)3E$k=EfI^59vOJ}PE)QN%?TS_74mgd_vwhZJmVlHVP
zbE0grhn0yKFVFcyFR#v$;}r7FZzw=?a%dekqQ$dB)XG_BTp`PUbDqxfqo1YqNIxk7
zA*W{KDV^FBhZC{vu*xDqk8n$7o!cmP7`;SyD5d+YG8lVvmLt1iGe7Rl$<EAb-JuCJ
z?QKG9MkZnEx~hY5z_C(q!NulHMp@~RBt-N{wpMvK6=A1OPS+<*76<a|Pc~O<9>K&+
zqAm^+zCJrf`i#)*LVSx)R>_9_s`#8UJ^+)hKwgxzo>Sw$;vU_^yg;pq@5ZDNL+y@>
z+E9c5V>Ji3AW?0_Eza!QdRw8bwiVi1TcNGA6&}^NNMc;NW;v1>gFh~FWNIAu3#1DS
zN~SDSb-_Btrv&HuI*m>7taB9&@phUfFK%_0^sKg~cB~pBzQA1FkX9sfnBWxM*{~i;
zdR2`)Y4`bPDg&TQ0YYCNCj=UdmtLe>pRyFw*SEx%VR9J$S++#NMR$FzON>))Is6_L
z%^|wOq9yiMQ}e!b@rhP>=Snvjn?hjLM-WnrVR0iz7{i83913(xRo)+sp)0n;L9@AN
z*hT4D+L}q|^3?=+s1wcZ${bzHkAoD8$0Kz|L3yoH)nQHxEhUQMT4?C6IP+B94)4o}
zsL*aiq7K*b0jsqBDQ&i*#fCx|sY0cMUQsp)<*bCL&`pI<N;$qQP7m(sF4JjmQ--kN
zMmWZ9(-Rp9br(yTYglzu1Hfj3QbnuNYF=fBDU&`EsdDJVA*%9uzRoS>>7%wr^QjDw
z;@e6&Y`Gs-4)O-C?3#u(hV*`^2l16q7-GWqO1K>?uCDCz-gVJ2^}X(*V-~3R<KzXV
zR(Ekb?5}B!PSIah=@D9`N>1zgusj)FeEgCT=~^$+^HFlzA#{MD*NELzte7+DV&X(o
zqCU(5bR#j2RWc4sZ&q0tNwmtaDr2E{05%)4zH+#`RQF2S6@N0t7fbs~C3;gKxD(=X
zwJ6m{5#@49R@NyxA(d!9R#xnB9-$deZZ7NVR7W~SnTJW!k!TIAAQUi(){aD8wPG@A
z{jfSS9zBh3DoCfRo9ObAbC?dNkkxTVmka01cCt12)uGv1FJ4{Wg#t;}m==iHR)bin
zD?`}^(9VcOZs;+z<%zD<wkp&vKYp=7yLQ_y)Bw~iR^1p9au{-To~do0u&;EvVVT?4
z4p(;vlSk+T4iDRkE<Wto>NiLjp!D!#*wIx*ajds4Bd)=c#Fs8=#+731Wh5Cx+mj0_
z>gDd?w790eD>+5Z5wXt*!LC6N_ZO<u^x;LvEg1<@su<9r{$*;qDsz9n`J!r0UKE2y
zwix>-9WPxeW0j5(`fkTX(oWL2UNMab4b6-}J!~6lRagy$T|{aqgp)22qy_2eKY74u
z?+~3YU;Z!;1P>9t`i_n46X_Pkaq=W=S%|af{5UTSZ7{~B#!=(+__#<O?!=XEvLr4&
z!_%4Y%HP!SGA%?jr1f(Ja_n1L+WC6+EeO#th!6JS6TRR(Sw4m(c{~IbYDavUExB}Z
z+FfKTx~ZeiVH$A3Ce3SGp}N!!ewJM`9R+AVHYutUJWk|f^(Zg5seQ4b`<eOhYCt$Y
z9t{tn8wLT@CeK`Be<uwrZs&y|E;`d@2*Hf3ILFI6I0YzC5Soro%ECcD8KvUbuf43!
ziNuB8I5~JweZ~@=hD@0r#$$wGjS$p@vCy|`FVc4aD`9z&9HW&rk-Xa}FIef<7($TL
znJ@F8#V<W+I5z(<5z~L<Z76GY)>(&1n9OQ*X->UPt-E<zcly1Z*h|?AC2VoU8A+Uw
zNDoH6951_?@`y;DIfXggF|x-goW}<%<-w2iN$Dw&CTwyV@5Bzn*rdA%Z8zlcM?#v%
z9|>t9PE(`VR8$DLaN<7>-L}9}c@}T61=6ueYn`(BpbK>w67}70+b+?w&8MBt+;*yy
zj@0crvsI_aa@aH+%?mr(X$}$t-N)&WgRu8~#S^Ej(rrS}T-t5R`wz0@&?iNwof`+r
z*hg0VojL*wZ5=YyuqkS)ds!8aOl<+W(2HxfFw)AKZu%riOH>Ms`=Qm{g$w1p9s2=O
zTZJsp<@vFGSD|WF+NsjluEqP+Pf}F{Sce^69MCow!d4r3Y6?@zs-|V5@df&ln;g+T
zKWy)$=B0-iWPFa(`bz9fnNiB7h#EdM+Cn1<?OG?kVZG|RYoYP!>{*_}3@?#&jjW#3
ziBXNuM`X{kA+K`i;#kMHMaRms_=+aR?jwk_d{!wNlbwd{;pv`(J~_iTDI|0q6h3ZL
znasxhLv01(44yaWgDAfGP!=`>dmLA!TaY0ouDA6OwoaNfgKSqV>c?%|DYdN2_3V*B
zm~qC9ZSj4zro#kH8j>6|k}pBYQ#n~y>Xa!u$<@T6Nk1W?&-Q(77FSa7yCcdwHMpgR
zJ+UJ`uJQ2U>fz9QCDg=;VYQ;q0&G_)JQgU2j~Ec0lfqtIIDa5rs>WsLR(0(rk7S#&
zI@M+rpKQonTMs->o#R(Js;My+YTjq0;mEd@YswCLc*dj4fxhgU$mWVXb~-g4)(YPd
zi;v@_y5yv>SQaKw!H@mp^eLyVj5Il={lx9#&?u+e<B@3CdX&ep7OXa|s8#L7Eiomn
zjwI-HAt{e)W%eFSpYq7-F!g)bP181^m8}t6-C+nb6d8!(_D<-zg-Hl@bgS|tIu1>`
z3X}0JES$rNtSsKt-ZojqI1-{Et@*>WX^J1%fvWbx?Ip{a@}@M4K&@cg(9s2+JwjJ0
zG~%$aCk=j?zS`x(dZ@!t=<w|l`KaFNOY|FFc@<^*y5SA%7@+aVXWGu^Ikh}Nl-LW~
zd9wMNVkuNe*cOvn^6~n_Ta}$0npl6)vgWeN9;e22STxqu<vgv+&`xbqAW}j<XiJlm
zhQrcC4jxaPbjZW16Wig)k9=E1pA^ZKvFzRH^H?>6SU)kWF&h`foyIgVv}UDUpY}$f
z+-WKt+O*2EZ6IAb$k9O^isaJ_Qeh)rV?kNP8F52OzFWbbQrOCt(9<woCFf;iTCes^
zd7u>nTH9HeW`|knsg>tWDT6GGo+n$O@fFat!=M`hGFQ<6U@#8{6?C&hW+$N}DkSUK
zI!iiB<vTR?%|6=-)mK@>E&8}xmLu}iO8Rg4WQOcLovu$gY<kBv)Jhzm;^f-aytXx_
zWvU)2u?dpz(0U=Iwbu;4Q@8KaCQf*PIYy<fYA@^`cl@Fd#@cISqlPvq7Gp9qk;z8r
z%;Y`YD=e;M)+NudbQehnz}SF7^C_RGg-%CyH7=D`4C2QW!gJ!dbThg?jcBaWLmSeJ
z^=W)Kups9KWa!mexk%nQmL+}+ORXA~Ht8gWoScnw59{acfuKGxkPjt<mz@3hrIfn}
zs?f5O9GVlIux!t`J3=O(bf^VPJmd#(WX+``fxbE(&pg`*uH%rDDLw^_V|yrtG@~HT
z3({`O60Z#{oOZy7WGs`Fqjc?{u@(AiZR&B;C3a5Xl`83obiYU2Q4F~BBueGg3`O!J
zvocF)$Oo^|Tw4R>r1p}|lAe5zNgfEuM=vDIV?64pC$TPPa`b};`kYM-694N(Vkulh
zC}`;D8y?c^!qeDL+N_o7fGJ;l;bfd2slgc)6RoC$==kg|I@r$_(7gTWdUfx!@}wd<
zNS|L#X_bBw!=Hf2DRnu@Weq{yIAxq!bWCV4q1f_>th#~Y{jYq<Z&7z?r>|Sy`b`Yo
zwM%=t#q%|NhcP}cg(-Y-M;@}t8@2Mq0h!iXs|XEOx}C5D2va)mN#gcehz;#g*oX+;
zx7iiLgOpUiy%qKn!{}}!!}NyPk~1!^PY8#FWSXvnt!$yiIFM08Bg+<9QY5J+PGgr(
z=0o$5o;36t>f<ax+9!2~W%9w{xJFn8w`G6(glhQ4*tIH{I(L#0RNgR=hY%9DQk9p)
zcm8AtL_S`n-CP(8LYuREO#aT49_GT!W9KoY{b*lYeJUF!Mkk)Mcz9UOMP7coyvQyG
zrlfa{E##Q)@%^wJ9|E_sO0qHsvhKZx!AVEx{)vlUD$j0ddtsQ6Pksg)!^r6273)u)
zLCRAaeaLACg|s2-OV}|6La4|inphHFHHTAc$LXiJbh>H-Om*oQM}PS$L6`-|?m~!=
zFq;V7j|_y;+o)A1%M*BZD*D->BA-?0!x{;aP!%ClWdozKeW7qcl&bLX1a0F&skUvQ
zP&O^JcT4B$BvQhMD8yhpUsNqroJ_?{G5g4Fn8SxJA&U!R5XWIo9q(hXyxE|Se)X}C
z?f%7EA-u!b7$-~eJ({rG(Nn2mN7&ku4G>`(Z!widv+5Z`eSWFWRN^L~e27jb7dlgr
zW)+J%b%RAJLCSlE9G3}R_2)~vAk-EqO))+fws}zsqm!2$*Eyk~@fi<v=^Y!ObfOj(
zRB>`Efg~MK_&h^7(T{yW6s8+^I*SOCs`%ie^0ZJM0aeUl>o~4Y!?8l|d82Pbk;SO2
z*OI3ZOO6{MyFQAMr>L@}BMZgY-|1i|A3Zp?e}OcsSb{U+POtWF`Vd4tsvq%)u2G|;
z1zKkr{1{d0vk#lVhuKy<f2cdXVLcT$RMl-$`iJTgMk>ZaUM4zec^8^7!~64fc$ZpV
zK#|TN)ItU7Q+usQ4c%BkS&D{(8Co<sO`?NTs(dz?tv18dVoJpLx;&OwKDVRcmcqh&
z7x8oFn5FS_yY`gYtyCgCe61v`F)KthGMvcPkPY^!=}9>2K`|l@hBC0p!+U+dJ?yqz
zc-kxFdsUT_!&8<5VIq`-xuxL~gBlZhFB?Fl!;?;VwaypA?bHEkKi-xZhiqTy5f?kA
zr1Pve+t*;$H@0=kA2(=1ScgamC<KAd$#in28#wa)3JE1W>=G+oHV@)lRJsmva;U~+
zKK1`Rt^cS}-K+yb@WnavkCZnuY8^7Q<XTJV%z)05YCImIOqE*`*QsrEh`x>x&cUB3
z9co*qbXt^9KxJpnqZ?y#7Poq&F!p0~8S&6=b~ZqE2lb27q0lzI#v{g3WZl7uJ+T~L
z*Fa+DEKdBbL@~5udkjlzc`R=0kTkYLb8Rb7YFb`YlZ9(l`IHv7Ks}x+BAxEE*A$|*
z3b{JDtB_-#TX4tms~{gP-|P#A4dp3S*e{GtS2vcV*+@sBE5FA1+P&zQ9Xj1$<&@qf
zf0moNg-Q(R6V3GCDOy6)3*lA?1m=9QZVAuaSua~mhpuPJGb4Qvu19-=ZG;C$ek2<7
zsFrqGakU$Rq;N*9`|BMS=K#5cI338Tab}QHt4}sk^&MGj!%^{EhYogSXR@e!+!A?^
zzPRjw`{B@*M1Op!Uk!NKmzX*;6@o>MH3=d3nFTpmDt&hQ<@ynTu$M9Q{Tn@uANrVh
zz|~#_h>yRdXF4l>_dy>c>6)!lLVBC<GE9nn?@6+yN(@1p;7tiY+luh9T4l*Oqp+a$
zCvIW=qM;*ErAsf_1CtYZdQdg2GWA(bZ1VDTGx;E$biZ-PXS66f@!{bm9eoZbWw)*}
zo|}{&Iu(Wx5A9n|-h>^RuoW1iS<kx2*1FKEPn1Ky9QQMXEgalXnVAi~B#mc0_3LWN
zRXNu*oD<rOOV2!C=7CrB&px|<zJAU7G}%xR`}KQq@mzB}hMkh(g#-P_jeg5H9&nbQ
zp3u+etg>%B%1ZF^uzHb0I*~z!-0<b?@I~If%Dzfh6ZVM&{gk|&lt!tnCv^^Up)P>!
z@pdRwz~`SE-k+8?h5MK50cLp#T1qM}qR98kWiooks`IW4ohzUFme13~@7JkfDQeuJ
zt&}h@=&OxVtnfugdCyK?4|3)DW}kkF_R>}IDwtU11vC|M{4u&MhRo^Gvt6p6)Hk=v
zcgtn?lLI&MvB0y$&+>M3_%iN=XUgi}Qv57)H~D&}eP=}WZRBxCKYSnPg2tsf0lGAL
zLcc#Q2SQ#cudzxKI7<c+d6CGDplkKT>I`olN-W9O)TGc_Kv~)tm&}voi<<K2C~Q?;
zAxnDw9K#8VWIZR}=+_tjmY#HM<=3VC*RA9<m6TL$IV_xxv+a8sBIV(OZ25=x&W)%Z
z(eDPHshnrT&sxMulMbq~9UDHX6h0;?6&=pD$vow3sXyV@Z;q%O5t2S#APId*Wq$ZK
zo<kO{@Pc~$=@^M9{Rl*SLsvghX#@#A{dA9r3KJi3+8O$7J`U%|2L`W{kxb6MuGa5a
zil_9fptw%I|5qXC_J(~mD!eRXV#1Es=~1;9tBTH*m-?la<s19q4Q~0VlUU{20c(N8
zASsOcK?|_@Qkfr1faq)A^7EpNRZ*}i*Lt#(i@7CgO?ZfMYD2!;q7^9L>d%>itK>kE
zm2Z_JiEsTZK#igH#_v>FWwGt+Bs$LOC#vK_qxSi$;6Uj@LuiE~x$=^(d~Gp&e<ZHA
zbgNOO4-y0VbuSHcSvU$IWLd3+kps4NR~`z=P2H1_q2g5erGX3OdFREl)C(V~)>jxL
ze=a=cjnNjrq7pui5kA8>|F9$H@>31c1cKu<%nX`d*(jG6kQ;J#F#M8*oXC}@ce3d#
zdo-bnB?o`U85nAGf#dQsU-~B`;9rIx5tE;QYplI%g2cCsD11LNctH5cxR4e2s;#56
zkTt^c--C@b)aU?FJ=7QlqF6+2s<C3Uv|_ZzicJ%x{zy5&t!M#JJ=ACcD^}d^R(!*K
z(ZY&9CsK_S_fKoZnQp}}@DeAD0k1I9%*HiC0}_}x)EEO|?N*JoYbIyy_mlyIRC{As
zjG2-hNbPxcQ(IinH`EvbqDiXjU))hi?FbO{fsX_Rh&&*+1ir!mBcOb!u^d>jV||Ss
z%WLddKT+DTyvC08MJ?`C*wN4J*rKs^{lqM+Li<poU+V0mbG`gfwEo4sw_EBfQ>eeQ
z6n=`lF<<(Z_VpeQ&klOmngD5qK=jTEHt#n(*DS24T|PT15fboVYy0FTeVWmQ6^PNW
zCW9l|$2uk4wq0ZGEtBhJuf0+JSvMOu{bI|=J@qcs-`U-*8=mnGM*7vPx{Ofq##FIT
z@yYg$_PW_UF=uFe-O##Okg24pnW5snEHmUI&8br}Lp|2+O6yc-tebO!5q2~OPt6AP
znd$C^<U^=b($0;wdbhJ~_WZ%Rp?UKEx>?+#)~3pbdRdacG0BHYO^bZJD-KiHs$-p1
zLaO_LL26x^{`v_j8$p4X@<f#9oYna4x3-mAd1mO-<)`sVKlH>b)Azc$+G+b!>`r>?
z2cBG@IH4R;N@4Y5X^pUQlq`kSPY-H@-Bomx|7p%l#T*7w*VYrvL0;As%^^)Y6A#=n
zL4xLm5Yn`(z)XTbf;q3~(%AMi#_m3ivAfq8d*gJ*?p|Z;jT6%tyZaLxJIw%;oBF>W
zTJRG!DBU|s=qrT;#3l6jdDRIkWoA4P5|EyV+@$G)gcX=ouXT|XzuC|-)91ZSASID-
z*-+Q-Y$yVI7ZdW-Bn(&)wy{pw#%YBSZ9|Q5U`5!Yb;2Hf62ey02z$Iv*yGa*!wj*E
zs(!Bgbguph33#QG#(+z#uNN-h9GiZKv)4=<WQo`NoMfB;`BEYgAaku!Lsk+88c|dL
z86N{5A=CBQ$au6o{Y!1)C=msu<Ra?vYbZOa1Ca#EhZ;>FAsP6Rx`<HvMGv7Bz>3l}
zUQzRG(G?1HoF#tfE?)tBn!9`yc$&L%#d!uVP9z{LHYlJL=%j`kE2sq=DkR|Z+_$4Z
z$}U{fl^h=n3y_k}Xk1>5;Y!Q@^7*3JexG{`69RF%ocp``n?Q_^eBZAV_Wh!r{EZ2r
z0ww3;*Zj$d$M_Vy39M+i-Zd=rRdsXH;QQ>VMgOs3TARcfkk%$@*G!Pu=%La4q`@EC
zHJC?&AQ5>$nyRV=(`<!}a3XMoL~PLVgmk*K%lCTwYyv-PB$W^Tb7CW^=-EZsbhU@W
zXEf#wz<=TXUP*(c?F=<m;@aEX+athB++(9S@%lspKIo(odasT(Cba^m(3(UgZRwNV
z=0@{QLv!Y3%xg_~sI&)cK{M27v$mn~goFdfyjiw$;lH&~%yvO5fm>JyGOHmU5^d}`
zAdQ0Ak-p!I0eWcj<RHD+^rsw9sM>8r*4jrWX6-4`rZW+}Lych+l3hsC<vPv^Hmf0T
zR7xpGzakYFhzCRSAwj9hPa11xN4baXS$H9c!39{F*mHxoG=o0khP8m$A`&-ElE9E1
z#DJ?Bd(PiqN_RzLU$3U8SoO`BdS49X4n^2mIAo)5mdmIw%%({SL+#aN<Q@gyWr}dE
z<9$VZUiee8!p~^TFL*GQo=DpPIQ2?xx}ZJ0BWW`Zzc7(<1IEl-7x<{z1^&L$4z834
zB8^UsYN1QyqMBBn?qC7^qP7r~HJusvxfv}WyAu)w>nBNI%T^+9!TwVH5HL<|%m_EI
ztzka!8xSyh>yTsZjZ#s$)j{=iCg19Ax;Qj6(wHjSj6jUs4y$Kr%Y=&QJ7Burm6*v(
zkl)V>GA9+pB;@50lk(D>Yo)*l=~>W=gM?HHD*B)In;@#Mu4iYY+S*5|_8tbAAxJL{
zJi%_wY+O1yATjP)yFextGMy^Ny>>Y+6=OnaR&SretX^)`HjUMdxtBKfy-fNbtb4g-
z3-?wv_LbWMXs5a5!@y*Due7{ZTHecR56c@Sdq(5p1{fy`ZO(Rf|GCKqAU0^$+z8Ez
z6@TGly{O3kYRs5ZW5(P$rk+Zd$_7@<@GTK$FJi{r8Z+i(Ry1-mc9kN{+HdIMIkV&{
z{~mPUP-C~J406kaZH}_dRUY}**s$y>_gNc=vC}BX-8hYcyhzhX%S*}J_%}Y0YtOVv
z4fA60EAV-COB&J8fW$JN%5{NE{AAh&Wa1~%n8~G8QPGG>vwB+>X7zHjwryN0&1g?)
zL;EH3j<kH+%1|mdr4h+Zh%L8$7?=$0m4+5=216h5HO9paFh145f86flTyX;s4{4hL
zV}xeKiVtt5&D5ANr^bxAnDMMsZXl{vCAeb7+!`~AHj|qXVs-wW+F+_}Cbvx3=FSo}
zX)x6`gM-d<W7|LsoJIk+v40u`d6A}(mbV$!WarytU}j_M{~nNFbtZdic|KU)>iOiM
z!EKfxpUe_AOy)Vc$ue)7#%;6zJN`{V`=bdOY7{{V%de8+jgyaBf_$QQW1;xU%(|MT
z!lbcWZ&%s;2fp4(W5B<5Qt^o3OLhx`YIJ?gSRP7JfZuac3;3{;3SDb#O?A7k?Yh7_
zoYVw<#7J8-emB$|kotsCXEY8QfbUP4f!}hrwdaBVkl6C7#<KT0O9%KFBdHmk0jYZu
zBk-XqjHHs%A~N4(87Q#09`O`INC^75Yb@q%w-tg~rJz<`=EgRW@(jDmAqn6c^f{FL
zNq-5v(@3#4Nd4+5&Ir6=mq^mco*?nJyGCNnP3i+i4Xh;o-H4(a_^sV4B1!zjh{6Z_
zWtES_RrdTLs*Zxvzw52=ci2^@yx@DCHh%#Ap*yR$r+H+hJFB;++5Qr{sx<IvPMbdf
zzsYHb4Q_dAv}(OwHNcad5s~kemQPNe0MBz$7r5F<J>XSN>b}b08YdM!SdE~|o;VkE
zj%AxS5*G*;HTG8XfRH|K@Y{*Blhr5nDqOjnsF7D$&FISf2E)X&Rt<QQ*WehC0GIu{
zn=PQ<WmnA!-e@#k8_)jlrw>T~yuu6qRmS_6rML77XwEiB1ChlZPWhw7wraoFym5_t
zrAhSQFv$r_zH0)vF&_%ojs|gSUD%ysL62W`Ap9>I2y@@lpx*5br3oZ^%@USd)R;8t
zyuyT(>&kOYSI>FA{dbC#zqG4_(CZBDymP!&6IE9m%d73G+Q9E{NiE=eDr~s{MAtuA
z;BD7fec#Zm)sN4dweNmg44{6)!?K$T_!qnNLuY9MU$Z?W=xsDe*DRA1AdOTfJ`;o+
zU2q_hpc9tNK)T?-M}kgR_<+Q2;LD5fCo?_S+b->G*Vz02!Kkw3cCob2wW~H-@KUGE
zAAo=1w8IAAUpcMZUcbQZU0LA)ztL!N9uWBM3LE&&#P&1`ll|?g)`Cy<XzG65;P)zQ
z;G1_O=!QRHa8n`yKW(I$ja8Ea5=(78BU7CbgQwe74FTVo*uHP@u|&#)iwby=m$C_5
zY^2$;@LM1o(EARcP#fEXJF7QtF>7D1p{C{1dx!5I@3o9}b5a7l-$)YqHx|?T-`mX;
z`74P0FS)ymCy(U1%2}3|xt8aSAlDktHCpB>2GIX3EF34-7hF*BD4JZ`8_SHw^9EpI
ztmcps*=Ad|E#=X`5eE!N?&JzPyBORnk@E5qw}(2*%Hs{DP+pnmBD8n*ZoF^_EbsTQ
z?hxrMkHbzGnw?zNAIzNpatnun2ksD=rRf3>a#A07nv+_$8GOH8wZVYDo!EfiHPXz+
z#ghXPKTmvrG`ORev2}pKgA(bv29LF?Djha_vR$`q%)eN+$FH;G4O7YgV98(DRm%G-
zgTJxsR*g#<b1#<03E>ZRW0o|)OGGs38RmS?u%i*4>b26EYw$&ORg24-YUMR`p1I>F
zH?#YYK_tnV>E|Xi^+v^LomaW)FYA1SIzPf|qzinxlSY6i8EI>Ah-|M-iccV&Vz;*S
zTeA5E@th=zdU(VOID%V#=-%rBf9j->+*6y2!yhMozc!fSYx&-$dLO&0Yrq7W9FzuD
zV{WNsS?$($|H2?~r_#X0pi~(#L#QYlIEBp!VZ#WeY<bBqwIaRVt~x0M;}z-ifIo9*
zEH4!<M>mR97&t{-(Z^%M)h2vPiHF0UIUxB)*V%fL!M{r+bSC*lJD`7i$OE8Bus6KJ
zZ04R}FejqK3uUe%lE}rduRaIg>H3RKm1#TEMOiEWD>L2y4`z;g+4=+PWkZvR_}6`%
zSQP&SMXoNnn6pdRmoxRErz!<4N6_7_z6d~a9c^Z4rGa1J3#t}y3*R(q0=IY43gDSe
zY64doX_m|obPOQ<8l#6X;3^q3AiOEdK>F4s8~6<;wLWPjebh_bDqUB!lFd0G)#fnn
z{E`bF&RY(W?sbz!G3oQ3tC*l%XO6~MauBdAZZT(@C~~zBfD^ZGT-2B=?v~NG>f66E
z>$a0YMjmzxgWg5uo89)pQ9m@5c)n&z_$kYs{8rzbYZk5>C-5*nn{I<JcYCf>qZk9a
zwpSzD0%sefUlCGnhLCb2R9L<&uGwSwvK2fD?;|`Fr(X){=Y=7hDS%9|a+8EKU9N4s
zxMRR)IH?ItMvj$6j+I6h2Nxc)(jMfp$AK?)QWJ>dC9r`P8Q09l#N>cPGHbjvYrHh8
zXcH%x)DgE~6o}#(67u;U+2E;pBvi7rpIFMY_9aDyXP24jiKQ5y^KDIu#&=mRb}_}%
zz<+jMi~-rt6fQP;*rcq9Y-Fcgh0(B}Q{Fd2*Tb&92~2{D;QzC6Z)v?{-1=wN^tHBY
zTK_;G&np|iWUOqr=CwxSOr!0Set7XjqO|8g>?{14M+^9d^vvVIiCZnfa3xI~NZhNq
zTqR=>YGf-W&nBci7xR&nt5fFc<hj0Mb&_(8l(~v&VVP@rnX8zW<hiP@+|6A%2E=<3
zcfc<sF5p+4)CXdUY-|HJ=kCp!b(l*Z2V#qiW5C-I7x0}%3SA)yY?dYp#AcBO#Ae|F
zZqEEuOcTb)9@m2tc{S%uH9bPf(wk1o8&i3KXqTRN?sVB+<Jrc5m2CFlBV|4#D_G6h
zZJ75rAhT-VSB(_A6;l7~jKjd68EHmi?b!y43qoc354_POwSl)7NmX_Rq`sIKfmjn6
zNnwbDLT&&`pJg|+<t#A#7MH&qm0w9DLw;Fgi19}j^T5}6t|o#$m`E<c0P2@nS~r69
zksE2unk}o}n}+mGE;QXi%{`ec(v&CV$gNpzgjc(SOM*4I&RLB}&+|VD!C&F%%G37n
z_j0?|k56UBPF==M(aDz?TXh**MaHJtb4oH5_~Ff(T4wCjWh_lCGq&n7mZsii_WUfF
z3jB8`HGzltslXO+k&~Lho|B5{aw(`L7tv0IH^{ZC3m$&H!DWf$>;}lSqqB5@7%vMc
zj81~Oz*LTrT=r~}nFK9Awy<c$u#u9WV!-{KIXSTuTkR!F@ucGvQ#5H;>12Vgb5aX<
zqm$aen~fA(5UHK*FrajIz}<~h-_)?<I@izvA~SZVq&}D!flqOzJz!O78T%-`!ezC9
zlvw6sKs2iztpO>N%k&ReRa&;2_nI<Hl%)%>nz6K&j5zd3`}TIz_)RZn(M~>Qx1Q=Q
zELIE;8OyKjI<s-vBYAK)=34#}T}~JHQ74T9HyJ601gQrSBk(&@7)gCEG3JJpc66|V
zTrr&TjL$NeaLc3s_*z%j1HR5k;)}@viQ5w&MY=zcfD~fu#?1TfI4zg~2@7i$wTn&A
zhg{$&I=-GrrJ!O5t7F`hMCRcLde8;+fe5Ubr6K4H%Qd?(*_gY!A&+yRT;%dvz^e;p
zC~KzNnJr@S8bSt~HCrohG$ECmpah%oExCwJnW6)6O$^jhR<UjHuvxIx7SVj^R)IVD
zt2=Gr6-J8UNxdd90^c}=k<@n*WA3bjP5%jQM{|L_N;UBJ$ojwyMw;1}oE(t2J@Ng?
z;Br^k1D<B2&=N?TllbxyNNi(1F9Jyj=H_2&3fJ0oo5suw_BbYR4WPZ(?du+C`d)6=
zDm%1O-KK7??QQ0y57|{G;^2=a2LgG=Qi{UMJk&(p!v9W_u&o;~T6$pgPP>bwnzh{a
zCg^}<67b*M7h`1<jiD~dE;{+=nt;VFs0~bUP*ZcoYVt7?kV2qchCs0tde}<8wY>-+
z%?3E`N1exjpS7d7vDuLNvQcG&065Ri$3;d`95WS0;4yYiDl(Gl_`$EjUk96^OWfe*
zax;`;?^1)<@gp~F6o@erM9(udsIBS#DfuBTXdK!5`5C}*;DJU8+Y}^{!to#2{ik{P
z#!DNDuI&aZ-%Va2Jzy$w^QmUxzHVs`n2ax`Asv(X0nb&`VNGobDR0VexB5tLl*}7|
zKbGnWm|pzsEi$JN5_L`aGbSOK*`^wjd)sZ3l)|Tocl2&v5T^WJ2%6D&!5}wDX}Kt+
z<-Yr%Rl+@9!NWw#Z>>l&D+d1ANU}3^%j9&Tp5pb{MpO#A!Ydd+u9=P5hYs?5ftc&#
zy@)@!>22)WjJ`bAjK)!eJe$&TZ7;S`wY_x1`1gV2C?Ex>brhoB<)Ye%BA-n6DFdyv
zW-}=lByKv`YaLO6m<tQUyol$UJ+Do6<@sui$aAUl@@#bu{h4Vw*u6JOQB$W_Ol7w;
z?x%aMcA2XPvNBhPTt|C<SnQ~uVz;hvmM(CuliI*H8)=KiCHG%5Aa%1-^<5iMpGnz)
zpL0gdPU;?~YWBRsFz{j**8x^DmaEJA$>0YpyF&&ioHPo&)<|)nB=ye32>jbAjHK>%
z#$pmy+R?!da;wtLfK-xI)YfCumuXwKpa(qMNo^qKSZju2j3T$N>|g>mlMACax~?uT
zm7^FI=bW}M)bl=em1z<1#ZGDiR~jkS4XLjtM&M7UFgCJ3lpf$2JHVGYsRvx)q+uYM
zV|9`Gt~2(4KXFnAST(JT)diN}`JS-}T<WAzG=49UfT#(FGaK38k;dQid`%!llife0
zpPslH*&ny=NGu;QhygVV>a&dHF3&Xv{GyXu!0$V$m;+s9w|?L(#a!+Ub}Lyp3`D^$
zjS1aspTGa?x$@sLuW9UiwH!U+?pI8}Zd190MHp+o<54Os8ttPda^~p^8~P`~4&2H~
z9pKB16oWlvsQiPhp_CE$G$*xzRas@wH7&#Kp0Nvj?JE`rr83nA{;iX`z^^%J6!;?}
zMe9l3c7}@se#uCYk<@R`az^0pXG7`&f9|AF-~s1Et|*SwYtJX|C~#n;$VlpQiLsIW
z;ib#nOC8|fdHH)l{Gj4HgR=a+y!<;Uqiny*zw@3GKTm)&9`|DQfE27I7q=*=bl*Tq
zS(A%f$pOW}7YAJA4rl?N=?)kN5-xLePx&(ahhlLD7s+l^?w>MK?ykL6V(zhu5`0JW
zloGk~68G*n5HFXRxPz0Q$PD<Xfl?xOsDLMu2p<(yO3dQ6v6ofOT)XPJ4@_Oi4i$B<
zy|>Xma91PEY+N)s*xM4%a=s?;a3iS(@G(xCKLEedY4ZkPDp*e|gQ-M)oA4pa^FzA^
zTjrb@+x4Z^T__`%`jw)+)vEZ?S4Q^0X83JRn?C^G?X-CV@IRlM@`ATJFVaK>@Qp@N
z72tOzHXya9Y>n)Xc1HV9Z&EpUOKIS@m`B749QWZw!iTs@bAmhOKFRrC2DkE#w+|e1
z=gu2|akAtD;$&4Y*Lq>XUn}({qy3Ftl?Hx~(L~&G^ZmHjfmEqs>OxiQW%aSI*US7t
zUN6dbs5$>NsS;jikou{sE6qw}eK2JOZgf%;c(0TC4;cJGBK_3hFYKy1_p!m|V7n>}
zywV4v{wW5}sIcX|hBz*ZqQ<}+^NEUsa-NyiC2Z&YcN3U;hB1OKwWzVV)}rV!)m`8p
zcx8^ww2Irut}-bEZt?<-0q=HF6G%I$*$CUoY^Hk?*+6X9uPf%pD{XVuqfz<tzkG17
zSv<k=0kdw0c)nztc|&{4)N#Mr(7$B&!%#f$*)k7xmR##gtuZgPtG*?!uSJpWd1G$^
zFEo<u$ZWcb#AQa5&z#9uGOxL5i#-RBu1g|-bR|Iq9mc`lVKjmCA%U;#9-1`q2Q4ZB
zABlf8;?|9=|7<4ZrKfu#__W(7+xh&WvsJ!a*45UN{groe9pKx&lbe|RdBfjIY|}})
z)>yWc13KZj(CkC^96&_&?8YTS@hlOPn>^dZZ290+yqW8O3De|pAP@^>|9ej1jX<Pt
zqYn$j=`<itTXE^zc{RQ*Pk(;QiiE6Mh1~qIF$X3R$=xmBzf}2h>k$TX%~yL)vG}^!
zuDeO-%W7}o(*2(?rO9!Bo$>81Uz@sVi#pESh<90z`|T=~1SGh3l~3Vbb<-BxG#-7r
zN}PSr{;InO&X1aej`x*)I!5}WnqK}s%Y`yozXK07L7~Ovq5?55%uh`i-F8i{yWR9X
zIwQ8^LL1$<^v%FjmSS0tYy@c&MiSZTnl<@e?4BDT8(PIJKqS?A08u-esBPu@uima9
z?qxS;H?FXzo2yHAau-u6)bcKJs37h?X#c;qvF|qPXOthuBv&e72Z*z3>gr!@<o}~x
zr55NG*7?k&nOnGz-Ga3`6Jm~|G$uJ|T2gij_uGj6h>z@D;Gdk-2L6|k;*y-yeitkZ
zCdzI+aGsGOV_ty&amHOt?7^<F34E@TMsjr+^CD;I0*9T{2KI~;O(%6-Vw_I=5@+cE
z+fM2M5jazp$6XRhda<U*ctlF~1w7HEj{*^>#<vEflKA2QM)Qz`p*)w^Rd&39XFfOH
zk~tLc>o1I?`f5eiO)jeg{0}F!fmK;GJ6@Jy$x%_G#xwYhMw2Zs;OS<VvVqSwnlvil
zTbwis#0<?DJW=^)uS28q1$Grl!1L$DThieJZ*tNo@P_%$^*V!_5(#*plSYBRIm|Nx
z8w((f0^f8vq(1N+P8tQ?>!d#Lmrfc5zWRAC3-~4{jRM<8I2Z7ICpCd@f4*}qJ~G1d
z?J6z=9_`iGry9SINWh;ssX6xrQP#<J72ls@@V$xjF@sCJuKRgi*NoCvJSWPYu&ai{
zwdV1^wrgF85c5QJ_*x-}RUS8^mm9n{k^a%(HxubQ27i=Dj~M)IB0XksZ?jd}!F~o`
znn+6x_7Z8OK?*4u-)*E1CayaS-kC_BGdR<`gwfp$9+XIj8(fx12V0wXNopHQ4AN}G
z2%5{L#C4~^uO`yJ8hk8~{$y~E)PiVdA5J71)z=g0+Xnacb~d`7!9x@2FoVY@Qq$my
zMCuznCy_2NcvB*+H+Xv@eZt^9iFBXAZzs|Z4E`dKX#dMnmvFDag{ft~%wQ*xmKz*P
zB;a*Mn%TH|-k|I{yq}npI)z;g9+gNhHh4lJEi-scBGH??Es@?~@PmnTr@<d2(oYR;
z;eF2N4hDBmq`eG2E0GQ{ctj$-(BR@kdYQp{z5g1e|9Y+WU!%akGE(r^n=SFq#P<P%
zsh{)V>P^<EMQ2+g^>m~3bT9O7ZS<u@Pd7?W_s7IF+d93}`4t15w6{j~x7kkYFTK@_
z)3zo&e8z7u__jnMc-FZW$MNFp+&kkp7Ty_W6nL9=`Qz^>d^3)3(kL)qjsoNOCOKlf
z90iJJlDQ+a$EP!2><wh?TPA5+@3m6MQspg^R5(+LK+Ig-*qn+T+|^^adJk{)V{}lT
zb-#|`*A!x7I59=j7#@3t$H`dfv9Z!)W2MK672)QJLz@;qTt7*IR;|lK@W-q~fiW*r
zAm*hCM9M`Z1Y%yYK+MY)h<WJ(F|V#It=6e<nZFFI&Z%x8<+&K`8RGS*+Y7U%sWeP@
zhuy0?5{Il;+o&%;j<#uXK<cl3TF?QaG&1IDBQ;kXsd+J&XfV5&(Kxc0BXf`GM&0tC
zc?Xk?8I9)`a+qQ;uTWP!&D?U(X52%*ui6wPmW0%Id=AqAq98KnD(W54w;2uVAUWLq
z@DX+v9NK@RSr70jHa(GU{)zz!rbN;Y({a;l*L2NDf4fOnx8&LCqUJ-!e}`Mu1pbqg
z+Q4r(sr5~Rd-^P^oreX2zTml<Kyrtp_&>1wKTmwQs88E144KuqOg|%EL<f^bW{PzY
z#66~tb<s+<`d;g4XEYWRx|kc%->Q3wKw6X1XteL&OmrgaN2V`^7pZ^q{=Nf5X=KdR
zMry9OK4zIDGBd1m8577;eInTeu5nTqc$brk8N|2j7Tu-#hp48B)rBef9<uzgD5QSk
z3Ohg)M8;f2y(dtD4B6wz<M63PH{U9|`Bt8bnGS2{Iu~<~$+CVdF_*(VX3sMkhZj6d
zqgUG$xbC?$<0;eR8I2<fIp453?jt_!9R|*`VR-Mx%-Ij07L1%Vf98xIM0nHCyl2~w
za%A=+vNADYY^+R77_H~0SqO95CpR&n+pF0}r37<)YBUU_P{(b)P;z8!znPab_SkI6
z_b$B2%!Nsd>?}}ZrYu5YE`|$)#GHlcijdgDV6q}4X0Hs_LdtyKz=E`9X#z1SOl)$q
z0x>r%5Hal(uc#&vYXe_yZy@Ft2jUaitkZ0a{+d_e*rNvjWLIUwI4r5#lgVA8Qxe4g
z%EgbCqRQuynDBeg)&$~R3CG;GLdrcWq*KkGm@f0i+=arGJ5Wfu`!-_~u9959ZGFwv
z1U|({-CYbG=cFd3VY^lAq%{BOE3;-zX>vQ8Ci4|`)h>%|y$4KET{pIq-8=mMf~V$9
zOvLPNVz!o_sFBBdvk%yF0BLW#B_Gg?&xvNgXwLye)XN8iXVgFcJ>9ZjWY?ON0OiDk
zb<^X&v<XCN<;8*m*FN2V3}L|M8%d8tfM1x{fJZyq+Ec*G5*zSDBgGwlQk}#I>`q}M
zbxL9co@yld3<@Npqzh${2gE>Z)UT(2F;duoSg7`P2Ba`j7=c(A8A)N0Faj&~o}Da=
zXg4EZ<TUpFKa>8yspQg#ZcPy(S-~3qy|c@VB9R8X!btT`e=f4St36`}Sj|{I>RDqM
zZug8`;Db&Y2L9MdUEnK+B28NW_)??E__Jn$#Q3blXkz@b#t=fKYJp_av24OK7#Oy<
zt<SNm4oF~L6W2x$zQOqp8}I{4@7*E_)4bp>IBos_{IM<JJ8bYN!#yukc}@{Ge$#BN
z>7OX$?&hx=mJN368_qHee3}(TJagX!2}&r$2Pa6}QspG^ZX?PoeZZ5f*g+x*${i$<
zzyX1i1l|aoBr5fHUr~RQ?rk%olO*S+2@>15fj!`yRFF+Y>EuyqS+*u+<4u0y0^VDd
zM&eNOf$#zGM6fRRfbiu-6_VAtUlv#akF%@PG?1^Z$OC-fBkqo?&mZKKD16xZkM5x+
z@M}(LyK)12TFEGu27GRM-HdL7iTryP-2`HY*tAO~T}p@|{3l$wzM6=?*CL%S_ozwW
z-@9YvXK8cCNcG$`K?G38nj0&zBQWOm7>K2L#rzNR_*9T80RPz=X%k2=%PD>!pIni$
zf85G*PYMelMU{+sL51{WiYaVmd5T^4A7<{}LVmGoM&WRo(w0_?;n-hzWEAeo#aC<d
z!Bm?YCP)zb5-dPmAyu@YuGTk9U`VBgH%!#j@P>)pBSB`~QvTU|@|#qjKzbs{x4zDn
z^>wzaud`)+oh|E&F7id@B%C4Jlx0nf<|R1Ma&_Fr7Yz+aAZjc5-HZu2Us-f9ej^u4
zPHIFdDQB5!L*xE-l_<Z(;0NtmHx1|e6VFfCV5c5y`U;fqX+Y*nzzeMI>gP-QScd&P
zWAh+`hbIz{od+rIu!%){jR$B0m%5<tsg~<(yVh)i<+=112WB6+|Lh~5ImmNYZkY<d
zTy5yhNjDa+oL)D%P*k^Bh!4KylH0(Cj5M>cdU8NwUsu-#KFdgfj|Aq`IPzAL3#-Nr
zc$vx4{sfGuy7;=t_}}1Wb%7JsM(QJFTf55$E_MQs_QoaUCULqEYs$0Mbgy$8n!sC}
z)V|f=yPeboVvEQ=!_;7Wjk=GTfUmfqF1gNgBfI8fzvQ_p!ItN)-16)Oeu>VcXqCZN
zCDL@cP^584HVRr7n`=xYBdjzp;5%(-s;}Hr?C$G*0BZwpGExXu66+IRZu>jThIe`K
zn(s6CkwgN{o?g&KyY(4o=>k7%r24|#Wp}@tG6Mf;vl;KVyZ@3h0>8i6jQC)G1LAk!
zv5Caa{ppExp21fo(hUaRnn>?9_~k@0R9xmdO9zN0@_CC32J`Ly(RLN$83PO(O~f+?
zn084bo;Sd_n-cN-0p`8mh_Yw}VzE|Kx#qs#GF(X`X>@@<b<!yCSsp!IAaeql3jh}z
zR}2kO|CaIsxA00H1@7RaE^rSg;T*HM(ZKqLQ?Y?Badl%rEQy{VmBcgb72>aPPqct|
zL}j%Gr1o{CEg;jB$Vlq9i4lk$k<o21KuM2uQ-*<<By|qN9+frh*74)=vdRWhi;@?J
zUt(TTzi@*)K&mV<lG@g5s{^c-Y?!gz3rNYZUC#dltHl`cVqmB+0<ls}85xkmv%(0(
z%E(A+SGRctShabiu=#st{lj(@_W^(Gq%q*pUT4dJluXt|K&nK(mkgwM!bO=zy&lG|
zHTdO3BD_+UUaYYmGyBp$PkSG;FR5#zZiUNkqmD0;$|#RI{8%&aFErUysZ5;9(lt?+
zO4kHlV;0P4T-m^c*Sb|rAf_lAm`WF&SV;9MTmE;gnYziVs|loz<gwcyO*ay2Rsyek
zQi5{zZ!2<*<mzWME?byq`=Dj}v0ZiV6O7s0H!eG2)@7R}XYDs<>qnoy=X4@aH%mlZ
zA>Y>^{RtDjmC!F+C||>b@HM-!wcU{A8zfBdTQdfbuxgj7R;lFuW)w{=cgxJi6*Js2
zM9FE9g|lih6GQ}#JRG965F|pPwGbRNkC67VTBnK3YW();YsHTQF4CYA9dskmbJyo`
zD=nRm01F97F=jTd92$`LkvE2MAl3vvOxejhxp5!`4t!5!nlR1qu9bcv5J_N>bOS&-
zi@-<X18#8}$k&0x43`AO5P1{=f7bLgEt86BsYT$ec1ss%8w{hQJ|xgbXlPC_UaJX{
zO(y&SyUvy~OcRYgYra9l^nid8VZ;(aTPXmZ6B00$>B<@4G~XWvQe623)>QU8+#grY
z0AspL4$8t`X&F+CtThU%B^wac^4W*xfCP339}ta!FG-H*RFh8?%5)z8GcObpFoi`i
zMa%_N7K#X@LMyj&bLLv(x!4;~7kKj)ky*wD;9HEOvyAS5)EAwx3;d~*`oLd1X&CtE
z6mg`U;k#2^;6f+$rz=4E)N%)ieX@<XagxL@+>8zo#et8+p{}w6#EQT-ogL@7BU?aJ
ztJhlYwRgKAEg%XaW3FMDN#>i-GC%{-G(+~Yz-Sd~H+kvNq>Ny+2F6?|8t|zoMex_X
z08JnjD|?$dC~q3VoBOyon?Stkywj<E(8{e70Pqjp%RS&5%p7F{W2zKwz5C#S3L_Xh
z10x9>qZ0GK<z@ihmgWzvDBa*nKkm*N2BJoEZkQyowL5AUh#7$|x8qi`<2UY*Ht?yg
zvU!lfV-ksPR-chb!1IhWqjAj;c*1E{Pf~LjRx@V3+041kt}{i{;C+_(oZC7E{8E*V
z0_^UljRN@;vpgyRQZ_k)JUJk7UCLToTP%lbt;ju%^_VK%Vkx@lp2+oSFLR4rFYu~n
zkHl5t*;hJC7r4<$qri_FDfY^w{(h?{uI9*fDZYbva;dCxQ>Dz<BI8Hgu5loi#O{m~
z8f5zC<uy=>A4dG&nRsoBU?fVzSTjii@pX+BVOO}VZQ#{Ll0B;f1|<GI@ge@cL;|MI
zg13M({m8;)Lvsx8Vpo~!0Qar1J=gHzi4Ay6h3zE6D-+w1R?#PTg|~piMw0c_(BBx|
z;B3WXrPBW%7puM8Js_@=lkh|CGM*>N<9Q&ilc58M>q1r%ANC@R0YB-aCU6Tke+;;{
zlbXN-oYVvIF>x^ixWKq%qBb-jfjgxHz_v>p1D@riCh#UFjREnw=mZj<HRl&_Ea4Zt
zgUf#80V>`m@iQl0GdUo^C-6gd5=5bN#FGOO2bp^VCkX;EaFTdgm6HUq7&u8#DM2O<
zJk1>~#*@HrAv+1&6td_2!?jl2w|Ov*!k^q)OqBCnTg%$T9{Q1+Hc`2i>!!hd&OEWb
zd^BU`*~c6c`1Tw?{({}!amsDkKgbK1<<HeUW^(>)S6LHG$AXh<j!xfbxoJ;z&voFr
z$u)I=WRsT;HcS>97-WR2<{a-vtM_}nX>@_VbW#WSTO-ABEH5syKAkcG5g;ciPXJei
zl>-^V{>g>4fCvy_O>k9M`I|!s`??Do1|mR@hJvfY%3WiG!7Y2dz-q>F>$WjFdTbB7
zO2hy^W2Ab=?rnFU<r&++1D(_azTHV}evkn1HS@r`jQd|bR~NW=>u7JiQPlpf2Bb8=
zPdRB6_-P~6%i6*2?&BHTz{89r+cQH05}OjAA-`b5S<X^4%d_p)2b`tp*$u3+E2kG_
z@sP9JWrXkBRmu;PZ}x^ib+^G8c8%pHwQYsb#BjOGzyo%beSYANoYZpYf_g(W8asnh
zV{tg|$0l|gmsPlBj@^2Zvvh%5*{+F{8OUyXEHkOEB}P-|mj_HN+qLp}>N&o5`)k+P
z0se=P0^hSuE(Z$5VZa;g)@*sRZ|ldOzTcd|-y7w#ZcGQrE^T6V`wURzmzsLnYTGb0
zOFy;;rJrm?_gj*t>Ez9DmNvPtv!>y`&vb0GD<AwL{kddAuJFxv3xC&0-^Faf5Sa{N
z3l6H8AFZ%l<8}?xHWI77ctu=w3T?&A_hDmUhftauu<I+gHt=L4#n2<QE-?b%GKG=U
zhZ1A%JM8#(FHHxC8dcgEkh;WWb%2PEjJbyWEdv5{12{KKY18Gy2U4p*L`8Sx!fLAj
zV6)-qWIVavn@G6@<U;NL#sZFUeACr+f!{JxEKP1inXyxsv7B){Y+~p5&O{e@oRj*%
zaU;pn_WDT@Y}m;}4|v&b(ZIl$+ltEVTz&^gzWNxs*@os%+Esr|1bm;-WX$3xK@Qp`
zYSyp;cb*byvm1x4{q&@M=kxnU`8T_&Q1Di}<lM`wV5itM$;nIEu+rf=={RuM553^M
z|1u4S*a%+Jz3f#8Y9r`NE~t&5V_i_unea<zKQ*19a!Bmr`TD@;Rx6PNznLwS4W!a)
zEBi4s@gQFt^?-|<)Wix(A#PY`2A%GP^|0ajW>}50N_8WsdycDX0S_~h45e2LNF=jb
zrCB3S%B+z*7%(gCt@VJ9x>-%&V{VqL|4HoT>!2p^C?^dA-|nOq@Gc|ChW7Qc`Tgk7
z=Z&zJuM2uWHVC8-`?j?Q+K22Fyx0Qgbh}Dh177Q-7VynZ8Uf-@*=qvU)cA?1#(^ma
zn!u}_s|CEyNh7x!ob92~0un{;4+xd80v==8ofiWAfVhCJ;LM~7c!81RVc_I|1kFX9
z@Wf#<LYVyC!=wcyG9-HI!lYG($qK?`A6xfmlbtAQx<$uFjR!swXL-f00KUdaT_ANn
z)L04p=fw2`gM@)hY=9{uys;4m(%^xFfrKTHFc4Y56cH<l2x?nG97t`;nifbs3l}g|
z`3kE1bg%L*kXoMExT>zoyVF%UEl`RG+~3=08%X<<`dD96Z#}9g`Oy2(<cc1yNG0k~
zq7<CH=`8)IN8$)@E4Q={tXO(ujin=4O0COy0!+qx08qu^9bhU?pYl+jA`3`;R;o6Y
zx?h&MpO^Y))>%>m(rSULz0~e^il9BC^+3ta;WCoE^GJR#mfWqPsVqnKq<47BOWDgQ
z-8mkm%ZbjUZh2l{Mu#u^NYVuUr<2Bk=eiG?=NVj^NWg7;ayFj#Eb_Po553t-Q#^sW
z%KEFVTu`&jRV=VRYmxc|kJvWwU!AlP_$McgTyN^$Z&#f`e%|o6>?(oqZG-=oNOxFe
zeax=2WK;K5a<q%|r;I+c@v6zeS1s|4Dlsot-J<6sRuTJ}tCa_Qy}Q2;Wb!MI+!)Q7
z;R>m&k<r|SnrC&)XfE`a=#=9~hgP1NbcYGlv0mF<AZle3gC>2Kb9Krl-6?~<L(r!P
z@8l7V=?sQ4UX-SHF`Xf<c7*Cu8d{`qm3DTqbFsI?Zf+D+%4|(~5FlNUbow_=kf0M1
zKH!Ac{3!5BkIZ2p!4QV@JRAbC42WTBh9(;L4zkivU@;{x)v)Q`!rN^-7bPQXo{NVj
zm?}H?xuHTT%^WLb7thqswRmNAtWBr%{YrfQbn~ec_?8J~kaMiy`mPapPp{gQj5*YL
z-786@%H^osIjJn)2*mtKv&+2)OSObg#3PTF=N4Nl2twBZjY}HOJ7DMi*6=qpf45yK
zse|i3Qbfn}0uRrzMFyE9)I6fO+gP^o2wn+f^16dgUT1|x&5c{k+H+6_#LB$fNKKLT
z|E@=T$SnSzm$M0+<%Q_xM%H>h7j=k?A&(t;k^H~MV~r=QfLv?Led&|Tof~+7=>8wn
zIz^`28EULJ%7!_5Rw3o}L$1x&Pbuihj97%trKvJ<^*PHSjjP0KPu6p}v^#C=`l4ND
z$>Fw(WWSvB18HmnKIEh(kWObi$sJ<-;US52sPw%%v$&7#A@Jn=P#w>7HX~QN$6QX`
zjD)h1FNAfTu{PGp`DH8mfzeA(BIL+{FP>BN(38kdK5Ra`^x>0`k{9xSCMB<j-<dbC
z?a9_dp6|)m15IwJ?fb}xw|<goBAr4YvVdZ$RWpKby=^SetL&=ggWq5@$##=L|H<A)
z8`#<|N|5!z9R`1IR}}{Sle4vFZXa{(WLJ?79C6Y(@S{#@zr-HIe%h{*5%?7&sY>uJ
zJ7QV;sRqwWB;aZzX-@F_65GcN-knImuT^q_cbSuP8oVHpfR`Fcb%Jk8Y=3L;qlpCk
zRwXC+k;L{3gM01dW&n>elIjF6OKc+s|2mQ0Wbmzt^iG5CP9)&_jimCU^7QWsw!wdr
zU1i+>BmiZ@0C<)KTbR3&xXy!d97s^g4=_y*Nc=YO0bgOEC-OE;Tw{rQJRZk^KTmwu
zPmpMM_>BXJ-=LQS5iHFBxYDu)y;m2pJD$gGC@;ZFc#1qA(HZziyvO5m97xCp`$!P9
zA`eK+26-e1QQ-q#YC#qFNW9a7ZX8J12E8Ocn)rZsSLKoTb>aj5*-1?x!7SDRpKWm$
ztRpe%@i`8BrIVV#4>@W4nLEd5Wqm0-Q+byvq_RWpr67-pc;!dtC9Vn0TRk*;zqC*z
zRAh7XI~E{+_Reh-xUJRkR*kD0hwXn+W8Y^O;e~b$gU3Qk5H7M8aIKN<u&WqT#zXH1
zc6XNhyZa1-FR^P-Kw?Sa1NMwGLz*J^jKl^cqLl4gyG>MxZN$REp0iiRLXTM3)@!f1
zi$P*S+({%Xa;{z(2|Xg=3g>EGYmk0TWC7{o#MHdnziV~-?_S4!V8?r!F(5sTgcK1#
zXCW)BbFAOE(7T={a3Xan8z%nJ60c8uz%*!ffDE3Z6L^7#S`$b&C9P@01m*ppd#4Yi
z>1-tv<puj+(%ARw#zRBWVE}xBH7?nAxY*#=5()TwBZY>X`}Zs6*KfFgn?Rf?`PNV1
z&PqAfPms7Sl^6JNBZbT)=$PloJaxhTGuM3dv|x_B--$;ke#kbRtr#ZZf>}rwQZA|{
zsQNZso|%SC;N?b==UwZ=i!u-nNCmoUg2W+S@GkIBBW<JK<C?YhmPsicwC6c{^92S8
z8EFkbYFB)4*93`w^m^?8sbAS~`?}rzv2!&Y+H6*)215qvi-Ur)H}2%Uap21<W3@R7
z|A>6xA5&wxe}cp;FM9{La|+D+CrI4wMOXp!qBO>UcYCQ;04t@sf1)haiked0Uwm(h
zQZZ%H)&{P`<}GgSu5NA<h#@kIF3o7?X4FmVumXolZ~$NI?X(X>pH$P0b?cQIC($|V
zTXcOOOPG*3ujA{ij$iNXqzR-2NWS}OnnRQ3Kx+(qB=Drf46ss&`-<8NnJGlY;_{P<
zx0t2)M&>iXU%ThVfGoAdzrdwFsPuu$ozw)<?Z}`4Oyf)+c)5rC7?2)QGy?H}$O7);
zK{XDn_-9j{e>P3z{*j{R_4xtw&K;>ffsBpf>J1Yl7#-zF50HUU`o|67>uC@e4uuy;
zhZba#U_cZ;Af6DuO+Kbn3cR7Nz#EDJ2Q_(-@3f+RJ{1{AU~Ju(d5VohkWROn6OoTj
zkT}z;vjeOc`DmSyj}}H&luc*q@7&a3Aa>cP^ym<TiUE(;8Sr>vK+Q9XFPg%Nut(~I
zJyHl0|2$Ikq2D!e-}7>GfX_=k{*86QZY+fT#Dx68uKHWb`X%kT`_FsM0OA4@EBoOa
zC*m)%hWmMwn36enKixc=EmF4YCrG3zhp%dBtbs2VcA)hcERic)F(>$}vYqE*je3MH
zEBfW)qj*67Ba2H`Gy1dz%>InDHsBs6Tn^1l4oI-@5kBBi#;4-Itc#@k$_=Y~#xw0Y
zD=+xKbiLEAdI(z=WV7~#@<F?^mEGAl7r{FF2w&q2v#vTXk@8%>FtIGrv=rc{dbSpD
z4<kk2S%Nj4`p!s4*){miFxH6gfN9xQe*XV>oA)oVYjO#cmfe}wB@}jV12Rzr-e5<;
z>(A1D!ZQ5GGq!=hG*b9%28rJ#zS$;tfgeL}1NjnB$V%db#AibMvcI8cy7cCA4IZ9I
zz&|@_bg9XtkTnnQ$Bp|k&(%HOa$VvUb?v5K@?4eAH{`i1w>-Ono9%kLU8P#CGM%rU
zUN^Z=q;HIoje^#`MP?#zOQL}TBh?21W-m-;0xxz_56ISJcs=mlcK;5$*1j`n_ZkZg
z$Yc=s4kwKQ5h<+)i1eE3CCqPgLG3bE(fuA_+?XLlC9vs&dO(i2O0x&zjG86q0Vd#G
zE@-T@sCZV7`Xsn8I%m<-+or=WWM69(8I4Nih2%U}*sIF(1)?i5aF<<Eo9qI2+alhp
zkGV2qC(kIu?TwQr-!EmpR!zR^i+n#f34h~_qt6FOF;up7T#W&8p+c8%;McgM9+Ezj
zNOu{0n!iQT10L(7Ht>8W^;Q|Y+^(t;{GP=2kin()PJ;yEN`vV;AwA&hoy))bdApN(
zcN_dcBK@1e|4t-ea#s;YPtINAxNA!<&iFP4pOHvFd?cX^JU4M|&RsVrwznJnx|4c%
zaHbb=9QZ6J^?=WJ(l`)*i($ZPoXcIG{5%ePAaMclx5xtGZ&}>|pM>ifl|>LR1?niC
zPlAe9wW&j1A(O>wnQJU>C^U-I-U9slzJ$G41f(9r_d-a#-m9h!^eWQtijbJ+-fIJK
ze~?Ea)kPafGYEVns1>mfNP`G`B&aIk15#Cij|7z^d_deC_;S}#P0W+z_%06ru6uKY
z2Er$&gsbcoMsNsa6Rx+LyZ+AIHbRN`9<FdvqMsx#jNjh+apB5M=L3w#xt&d5+es^_
zxL<h%uLM5b)Ja!=OVMTXCD%WBJ_cmBV})r+Vb?FKq3G4~TwBW*3GHhH<o=@>R=MR$
z4Sd*i)6>fwqO6f&YJ{j1t~?rrRJwmSS4W$mCzJ33rcQ0VR96JG^e3pJv?424$54}G
z_w&|KGhXJo!ki(`S38j?JJo(^Wl@uPE}atP+3KcAG%Q+`6on>3d#Nd1o+}h2&sSTz
zaxCl9yyzQh^yRrK!ANczXXRF2lk~3yrzoO~)J%=;JlBlIiw1c%rRCa)bAnt%)7?-p
zHQMrA`m3sWwz^+hoojv51>Q$>fxFoe_c;9|#S3z>5(C~gg)uJ=8eZudI>4v+A^P!B
zd<XHPi3@m6MPp|`>YBuOok2{i+2F;lQ{1i=aC;Zj17e>#qctFPfHSs$mpiEk#F&_u
zR5GoXyNu78ZRfJuXuK?ufUkB^x0GFUOZ@Q3PM&KF*{@2ZQcy8rX`A21+<#5rwkAkF
zUj;^q3{)E@Nl?YIQU#u0$qUAske3AhtNTV4wyiSTbO``{z1!Qm$>6^v()SJi(n-zS
zSQUn~gq|#Hv1^@su?56bv42xBNMq~SrcuR%cXU~!o3rA|#D*29tXc5iW{N)UMQoS3
zint-yM$a`&E{Z9`a30COHSVq4!Zt3uERlefNPZ$gx_yHr?5Nw)S#Mf?=i0i!@A%6o
zqriuaBu^f0w8tEf{^;CY;9NhuU9160wH?%c&jpPG(IIND&(v<?Iy%6lmOVCi*5|C0
zFL51h;0Z<wJBlP8NPO6kq!%IZMU#HB=jxTYiq32&E5WW_k`@qMv*b)s-Oq`aS%=H4
z6SB)){t`K&k8!PC;4`<5{;J<r;WYi0e(<{u+`&k}g(NryE;B&jvyHD3Mdummi%BZ*
zt5vBau(4)dd83u+qh7K$@H0jV29o%4;=9aLebBA&x6&Rmk{&z1M*K-S8Pf77GjM_l
zewiz1o^0^^L;~LLq*45HgPSq>xWQelZfd$MaxFL3ZNukTFK^7+Q$9=vam+;)=90f_
zEOO}Ngjs7BhV0N%_M#`7XO<o57IuNJa8et1xsmE)3{RRR@&P0aXxLj1LTUr|G<NA;
zfqNOLUi@6Ud!c9S0@JSMC~!mK0{+fPqrg8IDQYCe&p=6a0bgN@y2wbXvV&rR{4&=N
zCd%G65EE5aXF%#v%OEZS{-={VKs3j^q>>#)?^fE;s<Wfzc6`#6wt&BJQV)ndGD84j
zjGEROkh;v*`z>Iyw&+!{cA0A&2I40bKkU}tofv^=j*O&GF5w2mj=HH9hVW{zY;pjr
zhK$r0GE!&ANR2~AazkVyRX$7K$sEWJe@OwJV<gH}GebGs{6byp^b1M5Saziun_rGD
z@*O!q1_hTbWm*cNY94pw+GH{e_vvPUY#{<EiVQAC-f^0nQw8s^#NBoc3u^LFm$j?x
z8%<x@<L?65QPW`Q7Tzc`cIq;gUlb}cw(2sL-z((T$6n%lTcg0GPAVoy`~b#gSWdCr
z>4`!Yc%ut0+9S7aah5Ld9w!xj&I;QkJJmN0o4_-i)CK;xO{Vn=k=6QE{4SfDectD}
zg|fXe7LDp}!fsQ#x=80kt0()kuM51#hB-NFvvG3P{Bjyr=IzwvmCvj{sl2ZDHEv1^
zc#o6%z;8RL1>}Wj*+F^4?lyd4(g*I~q!y5`?MlzHev-tC5+AVTq?N!^oYV)da#9oc
zg4wZ3#WLWzPHF+)>ZCrfGMNM3ZCt@v60h=EO8;tu*C!J27ALiU?{iWg`1ej)$tSf4
zg_^yo%>)6pCvSHG|G{f*97yd67w{*EtE|ZJvLaX1ROAM)$XmTWRse5zQVY1rN#npT
zIjISx_GHTmNWF;tKx##*Xu~9l-+Aq>0Pf+Q9tR%aq!qv`oit9}QhTBk_*Um?QIXW1
zZ~;?A7QJU)k=k3FY!&e%uaGe+grJqt3wW)Ua0GarlbU~NkkFR71dzguEa0hLoDmA0
zY%jK}u=5tTv;8)MA5SE@j(<rcN^_J~bsI>dmk}E{nz(4}&+`Jd35e4Z33!f?X2>^}
z!FWx6=wcGQ%1hm*)E`ZxvJ#7707v|V6;a-UX@F^iGvs?jI0`TM(J5Nx*DC_R-*(zn
zlX)XlMYO`3-Az3j9N%#ewjnSrPwZ*rO-{w(Pg<4Iz_cKpgqd&Wn4^Skk|^3Q(HdZy
zmAYY}-RDccnit2@utWurHYRLCU>aMPa*?2>Y9@rJKf>#E40x22nnxQ<&7g?+o2)jd
z%B^IVCA_<p&mJB%S+o5ZY8Ut-Bh}CQ%8VT{9__NmfmK=MRIrrQLe>jh))=rVtDGH{
zvb;b~aald!Gn_OEJlsjeR1c#P%V_RTSWqBKRRkaGf}6l3sA#MUjr(<;s|)1qf><%6
z-jf)C|6zyu>uV4Vul0-_ATl*$XFv+EvQ7tn+VhSBKWn6zmlUSdJdVMROI%h9h-Mip
zH%^j3x2&syAF-^uOa-Gk<RyU_b?aH|IN$9U2BKPIZK|<j7&{Oj`0~(ryUG2i%Wvmq
z)ol8~vX#G>(c9JFeu)Hpj*(<6nOtcYqiXsaOu~NIjskwht?Xk$64alrY~<GY0om?x
zGso^LOe%V=cbnc#u74CkNq^Do{>`|Pm)hw1j;k-)Se{FMu27H75Av+g^HM+CL?7)c
zdccK7l0%)70}|9oO-)d7iKVbMXQ^GspJRI0xJm6t3?}y#qVrt(yg1KR_Y4^=pG?|t
zH`!}KI?tug!t-o(&&M0~x<Jpa60N`+ozw>YosnYaN9sd~5%`HIjHEv2j4dE9<<}Gm
z)0TOz4)ALg@tpyw?<Yne;$z2|$J*|e;mw|Lj52*Jk+2?FGHK2Q?P=WWJl80KK9WeK
zprXwo=$)Qx9Js+rU1V=^(s(JmSZ^SEq2<#41lLivx*ZGRq3_x{Xe0YJjhS!V<Cx%;
zVlxYMh^a(alGs8baUlZ{@Sj|78;D-v%B$j0<9^I@b%1=Zq&^tt+S@TN^0#EVz@<it
zVNZ&e?W91!Gd=Gx@T@6$b8At$*fVy3sEO8+Iwdgzs~XCAAQ}$wj4fa_V>#&~<I6qc
zFc4$ZwBZ4%PGSUBHI%<=f*lJzV+;6FBW*1&qszAbzVc8C5=QKx^QiqE8JcDHF$2ff
z#KwG+iU?T|m$`~lg*XCp!z(x>DB&zMvu4{3K2*x*h=&FwP_CJWrHG_)UtlIt)uhaM
zD4~h?kr^crx&O;hy2#x35wEW<@MlJnN!s<3B<9bFHpXT{YTT&OY=CD?VayALTEt4h
zfXIvmBZXLD1XeYaZ3GPudcj&iWJ<v{Op-vVgcuM7f$xb+FkDxH;X$cjI9Cwc+!JdU
z$u)>&8*551k}C*&xqO82cAqd^KS^S@9V5H=8%RL{UyX+Hg^0QKF5%(nU02{MO}+?Q
zGfCp|q!d_Dx@NLQ>6*#BSiDP)CW%QPdPM2t6C}_ie87s*$0ur(K0c8v{hUP^KGiW7
zyp5G!wB9m_brlu2)Rn6|s=PTBJ0=zD>r||-Q?Y(p*YOUhEJA-}l9zkcjE@>zl}JDw
zI4geoZFka?Rs`nmtXb$%U7t1G`rac-sWqi-XI;!3yXueE%znuM-r{J#%9~dh7GX}^
zB<Xgm)UFqF6f?*!kM)s&wwi+(dDYddYf6?e;s;$4Kbz|6u{<z$j5&_VlP3-sj{j;N
zLXd0Ja&IdebPM*stg&z1qo<{Xim_5fF{dWiIhI?j0REMent5GOjDL5Q-mO+82U^vO
zN6UIB_NB<R(Q?NUUQ=H}wEoex_TO#!s1Y&0)Y{L@C)X!DjC#QDIjJc0MOL!ccnQ0}
zuQ+K8c)yY2u$)^^%IYBNUYFGdR%O+UtCj%)GF}3|;Iewas;qK4db?%#tY>Tj?{QKW
z_$4Qe0ue8d7xFT5>wBK73w+E;J>cU;s`uZ|?e4EUV-xrXC$)jdsxhjuQ#5l2yULgY
zJlaWZ;IU5X0*^CNy`81_4&q<pvPOZ(lo|w9#g|pTtI2qp%W48&<fNj}J>71hqsA>w
zV_E4^y1<*9RBXnaZMR-$*BOn~yXR3*!!!3u@K~iL&Kf!P#3b>MiK|pD@J+^5H_E^>
z*LY;c1tgo+c3B-|##UX%ve~USO&jehh5~unUAAt3%k0EUeaL;)WIW`unudzY&d$;W
zzQ9Rs;1Vab*hyLCq&9H1k>rfegWozWBp|Iz+=l$}6hpAqgyNpYa=Kk>R-EfUzA)VU
zpk2j%zymkMTQUcj`>6;Iu&a3V=XXZZ{-1HK6AiW#X}`PT-2?4fvx|lWcen)|;6FO4
z3p~dJ)ko1kS%w*Ar|$TJcQl&JJT^{{KwRCU0fhbbld%jM@8B(yBY=pMdH^Qr<$<za
znW>L?8JoaIO`$joNqZ%I)WO{3QoMU;A{}NB6KWj4uhs7wyXwsHHHKGxf-=t^fH6xP
z_*r-0#TEvENaD>#REgjZRT)VTM9N6ioMzFZG%y7WS{m8k*5<BtUQa3Gvp$>3@nyr?
znQK%*CaQ6QmHU-;-LA22&hWaSbu;_xwph12R6Md(W8E&{MlOb?gKOo-i0_&xoExdR
z(;_wZP^9L1j<)JL)vNI8237dR3N6p~Mk^jwD$>_X4hS|ZiqyOUBQ>v?NX_-!YkGcZ
zS2@|xc)A6`vph&H&a*XMXyN{kb`|O3zmq<_FmNIvQeR+l+IEf98mmP@u4skHzt*m5
zA6iZ}ZA#1k2)T;?L^}SXg+@ziJXK@Kvn+T|^dP>tLC%Z4MU<9YWc(9$-9Z9&?ZXoq
zvZETZ&|hu$HDtq$yht03;mH(<Rz-`71*KilSR-{hJzq6_!gc?|EK=V#s!V?xXnDT3
zVTQUSlMZAzchUR-m=2|8f%*(%Kh&=JOFZ(8+af;TTT~IBlt*-tbth}Q^X&p(<D?Go
zolfcj|JF!xPD1J@i4pk76vo_+H`v`<JYy614kxvNsFBeM_|3!x{JxV~xw`x8)_0wy
z3H-5>+CWUNnWQ{w+}q#1FzApO2yk~Nb$}N*sRz8qNYQ_!zV<o9^?<)MQe-5x^F7W8
z+`~wbk<^Ka5x8y&BdG@yV<Y>cu-keuI>6^SsSTtoYDZ^4Y9A|x4Cz2LM@CZbay#0<
z4Hbhs15$S+M&SKZ7)gC2F#;)URGk&Kv8NSkt{1KeyuwLil<ZetvN39BH`h2uJ)p7X
zG3OyBbDqm?0*`dkIO+~@b>r(y&3acij&n985^hKq6wffRfGX5UBlt2mVH6W?Hj=V|
zZ*{gN@E30BD3001%^EEoGn&@}W*uMAhYd?ixY~dpD7<V60V%w)fs-Tp(`lseRYzcj
zL@-8B_$P403z8#%m@mSxK2_N$@JsHlc4_>y?y58XYOkI?#y`8_LGW+f(mqx8bhn{T
zmEqiqpRrgy0e&#$%>9fnSG!s5Gfed(ZbBOqc5*>&Af`yy48)H$i-zBun*VflP2m2n
zt`9uWNnK=8Bq?!O5k(Ze)6~2tsRM3uQjzPucIzX~Qmo_8G)J844ru}}aZ(rf*G}pI
zDNoIaHm?!?7TZ-uG~jY4^?<K%QVV#7k>dD6>O5!c0xxq?u~W6iZr$uGUErsj)B}FT
zNKqrH&pTrm$QDV>q-u?Eqek|AfOoo}Q6M_vxIqdvk{6gX7R~g26Z;bv-v$2BNj;#v
zWEuXXIvg4)7JJB2+a*TeZcgf%V86_@TL(Ey7ua`F8+e_OqDE4@r6mmx_@*h0uFb%a
zb~k+ksRw+S-I7CSR}4t-1s|z4;04AfI)Qu@NM0zuVnAX|;+xKj^liqXiqJ;+rMUpF
zb-_I#{-|kG2;#*yVF9jkL0ycVbW+jsDa5V@BpiVIIjIeNwvl3ekvcLl0$(tN(GtbQ
z4qi+Ab$}?B%{kzKF1`mub8If8j!KL`?5J_!ZpOW@=V~J8`H5u6FL&L$FyL?5Rs03q
z<xBBabdKjRP-g6qalsd2MtNQee9e7HR%bx!H~;92z-=l@I|EWX8dW3$tJZajrQJVU
zaenH>Y62Izbv@wAoYVxK`9)0Y0nc|*8;E_<@PIqGsZAiJ*7U0XVfNuCofcri_uZ=Y
z9}K?hAF!(ZA%hPj(svCWV$PPfzt|uiuNm`E_W{c-yKs+8ARSSGm<tQUM)rp|a>@?C
zqZ5NXYoumb8#h=nKVa7xja3bbzLlA$wEU0ixW(crO8<<dem;ddUEa4??dsmdxaBy@
zu1d@Q{>nVN!JXX${?tkB-x)k8#SZ2W@ikF_uEPyTqXcf{U0)A4$4IfAlDai90^c=-
zk<|T(5%>cqb%8&el9$wWGopo32H;#Lb%FaBDH=#>xij{FXE~`0JbOxBQg3s{9`IvM
z>H<GLB`>M;-K`$*7c(hF7x>~WAQe*rtCR*4LFw&*)ROe}Ky<{eomBd;U<ZiC$cU2s
zdaw~h0}xH}K0FXLDy!w6fTL`Z7g$wVK7B*^fv$8Ih$cD12&^g{u2DK%r?fnliBiUB
z(EwyVE4>(yaMzNK3`o7m1Go(&+#@5YI}#(1*p7^(ew`SB1af2~b)?5(8%WefMpD-$
zMj#;?8A<WMNGUaNmIZ8NB(=c9xD7mW3L~kvBt~Gh@<zP!j`CK}238|xq!@RpJYr&~
zu^jke528^Z)uqK)?v;0hyLuEzbwx%}Ur&rcsw*;*`ekASQeBae)I6_~Q6SY78A)B6
z7=ct*WF(b77&!{0x*{W~-MvmmfmByyB=r}G5m>Ff<z9I-H>m^Q-d>-hz-oOiFY0rl
zW$1gxE|Bl*sdeQyB+87Px{T$_t<2b}%UE_+WyayUjAe&YW*n)@SOz;8mzZ;O@&;b%
z4qHx};ChPP`mD2bf%h7z-lt{8PF=>*r)9=gUB=R<WyayUjHOS>_$e>r2(Vhl(x+rR
z$1<u<!Kjvi#+O|0H}<7lMvBasfL$Zi`?Sp1smoaUw9MG5%UJrf%s5<^vGgfrwerX+
zlcF`AVfX6GSZ3@XqnfcSW0|p4m$58knQ^!-<C7`lNL|J<ZniO%_S%g&rwQEAZpruw
z+{H;vAfBjMA<Z@J13Xt3_);U)JHE`=smoY8{ty%U9M{+c9_FMr@MtGBf!I}38n#Tj
zo~sMI+(`AMDKmEJGM1$&Gq&n7mSMzx)3}@31fJ%kHjr&osd^v<s&RwmZ%`r9nt&@^
z_89PVBSp`U`s>69TsMW06ys{mLoMU4*x@m9ii;lyqFL?e3`pIW7=dVxjHHqs_|bBv
z3r>(l0+3uPtE?ol!Y#`o;E8Tm8&hvcq|&H1vbgSSfc{<%s{v23TU*IjBE+nH2N2LS
zTU`|HKzV~@5h+02<x(JET#^C>Z`2%~$6U(4P2;xN{~iA(p`GkT^swu7iG-53Cz2t*
zAZWf(_}(UIwk)LrflD%06jK?9Ks!Z*?z#=U@c$5ZCSZ0{Mc=<kU>J5}k;MQZ2@1#(
z2)haq5RgUgox3mzcV<8~LBX&^Kr$13Wf4(>AfSLZDoB*Y-~tf=gQ9?dL=goP2#69v
zA)>OVz*pT}zdAjq&LqL-`@Waw(f(I;)xVarbl<)`H+tMtj}i*VVw5j{i1G!q8i)gk
zm7cW26h-7Ls~Msb^;F{F=NvtCx0y77_nWE*INClBG=cnXn|z1{t{1G7!VYs3eNT_l
z0N{L6O$GkkR5f7WW<IM;rLs`bgXUEQK5VMy;|l*^s;VM8K=gMr>9KPPUe)7@R%#U(
zGMpBBk<KDLA=LvzIz7N=gOwt8Sk+9L!2L~C<>i#)f+}X%L>2D{CcuMCRRcmO^9Xos
zumUb6oEle%k=>+%k2a=8%#@ko%5l1a)6K03{EVsUK(?*oGKBQyU<kZiRfVAn?w~i#
z*_|YC#icr~rDr$Lqc{R5yh+DK%F*9DOj6oiLqy=-OO5Cq8!1O0v8uF<5D~~-OS-Gx
zv5|805f9f$mxhSIPwR7rbVTpi!0`p+Y6JhFs*J1AK_Wupat8gNI%e}1{1@Y|17Vb9
z1?;hXr4H;hRSg(Ys4J@-2)Ee69SS6dJnWx6lqiP_t#Mtg=srDWuYUebvw1_0sn<a_
z(sTS2>02tTi@GoBmOp3B-oxzA-oxY+U)-*eo2-_fLr1mQJDT~4KPoRdBzP@%1zV`g
z-g=Z)^FRxh#Kn=Hvz)J!NmecJ2gBwU(tW`Y_=>4oz{;2+E1jDvt)WK=0$g*LA<{a*
z5cm;OwSXTR=8N>{U<kZ$m|@&F--1S}1&t0Zc-iW$1IzWwBGz~-S}JuQb<3SFkfMvV
zhcqtu0;#YtL^>}R0?YOKErojLS{XGU6=o4?R_{-OA+Q|5-}XPE4v(2*75Ij!`Y2$w
z70?$C&EsnQZ}X}GAzCxrvE*+b<zKknbz=9fZ|^`$iit^2k1;LEje}!F`{jcou<Ym?
zj3ZN5raO?SD_@EM%Uu3h>D#n9M3!oRGe+(kUfY;S6}Yph>cG8B)qKCgrm3pH51Y#E
z#M|nr-OQxgQrH(%Knj*$w>>EC`5ZOB#oU^}#ipu1t8f*)Gf8}ehv+8rY5-SLuVNW3
zD+Brcn8Od+E4S*9%Abw21tg{Ml`%)Cx%tTi-C?8rA7_?5`mO79uwB*CZvn||d1&Iy
zf38_QY1vhYw6aCwM#P-Q>8b6_qzRm9sy6TwrfLE|sj94<e*SKyXFp($bzsX>E#OI}
zssm@3%6-{No_NcmYOD2|@~V3;H^pZw@lBRa6F64yi{&l}I8jwaPms0@hSq)sp1uM7
zFD+sn_^_(-fBpdh_Vl#&0cr%;#M0^ml5xgW>mU&!@uccT&1fUzYI!d=fVZg^CCDp0
zz^C<8c3-(z@ybe`>A-7Sz=jXlh}--#WulR?aR3QCtfyolc5xE9ozJ4~vv6~1lIGlJ
zxi^8g>JNDq69?&+s+9`~@RebPah*Owg9tBL&;cO-U`;V|kO(f%VSogen-?H?B%am~
z@p+5b=ehelk-H0kh%~al1suZf@7jo5xvV~9GY7UmTUvFWR-IUc$vnZ~C#mbeXKjS4
zz|a{t0e+;Ri7UC^J{0@q%DA92)$<lh-gV2HxaVlz#4SxsF0w#8aJQ5$&{LRXEdq!9
z`psTJ>?U_Ku~)M6t2NyB^*CDoEur|ogiUvB^A;T{MmVvXc@sB;nCxH!KLGrysrrH6
zGF26LgQ~_<rjP0%gq+-Unt+=GD&S_OssT4QRU1fpqboC4i+jR3;wJ|nHcGslcBF<q
z&BD7n__65mD-}t|o(8<tRBhl-R8{PUNRI?V;2%xZ1oBVq$aNXmtFxh?LwZ5AiN_p1
z+XmV4&o0UQ0g_*_ks^_z7y_TNY#YEsEr~uL`4x0XAzQcfeYQ2S4gYpi3)s>mMpve<
z2A*NMQ&t00N0vsdgG4DZ3xI#Ns%pT4t*RD~-#jnqkU~{%E4ol=e_-_Wt(3OM=<EE-
z{9Qryh{C|_mN7&mCs*~gIx$tQjLC9kypHzPh|ncId%mVs5Lx<1%7jQPtk^623-;J8
z^;hk&pG@)CEivm?(K0r)URHr2?Ybv&?Y%$=Fdbc)(xFO5CDX-yjQyn98#u>YIg;lO
zEcGS<pAV{Kd)4q-Y+g0sv#OF;f5(9XIbR!Cj5#{u*Vz260&g)@3;1JG@kH5(=IW_n
z;&#^^)PyxIQwhitU)FMGxfSb^U59mAXe}iLgvB?z6^K1E-Lm{-F2-(&>A9a4Nky{C
zfFvL{?4HO?&m}sLo330WCf6e1kgDWLIC}`;%3ufNm$-AgxIFmBnqLD5rTATz;BO@O
z{cq{PzqRq#fbbXNg#@d7D+i>2^uYQEJ#hr7U~Zy<o;W~mH&TZnl^1$}*H}??;Ek%v
za_#LPeRCB?uMWIZRfQoEr6wL1t*^|x>oJ?G=P0I-Y<~q4J2j~%M_e*Jp=BIoSzZ#c
ziwg2@=qYgo&NWqw&|Ow`>kkS;f$kzofqN-YmN<B(k@o{bqE*^J+{_dFuiy#X*3zo_
zwA_b*4b-~i1>DVu+V53(h^cD8&#Ovi*Lgz-mziCgu_u?@E}n%;$>IW|>IWv+p9ogK
zMW$*zsgN8JzZFRafx8uFp13R6Lfg+kmIt+}=f+fqMs*Ovunv4)&oh+eVcpVlA0X#2
zwcMvkvVc5eg8eCtlIg%u%1~T4gz%b%%nZR}^b3Dk2f$5KmHQ%u+}!n$&XAilk%Hgc
z`Z-YZW8TRQ3glm}$fp(pQ&H>~$X{7k-7NwWl1si^h=9Cdk!@wo4pMmCr3pMmNeV-x
zA=L^a@KeJKkv<;`ffo-mMB*YYjKHgg86tf<Fap0f%n<2E!4P=oFhisVf+6tN!wiw0
z2!_C?hZ(Bi4mw@4w;q7+Hm*AGJ<G+V!<}&f4_Ge8jnyi<;DE<l7FFQxB{T4z!3_Am
zk{OshWM%1DJLm$d5Lis&fTD`Y6GUq%C8nv5C)g}KnB}Gbuk}=3Rer%ozW#e-qwc-O
zc2GjuEzei-lbx7`vO<D8IU9V|R3KwHP9e6U!ipm%w0U%8atC~b8p+FKzz?Y^|4ns-
z6N24&3O}#Mj835)#wjAq=*n&uGEg-<)ozYzj#9CXr9j|3Jyq;6D%fFxqQ~_pjzE5W
zQSRn}O?^+H;6j>dZ!ffg=MFPOS`Z9@KOJU>^hhwYOcgB9<L~q+&$WREnpX=*idn*q
z4${YiA&?XcL!{e-A&?XcL!^+fyNe^?r!3(buwnH5KvK-;YnJdi!4OD_g(1?N!4OD_
zg&|T%*xldxgnLLBuZ+vT?EkD*_<l>G?!&ncbX0ss@S>XAf=a3Fu&$m8u^PnswRttn
zT*2F&m%FU*=uF&0bZ_EVE>#wCl35z(a)mQ-EZ3+Bi$zu<5aMhk?3!*NaKuXPXzZMV
zKPdP9qYH&x4S<KLYINna$~47C2Qwgl(wmvZ|2?PdxOY{)vcmoM-S?i@Zo1Nb(de7N
zx_u?y599@fqG%-k;8t$YfxLH67$W^OFfKcf26@!Xs}D%zjK0x9`a>`T61gx$3VHM`
zJC7Q9;3c=LKN^bt&ei@MVmY))E4*6J_6fMT{VgTB%Lb$l<kc~mOu)BVxH@p6soa#i
zQ91DzqL)<lro37YsMn4bt3|a>1eLGW?agF#k5yZJS|M+G$+|dAIUhG}w~1Bs6o2ZO
z__*jz9Lpz^<*OE`|89lM>=7q<JR{C`T-9Hx>M^6Q#$L-|!pkS`SfOy1I|d+s*jFsO
zm>b7!)iL|n2tL-xszAsxvzTgUHQ(Lb8o+~0RjVrGRguIl2+=-jn%(e%d51dj@6u0K
z^I7ILsRQN}jl`C}d~R;toTE{`phrmvc$KNDa}{16RB_uD>Z$kW*Re8mz^7G}9y%QV
zWZVtlrN-3)e#2Bv;58-sMhA(YiN_=_{<o>(xVI(I8@B<Imo-K<!@xV4n_Hb-dTJFj
z=>_r*k!%*@^z7DV<rW!4>#9jM>A;(toBQLAXaC!lJpbQ1F41IGu&;)jzynRy1|FoU
zVhSNm3x>eMh8ZFq9t`6FBacyL(g5yfsuqyQ#YGpX84Q6$E)0=E9`16%Ke0X0xa!`^
z%^R%W7raQS5ma%_r14cVX#&5ds`OetQO{mtj<qWlLXg-9=c&n^=G6qQVBc=FfGer0
z$N*_VFa&Nf%n)gtU>KK89(PzC4d58_sso8!j35%<pUZa!Kq420NFfh5Xb)=qtu3fq
zj}NQKQ<iEEkN}BBPg25n=`q`Uzzqvl1%`jJychU|U<JImL>6~+Z#@U2{IxysOk;Az
z@dar3-m(c?xw{A<ua5!w^0}A~NNbp(d)ngZ8_@s5l4=7XEJhD0(7Vr8p1$Vk`%?6^
zj;D7Q<d{AiL(kuenNoK$-_vSWvR?JaZi#!z2h{6H>s6gMXr2wKcqXi+G2UUZn!tCd
zYE0#{p$@`6!EPj~x2Z{18hDbq)nJ+uR58=KdTLiQ>BTF=cbD+#YW*qmY6Aahs(v8f
zVieO8=>>gSEd2$(XsRl3%qm63g)h=-s!faysoh|CG=RGreG7Q0s@BgwN{*Rz@LqW|
z!IQQvUOea9#9uDU5QC7KyMB?{S1h#}@T-<uACSmdYPB&77ERIAYH@1!1z#Y^jOdF&
z$ku-r)-1ne+4cZC7O@R1XWKJop=H|>XZ!Qu3nZB=+oUfBAzSysncgzi@~t@VYKu4k
zB-?CO^>&aJ216i`3qz!k$3QVV!~cI@yY&<6S`~PO(btK1S5U#t6ql<fa21>FRba@#
zT{{1$k(uIhcMn|d**;(M8gW_pY~5@p4|V}rtH5oPzF5>qWGRL~zKfI_d*E@_vKC3O
zqZD*VY$|VNe+lDQpjWk*Z?m9B#6d?@j)=Y1((xK+<JJUTZK@V<uBwXcW3G+#>^0`-
zrvBD?Y8Nx91NSyn75HIO)qy9N%6(Q!5b@32QoQCV;XOv&1a4<vP`7|PnW_ogSye?(
zkoF9Qz>`en=HLAqe0wu#@22pepaOotRCQqBb}fHQxt|UN0-rNg9r$-sHUFXTRa4bh
z(#UIA22J2Prm6$qW~$~`g`1hmQXdGactR!ee8DG`$Y6aRF6QQ+t^b9EZvt=87pP@h
z1KzHxVvv#U3WmV@hZ!P08VrGph8ZI5zIu_Tga+=Rsv<PfKrkGsvbk1S1BiFV)#xDY
zYg`TB`%P5^60z`&gTAc6ZnjDf1=6kJueIM$gIz4bp+NE}45z69aYt3$pLJiRK~J=x
zErR_ls2GGtf{J#Nj9hmJPT0hQCc@E8d29!~S2HP^gY>H~0*@+u+Ei8GMwV9_c$})_
z0sfpJ@_!=O0jWd&VenBMgny}Bkqc5NwLz&2w$uS+u;n5Kq#@~XzfS9+WVytU$70LZ
zU3CuEvHhe?f+p~@rm6!kR8^KivxBty8n#q`Z&6iYh;(x>1l~H#5UHcD0m$Nur?*eI
zLBgN2gj+yTELw)NhUL)$lA^R57?N;TiT}|^=UK!m+*bruocg1BiY7^QKw=jC+F8rz
zr_vH_;2--PW2IDqYpF{9Zm0VI$K)>7%VE;5j2Bt3+L=lmn&dukpP<$knAZ__ooD0g
zCgdDF#Xor~kGp}tGp{=E2~`z+L)vUDn~=cGRaF=wo$?klj0el-(I5}Jib)kaF3^;I
zW7$@Lzc*EjRG&6g6*%6qZvn|yW+(8<U<I6Osw!}8E3gIR-&YkbAO$6M+GCXSyuc0o
zysG5w{4F-sI6GLpDv*CZHZzNR6;ma?e)+0Kp(2?N!0%d4ZQu`0)x1^V9j0<OWC^01
zm+eInJ1LNifXC<_ELV#KgV@DKjHOuM@oFP}^9K=D)kl=YG(*}}wYe$60mDp@c&MD4
zBAh?W6zR)lR)p(^nIhd%HbvmEYLP3_%Vkppo_Q6fNH6LWusm0U`%9nr8XcsERGXWc
zpm(DME1!Y8Rhye4Y&Ogk>Fs4xgh@J{1uGJtH*!{l1BaO+Rl|gsKZw9ADOls_fy~^H
z$I-yA>pA%YH(-~(vms9|fE%ky(pxl$z*p^J2mFS8qud9)R#jPMwGPrQ_VrdT@Ca2&
zjKzZpOi_seT+1G4^Z^G=)eHQDeNgTLUT3Oa;Eznz2V_b}L?9DFdIWsV9D9LG5Xt}H
zL4-YZ3WzJP-&DQ8(K@7J1!Q7K8bHQatQgSv$f(LU!@zIZkPOiLeXU&sal7*5eZvOg
zhUIp&>>t*Qf!7sMzg!W36f0jB0I4izLkMNMXIhj?ZPFaz2{w=WflL@-zi$wMjcjyf
zhYpw>D|<H+%vWXd&<4nEmGdF6FJ->qd+gDBKaf2s_eEg(X1RcwbGab`vrdu$($(A!
zfsH341T*cj1i`dAcSc};$(+HAMe40pKNwRPjMHr}>OlH0A!iRE?4_Hz+>8PlliUvB
zlfe$iIOTQ-bAug_amwuw?hST8#xA!*c#92W9mv?_b|%<@s*h2~(B*ar44%{rWax4`
zgt4|o)PW3VZildYumduhxgEm3w!hSYjBsv;a73^JG6QluhCDv*rG1iL1?oOkF^-uo
zwr5gs#mT-k0^eX)pB9iGag)si_(6R;OKvYuRme3+RBUuyMMTAKB0OXlo)(a|3gn;O
z8tNc0Ma7k+$zCZc;Kgir*>w?tzjzZnAlqji0)g#QTDxcvfvF<S@e~mi3z!X5R6xc$
zXNwz-OyjeLgL#uwCMEDy8-p5<ABPhwV3%E4s=zP?b;cmPhgAp8(DzVeJb^>1lD`Wc
z-9h+Vumkc-E|Lb2w|ImN`0v0rs)MkijeHfjhTU>VRD>{T>P(tT%(V{uim4jF8v>jB
zDufC*1v}vV!ESU1A<VZr@JqI;CUwAkO)T}_p{Ln|L<MBVX2T2~2zwNe2`f`()(`@-
zQ|N%q&D;(lOw>A%37drlv!w|gkV%}Gf%$tZF#|HOWn6)!IX-I$A#61M{lL_`r@b>v
z?FG~3Y|{eM@|8r_b&C9R(=`64N+2KBfDC~6uLWiRvT{?MO10&`t&KJPSuI>{7=Y}r
z^4bR-;N~RD4E#$gstTkKAp`zz)I`=Y3+LPI9AlA{04B-obvkf4VK9S{6CyBgGeR&U
zlp7*2b2CFQ!<HK&ENy=BgWJ3hzoPs#)b?9;5OI~M_sU?GoM1k4JU{`DG-a&-kJeL?
z%e{jL%#W4iA3ocD^X)gXi@+E4jwrWA;2z4XQE(r%N_I1M@d`N;I_{ma?t>YHoE?E-
z$PB@ZLT-rgYx{Un1=5(@j%IM&Nv~eqKFD870J(jT=OjS>jV7_;Dt4e<*xFphei2l_
z2UR7%$x{Jy<q|R=SFSOY?nxblaE)nmjk(7z6zyLs{7X>z+miMcx}kr>Hug4<y<FOJ
zNn&GfCpPv=hWy6fju(KG#Z+fY78Q^QpGRddIDTKdMW<w@E>hJqdXx?w(?NJSC}(um
z((C#9c3tm2wKGSB+k>)gE0K$cgdqct3lvP!X_75qFq2|b<uE@P4r4O##6qkXy)OGi
zaTt*OD&uE<GiI3%96pU7#<(#)62OnjVT=k79>mIz%3+ktak5S(re3z}z$e;7tMY~x
zceq)m;E&outOLnd`b^SfESGXJWzWpWm@Q|8&o01=O;rVc-&A!VU*Jnf;48rj$Ye}R
zfL*oPcj<9``7tv21Jvy&POo&0zj*X2l_?u_PntMs+YSbYs^MFM;V?Vjv+b>Ceb%!!
zkjE>s3HhG6HJ6POJ^Q59*#@3%sv12jy`e#ao;54?z?!jVx+WU-9o=D`wVkF4Jle`@
z`C9C=$x#-*3OvqKE%Lt9R8`;=rfN~jZ%tJNK4B{Nt=gke>RC6*eN)T5=5w#HZaDI+
zna{Vf%iZUm$HzwU1GKm3t9<U-y|UhEjSF{N!0lC)-G=hnnz*UY)3Hr5x7bK>+k5}L
z^7346O-<m)kQ=a+hkma?hboon`uyMv_8g%J9B<zj4*<umUU+6thW(!|daedsI7*pw
zhC=iLdB0l1Z|-vV_2Bn{<z5HAqAK}?j?+5`uc|UDsHcNOwz40_xqd_Y^c(9}6^OUg
z_`M;7m9%5BMuF?ADz`&;Td)I?MQ%4z9*m4Uq6HGV7$hXv62BZuO^dCjHgFy5V->iC
zsoHR_YRR{O)FpKTLk4a~yHz9ezJ+{lfg5j8#XZ1_WLKBXe$3(D{a|jlrHv*jMW<u7
z$yyihddM{zc)FgFk(fV(aG~{~0lc(q7xV9`C$BTVeqI}SDX4&ypV-^?QR^k<<@V6y
z^%RK-3y>V;1IqlNuI<OVjRb?Q8+`*vzIh+w`o`%bc&AN<Ch%ZWwSZMsrFW9;^z0$#
z=%&ncJvG}*n!u}6mFC8g_eJEI4m{hqdVpmv|I_nuU1E+kVA;|CWdEQ#5P8kYsg<2J
zms^@0<d$aqgzgR}c;{wyF({oz{RQP&OZKnEFapky$HbC_Y~Eukzb)2@V13Ox3mXsW
z#mfIBJ?5WwH|iilo|vWc)Z<n?$|D!xPl76rw@^<l3MK~a1(N0{g`@SDy=t7Q$dv;<
z1TywOxUxy(2iiN<QjUJ0c@1aJkUj9Ts!FaV@7KWZJfrFZLX}S5bJgHF-?;jLWv=C^
zrw6X^hR*=7%;kS{!spcsSJ~133zIu**8gMK*MT@@Q=+#t$$R-*f_TR5tsLhVm)mM)
z>nYw#%ciobK4vfO^a0OOReJaFTn)I+Fs^=JnafW~&sBr#G~;Rm%Uph3Jy#E0Wk)}V
zH)$tMwup5gj&iA)H`KMOztr5OzQ5O_tb{AvUEY0q@)Qf;E_bWzsSVAf0VD^Z_BW8T
z)c(`v*94xgs`My&$41K04;hYUTf`a=0(lVtSWdzZ886*!Jo2ken0#NuWuK+u1u#zC
zCmBr>xV@^<P4JG5l%sFL6s3KChzLAjsS&+nBjva}5o;+&-{Y$0b3{lLc(kb+Kwgte
z_pAPYk!!kg&9o$%z)zT}0sN$@(s{x4@!$xAK;AwAmbrYRPf-pC<N^zXV7a+wE7w?i
zo3IJoTvh3UaJ(@T1cX4ggLy*;Wj0?DY&RHN4G4kU{s7BdemYIkyyu6KfOjmlBpeSi
z#|99Byd;D&n=c8r_ZV9Z2!WIYEOU)qQq8z}fDp)t1It|gTCz|%ersG!;O|V;0RCQ8
z=}7?BL%|UUf#d}&bNPNPQjTYhs|kGGR1M$@s!Hbt*W%y^gh28FmbpgG>rcj2141BI
z6JVLkkK+>M*ktYE0wFg!z*(kh0MAiXx<<I(5*&dLNR7ZUm#-17m5i$fT*Fj7z%rMw
z@hEjT+Z+!C21nT#+%*zMQeL%kdS!=+7gol1??1MK5{kFTt!GU?i>XO`&4uq&O{A-G
za`x$N#JJe4S~;Vz%)SVWNoOlr$Es@r=cp<@TsU5Cjtw9LGF-qimme<9&NHqi@W!Pk
zu|Ut>6C8m*f0K@ll%r2|q0&AZA_A-Hun6kFhN{vngll(mYyiuSBPW5iG#XfT^mExq
z?7^{SNwk1vuEf5p9e_Yy(gfCxs|_r3`OjvDtHX!Qu?hT$s?sg=j*XO~Z=rXrr5t?=
zy<<<x(f4b*7V^nZBk&wkHGt<XwQRU%1xFwRGADp#F5d~bW*S!w2!UJ=fMqV<oY~6p
z72|3Gzh<fi@aw8d4=r3*1V<nQQX{a;<!glNOU6|LLLfB)%UmPZc!_cK03nd204#I)
zInlS`d-FZxi+Yqh->)eAYES{cuBvS+r#)QhI&FdcPmU92@!zOSRT8%@eo-Rc@~11!
z1$tade$TN>9w45!g?ufV{Y0<3NX%2qb-IdlrSHIPRF#ckt%LM|U<f>Hm?6@I!4P=k
zFhist21DRo!wiug4Tf>yKh`qFm`N45f~vCLwp>&3hQSO-eVG|}w_pa`y~GCICzt_g
zO~yt;jtgeMnI$%wbVW%QmwASsn;octxMvaR?9YN3kX~kH;75WPkXC1A@qbM<r>^WF
z0)>PucIc2r;M&1WzpIsNUPu9mdn$#>O1il8C^x5HRJiTR#VPstGixYL-TO5XezQmP
zThrpzfWJ3Y8@NPO#lk__rkfSk1}-pFAMjCAwSj+9RY8ZeqSh&I?*QMbs=^Ryq8au9
z=}}=gQj_XdSq~7${Ilgqesol}N?^(F759z%SdDX$#p?soQTdXRHm+w48UX&#RQ<qT
zm}<Z`Y=G8mX{~YJCGMih%(kQkfE1PZk^?VHvbSZxp_YDXS=+Mg2i~bF>G0ekgiuYt
zucn`BN=^2UHp$|9R!{3zg(0yPiM`ztYXP@Y)f!o1U6Uuu_x4>A*6JFM{=4Rq=y;19
zx3P{7#M5W25`<#wcx`H4_1LSeUT0eP9=zy>T>fLPkE`|N=2eYNCTYx%S?nh8bX8@`
zr`bWeBp8mw^)54M0P)JW{LPI|qLxacmPn#DQW6kITY!|1CDD`Ma{VK(Q>>s~V415o
z!PUF$yr!n|nwsF68guQb`5a_<Re^A3pT-+IOqBl{KY8M550B~^Z^Y-QSHgr-Ukt=R
zMlj(Or+1iof5=#-0Y9v&F8N;f%*tjRWYU(~$Cz!7x_sN%n!wjoRm{+3J2r6qk8!nu
zWiCHMeG)ae{$*S(V42I`eqXN+5Xe>iyQ;d&xaz<sP1OT@)l_bu@LnUD{MuNm&nkQ+
zsN!Z;Rw*v)YwA&w2KK2cJqq5jfn$$xwSn~#SEGYO1i1-Vc3w5;t47}fLYSpmOVInT
z*pvg#QrYh``Z{oDQ}qD%GgTe<0aNvmPbkn0*I2clXkKm)_u=b=-zRthL-;!34+~at
ze-GDF=b1?p_)AmOfe)&xm<mWQ1;df(XPZd__$yPjfDmT%jSf<vcf<EZ<@l~~x#pdw
zr*6~Z=*q6{_WgU2P2!g5X*GF4j|r2?s>Ko-t4Enjz#U9g2kxk<qLoO;1jD$Mp1uM7
zWb<kPAuL*nw4WI^fFYvmZe6X9GB4NN>3ZsmX3_*!SL1_19XL%@Ma@V%tZs&J%~vSx
zH}u$5X<XD@yGUQ94c46hjiph8{iBwKyOp?8Pu*=MRp6GEle@wDwOT(Bynw;W-H1P@
z)-MJxVDNH(P5*bb-qg~m0`Zbx9+?yxQJ^oY+Ydsp*kp<_9&gM|;O|UT2R^B)V&F#N
zI>H<qz{gG129~+}g_yjKF~=Hkk*WHCWiEdqUZM_bt-%Cq0=F<#9k`XMiW-sL6Aa_B
zp<mZb8o(`0)dE6TEJ&n4?^fRw<@l&^HG!koq@aG_imEEIN7^nJ#@R#vF{5t)|6{5a
z5W*sRq(DDn_HfDrIpFO^-v|7usxtao2kC)e2qa=*7}xZBb$H1f>poR?1^$Fue@>6t
zr(G}!CSI97OwCuY9uN3nZuh{8W{jzvI<A9ozEa8`XOHV3gcRC98kE~1{8^plCJM;t
z<#q@p*_B;nCyeVLzs2fk1L=0|A2<7J8t(@d*WKDrQp!G~ZUUb(RUhzqRTWbh>5{dW
z>uz_1>%+#?e~rSw2Gx)f1R}RNSJnF4=2Zv&)>Jj%pG;K;QiA*i-Xt&utSEhMPMCxk
z(r^>;ASHgr0<^rBTWKe%_4(#i1Aa$UU6mP?Qz~OS$d8z5l>k$%%{3sI;vG+b&nOG5
za!Z8kXO%5`rV55GapyFsOyr&Tlt`Yd8uO$Mc!K5L13Xw&@{i#Sbr22-c5yBEZKWpb
z$e&Vn&6KYj<j<^6t>~8yoZLo@)|98paxyb3zLns_UQ1(%L(fs;$Mh(-jll71GxzJj
ztyNVl5~MlnnPE&1*G9(GchNe9_2qh$zd=~2Fc7)bcAw_=qqh*NANZuHs=zHRTt7*^
zGlT<9F;y>cA61R1oIa|9FfG^tzhkO?;9cfAII4s2g>@}m;8muo0#CLE_Mf3Jw8HHd
zv|@r4*`ml3jHu;_+}a(jjoa25SOe1AZ1oMw+C_fEOsCT8)in)F=c@dpNRNE4rCkGV
ztF40qnQqHP1^B7Rl-WeXp+IJ8br*$97}Y_uhK)lFNc$l9L^K%a<5|A5c4dF-P8Ap$
z)}~=ASOeM*D*U6Vsz7>Bs{P|O>DrVX7Ev46F{>(d?Q5mBfd`n%W?`6e?m5UtS{Tz~
zRAn0QOg$yf+V38Oor#?*<8HlIJx;c64FCsCRRx9y4)_KR_zDMzU9+_?5RYTx&$Z6h
z$X^Q?5blMb0)`>%CET^v(B2I-@^+R%FYp7ZlEy3?j2rWkQs6HSm$9b;Q31nnxzELG
zDbaS8lQVf-XGx`GqHqO0j*)+Lw$r5ojZR!Y7c15CdR#}Y_FXe8<K-*!Q|#iz$-k*l
z_P0613^+kTNtU={$7*($>rw9WfgM$?B>UG66Hl&;kA0iE=6dzGs$6vSkAb?zqdZbi
zt`bf<qDRz*l{>mJQ~{6Da^<(`fGe7+3Y=i7KK8k=*6o6MNwA7*>C#i<&7|sg2sa0~
za{WZTx@1JM*Bg-8Ls!pRcoH`vsP9!bIX$$)L^~bl#yow%RznlG$6L8Nwt)Mos<^{I
zI>-#0z#db%>)MYs(tFIL4pH!O_rJHR*Cg}m!|Q;c0+Pm?eAfiGkcYd|c}Vm4z4faG
zeA!g(wKS!WZ4K_Ko?2DjYP7pYlp(NtAoYy0m!iaDdAL%aYYk}v|6r;*@Q<o0#uDk(
zU<iEOR88O;!+eq6vOW{04qQi7MG&N|gJE35dCEM;f>yUs>)_?q%JpjfgWwetPg0ht
z7P|>N-c)tqiK;5{M!F;zjzr&QCJo?+P1OQIn9(;nNP*rhn)fNk3C7j-Uhc-AU#&lA
zUaoU<^we`^(geO@suu87RTXVPdiMs5dlOhSRSQ^CRpE<NH^V0IcvH22GfmZu8&3gu
zTec10Dy4{x4iYKK2T34dis3*CLEXa(g3>CvvH@vI##QSeZE6M7fOMcRL^?DW0?DT^
zL^>fD0!g?qj2lH<itehMlzajEDQ)D7*3df15j*k3i=NX4=`LQ>k@)0JPUE#0azcK)
z6<Gx?D}5-pGS?m;uJX@@%^DTAXO`Ok)BKvi-8U@ech=Wt2kBJR%4c%mCx#g!%?XAh
z1^t@^Z2$?A1#KjPHc~+w9Us(9UMl^$1+4+8Sl(*_mh-4t9*0>?H6ZzjFOX!435oRi
z;0p{ba_>%D;Krqgln9gEb}MHfaxZlJONmyn@KxaUrs{$7OjA{X#E@|DIQFV_zaIJH
z2ILP0HXwm89f=aV(Q>yC|3|g=8+{Y_D^(S97HO-EY^MgEpsK<U>B?XT{Ms->qy@nc
z_|svANY4aA;OoN-k=A~j<p|tCRYi_S#|1;+iNg$$J{b&w7Y;K-x;hvFzctKo*#po>
z4M3yA0PJpEXaH$>R$QZlbV)D-((=L(>84-^q~(Pn5?z;V7)Z+tL!{NM3k@JGFAR~6
z3Wh*hUKk?H42D2jUKk?H35LM(0Qj#2uhVHx*X2S?t2ejC)PS^H*3zyt`l4V)OXmd@
zkk)3N;5*eUdx+ndu&eKLjgEF(Sv4S?%?QD7RWl`|%>%(3NV_v{@Cn1c>HX=!8^{=B
z-r#eFdov)H2X7z)lX-)`Iovy5Ch;g`-=Z;M43|8*06wLS&CI||Suq1%pg}V;@@2MU
zx;Tq}=v-ms<t_#)21-=xE9?8L@_JPvEfuSCRYknS9ns2KMF`jS;o5{_u;qc`6qiA}
z=`v{h4BYMiw*PGgaMM*uDsHCdURpClb=JAS?LO;!?w0Rd%XhBj^L8Jk=4mHy)}!3L
z0q-$Y9eBT~n!sPED%-gH?}07Uv(E)b;F4jENPiE8z<&-ij2mAWt2d*1lmb>zxGtxX
zso}VqIW~Z0N5998Q->|gu?alYRCVC#rfLGuP*u8Rv-IqF!4WveRCVB2hjAfY9}I!t
z8D<!Fae<zF+#H+0jW*%_qYWHyswQxPs?s$*7}00j5&X|t$U5)^Q#FAvt4e-qe5ix)
zy4lrN+qlSbT|H(Iz(=Z1es_J2!Us&%2YgsnV=6O;Itb4PySQan>8b1Wm_-ENYHoGl
z9jeL;K)5T|jYJ<ZaBDY?)-8{+Cr_LqZ|D<rf%40lq2f#&W|EHEL19RN&zPzoxOl0f
z9CKwIf$WDy)(2dms=VO{_XN8*)jmCSv>r2h@M-2&2cDy<yx|C+4R#~ZhYZ{%f0B9!
z7B?nK)MTYiSv5`I`%KjW9-yl9s`*dEl@$!x21eEf?x?CUm9vIA2)hTnxZtXude}^w
zz)y}N`#SIfRTZfs-L|<Ijzs^8(Kmo+8+{uHVMgERAYEaG4d72q)dv2;R1M(srfLIU
zGgSk)`DSF_1|Dy!2JkZz%nJBBQ#F7uO*AXuCf1w=@Jds)f%8n&0EVu*DafGx+qzl<
zo@)j60qJAb)moyfHQ&`f-_@G$Y9C#F#e&v=v{JrB0v>5ytpRDJSOLFpU9ACWrC0%J
zrF^sjhJLy4Cz#RyV|liG&8>U%Y#?$A`)W10)`;A*V|v2$%GN8GPDs}KjW1?OQ;(vm
z=^SY4G4lj}%;tv+_@d@Q5P8%DoM0WV67M*R=ZNrH%e?y6R~QoShv)-F)c*s8_XZX4
zK~oL<QQ-@w>IeQ^Rbwjh9ty%M!7koacG9%oWtmoi2dFB0%NI<_@(uQRL;LFdIz*4T
zlF7$9&Xud_VrI_eN`zN!rB{JW#4I%9#bVBV<1&7t9QWuk8*uOofj@SuYl%P5<Cx0I
zZ*<nzZc(eeqD206rONFPs3Y-nswYMK395wGEax>q0xhe>z1?}L^J?HV&b%7HNve9E
ze7k$f>`@o5&^>Nq_qex@ogrV_SGt_8^mp@ex+HD2#i+_#*KwbPw^n+>$eN6MzrC6q
zVad5=#IP_DU6mKNesol&!jxdkM<0iX{pE9J?3(!K>AmXS%YCTaL-&r8Z9kiKibAd$
z^4<)4<yFCo4Up@ESUsRa`IsI>^`gR;f@)2jr+e7yp7xBc#4hXUw2vyhF{oH9VPQ-=
zUpK|eY;&B(db>HO;{M*L$=q#8Re=ndylmr}=jQIqO0c$-QpM|R3tt72Z2nI|BanIa
z+9#O#k$7!|L8jIDibi<Q>glJ+p`QLYVqyh9s|0w93H9JDD$=~%N_21geMtxO1_oAt
z)d-ngR=zW!SjH{!H3DAqm2KsWEnoK?RJZCWX&I0hCF?j==~O&NhzW~)e3&&V_Rp2E
z=j68+*Y(r&m?#L7hM6>hQ%zL`e#lf!;PIxa0#7xS`!1Mp?>3X_{tAg9eFL`5stF`U
zVnWVR>x<2+2E0;LGT(<f2v-HWxN!^g)SB<$7TSGB=S^I(4>}h2wbWP*u$>;|k?j`X
zcUf?^^B<(APBIf0+?%)(=BfA1ddx2Q;E7vMxyw0r%O21v!_$^eFYwQ%ssdj#RWI-j
zQ&oZMSO)GJN5b71ydG3Y44EImznE1okQj+sM0M+1c-PuVdg^1r1h~<bw5<-DsH);)
zD$*XoFrIwS4;g(A5HGod^S`d({d)1+)S~qPNhC|Fw}V6g`E;}Fw5CFjm!vgsDE9lf
zmVvSK9JryTHM;V#3YbiUYxWQV0W!n*zd6eP4LxSF7`&d<-GXZOpo*DR)l+z_oW0Li
zZ0>k(qb8+OG0UGdkH6}%WQr;T7>omu-pX=Usj=e#vz7P~JxW7?^hug`nHz|>QQ}9R
zN`C%d!gyTckhR>9&<?Uqybye+dOfMfmF3&<?kzTv*Bm>j{-~!`Elw4`gAi9cMLT|&
zjaw6VkEz<g`&3mdHl($;VpX<*>#3?RMEcG<&2XeV?y#T@AYn4DMhEGoU<f2kVTklu
z3)%pFT~&o4QpnD2<#cI=1+4+^HB}#w6f^poCA_Y6sSiksg&|VN!)+4eL2KlW16U5)
zV?k++7y_Zsg8H8{^AUPe5qc95dWk?GS%lsW(q>kFFYwILIP`Xq7$teQ0W9b2e}2&C
zJT;Z`)I`oxQ#ntyoF`b$Q-NERX7<z$(zd}6NI6*-rY4G;nksIp`=H8dq#}8H0azaL
z|D}b|r?dY8J!T(nz#Ur|Rp3>sl6UuqItY}LxLaWE&`Y^)`qk=IiT7%FFSo|MSKE8J
z$Foy(;E%BhPy-&Xs+HtJjQlOZ_G4dH#RqLia(ABb%8)hSlW;d|criz_Yjiv_GaXa&
zP)oK7JWN&jUsWJb!I;V!qdL>o;%%0F6&MPd3JfDw^#!=+C?_j79g<1ziI!&&FOP`2
z<*yJYPds&luJL4Xy`~?|#FwJ$BM#olgn`Wnee8cz<S#eyv8$+-?X^7h{>H^}pC=Y*
z!B5$^HG!|2ss(&QRoSl9>>zEqH5cv{a4S_6hDZmSVH4Oem3zcaYL8nU4d830ssl+T
zi`cN#wlMlSkYox&r1u9yASudp1BPtf12l**O$;I?1dz94fWgb{Jcny$r&xwH;6tj)
zN~v{_{uT^@n{88!ko>!IZhP?jJt_X41b<J0|L}O~dj8%Ne{X`nH^Kj*nEz8+?gLh~
z+dy8_QyXX-<XQsU*i=)2o0`fIP0~{hGid@JQB^VH<0QRf1IM45<5{zYI!Je!cIND%
z4pKRYe-q_k^?_NYAaFoWN#(#Vn5qu^im7VAZ=0$Pyv<a#pDQG<#B=fk)TBp`^66;*
z4#GV~)$gg?(?sg~iFviWm)k~sadnEj&WNhOP+Z+}yZNw42@cwp9k2=fx2mMxxkCsW
zY**M7lLTpZ)yjAQ&s0_Jjqv4Q2mD>xE}nE`x36W_01~>`1d(>M01Y6q3qz!fgCUSi
z3d507S=Umj0oO3DI*@!au386ado!#7$wzil;Dx~oNNS0<5Jzb~Q!TG)z)Mw?J@z1l
z{fvAXkhqx{`0K$eZUn5~wSb2KnIsw0J<34psb?=$rC3>Qv!CbM!}<B2?DBq-5`O*#
z(c@jb-8#J*kIF|^cI$l4<*=Lk+~T<=CAcOfxO`q8*Su)$=*koqFSe0)zv7X><RTlH
zX|V|rLdU0c{7Cuev7bD#iQN(paTaMG$4s)#1vu7JE#Stg%GOM?gS2-r1nx7;5UFa0
zP2iEHa=r4YHAwAk=2ZuhOtCc}?G+4xBvTk7g*@C%*L3Chig7i8UpG}9c(tmE79rgn
z41qrwW{A|<o^e=?JR0P2mC?6=L@vriy3Pz6!1<<X0ZFFtMY`P#8^E_)wk_bUrfL8~
zO>T@6MDcp?CayDgX=e9XhBe?Ls>;6?LLk?~oy2=I{hF2GuE&S#sUb6I0>8Bbqt_3-
zURA|>K>EjIGX%b@s=^Ry+>T}loS>@0Fm9L6u0eKXM}K4I9cw8^|1)mhu_tzvJB<16
zX|?z3js3C`{lm5yZUC&rpWB%9(duq%b>C46KOIz$Dts}hX#FPEdiQw8XJEY=uqn_c
zgC#+=x`vr(;o2niP*9Q7lAt1~v6hs34s@7?2^mx`RMnR(gX$>dBonz=-%V953s?QQ
zLNXDnRW$MjmVsLtzAZMQU$+eEwB@fBu1<9u8n;{HjBF^S?`Gu;rL=%FRi4%{*rAj@
z!fj;X+{QFZxo2D6Rba@V&B#`)lq!%+<mDL#d)HtE40*P%*0bLYR=|+D%kxQ{@FA%>
zkps7DCSE65b$#B;&3e2-tbXt1K2YH`&0<yY8XHQDx3NR@R4BsDwn;jAbsNPdaHXBt
zHCw>7R8{PnNE-x0;AX=N<Gg&(20>Rgt~PLWRmq!%(>n;n&N69qkTwe5z)i~D2<7zr
zChpU#kzU!+Z{psu2gfxnvjHGUXC?Gl3FCqxupHEX)8m8o5_DDL>I0U8_FB-f!4Oyu
z>aQLLyJ=G!P}Nm7lj_d^jovMyE7as#Oe@t_fac|9?QhlOaZD@DWRiLxW-LwMq@9`A
z1HkQ7RZMK8vxA|V!j8TNdc2BpjU5~6xRr6YeK>bn!iyN$w*cUkjj0Y?M^*WsP#|m^
z?0iHwFtDF!{cD}3Fc7sok=tCaRIm9))Pq;eGU@>iTIPv&B%u255(r)cB*0K5KGPkn
ziIA9lg99w(=wC1CQ9q32q90Fz*=lm99_48g@T0phHCw<Lsw$=?(jCDN__JY#NWV41
zCa}G$1sN%|A6jY+;AuwG29ivcTBC#X(_jcBnZgh$<l*MK??-#N=|^jM+gh3JT@}8m
zh%F-0V0jb)q=aHne8iTI=oZF9+T*RPU)6UhWb9?qk;Ik33V6GzddXl5tJ%%EM_jnt
zE-qZvhpYK;Rl==i;oLW%ztnJ{lseoCEblr*YZ_5~1BGGu+}^aO66~eN>>Ir7r(co#
zEI<u-oT~DVum~YHEAp1$8n2Dt=_zuShm_>VXeXXqKBHc*8F3W|(df#IwP2cTjc@~a
zxSr~mNfY?g?!}6hkBCd$@BQI-o%uC@Z&N?n|A1pvRV-B`0wgv{PhW!`FG*|ha-`K0
z`(-)!8=ixAD~g?}N7-Q~Y0|q}J=L2O-Vs#sfWD#)SzC#+iz;}ok=KDYs4BmxB785{
z(W|CKbQAY3wf>EHjX26AQcmh<b87>SQ&slD26#>|1CnlL243CrY?FHEUmHj@nJ4(n
z;0b(KRav@mpP8j|Z2~rdjJV7Y|1ZGd_dcy>h0LgfbdXiq1pauKA=1x+A&`k#Fvj`P
z`ibUP8&VjCyGGBpvu3zGaEYGU<Xv2Fo4~)Ast@=#RTbA1q|M%qulpzo{X2}S0es$6
z{Xhtdg^d*G-DgfuUxR+J(YJsQX7sfVQlNL2KTqES{WC^i2SQkE2}pt7Ewyhe$8E+{
z9j&cg$68tiZlo%ihgY~~Y&$E(9(v5?I5^O^NeZsSU;M1D3`;Dj0lY#f1Mz&s>#OP|
zvv$r<2k8dmY5-pwW{5P(%5DM)S}?|O_g5Nd<w-BuLXdd)+fXm^lb14p5UnBC>+Q3j
z@|-+z<|O$?y*#UXx1v{BL%;j*3jKB~1TPZ!f0aw!=i(+Lxr7Q@-pj2LyiU;iv$+SR
zor#Yan4F<*@`qhB6$UT&t(o_ldam<w|B%}xomYE=`2{@9RCVCTRaNYANM8<yz^@E5
zM7l8;#?zHNT4vG!&M;LANaSKWMEa5$Hh`C#ss$vO!WSu|=0-6=A7}4P+zeWvnXLXE
zE(uNGhNkKVj#X9BXrx`uunC-Es(#?UrfLHB8%BrJ42Hm$P1O(l*DznCfjub0U3#eW
zMeBV7xQ@}cfYeqD2h#Rt*Z}Tssuqw!3SXqd&9DLdo2gnr3MqV%LRoGaP!^*myC-mM
zqpt%gB%`l&kQfi~1(J1Ph(zLI2wW0^0Li-WMG7^zN%#rnxYD@#u2Oh^Pyv6fs{E%y
z5dInL2-vi_;P!AIuuZ_f8&TU6xn~NVs0I<4$;TVuZ;ZPJeAQF~K*ARP{z*6D=2p(Y
z77D9DRaY2_c9;Ca)#T^q)dYU#y~VPTTb21k2wzjBJW2w7yKEQlHt?Tr{0(6Do-E60
zz_+SOLY_B-u!Aa#*^hKc@CH6m_C_G_!W)U)<#Giqm2sZCGoy^pS{XGUY06y~kQ|G-
zj`Waa+y*{sswQwnYq0!d@kN7n(qln~L@Dy68IV$BB?74`agRt%G++MY14tn<4zrWv
z(9@wRnlIi!O3A$u$T2ITr-MYA;teF@+&i95x47x*KG()3*^LZSnz|B?PtH+hhE;k9
z3|{|hBOEs;F`N{@82<kp&N#i~*v-}sUmn)b)e3J2Dqv{(08{PTwps>&ED;GfZzx_F
zxiU^I@nDI>F4inkj~19gk65Ptk1GtBy4#DtI}>-Yz$6Ttd(;0wt(&5y1mORb`r&7(
z=A(zeN-frH+|A@b!^bWslNAW7Tt0x5Ap01QfgEwei_=If2a<R|n<tr`H-u0ws?mwr
za?^O{xj=bHJDVh6@|JCd)QOPTX~+!kG}8b~r`ZKz00?>J87H5bydT!wKcPqY9Jh|L
zzRlRHFnu$q;wH3|;P^lUoM2x4WKNp$!w_(@xhH;M;;1Rb)$V*f%13D6wW?Yx|M|L^
z^7D0FJ5D^aA|L4E1nKE3mSF9}>U_WP)=2OG%h^3q^F+OHZmL8p$v?rg${X_Ui+s#Q
z==BkL2}W1UJ+5JQrQ1)B@;X9yhwNW3D@XF&TaDxz2866jS~w)%V8Hi6Fa;6<(>TgJ
z?b`Z#asSo?etqvkB`awD5W+lF%9;n>Qnnk3|93Vz4d8(qGJE$K+)|yyoHv9(?932M
zaG6*@@<_c)O__@<jT*3Nl@9<3Tx?lLgq9r}NN5=wAXy|XO)F_68k~3n6Psik0OtEx
zqVD4rwLBfldtTwcg9^Bx5%v4p`h6kpN=UfH#$5#xHvbz>gntCPcz#gamX=d%TZN%s
z_mOx<XW~8!VX~{5%0JZE-9gyXqBVg;%kAPU|GPGMuL0j&mw4=zP3PDxHN`L2ny%Ml
zHg&*<+p6uoP$5%TzATQbJzp8Fwk}mas$PReR3)dIgDNIEO$k07h=4=p)$$p&;0}w)
zO#w=K!?>rdshpwOX`b6XzVt*>*L6fwJ&}8&xj?<1w9=Zu6Zc_v?FW8TRoNcne@NML
zHQ@S?akYSDF8^Yh=c>W=5##Cumbv`9YM!eHuH%iX4J>o{Z)9VxY{Eizn31`?Zn~bj
z!c3aL`}U>HeZXI;s%SIPbHOm4v(TS!^bO#{rm6#PHlh}g7+J(d2Ps5!Gnt6rHu@Tn
zFmg)_B#c}kmkc5hrMO@r5i>U(sZK)4Crn_;&wst@v+YgzUEm(NT&vY#EEhjuDc+*N
zIL{5V!y8+t-9v(TN`1RE(3w1~r~YgvZQvi@$E2wfgSN{3e%#B%M*xWSG@|}96wVDQ
z;B~56JsZESQ{->cPg$#LY{!T0_o3Z|_%$sjgdT|FNS_Hw47pziwydiIUr`u}AMhEt
ztJR+Bb)XTs-qYYeTQjOa(nxgmMYVn@cmac#OXtb)Q}PM)S3SyYD)6WY#VM&Cc-<C-
zN*2h&g9zVMWwB!*joG?nim;w43)4#U-;?8~<eD)SxB<j5yUleo{v1u<3wo610I#rw
z<!8|mNL=im)AN7VW45J&kKC$AN6a2oSb3+Z?os$FJ!YQZM}isf530)FYB53Ekr>VY
zXhLt45(DpOiS?ha@LQ(pou}}7LG?}z{(j4=XGr0drm9`1@cTiP4@c?$j#kc@dR#I8
zy@<|=>amF)SClWFCr|8@9CP^O_$m4E%u-EE7n)uk0A`I0y8q`@Pu3I|8u>)AwuV2^
z3UId^cu_$1x(zrm^}s|ynHe~+yGK<NxVBE<tQatpE~BDo3e0qQXG;GESE^Y{^J}`k
zRR5`}+pRBd%OTq7rJ(_nfozN<ez%&53dr1-EALAhhcpw<ryf&+Cjt==FB$c@ZmF|g
zmzZB2Sn`|i{1}COZEL9l85oJTV2}b!WD6YGfl5*hWWW;H-6^uW9ocG1LORk?U}@9y
zNgS?zZ$4teb2$sg^Mj#qU@47xslxrP4H?&#kuEcdA$iz!aiw=m$=A*rdXz4ntMJO8
z`i{a|f-3ha{ofXPYL}5sNcb8x$+ss2Lde}AkoA+>QO&P(0_Vz7{2cDT`IP*4lpbYo
z10JiY`~_Qtj|RI_6n@rJRp4xMm0y!WxFpy;t?+eI)eOG9NGOjwN`;m6DA}#9a0^pa
zf$vmR{(J*r`(U@H!ac3w?e{9&FQ|ZFF#Bn57|ed)t?HQVzu^0gtPcFGs`6_x!jr)+
zAA{2W&CpcO4cP<FS5;mm!cT%7@MmQ^gkJ}{QnVa0*KV3PC6{F@1>SC|J|MjmD<F-N
z?-zjIw+h=p8YfmjcK^iY&B|r%OVQmO1U7<|vOBe|3El2uXD8xXp{3?**6T)du+}Os
z&@CG5AhoRnHQ+CX86qtShQLj9k{66f+l8qQyndJ=677|zslbM|wO~a0h&8(b{M;}@
zq%gA^KxTNsh{OO%Xdpc=4B2A#-?Er9g%+u%TDj2&&KPEh^vPfdyknRl(*3~@$mO#L
z9S`&kI;z)bBV-SpJ4kt~zg!u6E>O>V>;mL|zw0hNHAlyMCHXne{Cf%(Nks?LPIRl{
zs`x}4o%R1)Td(f@$;<WBVl#0!iI}j<C4PD1AoV^(kNlgT$aQ0{0{bG<ICm(qOMK+`
zrBZ}zsQa{t$sg5pmCDS@P7^P@dr-cNLf2(8z6yk~Y#t~0tWv(9N0~bE7CO>Ps+CC(
zgtRami4Lnoy}#9&@|Yg!GV)(kze+YeyDlEpEnjxUVc__i+NLM`8+vv_+lSn=jZKzL
zG)jrG3tXJi_Ihsrk%Pr1>0nq*UP>^6uq78vNbJh8lgC+}r=%Ae`R=Zg*e0Fk7nR|1
zWAZ(TZPHA4Dg&2|!U~BiN1~W#)De@>6<<tjlb~TE+E6#5Y;?H{aZ8x#z~Q#92gvPT
zW(H<olUvew6o|z2uc#P_*ojo(<eo8$2M+gzJwWacGcz#P%|u$aXanxmqpbQk^MiDk
z;W}Gnj>M%_9D$!()>W4a5Es>@1pT0Ltx`G5wm)>ohwTqY3UbK>UY=k;$K}7gTap|%
zY~{%4NWAP9w=Is5C~~rXGI@9Shz;C3d}x_9gb+U742|j_a7WT5-^F!J7-cts&l`gn
zo1l-uFpiTZBS>Ye<<h`y&ctw2B3h)a!%Ycr?_q{W+yu!a2c9&{5Q&>0F$CT^%n*s2
zATb1%?uR7DxIP|g{M|ZU1C|`;c*pfL{-%1A(F9WTO8KKW`90k@=<DjUi9Q^X+YsO{
zcz#ovakxtsKOXYPU?eibs-o=K!jCgpqEEoL-0!{lDOn!C)%Hi#0<Nd3;?XhEf?zlj
z{ia6W0Iq9ZZ6JgheWQaE=-r!ZWWTe~*MO&$Qmu86K4(E|K<HDyLJHY$0zX;3J21sX
z<3-ox(;Hsok@!I8y;|POeGT^k&1_{$XPWnN-yZikufx38VR2p0sMm@Xt4S9^UG7$!
zSf^PJt7j;@E~uVT80x5!(JmIQO1S-l3V4vJ<a6+-4nj!FJ#2km1HNuK)L<Vl_8RcR
z#xDO_48keFE^ZaW5~e_%azak-OXANf;SY`2rOj-8z)YIJ<^i@|f&W%jv0jnha-bQ;
zc|$+x{g^a>M=4kK76%x{V!<N4VTm+=D{08g8B7|5^GKOIX@%B+WF&hPkkImhb=DBV
zYnDe7NX*=Bq>zxxO%V`E@w?3UDNgKwC4T>}ZB(?WkY@WacrVMf4g8Qbd{PH|ubK4&
zf2}HcM{lTu@My3jbyCctf=M^A9UZO7o@6tjir1<(f2u%;Qm^<>_P;Er0dm4E@!HvE
zHSSFzK5&t$y5-Jq^28x|7c(A7y81qIo(iNM8Oc`$f2QYQ995YLWE65cDktAuIZ{v}
z$aB2=lpiut#Z;n-i5ToNtzq@^6^3zjo5y$5<U#XtpZ73<MauB6N{rLd-Q7mH2|U<T
zE#MQXDt4H-63^8GSJ~0OW%DkjJwlJ!qy=AWS@c}35VFL_7?|qjRR#8%ss(JD%3b|F
zqNfPomAwKr;j&S24(Q`v#QyT_NbD-A*lR`<RsIQp?&2v(>>SR-9A_)XXY{yI<@Dld
z912QWGb3MN*UeXXW6VbR<2qveI`%|C<DF-m!y;uEdk`0v8n91Q*%YdEkd6(8z!}2~
zM~d)<M#^?&g>YsOdMv^REkX~l9KlaYY8YpZy})vWUW;&AFa(w(_@5f{5vCGhnsK#&
z<)Bj&L8qpI`hTtEMeWjR7NH6=1c`}>34<daw1DLr{mXbb(sLOnVA;{PAIFeXFR<+B
zyXqa6voo`_BXg}YP2m0qGmra#2db*r3X#6uFvEDpLO;*w8^FDdz7B*iqi=MO0=>H+
zK>wi8_X5}cK#^3&)!RYZPPOuKE$~>)zA!}kl-1M=BoFx%wf{(Ue#a7VuY_!%^=@Z%
z_W&oWYE0$iQJq;TTpH|vmzV7pt5C6$dVnjaD(9=J@S$J_{7BhufeH@?JK*ojcHM^*
zjUA^)ncTpMs><UYuEOcT4tQ4C?z<}78|;7&l<m5zMcj?`C~<+CsVa}VhYClST@`q=
z*~tf}D^<A4l+yegRk&A=668^ZubZk099=6?%0H0ps=^_96jxx~>?Fi=6)rNnD)3UX
zll&f4;YG9S0ls8*!naOOk;E=~l#LAdE>-3E9jd~|gB@_FY<IZ|KMHohpOo#MK&Th-
zCGHr7E9o(hJ3)p0f*tU{vfZ&Nd?wfdKVP=HR)q(G9q_@j-4Yenv6Wl}uCJ;*zsV}J
zf*o*L*>0pIe_L4cz<q4#w%EkBvQ^arvH{5*Igl+T@m<~5H4HIES9Wr{TBeKBT%vw^
zXik|8NwF(tI#OT*OmS_Z9PC>%#p7_^#BJJ3i#}01o{D~sMrSunME52x`Zts%Rr`}V
zWm3^^PWYXvgW6m2yF&5OxL!~$_Ul9?-o#Zx1&mxO>q9j|cKk#nZ{i}Q>Wl~eGaBhx
zJ!aYLp!@f_rT)Zzcd0$snnZ@)#AUdqM&e48VDTo7g?tz4)|Tq%u^NeMSt61*agokf
zmJ5~==@zx&YM6-RO<bhMlx6>=L|RQRZCp<ik-UkEbbzwd^~m?!$Xtb2l`r$<i-PnQ
z-H>3M_&)t)<zHGw^VOzw9gioTH*pm`qby6JijcVvSZYO(V4SFEO}(Bkt)e~DhI@*{
z7<m&{(OJrJwjLQHWbQ<kS`j1|Cn~ziRkX9aGCip_+|?v1@+PjLaXPQJ)FTxkb1$^i
ziXg!_QPEM#e?k-onR}_F#(@OmM4Y+Ge`6E}nR~IN#(@OmM4Z1U|39NR$lS{<H4Y>g
zC*n-fy?-}7GCs)M3obPdBp4^+oT~gYqd3UiOD;7IBp4^+%vb(9qBzLhi!L<|Bp4^+
z{73m$)H@>jhRnU}QsY2^aU#y1%D;aU2bp`}rN)5-<3yaZmH%6MOgwLyr>E{UlP2)}
zEk0zlfmKx%&mxeH42Hm?&2XlCDUNi!X|q4`M7l1x$JYz8yT!6=0RP$~y8+;*OZ1Hn
zQlK9giT*jGuL0kyT=}zX1Pac|uXT`SmrW6fT9__7a1Vj+u)12l0{1;F4Z>TVu>i{%
z_=i{Cacb-+rTd?YdR1HXnzgJ7+}FmjPHPSiDnHupva*7fKE+y41s-ff{cs-}RGzy(
z?)ZC^vnO!V-iwW>3Z!?*Z!(x}<ANWMi6UP-k>;Vn3V58U27pu`D-?KUu!@U0T#GnP
zkL*(;+5L|d?Rq{}Pu*%J?&GC58Ik2%%945|WHYU2iq+-5m3X_JqK&C{?XY<hG>NYP
zVIflDo632b%qoYn(KLbAPAgP0JuaJxu-;*Xve+AuHdn2DsSMmjRk=69ykXu*_m@o(
zo*rh3w76`F@XukUNUxSn5%z4C(~oBo&3MEHuLroAvdQxkAjM~`=;<JlsTczPV!llv
zNs1NlwO|D#+r&eg$27$!EY&KI@sqn=AfuOk!%U(Kl$Ze-rpzoJoJ>bSG(OXjJ{`_<
z@qd4bCRw&{;?!iGEIunvBv;0n<jOdeTp8z*E8}Dc{BE1^ea9$V6jZ={dRZ4e!2MJu
z&xD6M2vdXIbqa4cRo~>P1<Q0j%J<g58LC<>tG{dV#0zK7?CKhSpsu~99>w8HEJvFs
zeYA@Xi4~A#B%=!qv&nsF?t4=El=k8R>q!mx6;*Y~A0}k4l>35f6ijvU1s5e9Y9-Yu
z>FS^YGGo`25A+wla#q*)3Hr^guenBn48H^eGAkWTmu>_b=uv#)iSlVJ^CCTF|A2h)
zXaP-V#7TK0kmsq#%JK*QXB94}es8@iTt*5?Pi5)*A$2!M9c8^nkMhF*lC!#Ym^fX2
zV+-B2<)rd+?#+)cs|j`R58fkFM5(Sg|NE3;eVzRBa^)Q}J4iKK5;dy2Tc>kjh{TX4
zhUH4-xJHlN^3bQ~F&cW;C37eBCl4@Sm%5I}Hi<2m_5Fk<B3+p^^Wqg|$ggvus)WU@
zr-mx>qi3pJL62*gqnwpjjn`KFCVE`e&QI|F5N#YPyA6o=$5iB1<#?d*W2GkU4gREs
z!6#c(xr&G}woY{Hg*QdGyOzN&k+{J*N=?{ivXKPO)pN1~0`F6mTo;y{^={pC*q6jE
zs;KfkwO^peFxAj3)HAFU<Y!dBl$8QGrip(2Qdu6+V|iJld#W5My{svl<o=6fx6)?q
zsK?NWxM#6tYH`IjiPAr-fiBgfG;-d|Vwt02UW~NNp};PcNo<qIWQtxP_6b)C;Clwb
z-K2k41ILHVu?P6Hs)}1jr1kskUIREmRfQqaKEV)p#V|vp9|S{SUw_D1UguHibUn%<
z0G5mM@00lAdQ-*qb|`LBOQjb`IazVN9i$V2A&_zkLnJDarvX69DGZTrwBmY!kCwX7
z+d-n_#1EwHrz1v@a$%yfB{se_YS`6ksFCeAgNnS4u)J!(Q&qKc_UvWHiKk^(i|9Y5
z23^d)O8Tn0U8~2@mB}42#mR^6$My8HX0~Go{7=(O?toX+`8~R_V`pW>8=G#Y&gP2g
z+vtja7QctqeXt(0RR|uio>Y%i$dG4d;Ln*^`(}j<cxDE^Etvg9;cI%#%)t9-p>o0d
zk;2d-cN5rh<Gze}&hW?_Vm45RsDR9hH#wuDsZjCRE&moncI+Us^nvB<dOAq-Sqy>9
z<g5(8M;xiW`-UE~ABh3qYKx{0{IRO?cP9{jAM99ftJpZ#fuZSD$|AMI17oaNL9#MF
zq%+|Pn;cc(m8u#opLW2kE%5|0hcYwp;=l%Exn*YHx9KtxHegs~r&hq*1vB7|wir*X
zfLV;f7Ec#nc<s}g;^!>Y8jxaF%?5Wuch~9J%_&Njj_iZLUn|9mQkwjeJ%}_T`)hSk
zZ$B1ANYt&mcj^%LSyt{N4<>95*%AjcV`c1tFlA<OTiBv-mygjmYXUFXT<Zg}kBpYj
z9r1r>s`;n&SiEFELw@lsww$6PcY_UT6S(=&+y?Xkw^CKM&YB&hEsilmV9QiZ;4P+d
zANze04U&LRZj~1fBJ>zl0|<L=H&T&TTah*3=ME?LHt@P5!<|X3gLKSMW(d4mRarM`
z9i(puLm-VR43T=Rzir^9rT*4BNOuN9;B&(akuI>lw1M=c2t86`K532V0n!bbyFglz
zarGn`Q%^OfC()RCsxdt_pXi2!2GWWmG!oqqLm;gv43X%D7y`?U@s|ugBYP7wa<R?G
zY1a8(AOW(6f9_Y7Jpa@L|NI31)C9l(m9BGjK+m^<tpbT7mro$;N>ZJd2-%Ye>3@al
zOB!lU2nl4db<4)P<HVEYVGtTJ$Tq0r44P6-ce|W|c_KCc%U};`N)LzBfE8W;^6&lJ
zT|r=?OFtG3BK%0Vh1?Qh16_x?B@4Th`l7*jzU7wjI(%FcTS2oKEl-TV8`=&v0DOn3
zs=#YMSZq&1|H@2+Yb@mpFB?Rl9vOe&rnY6(f$U~EAHuiHt_ox&=XNyU^w5=8W`0fu
zR%mX?!d%zZO%+(`-YYW`-Mh>!rX#f->{IzASarvT7R((yQ3dLjROSxGn^vx*V#>=X
z*^5fm%^jpVwxryftgqMVa%DW`EKvqE3jsbv6O~6zz_zKXK*|s+Aj6lD9jK$#8%7Pt
zv=z^|Dp66>nl?BCKn5w}2Qy%DqX(n`nHl&ZW2*w$A|+<rorg5(ZktN-%UDbyW=}>R
zJN{gk(l5eV2mVJ@vV!N2LZEXpM)E_f+T?rmm|G&ywA_-ZPQ|&BQmHFf#tE*XGjqML
zh=ELCdHS=BX0U%4_Js<c3MwFTSRCV-D=Knjs71werK6&vsZ=DYIQ6GB<-Q}hL&|<W
z0_kYg%9pP|HlpHpCdiT$3oTilt|MJ&nS&%+Xh%wjIP!#fTqh2bE8{4+G7gd}mmNcP
zSRX@_K87fL3{fsChTQqb5kwX9iz;RpRm{Ca2aO)dxO(oE=Wcm!HzAJEAwSWEzPhbm
zi2C&?y8_%F(GgC3BHUC7cG6?EvcVy7yTP1oTbkV=o^IszIPugrah3+Up%f7OTh&RP
zbm~(U(0!OC&6;`jpQrHWLFI|uOEb@?_3EK>@mSvFOlnwf5^ey_b5}_G9#H=^vTvlu
zP3#``cA1Rwi(}|Rt6g@7>GpkA*v8}R*g4n+6FbQE>K#m6pap8O;jw(+Y63Stk$oro
z_=&WQYGvO6UOLP$&XWimTZ9I1-{ZKAnz48gfk63ojzB2+r5GSlliR)zT1y1II~8>P
zpbuJ01oa;Se9)dm&_$`B3ll+m5<&g%N&BF^1f`Db(^+p~0DI#Ag<(8^uj>?nRu(Fd
zF_V8w<>6FWcPGlK#!+Pe{fCI7bhdo)L(I$i0}6N5StB1W_fz=epxX5K!ePY^o8u7*
z$9=?9qfaQ{K6(@`;K8P<HWe;3Rec4W>l@fIs8i4Tg6brNX9iW=)pfPNUG%s@WyZXr
z4$>aBSgJtEmR>I$q;Q5<dbnVaL`o~e|Nio2%6xT*04zmVFnFT2v=m`pDuVxLx<(Ws
zyC5V&Tw_HLDl-KCMaN1CyL6DzD&=yin^~E6q63$@?Rh_)N6e?Zp~T%nr%&F{dsQeU
zvtW?<!Q{v-zpOKa>5(hf)6p-by<qTzs$A+Ik>bsos{E^C@>7me#&%Hr%$CJeAmx}X
zB@O9F$`9CHmXn~k(pF6qNcm<<3vSXiWG7JEX6vj8yhF#%Y*GBw7GMKNYt1%pubqfn
zY$xJ2+ljc<b|PMjw7ay~(7e*lLMxWOvyf(K&mh6lp0OMo1WEl^hgvp>^M*P|jJiCD
z2QmQ)LkeI-<(B@H!45Uh_Cg!?ywFk!bGpz{43oOh#;q>2BlVd~W#uihjfO;J=`0+K
z^URfTnz=I0GFQe)=E^w7T)7-6-knNuek#TJsm)>jU?Ro&gNYR9r#1(Fo592=b#ZYj
z#fMWVKAcMN;Z%wbr&4@4mEyy0i*4$h4GXHD`S>N<bozm8KC(U^mY?3fY!suvrR^8}
z^e`-|{<wqkL;QYOxf|YZX#7Qb%q|<?^>n|NFNq0#x~0&Lr=M7n&2Q}n!TsLeS2WJe
zR(JJw-7<e+Tc`V&^I5fCs7HA;(%nIL)RfbwcM!;3nz$(6<*DEoVK**L#C4bl)v)00
zM7&5CIQk}?k4@q>kEyKuMxxL4I7_(^BfqLOwH{|CR&l_mwJG#La`N2$aC7k%E6?qU
zIZ|85bxaylTuD)IHIt7gz*5@_+c=Jq#FY>YhJ2rjy_1_)!gKy$!qe|5vFDrX%ja#8
z3;-`z)oA&uA<iK20FwA&x%B``ZCGH%EVjAP17y}pXZ&67&omv#5)VaAbS8a1areCE
z&(V!vg7`za84l_(+i}?8{;E4prUQrjivd2loU1!UW(I!Dc8>wSIS%-p&^`2x^Wu#<
za{II9hMr_Ttbx%Z|3LNKl~eVtZ8Y2%u2C7Rbe$zH6zF;K{<=0XcwVcTTih8mx9geJ
z<^AjuCF-B*={RJ(*l0Gz$<D&ZM7EE_W`p%dtre%{KNpOAij7SbNH4P2=d)iHMy5Bb
zXm7G}abNI>yMjLM$;w4fGOD;A<uGwCm{HwfIs0p@n?^Tjr|;0C+>rtqgwd6gyW?Oh
z=xTVYUCiVW0yhbzdqMd+Qs*J_Ql2~kxs8=If46-~WN*)v2!~sCP2lOO%Iy#?2zJ2I
z#&UP+p6Kq>$726PBT;a;vn&-d-wG)O9^rm5@p;$p?F2quJ1$SHxpk!ZqN4TOd5DU}
z|I2QR`uHTybyTeAFq2kPq!pfs^syhEW=}-iR!W}S-^#l4dDcmaDIiuP#S<J+`J_^h
zX_jM7h6f>~A)1#OqIs#gv7C=gD4p>b_Q9wWcws8=!c^desY&Ud9*)&Hv8~OG8V#Oo
zqh13}Q&qRD=i;sGV^s68U<|y@8Ke2Jo>@b-sq*E3L7S>;FocO$XY9#Rovog0W&1%_
znL8fpT{MS7LgGNG%>ME;+d^Yk3cMt^0;v#JWGY@oE6!-+YVnC{E&IfE%HL*aovB10
z*FpWe9<#d#Ff&bdYnIP$w)MF;^XBNPeZ*F86Zi*H)q#IiRrWZ!*+DwvqxSR_c#f%>
zz;jhq_#*X8H{W<PNbMoZqXvB1R4pLMWb`#l?M%y~1tfA|h!pa0U(S)oy%w|wNUP*c
zVBli2>I0Tj>#@`ZEww%%$z-YZbdW-7Zeu02A6n2}Ao<8|h5`R%R&8K8wO&i@EK98o
zB$+I=-b8Bd)A6Gk>~RZPCD_YB6_5Ff8hH)Npyy`_7Y7w^b)7tNou5DSZWU-(t{jQ~
zlSVc`W%wmN!;lrtkmmzHyqCK#a53g`Q3aN{mTUOoV%5pz5y+~OTPk3gzL^+8_rd$m
z+N24#MyoV=zo3d+e5`s=)rbX-<Vb5r?D9yCtZ@0h6j-j=|3wd}(zG|zzhxz{YGp=u
zmwYH1D<5Gxq(f<IWSf+{g3WpKv$S_>md?w1^M5pQxb}a@#-Rz^`V@B50pM+?qUr;_
zFay<q!H*THY$`W9qf|OikFqR)Uo=%8@Cs860Pi$aAMi0#4FK0Zojm%0EmOHqBwx^S
ze;mpN;w8&|k$Y+xr<q+Z;{m)h;?8U!r$s{k@F1OmG*?n}DGmSdG!7xJ4icf{cbQB7
zJEs**`i>1+YofMtmbJ9yyX-Dye^a8D^(fCYfTa@W4Ni*KrNnuIF@LU%yZHH&ic~Ms
zqeKAiq(Q}R))2zGO?k?w4#L5fUY+_%&7L(xv&krDWJZ-b>3`4tRUPC?NDsJ`s^rc~
zo>j{q?#sXJ-ZdUA`AVqygNdZ(4<?eDKbT0$e~f#lMm{Da^<(Y8J=TdTa6Ov@J-|a$
zl_$r{sM*Zup-*I!+r=X{Mx#@4;(6Ecn$2`Qc2#D`3ov6l$Y)x%4d87dwK=wO=%3^<
zCpE3+xE1hwWv*E9H6TqGUHN#0+TUfh*MPJmGmHN_RN1LdN(bJer@AXc508@ldc19n
z#0qC(TE7-*tcB8QyUf~Bn&X$*bSh0}zcCQu|K;o?1{V{#5CFND$R!>~VPeHT$z>yb
z1&No9aK+PA9GSUXBg6_wgT!iC10e4uUN(v$DD`YXYDF)wAs`=_t_xBtdV!m+i*+si
zGpuOfhB~2yY+)+w!c^FWsj&Vte;hWugc0{4y$6uEcMl>wW;X^^;JP8dyDh&kgiT;+
zvfiCa`R-K8{@EF`>(G<A59kM;ZK_`2RjSH24uo$8yPp8<9;kPe!m+062Qp`cZSEk#
zUDlFb;QglR2hu?K;0K(njgv1}*x%@tsDP!m&9%1uNVlsz5d>zPY)0|y&+VB1JK610
zZ%tuX620+~xL9Z8)nR7FCg0RkKN{KOR_*g|=y#?1lEPPm>Ob1@HLQQt8?@3}Y=f@u
z?2>lhnQo(;>^pLw4rJKm!vc^25i36s^>`q}(QiTRxZ`3)ze97~2d1f-=ZV&XsgEn9
zJ@RoJqA+k%fpF&o9FNQ1N=1}xb%UAZrJXpmp)YPj=1CTW6whS^l-pI}vG!zU1H)Ws
z0YlOKKn6)ZqXAiF!UYVu_r$qN5`G9<eh6EB2wT49{$<rHBXQXvRsX}rwM{*n+P2aL
z9%8C~;1Q;(0?)EV(f?_MG(;K!42@{}Mznn+`h6q%eIxpPBi!>FY7TR`24r}%+rL4%
z{aftjc#ZbFs;4leE(RJs@<MGzraxJzNt6X54>f^ITp1z%rXt(JF4}l`bxyuZ>>Ara
zv2Pd=T6TTdlj2!%rdrR|qx?yGcL(7qRj!`>IZT(_(RPi`{*`$~^{ZM^bUF?(s4T~-
zxs<hF5DwawE8|hmmGL0w%8_D_`TvJ9Mpt&TPEbXri;Ku~aSfSnq!MV8-1WsxO5SHC
z?jYUmB13Sg4n?+2f*EAF8WZmV9jU|zCA_XzCb<;d7>%!}Afhj#irXTpxGSQHo8rUO
zeyHI>-ZjE8A!RMaL@R4ap}VPVblG0ZleCYOy6VQUw$KcZ8M*mS={kPJ)^iQWb|S08
z?-{SEJw}OfJzVcquC#luCh!(h^#gBHRq;R#=~Xjq0#81}ZhnD-rfLGmooQBaSA1R#
z^7^iYs{_d-%d62r3iNJ%dHNdkHyC{jqGwH215UGQTEIS4Wl6|Cbf(fr%&-c)#Z)ce
zZNq$#*0uh)=U$)IltQ+BWP7jCyZax!ZnA>fc!g%U3+JEIx?;pt2KD1X1^gdXjjjyE
zgId{I&wU`cU9Iq@po-n-d5B*l{w3z+Rz6w(L$lBJJ}~aGu>u*1%q&iT-t24R(FA_Y
zRCVBlnZ>M@CF!5rLiKL*YXE<BmaPWhL#is~HPTudK<=u5>!_-`a^dWuuI??ycF>TG
z7{_HDs5u;Mxl})*@XVkBQl6A`#n9E7*nG>m3jCR>a=VQ+uaJfNC`3o#&jtYepr#>Q
zmkl929&!T`JGY}ve+h|PHiYnUNEk?NxpUm3T{YM*%&!gqYBmgQ-)y&tR{Z$?Ved`g
z<fy8?|IR`Ph!FNggb*Siiwv6tPzj(ciqbvPJ<KGtAj*!)ViF*kBs{W&O;#bY*kLsy
zLJ)x{AYl<AC`J^CD33u|1tB5|3d;Xf)$e<%a&I*ge4qDyp7;O%M?ak3J$3Hc?zy*a
z-LC1*M)zt_d+XeO)0@`y;@XE>z%yhq6T~QSWL)f$=8PN0fN3<^qhF}bSfMUs4X&s!
zR@4_OiYgC}HuA7LfSWq23dC<4pe55ogDEpKnKDD~*O6w_+4Etj%vhnSlBdW}k-Y&k
zx*4iUnW3_j*~%}%O(p<1_q8K5V7sPJeaS`&MfZ4G`+pqep+DB$AM1{Gmq$p^*{-`C
z_;qJhLvu-Z*!xePRnfBWZE3hA*A%-H^*Tn<r;4s(&s^D`vnC%}!p*&lPLrNe$G?hN
zB`u8(LlMeHr))xn;~e)Y%llxxT2F$o=MW`#T~G2vAdZ`|H_B$z8&Sybmy#`ASrvGs
zv)X|L{m;Ap!e9eg&Flyy^uA52>#@GdHh`x)s}8*1Sq<PBXZdY-=~NomifQXC@cS1Q
z<XU<0S=V0&7W&PZ)~eqX-meBM^qb$Z-=W^G9a!l1M)ZLX+4}Ny_7Gh_LbtI#ZyF7P
zx6@u=<Ex&B^QO@_N=%aj7W_D`rT>S|z>jX=@R_hWfo)=$Yjda5z{O<G)7_-?j1OEV
z5Fax^TDWP)aX>uI1X~T&AC+?ZiPH)g>-OEQl@aGJm}bW<ut-}X4#rSHJhXQB$ypXw
z`;Uw!-#EC1@TWxWF%7uIDVdmM=%uMNrk$Gi1>Y@RD)_V-e=Z0PIW6n-0nt=&XEnAz
zqhMwqHU3g$(zxbKY_~PRH;89`-zB(0KKWjnN@G(olbA=Go#|OqG~s~{6EAh~Of@bn
zGHKj<PVUXmgxAmO_@$|vszG(6DyfV4=NF=WM2*))Eg0Z?FDS@uq{e1NW}6z{EixZe
zW2Jn7d1>l;Y8+E!(zry-<Q560rc%$tYWkvT_IO_|s=zaRCFlV9OtgF2)Dg5OXfv?5
zWS#7wxF5-fbn#Rg&xmOoPg6;&knP1&X^?f>qyP)CEsmD7QJN`hirRoU%xieoG-|jI
z$E<01vRhs?v!+o>RE<SEYZ_&Pn<*0q3*$L!TFH3Mn#On*LYWn<iW@3~P4ZA2=AkT^
zS`x~VsU@K-nOYLclBp%3ESXvo%95!ip)B#zEQGQo8kHf0ko!HiYzXF-4Z+;9A(&e>
z1aqgA_&v952<Daz!Q5yFF4A<Ei~p6Vu&pr3HLH`cSd7THu~=bPT#UsWryPtG&Q(_a
zv)zL#@Dj1?^m=%c28*{n(%&%cqT!nkZ-(WOU%_9>J->q6)O>!0Y9X5Z3UM(d@+;w>
z<X6Iq%CC?T$|}DSW{A~{F-rdqlW9$eDKi|Dlu01CpE8L7&r@bNS}8O1Cfozq!mwc4
zwOa28CS`^_$7wh}m5;Q;eA+x+Hf^5vY4b-}vSkm*=$g@|%VyHkK9fjADoJA_-^*2j
zWG9s)MTJH0>9QI3blHr1I+}4e>7K*@nvI!d`I{N_d`vx8_gh#4$W3cRdcWCp3)%%E
z^V|qGDYHCp8V#S~(m=bAih0rY7jvYjF#Pi(_n(m4_%@_65m?xKEiPN_7f+?YaMyfa
z?6-h|kBfa_FZdGQMDgV%Ph}N|Pi7&0iG_au>HQ`E3o*<qE8!OTFU|A2%I7QYOFQuM
zddwJWf2g>|rZf3B<haT@YZaPXZ84;>&YDf6iF}*N)b9<sXn1x$FnITHnv<gm{;bmg
z7IHMdEJyRpYIMHO{lYlU_Zwkhoa5(4d?B=<_AxfN;LMydXXcbSGpEd%Ic3ho55G8r
zVLN&bZ(YU;E8SROjTkGe5Mzbo@FnGcz{jBq%<m-j_!Jtn!hgx9R(^XiW_)`wCd+7k
zdod<=k~NFl`OrbCmFoCJWzvvhxh+TSE>q6iWaW%H%6dP0k$0N?ZPkB)YE)7}?Io(;
z&D<$-zg3p7`QN#0GGbJ4dIt$>IAxX;)x5H)Gp}sw#P^QSu$6mg)>xrYWBq$m2XmB?
z9g6`Aq5q#*!tjOh|8HHwUe;Q&s!pg@uy<{?8{4FLzVGZhfh;wWWIR|`>^Lf1Rg4v`
zDaK+&VcTr1aHibNLZ{879YKu>t0dv!1N+8=hZ8&xBs`u3xa}moaNSLKgZWWjtf3bs
z6*^(8&<A6ME*LBHV3daEU_VG4xkdEp?d3XF+xIIR7EP&qN_ZumuO+_;3FeqBIfdbP
z?FK(dn^FOP*LiLJX!a8yk|~w%%*yP&A)43-&&LuT$6om`O{wtM#z9viH&Xj|iYDQ4
zGs=f<N`<^}yp_m>2UH0!d}K>_R2?T$2`@Z}N_gQva!l@QZG3Sm$@`fSl`<*RQTgfO
zi&HmNV}<;T>BXsGUefL)hWbsJ6c3q6nPF;DW|*6l$vI!)!RN)YBa#=(j!0gNj!42>
zSlx!1FjklcV})5TR+s~0g&8nb7{9T?=#3S|ZmckJV}(^=EQ*31sIkKFzeaOx1I;U2
zwZc+27Oqp(#tMttSjXwybegEK<_a=G#=_4fxl}8sKH?L<tqEo^umV^(HCzo+X1pA1
z7cB>=V7wk|=j*|}`Sbq5so{c<_72mOtUBSSr-EVf62UNg2`?P^v~xK2DKlOa+M1-5
z+fbsB@n=y;JBO=6${cJ2(t{SVJ<DsQH_Wwt=pJU(UPqX#WRg^q3bU6Q2s4#3!&Ifr
zFjuDW1+B6lIyYOrjRhQ^e_pU?T2&2JS&M(sv@oNokuaqxlbn7ue{fhdEzGIe4l}wy
z6YYuovmzj+op>@ePK+_*#27P9j4|Utj2Q=F%+Nu+V3h3@E8rbI;61+*<bGjNtdZPS
zjl~+tz#EG>^o(w*#`<G$pEVW}Xnh_38*8i}cUfb_qu;|kInB??`hg6z6(WPjgfLb-
zbUk5a7`nXfJD!Wu&=IGhBMz`599}zb4hPp*;m{f@j=3YQ_>Pi_f3~dRpY@7o(KZu6
z7VTsS0p|;N2i24>;2prS#iuY)o-LUu(Q!N3W_H*)Dv+W}Ckpv4Y*H5a(OhAZvZ!p6
zvZ!p6lFzfkCS{R-I#bxBEGqkaa*?0xovb2E{S3=6Wrp|flu2UAV#=gsxre9ButJ%;
z+#Id0yH%m9X`^f`GB!)wI%CBXwTFpH@tPE~GM|DyaXI=F{9m4Ly>dODZ=JEZPO5)>
zU++7Ch4p@6S@kdUgYZIeE-Wd|=n1YQ(bN9-CYpuqowM4iAXvd|=ZBw6qJ*VF$X9OP
z-R3KI9|ghVkadg;qHL2&>E^3#wEZNX_?dhhJ*|nW3zgc8OY2c_?aTv6OzIwlm2tyT
z&$t9PU-zPnOY6sevuXgzLM9j{BIAZ*mT|*$WZZD%u2XdRJ-5mVa+crQs=(Wv)edA{
z*g~;z8uh)ub}J?CYh5XWw|H9p&iSxw?_VtV+nj~&qg;3NqT%h5#wT0L!+5!r*S9~m
zV4&o&<#j3MerJk-8~S@7{lHDcvQIFdpEhFT;tiW{SSf5%5$+3(#fasOL=lFLB=<}_
zS=l}5#NN1^72E5?-e}Kgv;ZA?Ubega4^jKe85EuDx}#U>JG4d~;Ju>#>Dv<7#6_Z^
zT3?rjx}gqi=cCs_5L<W<(JlT0*?QKO?&`JD{XlO1t1|OVHy3$ygrxIqRPm@I?*%+k
ztf7??!YZshq?w-I^{UKmHlQWNJ6R7l`D)qDg2H-HGUMW2)wov_EBhkWy2AR+7RXqv
za%_N%^?&i{1TnMpXG<n6R{ue71mq{{PKsFMGcK)s+<eI=mzf~x{EOb0%eb`O64!hJ
zayFI;QdR7wGA_>mY&<h=cs!JG!@W?(Ex+f4`^-!>+-PQ8CN4Y8j2q4rhU9<LfzfaD
zQ2ku~aLt1jqhPa_Bwy$cm(}<|E1Gv}o}R6^8;h1K0}Wkb78fQRuU{IA(Zr^)7#^P5
zjTPqm5b1uv&G!N^m)z<7A!m$EWbFuo_dy@ZS@`gZ-nmS>;>AC-KBi1wm&{#@ZW%|&
zrQ_YTDsZlr)8xn*jJuXV=FlVZED;0e8SBSeGM0$pEPj<8YLm0vVkZ{&^jvh3p4?z(
zXwZ%;Lwm*whiEqiySwietH9iYemr1+(k#=!m*j2Qo8;mx?rIf?t7%`HeN<y<8y1H3
zFV3n0$zkb;Ti1$?V~6{(Y!yf;B&i1H>HkRdxy{9@hnw@d0OtAVARmNo2N1xHJaXV4
zoYes&8OfH5To9!xW8etPSU>`^MH)yviB#~9YMQTb5_@2#qSZ7o53z?38ReuWm{{%c
z8dw(4Yd(@aKw?a^5hPRBv=JmDWh@{;COv~7D~lD~p<cv38!Eo%_t}u!i)I6gnD$B4
zFg$1~PGnS-O=NTxavG|#@XC@9gcmF7h!uIs;8IC3py+9(%Wjf02b#3D_2kuoxSk1y
zMl)_0K*kM1sD#yID-o5Gukg`uguRk9huz9jANOl(#{J?t3j0|O>Bd~P$pW0HX>F_0
z%mEr#i8<6>4g=>AM)NbYm}L*6D9yOEP;0-X0mMRi^52$E8*6`;EY$2HZq$Av;enrX
zo_!3XIXqr8nSKMpU-kK22i`8$u*$JBnl#uLn!{mT@Yfmp`HQFRbwS>)w1*I$(0=OA
zMeR=sKAW>b-Rx5N;J;*pvOv#yAG(OoT^hi9#j??zKb^)ixg7A4%d)PiT<8M&f9B7V
zb>P{qst<^j><_PLVaVJEes6YWGZUoM^L2vg1L9mJ*vh-@+?5&-mux2n#Ggc0tw{@)
z>{%X&KbascTr!QobMn;9oKB<Ya{N`ZBy=x#xgCf{Hfe!)WF-Xrr+4fCuJ*M&o9#_n
z*NSWEfP|6+*50Ir<0c3!#?T(!t(K}7uy1Q&Y_v00A1#lg6$=@#wF$_eSyj&Q>U~u5
z$s7*Vr-EUDY_^;R{!L{*ba-ni3{@Gcl~;MM<w@3Snlo>TCP@JA<TEEaBilzQ_>8FK
z7<j0&dhq%wDYqLt5Z%Kn)Ao%@VZP)a^?uPK93tp5J>!}*P@Zg^f`610uB8JU7HH|H
z({q;3fL`Ei`Dy)TPM@bn!9qNZQ^~-!3Kr;TOIzq!$zmP$GS%~=Wg}&V_O??bJ9$JC
zfy`~|H*0#>Z~sfOmEmAf8~n+Fr{$~@m50moK?Gh|%vY$rQ{Lc0Qjy>r+|xRcbepH=
zMY*>XF3eym7urPs1FpYkv0y$JJ)x?S^4eX!4sk_QAd1X^#bx8OILh<d7iW1s*)td|
zr6ubCv5+8sZs|o_l2-Ub)ZSTil)YZL<Jf`92>-dIFkASwlX}>rCJ-f762O{E^#XgH
zRR#7ts~7k=XH|jwczN|cB=~I30>0s_>Uv6Dp2FUE6r)p+!(@3N_W*daSR*R~>x~!~
zWq*YHGg<p(ZWV|_xp0`u<E0L@R<OVy=~6lcX)JM%+JV>0ZYqZ}ST=oO3R1Z+2`Mvl
z?zG6cZk)r8^_xANe3RsqSz;mnhT%=*`*wNm=y!p3K~_njUsS=R-m4dQl~^m-H%CvZ
zj0t<*rppEQpLh33l)3+WG#BZ4huf?X_S!x@qYr7qE!_y)BGoq?9o_IkIdfrV<U)y1
zyf&8z%^6fv$tn`+DLEq>a%r|atto0FwTlMrfPC;~3No%G<9UPj8Fz>#D?T_^-oKmd
zbcrTnw+jEPzylxcPDI-mqC?bHa$v7|*$|vJoks3_w4t~zaNfRxHTJz1-{;Ctlfu0j
z?q+vbt|vvht0>yn6;*-gUegxv9mY;?voDI=X(Ril`C0ark<HLrsZeO2Kpv7G_N4kN
z!HV0D9$v#<_Ru@BxkUY*79DBdahd%T6rAVWNDcURu~H2*u$*fM-6lsAO8Sx?4YFjh
zggGgB5MNGJU1+5q?Uo3{iap^0^C9m7<`otdE1pmCl((NCh*?|a(LKq_Df$|hSW)e?
zNKp+%C%B>-aH?1%E0Z*MVd|MhPq?o=&j{9CUo?m2=+fqwXDf;w;sX1e)d@V*Sq<RP
z&gukC5-WKsZ8T|J;(`s}Dpz2%6S$+Z8o(ZBbppTWtOoG@D_s}x56)@;x4p`x!u*km
zt=!K#kXUW81`<^gW8GuC*ZXz=UoRx1-lT=srV%(*F=ZNQt?>;U?f|||tW1#B_PHQ%
zw`Bxr9h?gSk6K2M)&;pB@UmqDX|3OMAAw`U%6z1CL@o&Yn#L#-q?Hd-^sLP={n%@|
z2Bb>uNe#$w*<lc{IC3=~xeL6a`har^15#_!B4=g<NWzjBYE4??%mjfXEEA-)qGzQK
zNWwBfTHEG=z`YB3t~F^Lm<s}rTSk!9iMb%~oMi-Q-INOgA6Q0^R&x%u&<DIltSlH>
zoBQPK1MXI+g<6wVUJHHUl>LQjU|*khy^JnPj4l1ZYb7<*zA`$VhrO&CqkM_z1#T=>
z(i6O8E(XNYL@fNbo{Y1k46A&3VJK4xh3u|~{Kq}S4t!_HEZIVyDQQHLv-EJCNqE#j
z?)i4n1{qx}Xl4$G`ebD5k%5eh38r?&rG?>=7{cU_s0>s_zP&*+%r^Wmo3Bw|K2YsL
z1XmDU(Y_XMhq1?0#=scqvQ;4CZNF@3vd6DCVho%yF5C_z9NRU;KSFt%28HacSUG-S
z`fHUi7D`~bdKZS_DfN4&VF<JHs8;f4eUXozpxPAQM31up{I#<>fxj0kaiY<rHRNiR
zgXpX{R$oW`Vprb*L}3;qtz3O{pNQ4hQ2(T>?**bTQC}<ZK02oe)u$U>3>@YLdX5yl
zKW70S5bHfwS=)_0wlZd9+lEb;zscqC?WLUc7oev%+SuU>4%i)VR@5sRb9#{%TRwrf
zvD_&_7Zqa9vB09P<ti3*Q4Uu9z@n~t$<RfWF-l3h%#+suzVOYgT<r;T!2peMbE)A5
z@V(zE$kA9=Oxr>OxBhlPj>i6CnjCPg8wzqXCW>itz%z?-G_KC&fWIxu(fCU)2R!OK
z1-mpZ71QhjZ!5~tcqNwuo;0tZkH*)<G<^<lDaZ{`V@*+$1Ah0mf*g(e#WXqKX15pQ
z!ljP!zQo774!qS_JwQf1TWDx8@ODQAp5<lH1EdnNzO>fxx~Kzhbyg3M>d5-iI>2kC
z4x~IXL0Sj;;MRfEhn=tho4FK_>M$wbDn77vAhlsqzzcFIAeCWKz{R-~@JVO&0I45K
zFOcfV!lZSv*HRt$ptE{_TYWbxhpaCx>dd?YQfFotSiiN{m)61JT3_I&REC)mT3_+v
z>;cYNMvxZOY#M=7vv~uguuZB}Ss&mvTm#a}ma+K*t@^cjzjk1u-@=ytuJL|dKxRpj
zimoOtCW?J&Dv&9W3DVl!XG0f|`p*Pu?dr3k3rPKEg0w#2b>0PJ3S@$`F3JUg%z{ji
z)+jI9E+7+OSY=>Flg7+k4#-r<6w-Pi7X&gJGC^8Q2umZ7*^mj+y22+y7mx{Ig)nb`
z#@7q8qpL}aDUn7)gGphwffQ?In-=wIf<THX6Kqw5bG@3nfz*#Vy|m;e+#MEEDi_yM
zcUViQ9HrFZrPK|icv3kU{azs5Kx!wIqw&pL4oK;wax^F&JB0>PI;k9uuX%ZN1F4);
zj>d0tIUt3T%F&>7%r20+N#$rzIVR^YzgaIGh%2Kztc+A&To~P9VWe_lUEHL4;C5`E
zS^Q9}`>)AXX50I1aBT*!6gAc@*JZ4SM2+<^?dF~kHP%yt)R?gr>po5e8Eb-y;}9>B
zD)1F&b^J?^Qn8MQstS(vYN!G!6qCA9S0Bu!fRu?zU8|90q%9N7;75F>cRVRL;$~0I
zwSxEOtoSw-eX>WE-&B@ubQTVf=dJU7@xlSpN)A&=T*GL}3<tNw#)2{%3(9OP@CB@3
zV?lJADzP!Y%*OmO8}rL-#JA87D@TP~Ep;0dVp`sJs~QUlT<V4?##FK-flH&{F#P%A
zAkjG7=SK}#a4;Xtf`bbON*v5bxZvQzvdqMrgc1km55x}EOB~Ecso>!JG6(aaD>(Qr
zhYp`C_X|oKY?L^dmukVm1!WHA^;>XoIqR1U-tVL7tKHW5(gqyotSazEXLT^RKh0T>
z3Q~}^&@i9z)mRkc;&)tVSaWvtg{BiY&RGp$)mfdu9%og7r#h<>c!{&BB}-el#)SDx
zKB{IJ<93noUeT@NO}~Xy9eTR@hY0TCtiGv&UvX9yn5Vv<)N?yZOoAB$`=m0=eIiEk
z|ElCCJTNJ@F&d+^Y@VkF_&H~F94UA~&H|EGn*xgl!ptT{|J~G*=E5{t<kN&C6ca)*
zrk=c0N+^k>GnjBJCBSzb8O6Xr+EG=Q@u8LNn`ECn+W=DV<k?tZ+K$moKFeox71(sv
z#JyC9Rj<d1pBFqTX8}oZnz69f>?<Ql;wOCTQw1LAtcjBZPs~}si^WO}d{2!Z=W-M&
zDM{tR$XR3wGZ{95`j-dQ=P;j9%)5L*`k6Hpi+!#}lqbutL_e4SY}*7R4C@IbqNFGI
zXC7rAQBqLWGmLR}4Pm}scW$N7KI$QM;^|GUyAv1kWw$e&ge7nOjFh>3L`PJ*FC01H
z!jb)IbKio0m-su#7x<JJ1qGiu%QS_*vm7T7_(zFP-M}X*Hi_`bB%#6&(@L4(pB-NV
zanVX{;Q)S86)7_uwv^e*0#nImF0f!>L79d8RzBR9)qWrmn$dW78i&;=32T0t(R_nb
zun_M}f2x6I<_xXu+N@}hNYc>CZqedSKVna21j%LUCA?Tye4{|uuYCg49QqvZ2sPOP
z9*z;)oIIHEk>kj)|FH=Vq}w}aKGyw-X7;Ca2`y<R0}o@FI2*_u>87HGuXA)MPktO{
zC{uE$LF9V3R0E>fs&Y~ESivIBeQjuEe3LyIH@1Wq1YZgJ*?L7c_H#BGKs1%CYV;~>
zTtZu%v46vl-K#*J;O&q!JaaYkp`zQQ;NDyjFjv&usuv<<#eimHN)BzG3Jx1eSEdr7
zcqJ(jiWdXUG&uD#b4v$G&wqZUg^c6CRFab&jt^31c>bL-!*rDxURY*$;XsMug##sq
z7Y>vdjvqiv49_n!JipBF{4&Gy%M349suz?QUQlLuL7CwNWrpKI*h#17yZ9-3709sL
zwuM1|pFh#{0Xh1!RWck5>&Q@S;Gcl>0XKD42arm!j^S{X?48ET<wJ7Ufw}9wxSspj
z8~fRdpScIUu?Nw#4$CFE!-e(|UT84kg%%TDXfolonj3ubm&ouL71J-_-KzBdT-1I}
z?TvvE+l}2cezk-!iYmcm(&p)svVvUV1^JfNfK;-~BO?A#ej>bNfX4Rz@og2zSfmQW
z)TGQXH=C*wz9O3B0bB^=^y%RsnYPoXGfIU(PM=O7yXa$&RFcNW#7yjf&v2go7Mp@9
zL~{D{l1NUEUi9Dpd)a~Pv7&Y-8mfVOug{z6+Ja1}lAX$tO2rrRNdjEq`pkxfv}l0F
zDq@;JU?FphyaX=3vCx^uWnx-qAk!{2LWZa0$y_u*W2%_e8Av^+olBCrsBDdkHz<?^
zHJ!Y>27cW0(*24c@g}1h7D~b+iodGh6CP!P$BBv1;Y2PR{Dc=)@pJN{k`KisCHDM0
z!C@}~+D^R^%_AkgnP|cTe>qpRgUV><ys}zppI*@36fVox_<}_+rI6$%&S9Rf{WNP5
zZ@;Sg|AuJ7quOyh(FbOxC311D<JS|vBR}!YzHnf{^vJu68`{mdp_Pmq=C8!gyiz;H
zEwN+V5<A8n%+83)tAFbsTB(Hjh9BC3A6kRo%HDduG3W_R**-SZR<gAvL2N7Reh*}9
z3Ofv@o=Fh_dkB*PQWVR#oxlUk*`ky0FEN-hF^T?^8OE40!*tbd%2v%2MeQY|^EBx$
z_sQ2-Pp^FJ=x>8GLPZBhirUdROP9=nS<_?f(I1x#(a^oWa9|7`E8eimj3G@L+lgu4
z;5ci#{ifcK<{sjZI(xVbbCe5*q2TWtQeqEyl+aQ?AL(Q}LvBop^ziab$&=xg%EgMV
zyFb?5AM5VlL#fYo_lJH@iiRK>rAs7og{b|tPpIW{aq0#aiB3BHq~dwai>L}DVQD#p
zVWrH_-e0AJo_0f~-`-x4(Sz}Rx*KqZuy;Sh#oJh+t+1D^Gk;3ftFSBl!TMVbgk4L@
zBD87?MBFPn(WxoIqeU$*^tv$LriC8%OZpJe5y_9K+l%P5j~9QWz4o8|U0o{;d1fQm
z9+8s8Zsge12<_iFKQm7I1@Z0SVE*)S>!^NFqL!=B!5wtN=EiM_2}SnP=C10yV>?$2
z{)I9nmZr+mxuPW#Di(?SMP#6`(FlC0tgI1TH6K~v3C`+ZFV1RLvH`D2db()Y(GM~O
z&7nVt6dnjdk>Bc#lIQ&;lPZvxO-g3q*CdTd>3u5{DjAwk#Pr0+9Jq+FvSUGH@ZHYt
zfrZy+!r))f+c3NVW#*R-up8&Kqm(&VPs>r*uOw}uJ<CYkE2_M(SDK`-Uuov($t$(?
zmM4&qZC4elD%ohEh+bxGL6oSH)8Re!LeW9~%2@R>P3GU{Pi|pySCTZ=Y%#{ix4c)U
zL!XexZ_!E<@4Z=B08zf8{a)kvy~b`5y_M(}S}8@t@+Kn;Yx&3V`$X-b?h!47u}u7s
zh|D|W{%mb6_&m#;j88m6p^}l0MWVW1pnbtFM3cv_FxOoBT|ox?$9!J_d|52}Ip-lw
z8m~F?xFOAdsIiJ(-?!Tikhe#NRZK2)q|DjSxfLqM+TUw6L;psmZ2Ob1X6WY1T(RwN
z=xuiGxXKv27CN14#P?AO$6Od`E`;8<>2jY(-2gV``<cw_8H4w$)9+8Nsu%dGSjp?R
z^(L)dWx&=$;O=5&g0%3YWZ{hcui?iF?nfsO%Zd7$`|)A-qZ5ebOpsRYNBjq5GKO*6
zN&x@te)I#2ezdzEA9FwYfmlxbXm8TW{pcTjT)Ob%MfalzSoEXI{TSzd^Z>D(_|aA3
zNAw2)@wjy3$Mfz-2e9ZzxBIb^`_Ta``q5qDNAxK3c^NywjaGrLII9ncA2#=aW88^8
zjPIMXfE~`N0`ozN*Ed=Im3!dk-j^%F+}=4W9PNKfL7PO%HbBS}G`CVyh&2>BNEXg=
zXBxoIem`3$>}Cu+Qmmw08ckXk<bs2%ucMw`cE6b$Ekm(eHToUo);fSVlFe#b7%16o
z$LiZrPcL(8&T_cbMZd$`tv(=*WRr^)21+)^v0L4!Kf=}b15uc$?=BgPXbrhQW8Czy
zt^(I{^*tL1PRv=81pgyv0nc$(6_^JYtsVoie2-|d0eD6D)!ZxK>aM&!cA*^?uvfO5
z_?wgxRPtCw-cVWgs71em2VrR=Qb=7WLYP>$=jS;yMx=Ys(F(0Yv~UUkh_7&IFatJK
zL&e4l6&h=BMIEuCj#yE&F3(XsZ~D+Rfb0Lj_Z<rcXw11kV`eJ~t*gbgNw{Eu#)lp#
ziqhInTstELc8Qhtrg7>ry=k3W6s2+KgGEDOs^SRiB@xaqjj-M<iEw^tg!Lv7e%K?d
z0}09^oIgN=n37c1o3scj6{S&(u-+Uz!de(%^7YeYLug-NqM>8d5=k%-B_7s1zFj@O
z8jz5Z&R_z{I@2PeL=s$#F8(gvc>LPK=qy(YOUJK03NIBci?6*TzV<M_w0Bv6?PcS)
zaG)&0_?veBs=4=*d$T%DJ`oYz!*ksM+}BxEAj!3kz%z3xAZaeSzpkmNPKhL=Q&t#Z
z<<al{*mG*ftc3|PR+yL)pXSJ?Z;K|M2ZHYs&yGuORQ>)yG!YBkd{yFq^KMn(?st&$
z&g1UR;3=ZE>^^c|#(G7xWF-z$FtjqR$>@=Tgcl|u;e}a9c%kpH{(VdI?^~jO-xB@t
zcl-WTp}irR+?7{QE_W5R(*xkg#7aLp3VjWAS-N6XeW9x4h<rx+6upm>ce&l@#)rOK
zB-+)_(vUKqR$B~dNu4spNuA2<BsbqdRWXvwSGss`;GGm#5Ag82GS+*NC2Pd^J;!d)
z_Mzrls<_<a9z34s#n`i>MySt=u_yMp=lz=aTl)gg10;xLZ2wtu`|BpU%*Akk3G5Z0
zH8tQGigiS?1sJjE7I?d-yoKLN<!{wLS$e{JB)l*o2@e||^NcirBq<RKvy|{i6FEtE
zt11QCi6*@89~pR7?xwft(BG69I-D}`823_U=wHeV9ZZ>cxSKponXOzr#|Nna+)ZBF
z+YEE2H)-uIu5HPH2P`8<>l7EP120}ikk*YZ*Z_W1g`AnD^>Hun2C#h@L0X-;AduOT
zX(Zj3EYqFVWqEhtb;}6Sx;_^KeoHsE%nq$v{g&4Nvbtn~+ytn|j7y7YVL1n~5@mv6
zQDj`!qxWjoW?Whu_?&M5sqaiMyy0Zruz)_H9DLeyQ9V%bb2)3TXgR7<vmbOnszCg(
zihU`1)tvHVME}pP*m%G)ZJ)3J|L<P035;dhK3@U;yDK&-Sw6BNqQwgG|1Tz$3M+`^
z0?6`_C5;v<hzSD!-?ErcE&rF?-*NYU@csQb-CWPiZ@n)KG-+|aweRWxvOTeyGeLHg
zg#t4!cPln1nJn9s!mY_<xe49*qiipm$(Gz(Og6l?;QWccL#P39)1Ef)aq<E-(ET|0
zg5P)hPm}!{M6DxET<dqBem1!I<8OZ}r(SiZ`hYlP_pJp3xb;W5l`?UR%%x0H^m{!@
zq|7n$lf0!&JibL9r_4Lm_+gPrAZ!9tNgDfTM`)+iKmtzXT7}F$&Yq-!Y~r#diWbFW
zOB9gYWP&7zH7(=PVp$t>g(Hnw_mTp%jVswDk(n%+B<_scD)5JWtb2j4`-B>pIipEt
zM|);_fjlb>uOxz@h3`tuZEm3o{G+qFfqUtJFnQQug#WH#FFus)?rwAgaii=xWeus_
zM$|q@1MVZ%u*&hzM<z>N@|r29sSn#i0I7f#?EyYLCZ`CPxPF0I!u0hE;UxA83@20B
zFOVh1*)N0x5j+0>ks6N!Z!lu#YcOqcEFEalVn*B00vXy&ka680e-^Utv^MoMxdANP
zT}+VCFHCOZGPw`elSF2U)|C9A9yqX!Ag%LqLEy#92-5miE(k2#*vz4lb;Y<8BK4NJ
z85SG+8}gQXH3V5B83`{;MZzNyc$4r#UlJak<m<!sO%5yYE|DADx3&`B>`!1cjto<B
z78v{1R^nS*iEnKszQykkk+)?RU!r1(D_?2p!(vzVv3n>}@-Z$VtNU6R{qn~ay2R+F
z_f&@Wzh^r@Y8d#^+k9K#w?&WFd)>p{sxKUOlM2hvSX3YDudzZOj1|^i-w!i0lSS<Y
zGez*+oOPw(tvM@H^n^lrN;D}>@SEb<`n8HQY%7|Gfp^KZ13&7l8t_xjs&aF>L_4=c
zS?CuoQyO-3K#G6przJi2336jJDYDKj(O9JT5^VsC)ymwT-OKJ(r91ba8xQVq54!Q-
zNwJa-O2F&*KD#^iDw+(h%JfiI9=#ZTm=qFjk~r{VZmfr$I~%!@c*jb52hl_m7>zdU
z=j!tL1u^i0;@QU$vBBsQhIx{{(|c9vb+bQcL;+(z53ZkHd2rE#2P+3R2s`)+*IQ$S
zCGe&^TiIuD6}X02D<ylo5u2_zV$*S9?`<TqpJ<X$@QQvTkLK|a691W~Jzs{JkJqKU
zMDw4efkWp}l@skZ?T&wk-?TeXI!+Z$yaeAaUddi{p)TctL=)(hNF*9e44v<WYL^Q>
zoU_94`;|NfGkZm1FsYJvDL*GgNBU?qfX6$l2Y8aR8dC*lIxC94MA78Id##|I)5fC7
zXn@%)*tfiL(|FQ9K<fhXAe{6B^E_<tXaaZf8P>I{AZxJc=TU%XWn%$(Vm4hs9-b4E
z;V2v~<&#B|T@x6CLn}K({gy8g4HB_~htt?eFpsbiN7x`jVz9?$;5&u0d~VfnEBB!m
z`%sI0s4b5Vq%==ooOYH%J}4-kBB4~tUEv;Ob77uf;4hrj3w**^jo%0^aaQ!lYbA<)
zHF&RM^n8A*Kc_c<*E_2l__$c*2|(9%-mwluf!*?eMP2dBLFl^Lb=80<up$E%b;YmZ
zd|Ntx=DMnj1Ru>=;app)ODivA!`T4-(peqA#bRZdp|$;w=^Nb*hpEG3uB$Wd72W0O
z^|<%yq1Q9cY5;Td(SkZ&o?Yx7Hh|kdjMII<J;chQqqWLUToCwvXElI(JF5@)d1p0%
zoBY&ug#&@Bce|@~;AaYc)tj`A@&M|<GsUu}jX5)D;B*pIy-5qd?Pw8*-<cpSTsJ`=
zQDlOH2U05wq*fA0tt61SrGeB+0;!b+Vn4B^VZeKvoWNor@q~&;q@6&<d+z&zluMG7
z_9iU`%TB+6#Ar7|AcJC3Kw>c|Ac2?^kU&fdNK7WxYGls!66*qDHu1izB)46m6PX}>
zba<(E0r4XfY~>0GwGAtfJS82wONykMtWn@r?ej{Dq`M@L?y^9-ONyjBOlam$t3V!9
zPKQ>`uYmvPdF}=Ns~`qu`LWGrTsFO=gJ=^2U`EY)0tqh>1Mldg(+ecHL=4P`m27%<
ze<)kG8ltwjAFU~{xle^?r@oS;KbH3b<}vrgG4~MPHLknoc0uB_Z3li2cz8X)Q=C-=
z=FvrWi9cvi7$keDV{9IB*E`~XJ7PaOVm~{!k~8Gq)Z^z{?q|nH-5PQ~qnjzCu#s|+
z?47}QXUc($Od<x(^WH(;_b+GzQ*@>+j4{y`2AS}}(MWh_D7;~cE#ZNQ*M5fUUribW
zp9r>^Y1jA^YHNbO?K7<bWI3_N5Taq>Fcy&LYz>(`gW6)=Bwnz>5nh>RRax)$V(ARW
zz)m;t0+Ys~zR9Pt@L@f#j7}hKji{Vp-)AtUNxMH61>)_B$#R~^QgDojSqk$zQQr57
zCcg^4!v;;7r+RQzBDmD2XO#$knX_igt$FTV^=82z=PX8kwC{|fWuz+0g}I0aB+%*<
z4@jV~2=?90GR&>up)BWmggJ`1<jE-3-5ZC}8;8;x>yDm`7(WIoIYJDTC%jO5!b3fo
zN_dP6;Uv7UX0Ua+hA5dGKM?+t7fiH};c7mjouQ{zprND23jH)z=w?Y}KcsSdIxjmQ
z0jKjnjP4o9BUEyv)uysN!ppY-yw+KL!0(BbY$X~^TKBnN1Gw5F{+s|@PpqtO=xXdo
z9X~LWbgaA4$J}Tgh$YL#+!-{AX5;7A*lZ26SGa)=V9}FWi6=EY!KlsQR)N-BeLE1#
zHt&E%i|ual4)5Coyj!d!N$pKq|H=h{EBMINfut(yODm5d+Hb^J>nd}&%N-^!cH;tK
zCf)qfz-Hn}S2S5;v)!1bK<%LcSWI1ai6`BmC)T&jkM78i*l5oPWfcV_lb9m9(#NC<
z#N~G=mrttK2>Z%_6YPFS`zF`c3ncK7mc*Lnaf}B~dP_FQVQ!O!Fpjem-M^LDL=5~V
zcclt^hjffq#y;ou*Z@B7tPbE(v68}QG-+-7Ggg^snxXzM*Hs6;;;cR(3KRA967|vN
z6|wpn>c8RYdx1suHCI2xz3&BXAy(o?tw}2nGrDIklCdRjw2H3xy87zcg6rojAU5nd
zYX5Ml`jV8M?aF(Ae{fbO!J)}YADBBHFClWJ?k+Wev&G8Bn%3pHAn;qu2!`Ib>1w-o
ztOL=R4L2>++CdSpXrbihA<dt33pL;+&gunXCL3E?Sh7PM;1%kd3DUxqvbn1c2fNXB
z;DyfW1Y$W+-`=E!aXW|sVmT9}mHQEGz>kozFSyYv@N3TMi4{e~F-g)Fc&`p1{@PY1
zRuruQQ>0)<t_XOBvuY^1(peqAJlg1Yi|0xDcJI{y{>51xz}Lh|lG%vvD0E!l9iy)W
ztSrjbx{XBbSRHtdvpRrZ6)Q7G>pQt%I9pJ^i;L8O6UDM6q6(goivcl`n5;Kx<tFQc
zo2-?X?84+!H(3K>Br#blF&T|n9A$fn$%8QYB{$g)EShXDF&TYVV{Edk#N^SKJi$$N
z0ZFjse>}M8Mpua&U173kO7E$zKYC1U)1|s-a&HGu@@@?vuGorkiLT~@9hL8{63Kg2
zFN=CbF3pq3L!wsnz(rz}PpG(Ky{u!rrpFy?WgX+g_PAqvS;zSAv+4MN$Jhl#LGlVN
zcu^tlc#F){=UiC>_@_e0cm;|(*2_A^35z?{$~wjgi#xWLb&L}hckC+b*g83X@Z@v@
zQIKRBTufN}5U^BAHvBnz&<1dfSmmV|cdVCnj58f~td(_)GaYwqFY6d*I_}t2)-ld>
z+_Af?W1Q7CrLH&6D)4jfnANyry{u!L)wpA=tYe(jxMO=+$2hBT$F8!DaaQAw-DMr)
zta3A0SHPB0;K!WR3C!xbQYkqtiWSvSw2Le10ir0|5zsfJt9r*8a93wVJG%9BX<N}z
zm1&jZD`V2Hq1}G$G4{@vE;!+)a+o+4Jn*Z|>I9zeEc(5JqB@Gs@LoMY6qN^$avm&g
z`wu+Rbw$A+u1hmS2M>OZBs+&>z=8+<)V?t}`IoIyw4M{!1cBYkdHHfSCsk6ZJS1vQ
zPe3f$c@_{eSypIa$pnE#qw%E0C~7TzKy)S+YE4?GH9=s}LOi=;3+-hV+Dk07msyCH
z0W6I5q3HsS9hN22{uW^7lqRiDi)$M$;FGHq1!?_NTsv(89{b*+Ag$BHH9=sWmBe(`
zDgW;rK~iC#dIQOHlK1YCtaO)UC0?o?k%ga&+9Cwp(Gyh%V%!c9=TF9iUwR4Gf!H2e
zIboy}J0a;Gl=@`b3&xIl0mP)KY6D**i{{3H$#<%OJ1LXKuidvQu;5!8c=+(ly|nKt
zYJ8x`{J0vguTYSDTa9~GDliXQIcr?KMuB;|8cWtJFkeyQ$+Zg1A!}!ipKGB{UHX+8
zR7=Xt<nsSAlw>JMEcklQLvNTbJK!K&q$BAGCJQDO=D=8F0LMyBOK|H}ccBLt?)Dkh
z1H8{!jYkDvc2*DYO=mTL|Dmz4H4S*0vl{0MUgfMF;C0Sw0GB$e2l$$^8bD$<i@@O{
zvf;4R9JqnAdVm`_tFf`*hn&>|+}>FY;6*E<z6UtlS&gd&?{roV@W;+-06SE(<~{I0
zXElx$yw+Jgz;8LL@qNLDO5St<yPeel9{L{l9(bg)8b=AvTHU39XFIELj^G5%C$k9b
zb5^5YkSS<Vz#DQY;14woO$vCgvl_n@{DdZ{N%abDps8vs;6~1BY%I8^vwDDgJF5Y_
z%2_?Y>zvg99=eVv2Y95j8b=A9uGPZ)0-oip#@T|GJF5pc$61Xl1#fm%5AarJHEt99
zyR&+L|8!R4UxKS^V`F{+*LGH89l?AliOwm*dxG7WS>Ueon^gz!da>*;V}~?p+>*<E
zKnv0bMN>H%<9xO1V6|FUl%v7YX&)tV-(Z<E7IzEQ2V)Ia0j}bOSeqg^L)09Z(WG&T
z%XMU9pZ}NGPb=I>FA*jQ$x;sHwmGCSftYglC$QkJ?`!J>BFPuh3Abt;WL-2}t7)Oi
zm$eBW73)P`!zTPma2H>SCII&l%kFA(Cez3lwh2$_`fTkb%qBP4d;ytoq85<hz8jkW
zJXx&Nz;$Y{RWohCaoV4m+}z2t)yP+$372X0$(Nc5U()cfzL>T>v|{Y<i^zoSHI-Qa
zOsXapv)x!Xi#5@w^n^16^Z7gBe9fkOvQD^8tbArp_>oxoG@P)bCfLV)&P}LAb8bRj
zUK#3B)lcyW(SE;RUOc`9XYXt?lj7ON@0{%v&l5R|N}(34Bg4I#4|hAm{hxkUY2R4G
zomW76TmkJ2_G4ZY?eVy_Gp-x^Tx(}s^Xb<f4`O>fi0$zpw#S3m9uHzWBleU=&N2~?
zSbIET?cs>M)3U%4kSq(~8c^Kzu?QqQ29m`r;W6jgtRy^!a<XQ6^8OF_USA0Mfe*V_
zTNBJ8k^BJ<_-_R{@Jd<{5;^cI&a-bd7N&%TR(5QHXLwolpDvg$Ed4+#E?qKc9Ha6}
zq6PoRdD}O^E2=gVIWYB_xC}l<RhjA&X01xH2fo;=w+f`Nms!%T)RL9x1AotX+cm*=
zIj^k=UgW&(o8Zr^mep3G4}6mIwr_%;bzWN&{CDSV-vr+|D%S`8jq|o|f?s!DTN6B7
zYj2W2@Oz!t)&%e1yd9e0Yn*3qfC@k4yzQIdUpTL=34Ydj+c&{13Q1nT`3;~S$U|Q`
zMl|m7HKq#WhLOtA$nPHgz?F1=Naa|KSb`E?z%wK`w6aSR%(|4wfuC@>4>uj_j+5kh
zsPKoJw__8`O)Aj`W}!<Rq;ZpX-l++`+j(tG@M7of&;*ar{V6d5W>HLy(BPhy2!dHE
zQ$ZT+E)&6U;rxYG8de@VrummxEHcJgpb5`pH`cc_cbH$s`jJ>nC1bs;8NqBY*5NAj
zGri#LU47w8MNJHNg|n)21g{p&-c#DJN&6NTt-USCtTBbZQBhOS#`-6<pkXl9UV;p7
z^6r0}@bkkoR?bt>t`ap>EWRK1#kUJMPORbf`tZh0T6?)*4S0yNx{ecMwYFo%4YcO6
zwwlqc6(!4nvF;O#8E>q30@va>SUXASVLDmI$HZdh7;AH7j7egw>&2q<jrD+7RC&qw
zEW|179vQ{ly>1k9_h!0PaDTAl;Vq&xbl)ANp*v1Pcf4fP<IHqVh%(dt!zeS|ab~(N
zjxy7IUzC~X&(g!p*zBG=netjkIZ9?Xm>Nk1x#N<aL@<mz6%1of1jFD{!La&6|LiE}
zoxH1gQ8$1`iM2vyQf0f%nly>S6owufEA-7+;lK>7e7qTsOtLWw#~}$d9EgM$M*6Z!
zji)Euumag*TZZOL4*L<vw+e%GdQi5*DkHaPel>cw>I#P?l?xaAGH0oVEo9V=`d^>i
zq&3b*p&iJoW0MoOUoHh?%<MO;W;AJZ<#Ird#Y`KJV=<edK=zp?wZ0Ovv#7Cv6T});
znLeaRgMv1>xH|gSk#OW?Hi2v^tRw3@cWz^aH(g_e*)~=<!r>E${mIVTO-?4(^kWob
z(%8hGE<1r7&#X{6uCm?OCe2Uel2yU{(X<nIVbKVUtMablvyZ(*$@#|=KmX|D$>(GK
zyxPelY<~XH$#c*Cdgw4+Ji@-^mCy;~WOZ0&@{s18IzZ(Egrsu8kNY`mCv`Da>%Cb3
za%`Ha;{kYeZ9YtnnYg!Bd}9GQOHI4-2)wRuPdkAJi<QdpTueooKIY`{enQ#_yxCbb
zARl&EN4Bu}sYoX~*!)zalg(;X_Xg`op>p;)ta9v-CJm}Lb(h98f2i&Ra-@=WronT0
z+L;C?EvY08&RkMSp50&0%>X%oNjuYETBV(7ur;*+2b)kyoiLx4_mTcBRe#bK%wv8s
zt%DD^60vuB%D+jQyF?DmqrIsEjww8qgP9%n2LQmmwMR{~fhYJDwy$51#VQdCt0&=6
zNtBUU08&wj7?{#BF(AX5h=KX^&BTB_P9$RBeEgPUK|KGG$qXRJvv#w*WHODVeoj5{
zRY3-NNM&NYd`)Ee;-hMlVo3Aj+lle=HIYHik8dZkqUDEj6M-Dhrh6Y6`C08mARk7h
zI{-#`wl9YhS<>?3yNRq`oZ4Ch+|}4u7z@b4W`hFk^n#g4!Q_Xx6ItQ%!`q4RVm2|}
zM@<Y1&725}%2*T-Ym>29d{|tJ6)q{pqRR5a+lfGyl{ASoSVOF9_%LRyxELpfi^){Y
z^wEA->*qP}E!`!O!>3)fiDym~=F;K1WGtSC&JZi<31*s^7}<F=?@4yf^>w|UXQW@`
ztkC&zYmrRAa3ZC1H<~onc+ymvG^~gA-T{;5KxN5TCkT=_V=<5J^c+^1G#~e;-YSdW
zM!qwsG8K3xFkMWADSo(J<!s@PIg97oO?(efWx|}CvzRas`nIvk?0DWc1y#=NuF;8v
zIq{@myU(F2bBF^8lj2n2m$?*Yc6<2-qsmPCW6t8!t_^*AQDyS6T{ZR0G)m7{JW1!%
zsv1{)HLQ|Dqn%+r9_l(nJ;MjF&ba2=yE^ORx<0OThMN1HZKoM()=6VA)Z6%~S7)d{
z=Ob2U5c5^9&LBSPgIEW?Al6FuY&de<*pcHlYcjsO`Iyv!+)3>z>6j+Nd8&^}oq;;g
zN2MN*N}W;37lL}c{?(b``9Rf~;ivensLuNL^_<1J_P3lBk8nL4VP@<w?bhvi?y1R5
zT5IOq-%oDR+Ru0PRUmiE^aqS5YMvh?n(3r<e9kqUv{)OgRIgHjd{Z>*PK#PGu63t%
zS1$X9$xT`mQ=$HM(2|%brNs$drZimpGj5o<&nOFD$g>fO9HC43%Q)>oUdpjs(!9xR
z$MUxx+JO{JD%VQ?mt<!|WwJfwZP=uZF+0`+V%P2^vDI2=)udY4<neC(%;p*+M~`h=
zXD$2hR$C0Itg~kF-3MXU_@1-fpfc&VRD_Bi(Ied!zN~ixKjy4{o{(Pfho^3b`R#LX
z-8FRYCf(UyOj=!KrRGrDQ@K|9c`QxxcVcD3Fn=eO<nJQQoP5L4%>u$1mA%*qWJh6M
z%$>rj!nu{n0iVddojZl4hO;b_1G1?|_0hP`cNo!`V=5O$|NSV0K0?4>d+5R2ANVl!
z0q=EI7mxtPCV^fw+)8ld=*?FD(Q{{>bK*uLM}Ht?j@fN9J3+f>_=Zg)e1}8h*CHpY
zIC-#}uL8d;);E_if5!P&-G4%Eey7cfzQq?)-<Cr}!MTDl%cb~$%{DxtveAah01lJz
z|Jja@{D?bFSuo(XtjD7n?P2~Njb@F}Bm=fS#=2{<?pj#R%)~9V^GSB?yp)k|eWEpV
z2Z>+r8>W7wc`4Fd0`k6qEynDjcwL}meMUEDZOJ`hhTRir^9HA#j-V}nVyyvl1D#>a
zp@C!pGXvoQX1`q+E$%$$vZJ%9zNcmnLt?C}#9~N{#j_oI9AkxUp_|jgB<|@JH*FrI
zEpD{&cxbr><_4m;Ljy_NW+04vdP&?5Xy?j%o;GZJ7JZ<<+|<u&%+vgS)el@OR<fo}
z=FMjA-=>YtA|+c=7q82QX}WhNr5biicwt`Y$GNK=wasYK;1IUtEYXr0o+OqW$c5V1
zHtk_XHysk$GqFmE81Z0uZTr%R5-~25trptCOw=`0w}>X$;>?kqc3B4L*Q<VM25F$o
zMhso~yPP#3>PyBI?I>!IL6oDZg;*H#i7GtyQf2WWGt-Oo*cnY4bS&|lew=9AXqAmU
zm(jGGp1-Bd8t)C+=fyxi;!eKL>lj-iXmd1RqP#rD>9euI)F91+XObEo%UEH`(nUW$
zc}UBF1|LJ%R6!R9<u;*!s4tmNq4pNp3hkL#*-Qz2XfdHezglPuGstIiTlw>O71-{q
z_V|;z8lRN#;*X^!)P0~7eAX59134D3AM33)Lscm=RQ9Hn49$;zfSekX+>z+D93m@7
zaq{*_a?_%HfE%m<d&Np`1+5&V|N5D}a1BiEQHbyv*Sol#jaoIcdy%Nc4&+2^?c@XN
zi-sSt*~;e)*&u~uMt*)ne>sZNs1{=E&424p7k$7jb-Iy$XiI~SqFSiq!v-dG3$ZYn
zg!zKPOpZgr#A%_k8zm-V;Xi(*pWB9BB<ezwvHEV*zv@pO-Mmi5yCC+E7AnH`)%|3$
zABgK#K(nWy{dw2k55!6;M`L{-k$xa?r*dKBw(N&-m)r^P_S;@i-N1skm%FzGlb27y
z<gR}1)eX$^fBxlDLO;yk%cr!;8)k=BRz7J+RJIux!&u3<p_z;u+PPYhGT_UXCwkrC
zd5X5dh@kl0IK``}H5JVWI~+a1RwLSdUQ7+(mz>oFoFvxp$_baxXwu3PdaS*j7N#Q{
zu#y@<q$?lh!L*d8{!aOKx9AAl10+$>e#k?r0v~Z!7jUsyS(LOm{m<UP3;jD*C(HQ<
z0iD2${m{7q{FYe5DwAe3Y4E{;y_UpIj`v7PHUoR;h??{1WIIB&a%(T!qR@{w9MUZc
z4PJLJd+5qPn5zL%{|;WEu*DXI%h+qNsR(^&u|)~}YN0J0vbA)g&vAZ|E%t<Lsmn4*
zzjgC>K4vs&@FIxi23`4wku@OdOEMU0Z;`>!UW=GRA6jHE^s9xoFoW#T_&~TUTgcpB
z%odGN{)F5P+|-|>>~WX|2GU|3%!?Ko3%ebp_oh!2wP^<&a8@1o6|u^{Z~$FX@{T|h
z*gh6m)D?e^0J^^Hx@tfa*jt3aqOSNG1JHG>>uLw0z@C19MP2cC1EA}RuB!`(0^6(r
zi@M@(4MEpYuB#h}g5+Coz(r;8pXW2MIs~!r2x$PdkQ=K5sFhb=F+pnsDKSCRL3O55
zS>HvfT!M}k*h17i0De%ctZr!WZ6tQesq0Qg3!%V1Bn57(OXei7O{_$Hy-DjGzN=)s
zIvno08o(n8x*APdU&#f5rz|5#>x^6wc;+&KYB(7$beO0`3dDF87Onrt1%VjP1ZiR4
zGy;pR#B*+MX(kmmE*K?fW1${eV4W%jLn~hv%E@_xvqh~sfLA%I19+XYYQS%bmDP|M
zPUZ>C7d7?3g<>sl$9h@EI9uPB+6UcYRmjOAp~qdM0bJ^=PT=d#ssrB;tK4<e{~_-P
ze8pKEKy=y?3@oaT1GM!b{WsEIFlzu;cUA{*4QDlgYl>Cwy*#X}=&m+^pAswUNb57X
zAbmrM0xNkSy%SyaCaqjoy_Jp)-CT7m!B6HaAPU#19QRb^xO?ow=~dpge;e$#b^0N3
z^c;X&x%S$}q!m>qXFXxB;fbl{#_EWBHWPs#(j|MB^q?jU3}n3};Uu&%ta3u$6(7wv
zAlgzn*CMcm=r*F}8gP!YI&KwQdw2#)?mHirNW**e0S|UoC-A$@iXI!c)1^If5zL?O
zrQ0`TSax}os2z0x*AZ*w%CNik-ZK?z!t2PzpAcM<vt-f9kAxl*wd4Q?+?D<<rC?WA
z)DPUlSyf=}K|dZm<5K-@T3{8K+1Slhfta;TIXY2jEMTs?3d{#F`e5lPnLWhK^<ajO
z?3*6;mA|}pVrc>5iAlvCL|^`ZIdl)Le6)#jyi9muR{kLd^<d{GbEk(DkupOkQf8=*
zXeWErRp2aV^@RE@#844MfnSywhxr(zXf<b5ft0WvI*>^sFjhQ(QN3Vp&d|&^n-)O6
z-ol&$zTi^54&A9fJUAt1T_gBd&I0CsdZGQ<rK-SJoz)9mL2F8K2nlBJ&HXUPMEF(t
zo{lJu3p}89hq9Q;5fZN;rA!(Rx^L}3f=cB`KTei8oC=06Z!NFfrAiIR;8?%;)5$K@
zZ4Cz&9GN#g)PGo{e?p1=c_sQMl<1$|QvZ#f-9B8!FB>S*!?!oR!`Lwc{_Qen9P`rb
zXH@dii6+OASN2F#_qM2QJ%Q^l%`Vx>3EWF88=584Y5YLUY{NtAp}aS+{#vFm6Qp&R
zxMmsn^S>1Z!=a5`uH*7XZnOu8m*(=E88mP*+gH)TPg})+IGG93!q4P!N8T4*j(4Nj
zz1jUc5QuSmi*eEPX4{{$$e$J+QaKR#npl}2t(X78ARP$&r&yUFEqphP_`KLNf8ZYl
zH&NzI3iuOebpi?2q{6{DP!UcS9cmwO;p^LqAmN4o_R=+E&H3|YG-tn>MMn@BcYQfa
zNE!EAf6ZiZGUJAJ4w9YI3%+3Go3d8s-#JR^rJnEVU**O>JdM@R+B97{M>O+^*1g`b
z6UdNcg05MiW!xcZO%^RVft)SPcZent(QP$#D~s|njoRG2PD_dfw{iy#B>5CgdHsax
zxmT_{Q*ddR%55#tGB=r>AJiaP21p!*T#^)eZRNds;$G4Ig<eZMB_011+`<)g#EPOr
zs8~_$eNw=zx0_q6DEjRDuQLCJ=*Y@ICHszAI5@bXu8av2zorbYBbuv#gKI5SEYbM9
z?8`#~xc=*`Nxi`Li<K??w64hofxlTskk%WyAaK<;G9#HrTAPY%U(g7wFC!Rcf-v6n
zFzUdy-Dn38$Fti3tzYDVKpf8mY2ixAqhjnw4L{a(^*ul=C+cfWT94&|KrCm1v~oY9
za(`QSSjlx&f$wux9~OU|vtr%RHg#7?FZ5mwMsq(OHy)6Epgt|>hG_DQE#M1WQ+Hee
z(WmaQrnVAI?XjkIcSfL3c60mnxL0&IbE$e!>&a#roadxQPS9wp0=1l{DOwd!{<x>4
zH&zr)ijprfMG>Bv2rzfDj_#2@aCP7+VhyW&c}SB+9!#BJ+VZZzJih2wdXS_~_FfI(
zZEkS#8v`_E|07!;Y~T0%0F7tgEG`<fHhZfeO5?VF6-8;C`*uN;#vYYD)4E6|S))no
z+v27U(716(QIyuoLo;qFN@I$cnbxoZNypiqjymu=&guZ(E>@ze-lVna-?LzBIRdUN
zmU(jCbQ&uuKUr^DB+7aNi!R5T;MnCFE;DHM;owpqLA04KO9sODFHuBSdazaCb<U~*
z3;JhHr$HJ_|Iz^(Pv)J01f0szAY_}Iz=FR^BY&TjUi#atqTi>LUSo9#qN-$ihKk;k
zct2uf+eQQS)>x==nTw(FWiE#Ked@p3Uy7;hy(+HF^XfZ(T9XDDv(4|!=^o)wO~i~#
zYb|l@SrWLO&)7*lO&Uiz(+tr#$vanp%y9dv(rHZ^6MecT4$<lt*9rpo1z!P<?P}6s
zB}i4$V7#+v!m-#|X=#WiTjE7po*ox1+a`Zn_OX&YK1^@^QA-f(OvVju(zod`Ogp?u
zBUd<W{)|ZBu!@O>`o1pT8P()24&E(as^1u3QD)d}*4d)2D2X~{4sN0?GGV7Hp#fus
z>WvjD$Jfo>*Xj1_(P|KY9q)wN?M2A8W~e`9h8B*Ovg<{Yi2_Ee8DNSZ;HyR-6B{!o
zMXho(G8TizO~+W2z<Awij1_u?2Vc~kbH(I#I%3BSn=l4+!KNJWWU=hksGcT``$7dU
ze(4ITK*Dun1Wkl~A&k>6gwgtiFlN6HM*b6x!>c|X$5u{M9iH_LvksTG(9AIdZ=@M}
zK#aG-3ousI%(PSj*AOdBC5_LC>6&3oaRpT%qwTUK@n`OZ@!z85@VBDL3PT7#R|sXR
z&LJwy?|XrE03Q}B{pM#HfBL8ILS7ZzR_V2^#bJV9&RL<OCrayX>g}Pz__SN718ZWX
zd8Khpr~t<IT|pIy*KREI-7kdhenswHD4OK(Md490RF>D7nxvQcWNiSS9hU7M?cfr)
z#&F+Ko;RJw^D8)W=`<QcMtEo72F|JicXU<{@Lp&20)Hmfu*$%U=0{e{6dx#R-T|*&
zt>6fad1Bh82e{Je1vwgH#LPCvwAzcJG>#P0Oas4Kl%sK7E(iQWQEsUktFDpxQ@$sU
zN2tySF#>ih1tkA=FI!SF7@Z8pXr<5g#zRVS+F6p*CDX#3rkzW&x@1~eR_o1@tS*@r
zXSK5=t4pTES?w&z>XK<?S&bhX9#p-PuVjxj;E5p6j7x+JUdD~>BpSkbiJg~xepTZN
zjvh<Ds;Re%=3DaqB=`#PY&&tE2Jsi7$;}<S&B|F(nb>}UojGfw;EbHLK=6}3VfqRD
z7dh*~QJGo>*wlxkYOH%y*<{REVPfJC+dM>y*;Z;G<5ZaLD~%+=o(%<0c#pGygp+LU
zrqN)0O&c*1n6ZFYDb}<rjXdz4IPhpaFl}Lx8tdKU;zS?r4q%>(UZ&~qeKqU_ZoLw@
z=m1g^wvY~K(x4P<fduAN(E+47ObU3glAUU!LE6)s@%LBBTzF2@UcH&oJbBfO`3+GU
z<ak(ot<FoY1IX~0D-6m*8Y$BSWSmm(!jVdu;VNVL7%S@6SU^fS?fPy8kP0p-W-F}4
z(-^`Nd_^`U4Q8`B0=!D|H0?}-F)=wHNloQw<b@w)IF&2OG3m||YW~FuHRivYQ0p2d
zl*NuxPnO*2O;SY^8J8K1gBdsUFyn?UW?Y7yG0wQ5Pa9|^e%u%3V=K&<BQz*wTdZ>>
ze~D=Fv518{V#6k!-|31yDFOc?mOa$XXwo1XCPyl$3S%*$S?-M$&)&Yc68hpn?+f!}
zx=0ce!dPL3u9nmIX?a{Q;G;%OXWY=+jElq6b;b?td`EWf6iu=|O1seQMaxD44@g?3
z9a~JCj2q@D<A$lqxM8+3ZkVu)8^-cE-CNHPP5j2nk^(R6cZZgXhkfObb`ksP4nV5S
zftfR!gh_xIms!q=nsLL$G~<>{tr<<~qBx0WMEjw|@@aM7cvNxd!JHKaJ3P3Nm>&zK
zH&1)-vUie<dzbDje;3WTW0cB5)TW^%YU761x0dxz(PW6QeTjT1E4SlxgDlvz{Fm4?
zZfJ9s`hHh5(a#<8n~JQ=Cj0vj>6t0nIf4)NN2|t_f^%K0t@%S?9u4fkfQ6PN)>xsV
zvB5Ssm}}~YHANp~zmq1O4wG>9lAjNV+Cl`(pA_xeou7~5sl{GIpLpTL2h}^-Q-i<Y
z7Q4?AyeMY@^PEnp#5wJbeTY6%#0R3b=R08T!UW(6?&*{Y829Xlk$|~dZB6j4?)`+=
z(+RPs(GMKqX+F~Zaj$6a|23J#4SP{CEGtIxP4}>OFp>0WG!&xEtJYS*!2E^x4&Y~o
zX7aWdnjLwKD&7h&yixzjA=yQH&H?^JtnA}0TBBsZ1cBJh1Thj){gIsg0YVKp-;MSF
zF_Y-3HEHEP$JPVfPkv;Av~Z>55e0vC6i9wxNswNawDVdfZD;S-1uXQN74`e0<o_g^
ze6!Cn_E{9|w_RT+kR&93AV%nX6L7+NUHKyMHmiWRl8A->Hc&UzTeshd^@5K;6^OwS
z<;Dtie?$zP2$RJI{5@T>ZvS(V@pU<MwL2Hh+{L=|Tx*d-mA6TG{uqh1e1b%Z&zAHz
z^IjD0r(5^hNtY0{CnP!Mq$-gkTuTGExn7x0=1HUJJp|&8bvouR$Myl&E9j~>X<?yc
zJI$-bbKS41Lw|$X-<Ds&SykYM&Z+@Vc2*DYa%WY6tNUM{^x)@)&Z+`)*Qr@g&~b8k
zX6`!h6lZlfbPsxYVHtm|`hoasBM8J_lLD^ke)i&e?q@Xgzm(<tPgA1zYxwD1z5&^8
zRv%WcJ>Bo9Sf5gqIB!q?o*aQ#Bw8QdlokfmYy)$}(G~``_Rrn>uHaocD|F{@T_TYs
z9>*e)$I~J$acU&;d~09c(xsJrFr)0X>C(O~(g5~3s{{Bsv9ftg>zrH=c=a-Zv~J4<
zfln+WNb5gyLEu}<2!>fFj6J<$9awW#ClJSzFzQWOC*^{`qS5&98>9Ps#~KhzwgmuU
zCfh5}y2|_Z0DmA>CP-^xE(m;L89`dl=7PXt81WymcdG+~Y_sEPv2Ji(QTd&uOQ+=`
zz&Xz9#Cx2x6$bcQm#P9^a8@)SD6ETJqzY_0s{@Gt778BR?^0FZ!_MjmtE^<!hFO1y
z-Ce%5^*=maOBHJ#0gn_bn@qHh%LReQi)EjO9@C^TZJFL`IKcyK*?t{}p%KZwc+*i$
z+9)<rAT|(n^#bn`-9*%a10Le6I@(ThRuzZ=+Xm~RlLLhKBL>qA%yma=_DuD9P1J$`
zzA2Vvaa5DWTViHoKx>3=jiTrD@2SI5H&6v)Xe;~bpGlS1cYJ-D*R~lo<n2oKKgn-2
za{TMteBkvR$9-VsAwxFWut_Hz+9v5dYWX_b;L#1ww@C)o{=a+*nsmzpj^;T5^SAD+
z+4I8=V~34@{NOaAF-<PKqzLV2sE&ygN4+HMgx=&Mt#ukiX`=~r&y#@1Zy4<<QT$#3
z>k8b|SslQSh-J@S^JdU!s0y;$pvB)_+6n>u<uZa;hOQ^DlW6jA0-hzFDFdGAtSS)G
zCUuxhVX|bMLiZ`I=s+L}?JRH3j3%vI{eiK1=A4vODxVNKS~NL5+eKdOBU*N%#t5CK
zy;z&}CR0~()ysfZ^5<)5yH@n4qW=_arSA!8e_C{9`MR3uSkchGvC_Mx=>IPJd&z#6
zDEF=P_3iw`d$;`9U3ojWMg9hhH?;S>ZiW@vTV^n<v5owqAAXIJKjeS($gF3Z=)R(Z
z>Fbc)rJ{rN|Mt6-UnKwE5M4=i$atR`jBn`gJk=|YIQ)U|Eai=Hp&rBj<RKilR`q&{
z#`P@Gb42+b<OOO!Cb~rQZ=#|7Gv1SN&KA8(^i(a2KM*~M^(s*CvgH3N`c{kn?^!+Q
zsOA>Zzm4cFqE*qlXt!vn<zex!SS`EqJ<<I~W$oXI@>|Ve|Dmg9oHNvKk?2<HH(qpk
z^-T)&4ORbE`a*v`qVvbkihf@7SE9ccy>iX4XV$(${4>_d+Sjg~(I1FDvrg82Ni=Ka
z|9xBi4-fj^u$=w>seUU+{@8Uh-KUA>mNK-m{J2z<AE14#g?}oq%2+9SMD)2(vDzQh
z{M=TwDteme0#W{e{9&~p5e?OzEB?1ce=YiC3;AtV$TZv}%5Sh<+G0KBo9U0x^;x3y
z3;o$m>u6ncPbH{MqJj={BsW~^!BZ<|0_(SszgqI&6unXOK2iGrQ+fh(l_w?lH&NtT
z*=v(u7m4z7Q`n*3PA&Z1LH%|X{g`M+3w@!#Uy$5sqJ!C6B)P2=KYlR|q5i*1{-2^N
zsNV+5+5ez}$EPZPD*A}%6QWOvJ}X)Y{+)H$_>^;w=tZL65DmmDT}Nc{b3~h8$lCKo
zLwV#5I&xXLdt1oADZLfR4-;KcbQRGxL_>R<h`){KuA;lQkpJybnP00MozZheuNIB;
zi@&AlHlks_ABq1f(L-9q`!DfFe=)N^R<untw7=^%ncN<t6GRUY4dr*-Hk03^Eu(+m
zHKQYU%V;I|cZ}rE6CF(cD#`s#^dF*Y%3h$pa+mn`i#{g0q=o#7J7#{qS9D#`4~pKd
zIPPo_&mAAm`Y#Z@Uv$*Y8Gl{TjYLC#ZxsJ#(c45f9GCS!Q29JUH0(d>;7so48qYan
zvi5gGt6OL7M_c&6P9^)dgXqqp<3)Q!KPwuNY1+qLAv#y|HSKH9(0%Fv?N4u8A=7Y&
zXs7NseJ$=!q5g-Ze--IpPc*bQTXugW`mAVZf3SFVk^bj{c+fwXKKkL`L-ONiqM`lm
z#ot|Yu)Kx+d4Aei`Td0GXGK3JI#YDEC~<`P_>5(eE__z`|DtFpKTV9UiMC6QexdxW
zy8ctqLzHJeath^NlH8C$Zo1l`JclEElFN7uZ;}7^OV19X`-+DB-Zx19wxEBH+9!+t
zL=-<pw$S%g$;}nLLG&ikFy7CKj~(>3^7lO1r5^bhhv&&Q)yH_z&>sE2COzK}y;}5o
z(R)STt^Tn8VE$0=`^n!!M2{3bUUZJ=0@3g2xjT&S<Us!Gl4~VDQR~=v$sHp~zfk{V
z$q$HrMf5CD_TgVsJM4eI7!Qj6Oq2u4p_(u65e@r)RQyg+&LNsD>T8tv$bCocpSO@7
zt8wQ!XpY)9i-!JeCH_Z52a~^C_m!2kzg<i8<D&bC9w_>_o;QCdx}u&RKdl?#L86nn
zF$NAErE$1e^y{Kmv>2aZ8vm6=*AU%abZ60vM8CFnX7Ezcz<lK%$#Kp#bYvzmLX>z`
zQ(S9_wu$Z}`Z3W^|H{&{i|AgW`-p~m!~P58_XDCo5#=W-UQzomqGA6R#Si6%Xgr3C
zj%+bL@6mJ3nxb2Z@?%~6*3vgL{^7WX{)GBols=v-SJHFg8LMPHzbbl}=<T96w>Xd5
zNZ0G4>%BMAvzut>&z-AgoJFF45IuUeP%>-ZBR)TG@S@sZ)HzYui?_fh>%tebE}Yb2
z{kT|iH;E#5Mhp4zlKYfsm*@$iA%TCsE?gseODITNc25wUBf5^(3B;hIb-hD$iPo{U
z7VFal$)W#c$-Uh|9{UT_kN0LC4eT7G{xd~6FS<$XdqjUFie2J>&Xe9Bi-!G?gYGPS
z*dI*)62<X%(X-V53Q_bzH<lmUiS8`QzG|4pWrQg2h^*RTyy(Y12fM_HT_|yp*D#OB
zLBAopw~L;l`~NpYk%PV}xfON&3!;-m`9W>;&=1O|e6wLFuic`sp;rprBl>yCo!UZv
zq4>Ki?;jVfilP_FD^&c{^LdKzQPCGg-xj4Gbd2IYQ<QzyLbZP>I;6$@a&z$?7yXUs
zlcIbsbGYv3M~m_^hBMW^PZYnP+epujqQ~gIc9ZC6^=qXcJ<w6QA8akUt?2fm$U)B&
zf1c<9(SPVZf*kZ^UFV1I7E12dE#%w8|A;8(f(NybKSKPOqR)%A@&~!ENe(~ghu=_s
z4elV_-xi227DWy^PWQ9BMGw;bik~Jz4*GY=y(xO0<VWfLc97^{E$(;RmbD$ItS7}6
zU?8A(-abC%JRtfT(WO7g_^aKK(IXaQG!-uVC+t6TekK?8A1yswh%UV=lk56nMz@gu
z?L`N(caQvRlfC1<pXoV4dS{C+6vf`ZtzUK~iJl}nOLSA&-%PaazsMirWPFJ8ROvrc
z^jy)aL|4-Ik?&S{sRaK*dsC$EWYJqi-w=IEbVy)tH;wbHqCXJ5U$lB>HeRDOKI28Z
zMDaIpuM)<KoeQP+V$sV2JO7fs&`ww<p*`|=sNy?Z_1boK=KoJbS7|Xn=BeKwM4uCV
zNtF4up8Rd4_kAt&Q`fELQ5etO_hf$8MEAQlYabxmCE6=m3I3g@eiw>fEV_~8$BKSX
zH0WOWx%ht&9e>~WROCX@v{Cra9L@8^y8fLp<I}4Til&XifByWV@o8(^0~xJ~&RUqY
z+kTwU7aq#!pG8-GIBTyax|V1q`1g+%`nQ(;eMPYsbgzt+KOYpGF1k?kA<>_SRvyg!
znkl+O6nh5^Vh=g|I#lt`6}>_9X3^h>&Q@L)iT=C!A`h+d9_D9(@=N|1=cmSGc?jh{
zAjW>8hl>t~o-8^`bhc<yG$fP6m@dk5+7oI&Df)ZSe~OM8l7YQN`9mwti=P*t_hil(
zs*V9c&kmC3JPW-Ch~G+Ypsun|c3u_bo6=7o7D{IAQQ{vedbH@5TFBom{!^k$ksF@r
z8!pOoP-u0Wu75_fL-bhD!Q?w7$J^FDgY@rRA=7xA=t-iFh`u4ZlJ?W9i!KoTx#%0B
zp?^P6|GP!Q{-OMOI{(^G^i|PMkIW?5&%dH}*q?K=Ep>g7=&xJIpDq3m1G!fE$H<?X
zMQ;_IFZx5#C87sOFMfyqa!$zmeuK$ZSIRUTDtfah?`z$u_T8ePy-ilmI6I1dO7ud}
zg`&@khW)kuw%3QVf3rl-4F%O+OY?I-QJz<Mvo!2>iR3s}xmxWzMML?^-=+Mun)f?u
zUUGhLquM_deO&Z6qP&m8=No?#KlF#cb-Gg57mBvh*Q);oLH|cv*!#8S_isdhC(7Ss
zaDK6q=3i*<x2n%2qR)u#qxxAaI<iGQJSX{WmQ()R_hcSiC^}p87ov}gJ|Vh<=SZEG
zju)NK;{5bd^?Uf=?Ei%Hj@0w!con?=@L-TY<X^!*$$yfG63F*S@9m=K<vDn!`ZZhh
zf4`n{M~faRx){D5cz5T)H?Tib?OCGdiC!(bK=jL+C*1!!Re$qDM`^uZOXJUbOS~sK
zO!cz6DCZVZ?_@pICHmT=Z*S4*qO(<Bq5dBXqQ8~ClmAV9__LMz^M2SKY7gemt*Xln
zg1TO}MLl04xobqfC3*w>J(C%@RCREjD8EX4quMu%uHK?PJ}UlxqWg=s`h4R}T_3(i
zW`9M|RYgA|+9AsOr^l-OWzlJ(K{%E1BlbvH2Z<gdI$LzU=o6x0|2<dC`uB+Ti(V)C
zJ<;EaE)ji3bgAfqk(r*QqARSFwO0~-kLWt08;Fh--CXp8qFaf!^0!NN@%IF^L;v0g
z{QIx==V<9~Wq+vhv9{=jqHUtPiZ(_6tNk0bayAa15$zJ~6%F%?{F=JnCc3=+CrSP;
z(N{$OCK}qi`aPL{*NM&-eM<D8RkG_}5)J#GwrY0$Owmh4e<&KtAGBH~|8vn_iasv-
zvgpO5GP$t-YvPYuBfGw6&5X`jyIlSwt7rUQi#{bv|5ew@uJ0{+jp!Go?>Ny``a7lX
z>K6Lnt-con|K4r?s`4^T^i<JPl&1?t$y=D;#ftYi(U(R4D*C$U=Idm6+h4R@G}O0f
z-AwLP(Jj}@+S`imB)YTcM?^m%x}WH$ME4gxK(r=$q-bb=E%DzcIz|*fLiuNOeWmp?
zKi?y|w&=Q|V?;L>9VdE{=nT<Nf0y_ZMf*e#Z6Uu{{9`uA{8=jcFVWHO%lKauJzex{
z(ep*G7Y+USfb?uB`XSN5?2VJY&|av2&iga}9v1zD=wi`OexCUAMeh{7r-giVqfGzp
zqIZZc5DoPoF8;BilSEHzA%Dc^O#jiMb42HfhWcL?{{x$3{q`A?(X%$q=tdvN=oHbg
zf2)4assAct%k|7_p|2zGgZ|e_&-J2z6UDD9TIf4S`o1rUzC+YMj0d@Om50If-!Hvu
zET=qqB|rGxDjzp0kGG1>7hNFwBhiJTVLa6jX8Au*bfV~WqM`hHTW0bnZI#ihMZYT=
z${#2Bimo3ly1e~o1^oxJ*S2-$*T+To6aAEE=-=#ZGWoki7m5B_G?f4FhcfvIqKAnd
zDLQuB?E1c<4bd*qQ$(*3y;<~oqM^N3cBaZ+D?0~E-=U&Mi?*`+;}-U3ZkNULjqNi!
zPxRRxvi9quYwVb{L;vqn{|7}M75$ayQ=<DxZ`i*}dizCB5FN5pxxFunzru&J>nn+_
zDY~8LsiL91EB+Vz-!Hw#?wr}5DSEf)J)-xCjvSZCeMoeiXpd;<-=abKh4L3j&t;-b
z(K|#J@0!{Fy=d5fy<M{FM~F@log+F|^hVLq($m#K-+On<^nF-#gO6nGO+-Wc<0V%Y
z?Gn93^bJw;g#E|up6TCokBp8JJxlZ|(VIlW{@+ypea2_~8=@;nKGYZXZ<G9vqPvRj
zCAvryePRED_RQ?g*ej#6MXwf}C;9`?u>Y0nf34_T(Z7nmE!v^}2Z~M*4ef>c@BMh@
z*J9D7qPu@0<9}MTDq0s^uy=O-=b|r)zFYmH)o*$AZ7BQrNB@rH^k>~o$EPli7d=Sy
zsm(Kf=s)tCNN%SV{XZ{$*nh0}TZ^6{dPNI+q5QRDGrxW)y8C8XyI1r$(S2IzTO@mr
zi9Rm+XVK8#AIr{S(cg(aB^t`_FT00`9w~Zs3xCcNf41mlqOJ0=*%n#6+luZW+AbRU
zbG!KWi#{s)nCO$D&x(fqUljjk(WRp6ZkhQJ%71vDJyO;x`(|`K(Mh7AeA|AR+zFzm
zithBujQ{`i_9gI9R#*EsY$Bor+z_pfXcZUYgiYM)0HPqEQNg8Z-%KWxWMnpHAqg&x
zYh5a)o1mhNYr(1w;zDh!aj9rs8h6}kXx(c|te;9P%6HB^&q-!(=53_?{{Q#)gJ<67
zJ@?#m&pr3vbMH)MHUme_k^BD2-@1k6tDyf(;9}rX;Bw&2z}taqflmWp0=o9yvxV|=
z(9V;93xEy4IPgl~3gGKNxBmC%ir+p4b^|v8UHK97M1C}Ici=>zE1v`30=yJ>y^s9c
z;6DIv01i5?bpK8VUj;k`826E14ZZ`o7Wk%*{8!+I9xwHe0PYQR+j}zjYG6I^Tp#(n
z!LJ5B2>hdud|8#)F$6dqxF^uHXA=0sfyV-)KJwRqzZJL!*y$s${5m{;A2{HI()~3N
z{8Zp~fG7FL*MUz0&jl{^k-ruEYTz2+Lq75^gMS^k9{9PB{MIK*yG8;7z{7y9|L1{U
z0IUUm-$(vO;I9R)06yj;|1$WufFA?5I;ph(cLBdAFbJIEBY!6NC@=@S+DHB-@GF69
zfG_&UzX$&Bz)irN=a;sBKk${nBZ1%bk)O9f^qdH+2Bv{I;5k6I|H@C1@`nQ#00*8f
z{I`Keo>AJ~>mdJg;H|)40NwhY0e|1AqOTqLp9S`jKTYJG2fhM)4d}|B3_Gs?E(2Z%
zychU5&@KNm_*a2DpDFc^1)ljmxj(`abj!a}E&TEt!E~+Q&w$lYxlaIFflGm|zNul6
zPXf;cy82sv^t<}rs26?Rz+)O<A21!0`yI~`>;yg+m-~4M!3DtUfP<1K2mBVWzxv(!
zf~d!@zD}pU{`7aDJ;TwC|5pDQu+IZVfKLGXv#-JNxB6G@Qh%zR9sBX;muOeRLh=7-
z*rEDd|G08nTHifRJ^k4?2<@!^2A#Na<H)r)y@m3fsAnhi`%uJ-#_f3cbEZ#xc7y*K
zI5;JKtp~OOPfQE%+N*Lo$X)1^bLDS<o|}Qc1U?FU12`ii_00k<&dUAyzzvJ!zN}I3
z<R-x_t?#p(l$)9toCkFEx1gS%0ha?G2fhV#>;D4!&Vjvg$f>^m$|ueiyRHCU4SX2*
zM__;cT8DOOz5TVr&!3~wAOFAVt44iK0bd0E6F3U}?q_ch@#4l$J^XPw@OQw=&_Dh8
zN9%R_du!-940tr~Sm5zM52$hDr*H5%(*LdJ3a$fw4BY-a;lBlR?HPyitAUUFm-^mC
z`EKB6jy|{kYtI+^ZUo)}Tmftct_3~~>;%3Dd<FPA@Lk}Cz=yvt_1t!);B&zL)Sfk}
z7x>@W_c8Qr03Hu}UHkqHzNSUm(Ez*%=*r)CfylK3mtQFN<1Q9#xkT_jVCYi0e-zk$
zncQy#c3dI%L*c*ee<=4M;1$510Lz!i^Id>@0T%!l0@wUV<bppId=R)6xb;tjKLVHr
zE(QJ?*kAi+T_k$u08az<=Z_UW{&3shU;DPy{&Qj9Z-AFN{&MxX?f($+qu}2vp!(aD
zKjv!j&o`B?gI`?#bR%9|{eJR)@R5H2@%kHJ2k?EpcjB?X_;c-f^8Z-hf**+gblmK5
zx!g|x9s~Ro`07>iT*t|m=$~y7_qzlA#)aFSb*TSM;QPP>eEh5SoCJHm2fPvJ>fa3h
zUie+dxwgX{mu`8TH!jEgp>e3~cIEf^srY9R@ZM!|AG%i1l^^jl;ctRmJ5bAAb-g@a
z3UtedQ9cE10^SLH0(b%R_NOljdDV9b?pFYZTqE{u1Kbf90-gf=ruE&wRP_A@xDhxS
z_PXtz2|rc=tAPhxCwdM8YCGNXDnHthKMnp(1AWV*TpE}MUITRN8@*iYItplRko$6=
zE8pbERYR@?nEAPsKj>ybxBL|-e-rTWoBqB0{g7J^Ogr_t`tQZ_7lG@59{^qXM{kt+
zUjV)ed=Kc#e|d|@m)|Nl1^6T|aGUT4|3WYXd>!~!yYNd_3El>L9O%|p1$}1&bHFB`
zD}NvO*MV;VyHp-_1b}-1_W`>4cD!Be+z)sl@DQLYKL`9mU=nz?kNhEM_dH+~@JwJe
zFaqpT-wLsB9kA+txxWnP%Ksd4tAY0e9|JxCd<y86Uk|=)rPMPBI27p0Zwr3%FGYUC
zU4n}d2d|)A!|xIP0N}O2?N<vw|31MQptkc3wDTRG_FjqlmjT<qp*@>mm)1WUb}YG9
z?6@1a7wqw~&-I6&J@>(`>+cr*Hv{hiy8ikM_PPGp()vF2(ccaI&1m0p;C+t&-TKPV
zuY-VF0fzxc0rv(*fZ9G+pQ}gfAC3N=2Gn?P%RhmBJ0JbEE$r8R>o0yzK)DPs4{QRu
z_5BQSekZUUxElCt;O~HL`QL+o4frPTL*U224M4a2n|Dh5ybJsgn8vu%aa9JtxaC#;
zQ<N)1xxv7#fg^!C0rvp9`X0hK{tNIu;D<n0UgO|K#KkSZ+kkff?*gs{J^*y}-GlgW
z`+1)S#80mLSKxPBBhU8$js?2%pMxLuYmwg(I2!26n+HX18{qc9`M(jq>0!Z(fzLfA
z_oqHCm<K)xboHzJXDBxqa$4S%-vBvR{yRSUPlKH?;AOzjZ^gdRu-k1%JNQYc?|VM&
za_x&a^<9Pge*wP+4oCfN`I+F)0M-J}0%m}F|4!`x<O#vAf!nQ>`?)|@|FI~q`de^+
z3GfQw4}sSJuLa%=yaVX!e+c|vfg6DT0B+xpedEwB?HBEbmpi0guRJRFA#myM<$e`#
zDg3Y;sD7yP@yF|^Z_Y!a$JOVyZw=&J``$vlxbnZ<Livx-&XdqSjXNDDuKvRw5xYac
z8Nm6#Gl5?Nx3v7P`YG?h&Rc;ifvbRSeS<NMbX@7Ypnks%{ibp4mj5mKc_`$z1?~iN
z<rn-x{Bs)cbl~5BtxwDI6~GSQ@Mna-9JmQM^jYEe1iJNI=ja=Pa;k5Yqt7kh_(#!y
z1@H#oN}wxWHCW_VJukR^Y{-i2c%Y!YDfn-CncQ3oTnfAcf1lg|>;!fL-S62Lj=zha
z1=Qcg*gRPDpEkOn(t?*-e>Lje<mf*g`kH{MZ^RH$QUN>ycr)-(;MO~e+yr0+zV~!0
z@G#&E;0dtvo7$`2TcZBx&py|l0$13V`n@IU&qwfg&-KGZas~d5_W|Hr_#Rr->+1U<
z{1!kzjKJS}2Y`D4#{o}(pS}z9fENK*0oMZc`)Oat{pIlEa^OwCCxOob*8yF7)z1B4
z?|9%{z}JBqUv3<@`X)N%ySK3XG5DU5mx0sKPW98xxL3d2j^EAsz0dFGw8PKZull{Z
z+K;EhFY3o3h{s7j<L3+LI~Q@{mUsQ3-`~3dU)a~5{#Oxqd*JWt*P~s3_i3NXHADVK
zkW;_7_6)|~*$)G53mgU91-KV*A7BG;AutJa^?we2Bk*6qR-f+!cn!RMPlU$xHt3gf
z;J(29fI6>eT%U_}zXDXhx%PFVzE6Sw1a1Ou1`fgZS(F2h0J{2)2LB;Y>wnFszYYa|
zByc9M(MSGle80hJpvL8FpZJ`H?=QF>sD9D7aP8j#^I8h1ai($V%7;K)47>z*1<-|E
zL5u}f0;d4)1M1I|<F*H0#;Z4g>w$-1{R#n32JVmV^EegQqo|*9yF2Ax$NjrNKl>J<
z-ktu#@)x1}Wx!>?q5qHd>Gy=)ihA7k{sa7AtY?1hS9@2%?l+K6d;-+p5&0bVZhxGK
zdKP`d`i6B+vnuWa20xMeF5m~izXJaT`~<iW_|d0Q?(e`)fL{Q=1e*U5xl@5@;9r2<
zz~?^~Ik$Z~z|LKOvw&9smjHhP)b`A9>}~r8^rOB2aM5SNuLM2=JN)cXJ9bBXTF)}n
zcOCHOK&^KH{Luki2UI&ku*Yrx3e=<hbsO}4)BalMQ|~wJKebEyPy4G3{&MX-7wvcy
zsB-FOS6==83G{sm+z1?s{?LAL%Xh**d%-VmT)FaH8>GLre|4X6(19UW)ZQQYg~<OH
zSiVv2#{u0!r$X-XZz!*NABX%P=ymIv=~Lf(;1~Z>?CShluywQGEHmAj*bcnAOzwvb
z5DWnufo^+L|KCv0Fx0aha5OLqTnNknU3;|tk6=fC_0NOdR{^!0+V9%?L)3fNm(u?3
ze+h2ANw5R{QM=so9Vox+e^}nFcOTSyFz{5zjxFsc*WSxv=Q3bBung@U2;2&IJW&18
z0)MmtgYdH(H&1|f>v!wb_I!f)`xN*kQ1$%8Ck|cx&G6Ss;GMwLz&C)ed?o$65jY9$
zarNDfIPV@T@jrDd!M}_Y>;`T(O78v2-vK>qfr|%<{Q1C(fFbCw25t@g<A5gu&jPjr
zZwK~g&l1$*w#Th^#R##l9k``-sDE64w4(lHz*~U71g-|I0S+G|cAN}66Bq^VHdLPP
z4LlIo1*{$>&s%`no^@!~igJ1033TmMJ068S15vNqbv5qQpW1Kh(0@VHTjki%p}g7w
zbnWu%=SR@rTWaquu=jc3OTgEFWr%ZakDvYRu-~n}3GKcTSoMG0z8$uf{!+VKKWabv
z#jE<wFFs#}{*h?kXkY-S^;K+B95?@Iecyqeqk)5li{2#gY+y66bz6BJ+fJ|xXyE5@
zK=r%ZKU&XmsPDVL$AM1+Uj%*tRJ)#n9nS;TJ9f3fo(><oTzkrfNIL?E7ws3F$6WdI
zA>R({PreKJpw7>lx6Ss+-}HALaO`FD_g6l04Z(dia3L@YTmy9BfHGlj29^(y``v-F
zfyV*e@>M98_bKnnp9MV$U<TOYqkkp%r?5YK2B^RLqTffo3A|h18k8T5=i2~h`N+TI
zBfp!Eyz03G&-M3(*5JNB`%Z_PTYmXBEbsb7e{Wmsb^UPy_VeEZt^nQ#bmbes>+cM8
z;C_>jygq*s&tC?v^O4tMtQJ&!G4Kb#R^X|KuQc!_ARhO?UU;=HFbJFsJQUajRQ)&N
z{!U;!P|v5nY5genZ(yJ)GgAkI`bZ2k1I+xA{6Lc{$qzEiO7erv2POF-Ca`VDxYt0l
zmDy)xDV~nHN0s8YHdQ70VWxchQu5oF&~Byp;ikGIzpZH<TS|UA(^irnVRB=p8}}M$
z%1uj2ex&)INGbVICYUJ2Z*R))u5s0yfo2CYx+K4&36$h_GUH0}JDZKaDy5&sMtdoK
z7ZY4viXUTIO7eOJTik?!X18JjcLUA0eE8jc_&t31fDgZ?4?ngK&x3rB`DC;EfZv1}
zV74>mH6i=x75l$2yjn8fT@$j*ckTbiwv_p*i0~P_%d$T`FEeAzdiag&<LeOm$NZli
z{&aeGfcb`d#s4Zl9r9g{{ArdiH&dsugdq#$$`G(Uor#bos_p;ATt>*e{@VF`@YjHE
z8ym6=-lQ<U1mBtzewux1%o;+rGXy)wfqxdfariFFmz%b!Vkb=r_WBTfOGx;sLYq&)
zccEP!aKvE3G8%VnM~eI`$d3kJ4f#g!6TutkuLXY$@um8GKJo0IyT*pB<QT{&p{He*
z)XQ<e*AF1CzcTX_2M%4F?Ud5L67p-uhFFX|DA%LV-v<47v&6jNqvtQsqn{2q33|Q;
z-;PfW>`(W6jT|8D>KZc5-s=e56TI0<_zJq`>j?0{t%a`>+MEKu4g8tl!>VVP$Scp;
z82hstJjWSd7pwd>#rl_nPlIQ_@O3Bn(6%CflhEcj;Jd-k1OJ@LZzu8_z`q4PI70Zk
zGI{WK@NMP78@#K`SsmN2-?n=X^o#~yy_3j41Abrd!JVNW{4~`A{w?tQE%B_sWwgi#
z%H%<V%I_llFtU%YM&ddCUq55Iz1J_jZ-spOt|G59DgPQI>+b~rZClEi72wToB99Lp
zn0vqn!1MgV*YCi$fS(|==>*>aJ_7ss*Id}nz?oua0P_4R5NuCycd3`>5x%|x-wj^p
z)g36SWBIB*L_UE}f$R^y<J-b({Lcg**hhHP69(S`es8JPTmrrw{FUIZ0Uz2|^hCh7
zsXX``_=mv<$BF!QW%7WtQno*|pYXaH`5b)50mA<jddev7Sibr|;U59NEBN4e;a7s^
zPgSsd7x;gb$pikid&?gr@)tp#e+``ZbWr&Bz@G}fx>ESZ5N|2)!AZh@0{I^*KUw$%
zW%A%|@U2sXe+GPq>Ypn7h0y;Z`0hi6uY~-^s{e4|FF?HmsQ=mi4)8yR{4U_Dza#R;
zQ#|oC0et&3;dLC%P(3q*|CNZF1>n<134adkYyiK0Y{*JZ!lyI%*UH(R?xRJ%v&=p=
z{43?w&RN2r06n*Z56lt%VG%cL!FPezdGb%h^EmpgGv2>|e9K(Xa}d^@5wxyyz3uab
z-&7_Q@UQS#{$$~=Cjas^9en5v;lF~NHOhO!FQ$9G_}ANQyXu606?`-Jwxsa)l!<&R
z`0BLqpF{pm<(q`>fIR=2H|q~97JeZ5@fGkLKM`K*{X6*JdBW?bY|6+V?6;>Kzl|ZD
z^|xIw@>i1|`T92a;LXB6FSMBezWf&9cfv%;zXHyBs@DiVp-c*#Ks?vmje2z*KTGvL
zAoAaad?Wa_Ukm>P60a+vCxrR)GT74wz6<=>(6b79LQjbvo`3o3fc#yKANbdu*v>Za
zn(zGsdV<f2o)1Kg8A$P7DxcAON#7;Ze5Rb_t$yr-G+)}!N6!S}*`IoPl|#E!zn)^L
z{&~>f;ppdId9wYoQS9FtdH6*>^)9h`cI>mCx*mGW;URcH;0EwPhi?a;cK9c({xPP*
z$=mr?S;|W6?>0eCtD}d1O{k1^AMQSJU*b#kOC|B_hYsjDhxGDwIQY=fA$z~b{%_2Q
zK6=hj`2`~XKIF6DgC`4rI`}2vTfx_WUkTovBJxYYuLj=+Uh{#q;Hys+`QJhQW#W0?
z(FuQ2xY}z2_$M8HD1B;;{SY`UWaa*e`E9iFX9%C8^_Z`5#Fz4C1?0Q14+@L8Ih}a6
zXV!hvQiQGHUmNCnt5P8=sdmnXd<*tRPeM<Y_)_&YK~E?zdXlK%Qt<7Igx?PQwctA%
zg&zxkg^&Jr$OoE5Uh~+;!FPk71HbXFPI0?J=Zbs){JY?*&lf%c{vY5wTZEr(<k}2A
zaDng-fiE8}{yY`_RKM*CzRKbG(}Sh_#=o-6cBU^B{lA6&so;Yb2|ow?@!(s)KLWok
z0AF>9$m_ar8u8rk)s8)N;L{GD0N>#7i!D#*NYlkLQVZ=XA>ZW4ui9PeZE^Tkk}u_l
zYl&w+bT1Rlm!n<3^pU>@@~zj2{AwfDL*T2f7hZqe>N)W3Hwu3~^z*NfalOGd;akA}
zlX&)9t7HFW@RvFKU|N`1Py0=xXUG6!ubqf5)!uIrUuJeOQ=NI>0Lzat?T-G*;8!^O
z4Df9Ze**aB;L$7-1-}eDrV|q<zLcGdh_~&!PuhiMnG3;pfWJ_hYp#a=&X;Q}qvPUw
z@Es0+kMgj`1VqtO;GcBl-zL74ogew|pZW0ARkmGSkA-Z7dr7rsF!9{)T~58Di7!>}
zUOs%K4?n|)ukzu~@ZqCAeBOuuKJna-=@+HFNUP12;9J0J{&NHPHiy3xe21gwLGYd6
z_d}pOO+4pU>ABObhgJVOkT<W0J!LxXh%e>m!E}I7iXY*_f6Is8n|Ss^piAo2U&lQN
zd<Xb)YppSdg6{-RX}rB=gYN>r3+z7)y!ms;%KgCpZ%l%C_Cw3O>6Y06{JD^C{d34N
z=Rwa^#FuLCGRU`mBJy>#KJm2*eEC-)dw(bNJWf2%GgZz!^9=Yjc%27c1YZqa{qUyc
zDXV>@#_A`f_WHB(uL`f{qF)kU%KpKmkp18B{4`r${x@a^@Z~QQ^Lv4>2LJ1wrQQj|
zm(qW@4?o9;|1R-7-lxKTov+UFkw3vFKC?dZ=Rto+^`n9%KJrVge7Wgz_6vUdf_5uE
z%5>f#aV6d{<{``X-7oO-Qhxgb$@9Ag?)x}zSUr8;uXzXZZl3>z<@>&`G;AdMd32xm
zaRS7TqIl>klYXc4*j@*LZy6x%T0-%}*A(!f7en^`0Q<i&{HvI($NXOS4EQSWZR>=8
zvP>RCz^C!P*Z|09EsvW5_%Y;zgTzkTOnTntBY&R{{}k~fDc<z`DUG*@lvglc{kDuF
zm}%Dg==lPA8X&KFhSEk}_wohin=zKB_lb}v!=2^;@M&i}hQN3KF=W+T0%dcR?-V~w
z0Dn61wq39%0KUP><E8*!rFEJ6tL?UsWwqa1eB_t<@OSv|Pg<VxIwN*|jJn_Ok?)3l
z7xH{<??76xxLvKz{CNybg#nsZgW$DkJ6rj3bJsBvx74ln8cRG?(dU}%!yjvT+Lvt(
z*)nu%uQPn)(~$4Let9ts1-{M$9~>Zl_?ggV3HWyCKM(wkKKfS?&wglg;_X4`DQ^#1
z4Ie_!S|2^HLC*>&&fkTe?sr7b4rQX~U*OFH!v6&NhtmSe_Ov_p>_B`eKkw_qf5-9^
zCzp!;9ijg?@CNTsX+KtjZ~2?ZABl-0PW(t--!X3opywRRk1@-f_}P{!;`p!LLE_|9
zw08;Q*Es&U4)wOaD)q`NVazYUr!g;GjCx-fEBZq_iT-E6|4!uxN<3)0p0PZH3ZTa7
zDIoCjJ?Js3LY7fI=h=4kmET12<uqP$&UhIJKLl?TJyG~!IQXjPh2Iw{$N1<E63_9_
z0l(2oW3R(~<f|ax275IBsr8X>_Thg9J?l`f>RI6<pRn_J-_L10>?8jdAN~u=(|iuU
zeGBa!x|8&K=SLySJOX|c_;$?O0q}c(Z~aK(;aKqe*M;oQH=Q`FwDJ%tfMX&5mLp#c
z{!b2{wR&jWVcnSsT^E55JSX;yKs;P+`GN}Z@>U=Ie&|WB6+QKk=f46jH9zdUYiWKx
z$+I8ccI^Kgd>43Ke+N;1%Hui>f6_8xuWc=ln*#W@56^!cS<23N#Irr!s8{olQ+?z!
zKKxZa{9Tr(_j&IPSu3ky>%HKE9|%7Qd<XdQSA~y*{}c3g?k+rN^Qp>*h5rN(hSGp7
z)!yBR=k}T|neh+~rou;lx(|Pf<!Mnw{NIIoBjBr?{#ppW9p83v6yzJhmt#Fun;Z5h
zZU4op|F05<+e6O}!B@W-vdqK*^56!`L#P0LrF!lUSyt_T$VdJq$OlHt{QnXh_XhZC
z<aGhm@sW=nnzBpw%Z`?(^STbP=L6WkkB|JJknem!<YTCJwvYVjKKx=Iem9?aatZ2f
zMP6|#>Rk@L^KG$5=e-r+%dzfLxY}!tPrc9j@E<}?0QKs5OBsc-UH7qGYu>wq<xyDy
zjDx&c7qaZNcs3P$3)bH+;QyJ#^E&J1r6;N$<a?U`*IK@yLcDB(d@IKLa>UPN#PfI@
zit(uPUMu(j_z?88`RKnF`a8ZB$spwa06vKQ;1clbpnrvvM|}+Wmg_{1w#(T0oYu$p
zgik}yaPR?)cRlyp$!GpQz=uBydb&GBe<k!EPdxjl+L^DS#0MZ#2s!AfPK7M}Cj`p*
ztY<*Exy<?8=9Q2SVtro*W!HdDqrU>+SFj$kr{ym-meKxt$jU>g0G@}Qs`o>dt;MrH
zgEzkregxuegVo>r`BKe)zJ`3;Uq$|H#LuwZjM<ayX?ObZAmZ811}CnLAfCrd`QxJJ
zXxLK)`84FU-ZLTJRxR=o$Y(5%n*#WO55F9G%2$dWJ)gV-d?(fs&AZkR&-s7o#OYRh
z0Cha=qrVG!4Ei?;`EKylXzy|0%cvq<Yd~4p*@r*C@|<6VtQ;**_Bw=kwsR%+r|P$3
zR37u5u2ZM`=ubmFg!yeY^k3;Ce=G4^Z#Dcg3-S;6$Up7F@3Sq>Z)415h-auV>#aQH
zT^%7yHQ~YEz?){_b$*zGdE<q{gon5pK<`_X^t0vZ+}Js%+Q&!!P{>!^E&3ls{Lcd4
zg}hYl`7ZGs|2b#g$oS~L8uEEZ{(9AqzmEQ7h_vi>@a5<)Of%-!KKh@7e8(+f|1ogT
zdhp%w1Es<C`iOY8zX|r}JoCAa{$Ui5+>h>la3`Bb(dPi)3t7GAiF&iQPkwb6<hz?h
zUi~=-eAR)%Ux)`)#M}AM@mr0L{&Q6S*Twp;@{zyA>fgnLFu&>eYKNW>)_vLr+UsE-
zJuh25W6TAPoo|4@%<=PwK6*C!@FN4I<9u)8*+1_5Jk83}z5wS2>gW03gUFMcja*^y
zE$By?73p(X;5(5&|478mCE%+r4O!+I48m5+TdL^4+bmD(!hIpjABCq6fKR_J{05A>
z*1b!&_c6$KY!LYuA^%6!vsw5FMy|~?F|vQwIqwht*~&wx06w$)cBU16y9Up;+LP@e
z`*#-4oC|(`8n3Ls)#=}I$fs`)SxL>8_5|OBd`9!t{gj7%0Q#p`9ybLr*N69@ry72)
zLYX-Dj^BqYGanO527KF}gntL}=MvBDTIRItN02W^9!ueBubV87n*ulx^LhCw@!N3&
z<lzHWf4K?Zea3@O=2__Pz<j0SZXNhE_GP-xzH9Z+Ij1x3291^e>b@&vH4lRR(cnAY
z7d{DoKk)633x72D$;7iCI-p;k8Z!gDSzlu%%OF43>cLF`>_u@{YMl!E$md!AfL%-z
z<|S2ift9B`0shx{{-@x}5&yd1zm4^f{bi1wYak!EBV<*t9w;^Z9()VV2Xw#lyz<YB
z{JtV?-c-I*__M%&0lpRE<x=opfe)Y`$AKSAiG3;mjP>CUwmf})<2I@HVd$AdJm;(K
z`!$Oo-+_AdTY)a|(SM^4KVt`pt9JO|=csp;kNjHH+lFyH5%SLx&;2sM>6h0aA9z~Y
z^&JH6hv2)Mc>WB0)e9n@hkmoS*x7<}gDCj17)M<=FH--1Wb@d*fA2N|dJOzF8hRSH
z7yARSzj}Z?*ctMzZ-*>#1myPs-;F$KItI)XwG;Ewp^!fkeDEF7gXzkgXn6<~z}Y_h
z6+ZmU#Iyg`V0>x*bHA0}&KTr@^R$lISY2I3#Dr^Wy-c(|+LSiAOtaSzji*f{l}Lv(
zQLio*k7i9i8LN$DqLExIl?=zdWVF#fFqvpNmC1Rr+GsKti_jAh_q?hTXU?C0ns@Yq
z<7UjCef)8rS21N`aEi(16Nzvpwm6FVym%~|Gud=B602+W7KP*aXwO|X*Bp;lkP*3x
zi6+tzjV$!Cx!P1dXX^4vYe|ukSbZ`@_DVZMZ#<Q(Po;BNlWia??JN3^nqZsgC9?Ig
zS`&{Ysg<crBAoN&shQ!$>T08PUVSE&Pvcp(VoGIjqA8?QJe^6UqnTtl5hY(HYVxsM
zG~*@m@m!1?)s&Ma1WhTYOsYI&G8M^Ya~Us}i6s)zTCXvcsjW%nleN)W>W)~#D%~QT
z2M4KRs5_}7d4zPwlJ%rMoXp0<xu{o@ud9n@Ogb7}=;cxiqe-tO6OJs5<_z`CLT;6p
z&DU@=h}UbgIr3*Bmdkq7#St%^%6gUl&kQ}!Q5(35OjKU<nvscy<MC7kMr7H*WU7{|
zj8YgSvr&qsc$i{>_}aR#$Dzs3O>I6MrwAkS?QL<fSdI*$CQ~qx>$5o$Gt>`pa%Lo}
z?d>J<Y3i?Hx`?7qizaJ(OpL^%;iPEw;;DKH4(it^cTaD#BB^AKih1E29Ag_5jzpsA
z9EaFKFG;OoGFvhbCLc0ovZ>2Nqh6#ToFQk(jqM)1q=)iK+Sgk*>C9#F5fovsS!<Fx
zlh4&n^|CcyBAlka%|#l#NUq7V?GaUV;aHqoMq?`z&E+%6f+o>$PbHzb(A}6BB&^x(
zy&cH)hN%}TV%bc%VnWfgOf->N6eS1A!--OUlHoCz;2A+;E^BOz@xU?JXgI?*=c%(6
zW@tdtER$)L@|D3p5r_wshUSbcg}DT^7mY^~R1i-mi2k}*hJq|Y(MS;`gCIu^hR~#f
zaAVrUQ;i&0GAashN(FF1VH*XJcq*IEL}70@lZnwp=h65IQ;<a?)B*V#Jd_%!zo@V5
zpiQM=(v%`+CZd^oQplr`6j=2hPZ7R#6qSx8X~0BM>E^yHP4p=n1mVcpd7AMN_6Tp5
zFM43CArPXLg_{l9B^?$C(-eZCn9JnCHSuUsojkl_G;*lFD1NE+UNoJJ(Y)<tGZ73I
znS>g`ahjHRWJ`3@yedIP-JPOIx+jo9PbxXg4z8SB33GUyMQEzgV4dpnG!e3`9PYFR
zQVrQ0jU(%3)Nu&hT`<<Yn&w;-Dko})qRT0sbG$xfO+CFpR}+Y~iIp_l(-cizBh9oP
z#IuP-j&6+Q8h9o$*;pN<X_liw+!)T(ntZy}dWl92Kc^L?cfybXWj#*ocxe{}r%o(b
z8%$l4=Z$1OQNt6u9a+@HnP@i4ks<^&isQMYK3exlpN`06q@mEM1(uMjqnS*KR!&})
zDWzy4b;Tr?#GH`L(U>W<qE0zv^1(h2?6Rl|CXiQ11+Bf2Fa=*CO^anIeUmDu9D)^^
zBo-#~<oZO4#&Fh4XTrIhM<a&&ymaB<l&Pi4*yO;Liez$Rht0w~@7Nh9dUI!=G~e?K
zt)9A^<q|Ywr;>Kzs7-nG@l*{>AGNf^X1#E}$!2QtDD^X?Sd%A{9VLV)FH6QeJ3wU;
zrRksY6|a`^v1Te#a7W{jLa<OYOrg@en3Ee!{n_Z*rX~}M*2SBthd2Y&90&6RiKZ#(
z;7LZ7Ma|e8TB6FMu&3EfO4v-Zj#gM3aCk)4*Ln^4<U*%>JX{lv8~e1UhN3&0OQ6e(
z<>ZN-Xh~_0p{Rs=m6Kzslv3Z`#(SLT(JF=f*xqrD=$)M<M;M-nXvk5D6Q)T+GTT_h
z<7YIX8|o$X4M}NjRGf#d*GsYUGL*Ym37d^lIh%ZDJ?d;ub0k})&bE%Lvvt8glD=|g
zn>9#nZCSms&x>SjJ-p~rrk9KcP0!0p6H8f>qcnzTspNH;lYFm+n#fs0xK=wq8_#Fb
zG$*A^l-7<#6rG&u;YK;?$!HT-P0^RCtK&>3S(E4NGixY;PlV$=4w74OL6)`{^ng|n
ziq%wtmTZ_$>q4Ei8TXZ0+i%<oFhWp&C1_a@pK$A>jkJ2$KoueDg?ui?HqbQ0xmYYo
z1E#k3&QLazp>)EA0Zs4)ca#&$ogEhRIvZQWMtEu3W<<u@G>a4`^YJ*XqP!2G6`_8S
z*FbqdoF-R$qYrFOMhR1<j?xW}A}$-IF+z(V?=)x;%+h{`rU9#z>PXeoc-9FN!qKK!
zj>FM9G)3ZegOY6+e|A2VV{h7#o^9~>p0f?v{?K+Qmr2H>$x0F-19+YvPm4hD-T1mJ
zZylR#ACIq%vA!nWYS55hM6YQ^rF{mysG;eVs~#V(PqQh}rbs+*JCmiUR?d34N`9@Q
zDiU)Ty=@3*8`xDME_WVDmz=sM985WNQWD=}%4?(zL4<}GjR^|i@ww(S8%=95C7}F@
z5`x<CGH~r(wt>J71RJg<6K<rwvi0*zu{BKdFqI@P+KI<zs7MQPG>IhZWd#q?j9wR}
zJ)tM8to5`Fv(s^m#;NU;aHgK>)R)+S&>*vW;o9B@$=<$-r*ey;WM`IMP}j+A(7x!c
zv_ucrq1B0KB9d;V39FG8LdrAjE$xTwEjii>($0@kYSTpHlRQK=ay(~xmrm<8Y+d-N
zY+`5zh*7yLEuhTM11TToS9r;-BfqdrmV%C+l<do(UDl62aoW6@-pu2Uq9sz+OMP9m
zYSkL=sMC&{HgEO}k}7yYqlKnu&pYP01>VeAo@kqO)QQGBX72IRr_J?_Kl<pCX3qEK
zPn$k>rdQ~0atpEm8_+Zd)8M6plDHi_loe;{7innM+EWlaK~P=sSWU!>Wb<|jruzuT
z9nD{|<0QX@LdVRVJ$;5ZfsQ$PdY;`y!g(J3y#f;|CUd+-lZ%QukJbPg;Kh6_+h{i{
z#VqDJo;Vw0wYdhn6)YB!Ns$+zY$Ow-Eo>$or;f6_bWKdMIyrbWIjDdPwh2Y&Bs^LX
zDaEzepy4nqro%O~SQb+rPi-`Wxdcy~#ZP;@CPxe0S5#$^rl4XuX_YLFXqTKQxnkCx
zG@%;GYGaNmbfOSR#pA_AIJ4I=Ru>ObiqCCMHy2CUm1%;Fj^6R^@zDaEboKT<&S&gQ
zTC4zbXDt@3N-TW&T((#)9;JN&S(#5HWp2VEN82YlB8f%FJTh2U4W6A1ovZPzXlxc!
ztc{i$S(S=uCkyDcKS?`wIsr;Z)pDp~C|{<PfHEQ31d`ulPA~E}jnR@u0&+Nk*7j9Q
z%VDCI74K1sOz8+F^Ik(M50;tM9(?iQuR9sawZgeDO?P%-oov@GFGBkcUcboNMmtV>
z74gus<t3job-e9%0+-j%WNmR7IvPw;{#Z=bkQirDwW$Op7{$+Uj@j5i`+3Ug!Vx<A
zig3F~zF1P{5_;$*YV0vdBHUCgLt#i$RWV10U%bz<yGYyjvV8F}jA1Tmanl4G)|mwL
z4NccP_weZ;pQ{$D%+hSeTS8tGd($kLXyk~1HrjmD+cS^YlN~xCvhzwkucb7<(jjeQ
z!F<R*r*ppv#dSdi7vVfKO`9;viR^%DaQxh3R!uxiM{v<ZI@e5sv<TS5gX6tP+vs_k
zZ53BX9;8DkM{zt$ho{AIb~wm}1W}l(s|`Cdfaj4P_>7bDvf}a{O#{^ad|VDhD7h<s
zPH{<dpNuJzqz3flHgEwaCxuClWIn}OWFpXQ874s*PBb4B3vv}{J~WO|)Kg-XF?F<4
zPS*92;!LraM4v{RC@n$4p#5xfy`JfshcV}j)W`Nc2n={TL7H?d?F=v4McJ$vDY6}a
zeTJ4~5rs<=t<AKON;SoX5*Nv)9qZ*Z->%*spP$-{s89dXVUSG#X<ts~th@^<R*iMv
z#u^>xxr3Zq-e+~PqtMQdUTPurGwlcM0$H#!U|!{A_$+sEt4q@|K>Jpn2cwQPRy9u(
zbkr|<Eia#?^Xs0TptXWFN8BH@Z6yuGjp^wZi70~u0oj?+c>_(P+%=S16|RFaFSCzb
zQ>{6e?&;*0cXe4t-NRF+Vc(3BJx;ML_9&!ht<@b%PeW{g5li`4aXATmY$*}<){b~8
zwUFYEPr7ZUYwE118|blmJA3pQC$a(ZXai(0bK8l4=T)0CQ|Q(6j3|*n2RnSKKvBzY
z1Jq_y*!;<`=7V``CTKFH?!sO{C(UL$U2p2i{5ggSGmOefqJ{gJw;{Z#sG&n7+AHL9
z6dcBzeLR^#>#lUZZG9%n(6fPzB^M#XvIC&lg;`oL=qQjJ#gk8A_DfShJ>`*74+(HO
zQ#{i&&<LS@o9EGZ4?9y0kDfl`n08Y!+El@G^?*IUv|-DWlC6l(L9(VXVpG{-gA0;x
zj<zC`?eRA)^Wiw1G!++<jY%=rMBeUA4=6jQ6Du6V6pSL9_Sj+6NC$hVL`|_0>v8TL
zTBb1&c_YEDOUCIyDoLGHmntr!S*5g<!kXWVB^}NXr6ar&o-LTms6Y6WN{^X((%($q
zWVUB8*{Q%J7WPfi(bGskdwPcsqiu}RNe;z01$u(sIm^;HzV>5XV}{e3(z6uCkKK3n
zp3C+Ib<gC*^KIW*N&-%D4m3|&Vz>o(BiGc`a!yw4WzVDcU@4w>4(sV9-um;5CbMvH
z0jZ47)@6UhQ#`+O%}0OKN&3FI%_jNy)=d>T3W~axQ%;-h71zW251TCT8%Ww5PVM>d
z2s2i3341VW=ne1K;-2%an!b4z#WTMjS6tR6hQ(Cx*3zq^gRA0)JqAg1^7^5RKc|?z
zu9Uaidc?8iu_J{?Kej}T;aHB&%8KitnZZ8hM6bc7tNf;s?hR~b)zVvhbOO&armT?a
zS~~CS)73pj@D|%zpeGR~T}LZfydW`dS}a3=G}8wGFc*<8OKhqa(cp42!rEv}o+c>?
z5Sla-6XfKS4*-nBsqE1v=t*erd-QT7PF2}sf?|*0OpdqR6bb3(Osu{k*Bcy3!-<ma
zxNVjE#yyQ5I(8s$^E*P6DAFDzoN1=VbhMs{vQGQnGoQqZQ&aX-J4)~16;7PG%3+C4
zhiT3tl@$B5D&(A1Q-*u7^`19>-V7Y!$S5j0>bIT9J;VLP>kMWE$>8Pq*8XoN7+O;J
zvnU!3oJ?W|7p2cD&>UM&ZR0m6c)6gs;XR7oT!tw#jV3tptgDOXX`v}SCDAm*D@Sn)
z#A@su$<8Q!XhrwZ1q-PC&`F79RHl=j_xX8uO~+rH*%nvB`Li?LXpXRz7Yo{`)%RUF
zmvXY-q;#?@TJ$a_fBM6VM-oM1i^wCA`{{|O?$vaog*QNX+Oem@y`!6t$R*#<EoqJ>
zD1OJhD3zQ@%fFm{)wmC2p6okVDP5sCskph~ehe#9k!?=!i9rRKCD@>^?3;^eQ<3D;
z?rGC!kI#kcaaW(rSJ=;kjHjdd3cll*Hx;$bNzx~n%g7T9x1t-5o@Ju(Fc-k9bUbG&
zY?@I)FDvR(bZg%&so+$Ggi`jvp(08r#rD0ohFVghcT!Z|b~CnwzCMe#UR+H$5sQ!w
zDSEGsYZ7I&YMBb&bMr2wLMEKBojZt^TTUtTb-1R6hPvMIFw)oLGkr;YrZ1sMKQ8v4
zBK;YT;g81Q<8(dWw?7pGeN3<D($AeLNgoHaUxBUV=MM<kNAp1h>|O7FgL+@uSC#bt
zR`gHH=LUr6&d~SxTi}ls7F}-nqv+}9n>VMl{IUTdE58iHTzhBqYmkk8?hdr!&-L<G
z<Y@U1288I&(C-3RFjMh?)FE`sZP)Vpxx|x+8%Y1Oy#8)Lfc_4JuOW`XuK&JAGMfwR
z-)Cfqi_z~4STL^(^w_WUC@!SuUl)`&qe4;wA8yspW4rc4tyxSj*hJN*zgJL&@*NP=
z&qKQHzZm7GLr#C!pqxIh$yab|K`zfebIUIwj(x)R@uk0i5JKRM5xVDp$DQVKdQw<k
ze<z_D<%6mi8p<8~sZ+jnY{*Kqj<wKZuiW+8ulG05i^BTb#)j;pHk5zi3x3*rY5mIF
zLN5x->+dt<#z>FAeJXDIs^^AYtVDT{Ha)-N(1P;W*@e=^1d4CXDyO{u-oyVyMC0L(
z0j~e~bI@$R)~~+{5yTfK-l`wSMZMbpxHV7F3;Oh{9Yf6N_XU;TEgD^Uy;pph%JAQs
z@EGJvzn^IIH!Q!N%CP-fUVo1w&`)`;i?8?SABUKh*Waxehw`1QoGuMRwOiw089ghk
zUw_|X<FCG1`!_h{dwvI_UCNJB!`KMAw0^~n#1+=Be-|8FE#;50rF#EUyOsHxUa&5$
zMn4CiL;0aWl@tsV-<p9`IoI!q(cgVZ{o@^ZmgP%vILZs#`~OWS-@%JZ!KLMt+SR9g
zn7@#pu9rR)RC%}jzCPtA|4L@eO;If==$4=CQ@(OXiI}eI{(bprDDV1jWV@8#SN}i)
zYP5dExjywz9V3qW$FapDUdyRfr}&iLKgz2reVx}uDk<oe=lfz0i(J<SQhxLya=$mh
tfh4SPtLraMPa1n7DgSTWbGUu+7#A$K-1>Q$Emi(EM@#vrQ^2`3{|mB}qO|}3

literal 0
HcmV?d00001

diff --git a/test/diffutils-3.0-patch/diff.c b/test/diffutils-3.0-patch/diff.c
new file mode 100644
index 0000000..256a984
--- /dev/null
+++ b/test/diffutils-3.0-patch/diff.c
@@ -0,0 +1,1330 @@
+/* diff - compare files line by line
+
+   Copyright (C) 1988-1989, 1992-1994, 1996, 1998, 2001-2002, 2004, 2006-2007,
+   2009-2010 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#define GDIFF_MAIN
+#include "diff.h"
+#include <assert.h>
+#include "paths.h"
+#include <c-stack.h>
+#include <dirname.h>
+#include <error.h>
+#include <exclude.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <fnmatch.h>
+#include <getopt.h>
+#include <hard-locale.h>
+#include <prepargs.h>
+#include <progname.h>
+#include <sh-quote.h>
+#include <stat-time.h>
+#include <timespec.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <xfreopen.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "diff"
+
+#define AUTHORS \
+  proper_name ("Paul Eggert"), \
+  proper_name ("Mike Haertel"), \
+  proper_name ("David Hayes"), \
+  proper_name ("Richard Stallman"), \
+  proper_name ("Len Tower")
+
+#ifndef GUTTER_WIDTH_MINIMUM
+# define GUTTER_WIDTH_MINIMUM 3
+#endif
+
+struct regexp_list
+{
+  char *regexps;	/* chars representing disjunction of the regexps */
+  size_t len;		/* chars used in `regexps' */
+  size_t size;		/* size malloc'ed for `regexps'; 0 if not malloc'ed */
+  bool multiple_regexps;/* Does `regexps' represent a disjunction?  */
+  struct re_pattern_buffer *buf;
+};
+
+static int compare_files (struct comparison const *, char const *, char const *);
+static void add_regexp (struct regexp_list *, char const *);
+static void summarize_regexp_list (struct regexp_list *);
+static void specify_style (enum output_style);
+static void specify_value (char const **, char const *, char const *);
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void check_stdout (void);
+static void usage (void);
+
+/* If comparing directories, compare their common subdirectories
+   recursively.  */
+static bool recursive;
+
+/* In context diffs, show previous lines that match these regexps.  */
+static struct regexp_list function_regexp_list;
+
+/* Ignore changes affecting only lines that match these regexps.  */
+static struct regexp_list ignore_regexp_list;
+
+#if O_BINARY
+/* Use binary I/O when reading and writing data (--binary).
+   On POSIX hosts, this has no effect.  */
+static bool binary;
+#else
+enum { binary = true };
+#endif
+
+/* When comparing directories, if a file appears only in one
+   directory, treat it as present but empty in the other (-N).
+   Then `patch' would create the file with appropriate contents.  */
+static bool new_file;
+
+/* When comparing directories, if a file appears only in the second
+   directory of the two, treat it as present but empty in the other
+   (--unidirectional-new-file).
+   Then `patch' would create the file with appropriate contents.  */
+static bool unidirectional_new_file;
+
+/* Report files compared that are the same (-s).
+   Normally nothing is output when that happens.  */
+static bool report_identical_files;
+
+static char const shortopts[] =
+"0123456789abBcC:dD:eEfF:hHiI:lL:nNpPqrsS:tTuU:vwW:x:X:y";
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  BINARY_OPTION = CHAR_MAX + 1,
+  FROM_FILE_OPTION,
+  HELP_OPTION,
+  HORIZON_LINES_OPTION,
+  IGNORE_FILE_NAME_CASE_OPTION,
+  INHIBIT_HUNK_MERGE_OPTION,
+  LEFT_COLUMN_OPTION,
+  LINE_FORMAT_OPTION,
+  NO_IGNORE_FILE_NAME_CASE_OPTION,
+  NORMAL_OPTION,
+  SDIFF_MERGE_ASSIST_OPTION,
+  STRIP_TRAILING_CR_OPTION,
+  SUPPRESS_BLANK_EMPTY_OPTION,
+  SUPPRESS_COMMON_LINES_OPTION,
+  TABSIZE_OPTION,
+  TO_FILE_OPTION,
+
+  /* These options must be in sequence.  */
+  UNCHANGED_LINE_FORMAT_OPTION,
+  OLD_LINE_FORMAT_OPTION,
+  NEW_LINE_FORMAT_OPTION,
+
+  /* These options must be in sequence.  */
+  UNCHANGED_GROUP_FORMAT_OPTION,
+  OLD_GROUP_FORMAT_OPTION,
+  NEW_GROUP_FORMAT_OPTION,
+  CHANGED_GROUP_FORMAT_OPTION
+};
+
+static char const group_format_option[][sizeof "--unchanged-group-format"] =
+  {
+    "--unchanged-group-format",
+    "--old-group-format",
+    "--new-group-format",
+    "--changed-group-format"
+  };
+
+static char const line_format_option[][sizeof "--unchanged-line-format"] =
+  {
+    "--unchanged-line-format",
+    "--old-line-format",
+    "--new-line-format"
+  };
+
+static struct option const longopts[] =
+{
+  {"binary", 0, 0, BINARY_OPTION},
+  {"brief", 0, 0, 'q'},
+  {"changed-group-format", 1, 0, CHANGED_GROUP_FORMAT_OPTION},
+  {"context", 2, 0, 'C'},
+  {"ed", 0, 0, 'e'},
+  {"exclude", 1, 0, 'x'},
+  {"exclude-from", 1, 0, 'X'},
+  {"expand-tabs", 0, 0, 't'},
+  {"forward-ed", 0, 0, 'f'},
+  {"from-file", 1, 0, FROM_FILE_OPTION},
+  {"help", 0, 0, HELP_OPTION},
+  {"horizon-lines", 1, 0, HORIZON_LINES_OPTION},
+  {"ifdef", 1, 0, 'D'},
+  {"ignore-all-space", 0, 0, 'w'},
+  {"ignore-blank-lines", 0, 0, 'B'},
+  {"ignore-case", 0, 0, 'i'},
+  {"ignore-file-name-case", 0, 0, IGNORE_FILE_NAME_CASE_OPTION},
+  {"ignore-matching-lines", 1, 0, 'I'},
+  {"ignore-space-change", 0, 0, 'b'},
+  {"ignore-tab-expansion", 0, 0, 'E'},
+  {"inhibit-hunk-merge", 0, 0, INHIBIT_HUNK_MERGE_OPTION},
+  {"initial-tab", 0, 0, 'T'},
+  {"label", 1, 0, 'L'},
+  {"left-column", 0, 0, LEFT_COLUMN_OPTION},
+  {"line-format", 1, 0, LINE_FORMAT_OPTION},
+  {"minimal", 0, 0, 'd'},
+  {"new-file", 0, 0, 'N'},
+  {"new-group-format", 1, 0, NEW_GROUP_FORMAT_OPTION},
+  {"new-line-format", 1, 0, NEW_LINE_FORMAT_OPTION},
+  {"no-ignore-file-name-case", 0, 0, NO_IGNORE_FILE_NAME_CASE_OPTION},
+  {"normal", 0, 0, NORMAL_OPTION},
+  {"old-group-format", 1, 0, OLD_GROUP_FORMAT_OPTION},
+  {"old-line-format", 1, 0, OLD_LINE_FORMAT_OPTION},
+  {"paginate", 0, 0, 'l'},
+  {"rcs", 0, 0, 'n'},
+  {"recursive", 0, 0, 'r'},
+  {"report-identical-files", 0, 0, 's'},
+  {"sdiff-merge-assist", 0, 0, SDIFF_MERGE_ASSIST_OPTION},
+  {"show-c-function", 0, 0, 'p'},
+  {"show-function-line", 1, 0, 'F'},
+  {"side-by-side", 0, 0, 'y'},
+  {"speed-large-files", 0, 0, 'H'},
+  {"starting-file", 1, 0, 'S'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"suppress-blank-empty", 0, 0, SUPPRESS_BLANK_EMPTY_OPTION},
+  {"suppress-common-lines", 0, 0, SUPPRESS_COMMON_LINES_OPTION},
+  {"tabsize", 1, 0, TABSIZE_OPTION},
+  {"text", 0, 0, 'a'},
+  {"to-file", 1, 0, TO_FILE_OPTION},
+  {"unchanged-group-format", 1, 0, UNCHANGED_GROUP_FORMAT_OPTION},
+  {"unchanged-line-format", 1, 0, UNCHANGED_LINE_FORMAT_OPTION},
+  {"unidirectional-new-file", 0, 0, 'P'},
+  {"unified", 2, 0, 'U'},
+  {"version", 0, 0, 'v'},
+  {"width", 1, 0, 'W'},
+  {0, 0, 0, 0}
+};
+
+/* Return a string containing the command options with which diff was invoked.
+   Spaces appear between what were separate ARGV-elements.
+   There is a space at the beginning but none at the end.
+   If there were no options, the result is an empty string.
+
+   Arguments: OPTIONVEC, a vector containing separate ARGV-elements, and COUNT,
+   the length of that vector.  */
+
+static char *
+option_list (char **optionvec, int count)
+{
+  int i;
+  size_t size = 1;
+  char *result;
+  char *p;
+
+  for (i = 0; i < count; i++)
+    size += 1 + shell_quote_length (optionvec[i]);
+
+  p = result = xmalloc (size);
+
+  for (i = 0; i < count; i++)
+    {
+      *p++ = ' ';
+      p = shell_quote_copy (p, optionvec[i]);
+    }
+
+  *p = '\0';
+  return result;
+}
+
+
+/* Return an option value suitable for add_exclude.  */
+
+static int
+exclude_options (void)
+{
+  return EXCLUDE_WILDCARDS | (ignore_file_name_case ? FNM_CASEFOLD : 0);
+}
+
+int
+main (int argc, char **argv)
+{
+  int exit_status = EXIT_SUCCESS;
+  int c;
+  int i;
+  int prev = -1;
+  lin ocontext = -1;
+  bool explicit_context = false;
+  size_t width = 0;
+  bool show_c_function = false;
+  char const *from_file = NULL;
+  char const *to_file = NULL;
+  uintmax_t numval;
+  char *numend;
+
+  /* Do our initializations.  */
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+  function_regexp_list.buf = &function_regexp;
+  ignore_regexp_list.buf = &ignore_regexp;
+  re_set_syntax (RE_SYNTAX_GREP | RE_NO_POSIX_BACKTRACKING);
+  excluded = new_exclude ();
+
+  /* Decode the options.  */
+
+  while ((c = getopt_long (argc, argv, shortopts, longopts, NULL)) != -1)
+    {
+      switch (c)
+	{
+	case 0:
+	  break;
+
+	case '0':
+	case '1':
+	case '2':
+	case '3':
+	case '4':
+	case '5':
+	case '6':
+	case '7':
+	case '8':
+	case '9':
+	  if (! ISDIGIT (prev))
+	    ocontext = c - '0';
+	  else if (LIN_MAX / 10 < ocontext
+		   || ((ocontext = 10 * ocontext + c - '0') < 0))
+	    ocontext = LIN_MAX;
+	  break;
+
+	case 'a':
+	  text = true;
+	  break;
+
+	case 'b':
+	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
+	    ignore_white_space = IGNORE_SPACE_CHANGE;
+	  break;
+
+	case 'B':
+	  ignore_blank_lines = true;
+	  break;
+
+	case 'C':
+	case 'U':
+	  {
+	    if (optarg)
+	      {
+		numval = strtoumax (optarg, &numend, 10);
+		if (*numend)
+		  try_help ("invalid context length '%s'", optarg);
+		if (LIN_MAX < numval)
+		  numval = LIN_MAX;
+	      }
+	    else
+	      numval = 3;
+
+	    specify_style (c == 'U' ? OUTPUT_UNIFIED : OUTPUT_CONTEXT);
+	    if (context < numval)
+	      context = numval;
+	    explicit_context = true;
+	  }
+	  break;
+
+	case 'c':
+	  specify_style (OUTPUT_CONTEXT);
+	  if (context < 3)
+	    context = 3;
+	  break;
+
+	case 'd':
+	  minimal = true;
+	  break;
+
+	case 'D':
+	  specify_style (OUTPUT_IFDEF);
+	  {
+	    static char const C_ifdef_group_formats[] =
+	      "%%=%c#ifndef %s\n%%<#endif /* ! %s */\n%c#ifdef %s\n%%>#endif /* %s */\n%c#ifndef %s\n%%<#else /* %s */\n%%>#endif /* %s */\n";
+	    char *b = xmalloc (sizeof C_ifdef_group_formats
+			       + 7 * strlen (optarg) - 14 /* 7*"%s" */
+			       - 8 /* 5*"%%" + 3*"%c" */);
+	    sprintf (b, C_ifdef_group_formats,
+		     0,
+		     optarg, optarg, 0,
+		     optarg, optarg, 0,
+		     optarg, optarg, optarg);
+	    for (i = 0; i < sizeof group_format / sizeof group_format[0]; i++)
+	      {
+		specify_value (&group_format[i], b, "-D");
+		b += strlen (b) + 1;
+	      }
+	  }
+	  break;
+
+	case 'e':
+	  specify_style (OUTPUT_ED);
+	  break;
+
+	case 'E':
+	  if (ignore_white_space < IGNORE_TAB_EXPANSION)
+	    ignore_white_space = IGNORE_TAB_EXPANSION;
+	  break;
+
+	case 'f':
+	  specify_style (OUTPUT_FORWARD_ED);
+	  break;
+
+	case 'F':
+	  add_regexp (&function_regexp_list, optarg);
+	  break;
+
+	case 'h':
+	  /* Split the files into chunks for faster processing.
+	     Usually does not change the result.
+
+	     This currently has no effect.  */
+	  break;
+
+	case 'H':
+	  speed_large_files = true;
+	  break;
+
+	case 'i':
+	  ignore_case = true;
+	  break;
+
+	case 'I':
+	  add_regexp (&ignore_regexp_list, optarg);
+	  break;
+
+	case 'l':
+	  if (!pr_program[0])
+	    try_help ("pagination not supported on this host", NULL);
+	  paginate = true;
+#ifdef SIGCHLD
+	  /* Pagination requires forking and waiting, and
+	     System V fork+wait does not work if SIGCHLD is ignored.  */
+	  signal (SIGCHLD, SIG_DFL);
+#endif
+	  break;
+
+	case 'L':
+	  if (!file_label[0])
+	    file_label[0] = optarg;
+	  else if (!file_label[1])
+	    file_label[1] = optarg;
+	  else
+	    fatal ("too many file label options");
+	  break;
+
+	case 'n':
+	  specify_style (OUTPUT_RCS);
+	  break;
+
+	case 'N':
+	  new_file = true;
+	  break;
+
+	case 'p':
+	  show_c_function = true;
+	  add_regexp (&function_regexp_list, "^[[:alpha:]$_]");
+	  break;
+
+	case 'P':
+	  unidirectional_new_file = true;
+	  break;
+
+	case 'q':
+	  brief = true;
+	  break;
+
+	case 'r':
+	  recursive = true;
+	  break;
+
+	case 's':
+	  report_identical_files = true;
+	  break;
+
+	case 'S':
+	  specify_value (&starting_file, optarg, "-S");
+	  break;
+
+	case 't':
+	  expand_tabs = true;
+	  break;
+
+	case 'T':
+	  initial_tab = true;
+	  break;
+
+	case 'u':
+	  specify_style (OUTPUT_UNIFIED);
+	  if (context < 3)
+	    context = 3;
+	  break;
+
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case 'w':
+	  ignore_white_space = IGNORE_ALL_SPACE;
+	  break;
+
+	case 'x':
+	  add_exclude (excluded, optarg, exclude_options ());
+	  break;
+
+	case 'X':
+	  if (add_exclude_file (add_exclude, excluded, optarg,
+				exclude_options (), '\n'))
+	    pfatal_with_name (optarg);
+	  break;
+
+	case 'y':
+	  specify_style (OUTPUT_SDIFF);
+	  break;
+
+	case 'W':
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+	    try_help ("invalid width '%s'", optarg);
+	  if (width != numval)
+	    {
+	      if (width)
+		fatal ("conflicting width options");
+	      width = numval;
+	    }
+	  break;
+
+	case BINARY_OPTION:
+#if O_BINARY
+	  binary = true;
+	  if (! isatty (STDOUT_FILENO))
+	    xfreopen (NULL, "wb", stdout);
+#endif
+	  break;
+
+	case FROM_FILE_OPTION:
+	  specify_value (&from_file, optarg, "--from-file");
+	  break;
+
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case HORIZON_LINES_OPTION:
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (*numend)
+	    try_help ("invalid horizon length '%s'", optarg);
+	  horizon_lines = MAX (horizon_lines, MIN (numval, LIN_MAX));
+	  break;
+
+	case IGNORE_FILE_NAME_CASE_OPTION:
+	  ignore_file_name_case = true;
+	  break;
+
+	case INHIBIT_HUNK_MERGE_OPTION:
+	  /* This option is obsolete, but accept it for backward
+             compatibility.  */
+	  break;
+
+	case LEFT_COLUMN_OPTION:
+	  left_column = true;
+	  break;
+
+	case LINE_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  for (i = 0; i < sizeof line_format / sizeof line_format[0]; i++)
+	    specify_value (&line_format[i], optarg, "--line-format");
+	  break;
+
+	case NO_IGNORE_FILE_NAME_CASE_OPTION:
+	  ignore_file_name_case = false;
+	  break;
+
+	case NORMAL_OPTION:
+	  specify_style (OUTPUT_NORMAL);
+	  break;
+
+	case SDIFF_MERGE_ASSIST_OPTION:
+	  specify_style (OUTPUT_SDIFF);
+	  sdiff_merge_assist = true;
+	  break;
+
+	case STRIP_TRAILING_CR_OPTION:
+	  strip_trailing_cr = true;
+	  break;
+
+	case SUPPRESS_BLANK_EMPTY_OPTION:
+	  suppress_blank_empty = true;
+	  break;
+
+	case SUPPRESS_COMMON_LINES_OPTION:
+	  suppress_common_lines = true;
+	  break;
+
+	case TABSIZE_OPTION:
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+	    try_help ("invalid tabsize '%s'", optarg);
+	  if (tabsize != numval)
+	    {
+	      if (tabsize)
+		fatal ("conflicting tabsize options");
+	      tabsize = numval;
+	    }
+	  break;
+
+	case TO_FILE_OPTION:
+	  specify_value (&to_file, optarg, "--to-file");
+	  break;
+
+	case UNCHANGED_LINE_FORMAT_OPTION:
+	case OLD_LINE_FORMAT_OPTION:
+	case NEW_LINE_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  c -= UNCHANGED_LINE_FORMAT_OPTION;
+	  specify_value (&line_format[c], optarg, line_format_option[c]);
+	  break;
+
+	case UNCHANGED_GROUP_FORMAT_OPTION:
+	case OLD_GROUP_FORMAT_OPTION:
+	case NEW_GROUP_FORMAT_OPTION:
+	case CHANGED_GROUP_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  c -= UNCHANGED_GROUP_FORMAT_OPTION;
+	  specify_value (&group_format[c], optarg, group_format_option[c]);
+	  break;
+
+	default:
+	  try_help (NULL, NULL);
+	}
+      prev = c;
+    }
+
+  if (output_style == OUTPUT_UNSPECIFIED)
+    {
+      if (show_c_function)
+	{
+	  specify_style (OUTPUT_CONTEXT);
+	  if (ocontext < 0)
+	    context = 3;
+	}
+      else
+	specify_style (OUTPUT_NORMAL);
+    }
+
+  if (output_style != OUTPUT_CONTEXT || hard_locale (LC_TIME))
+    {
+#if (defined STAT_TIMESPEC || defined STAT_TIMESPEC_NS \
+     || defined HAVE_STRUCT_STAT_ST_SPARE1)
+      time_format = "%Y-%m-%d %H:%M:%S.%N %z";
+#else
+      time_format = "%Y-%m-%d %H:%M:%S %z";
+#endif
+    }
+  else
+    {
+      /* See POSIX 1003.1-2001 for this format.  */
+      time_format = "%a %b %e %T %Y";
+    }
+
+  if (0 <= ocontext
+      && (output_style == OUTPUT_CONTEXT
+	  || output_style == OUTPUT_UNIFIED)
+      && (context < ocontext
+	  || (ocontext < context && ! explicit_context)))
+    context = ocontext;
+
+  if (! tabsize)
+    tabsize = 8;
+  if (! width)
+    width = 130;
+
+  {
+    /* Maximize first the half line width, and then the gutter width,
+       according to the following constraints:
+
+	1.  Two half lines plus a gutter must fit in a line.
+	2.  If the half line width is nonzero:
+	    a.  The gutter width is at least GUTTER_WIDTH_MINIMUM.
+	    b.  If tabs are not expanded to spaces,
+		a half line plus a gutter is an integral number of tabs,
+		so that tabs in the right column line up.  */
+
+    intmax_t t = expand_tabs ? 1 : tabsize;
+    intmax_t w = width;
+    intmax_t off = (w + t + GUTTER_WIDTH_MINIMUM) / (2 * t)  *  t;
+    sdiff_half_width = MAX (0, MIN (off - GUTTER_WIDTH_MINIMUM, w - off)),
+    sdiff_column2_offset = sdiff_half_width ? off : w;
+  }
+
+  /* Make the horizon at least as large as the context, so that
+     shift_boundaries has more freedom to shift the first and last hunks.  */
+  if (horizon_lines < context)
+    horizon_lines = context;
+
+  summarize_regexp_list (&function_regexp_list);
+  summarize_regexp_list (&ignore_regexp_list);
+
+  if (output_style == OUTPUT_IFDEF)
+    {
+      for (i = 0; i < sizeof line_format / sizeof line_format[0]; i++)
+	if (!line_format[i])
+	  line_format[i] = "%l\n";
+      if (!group_format[OLD])
+	group_format[OLD]
+	  = group_format[CHANGED] ? group_format[CHANGED] : "%<";
+      if (!group_format[NEW])
+	group_format[NEW]
+	  = group_format[CHANGED] ? group_format[CHANGED] : "%>";
+      if (!group_format[UNCHANGED])
+	group_format[UNCHANGED] = "%=";
+      if (!group_format[CHANGED])
+	group_format[CHANGED] = concat (group_format[OLD],
+					group_format[NEW], "");
+    }
+
+  no_diff_means_no_output =
+    (output_style == OUTPUT_IFDEF ?
+      (!*group_format[UNCHANGED]
+       || (STREQ (group_format[UNCHANGED], "%=")
+	   && !*line_format[UNCHANGED]))
+     : (output_style != OUTPUT_SDIFF) | suppress_common_lines);
+
+  files_can_be_treated_as_binary =
+    (brief & binary
+     & ~ (ignore_blank_lines | ignore_case | strip_trailing_cr
+	  | (ignore_regexp_list.regexps || ignore_white_space)));
+
+  switch_string = option_list (argv + 1, optind - 1);
+
+  if (from_file)
+    {
+      if (to_file)
+	fatal ("--from-file and --to-file both specified");
+      else
+	for (; optind < argc; optind++)
+	  {
+	    int status = compare_files (NULL, from_file, argv[optind]);
+	    if (exit_status < status)
+	      exit_status = status;
+	  }
+    }
+  else
+    {
+      if (to_file)
+	for (; optind < argc; optind++)
+	  {
+	    int status = compare_files (NULL, argv[optind], to_file);
+	    if (exit_status < status)
+	      exit_status = status;
+	  }
+      else
+	{
+	  if (argc - optind != 2)
+	    {
+	      if (argc - optind < 2)
+		try_help ("missing operand after '%s'", argv[argc - 1]);
+	      else
+		try_help ("extra operand '%s'", argv[optind + 2]);
+	    }
+
+	  exit_status = compare_files (NULL, argv[optind], argv[optind + 1]);
+	}
+    }
+
+  /* Print any messages that were saved up for last.  */
+  print_message_queue ();
+
+  check_stdout ();
+  exit (exit_status);
+  return exit_status;
+}
+
+/* Append to REGLIST the regexp PATTERN.  */
+
+static void
+add_regexp (struct regexp_list *reglist, char const *pattern)
+{
+  size_t patlen = strlen (pattern);
+  char const *m = re_compile_pattern (pattern, patlen, reglist->buf);
+
+  if (m != 0)
+    error (0, 0, "%s: %s", pattern, m);
+  else
+    {
+      char *regexps = reglist->regexps;
+      size_t len = reglist->len;
+      bool multiple_regexps = reglist->multiple_regexps = regexps != 0;
+      size_t newlen = reglist->len = len + 2 * multiple_regexps + patlen;
+      size_t size = reglist->size;
+
+      if (size <= newlen)
+	{
+	  if (!size)
+	    size = 1;
+
+	  do size *= 2;
+	  while (size <= newlen);
+
+	  reglist->size = size;
+	  reglist->regexps = regexps = xrealloc (regexps, size);
+	}
+      if (multiple_regexps)
+	{
+	  regexps[len++] = '\\';
+	  regexps[len++] = '|';
+	}
+      memcpy (regexps + len, pattern, patlen + 1);
+    }
+}
+
+/* Ensure that REGLIST represents the disjunction of its regexps.
+   This is done here, rather than earlier, to avoid O(N^2) behavior.  */
+
+static void
+summarize_regexp_list (struct regexp_list *reglist)
+{
+  if (reglist->regexps)
+    {
+      /* At least one regexp was specified.  Allocate a fastmap for it.  */
+      reglist->buf->fastmap = xmalloc (1 << CHAR_BIT);
+      if (reglist->multiple_regexps)
+	{
+	  /* Compile the disjunction of the regexps.
+	     (If just one regexp was specified, it is already compiled.)  */
+	  char const *m = re_compile_pattern (reglist->regexps, reglist->len,
+					      reglist->buf);
+	  if (m)
+	    error (EXIT_TROUBLE, 0, "%s: %s", reglist->regexps, m);
+	}
+    }
+}
+
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+	 program_name);
+  abort ();
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    pfatal_with_name (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("Compare files line by line."),
+  "",
+  N_("-i  --ignore-case  Ignore case differences in file contents."),
+  N_("--ignore-file-name-case  Ignore case when comparing file names."),
+  N_("--no-ignore-file-name-case  Consider case when comparing file names."),
+  N_("-E  --ignore-tab-expansion  Ignore changes due to tab expansion."),
+  N_("-b  --ignore-space-change  Ignore changes in the amount of white space."),
+  N_("-w  --ignore-all-space  Ignore all white space."),
+  N_("-B  --ignore-blank-lines  Ignore changes whose lines are all blank."),
+  N_("-I RE  --ignore-matching-lines=RE  Ignore changes whose lines all match RE."),
+  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+#if O_BINARY
+  N_("--binary  Read and write data in binary mode."),
+#endif
+  N_("-a  --text  Treat all files as text."),
+  "",
+  N_("-c  -C NUM  --context[=NUM]  Output NUM (default 3) lines of copied context.\n\
+-u  -U NUM  --unified[=NUM]  Output NUM (default 3) lines of unified context.\n\
+  --label LABEL  Use LABEL instead of file name.\n\
+  -p  --show-c-function  Show which C function each change is in.\n\
+  -F RE  --show-function-line=RE  Show the most recent line matching RE."),
+  N_("-q  --brief  Output only whether files differ."),
+  N_("-e  --ed  Output an ed script."),
+  N_("--normal  Output a normal diff."),
+  N_("-n  --rcs  Output an RCS format diff."),
+  N_("-y  --side-by-side  Output in two columns.\n\
+  -W NUM  --width=NUM  Output at most NUM (default 130) print columns.\n\
+  --left-column  Output only the left column of common lines.\n\
+  --suppress-common-lines  Do not output common lines."),
+  N_("-D NAME  --ifdef=NAME  Output merged file to show '#ifdef NAME' diffs."),
+  N_("--GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT."),
+  N_("--line-format=LFMT  Similar, but format all input lines with LFMT."),
+  N_("--LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT."),
+  N_("  LTYPE is 'old', 'new', or 'unchanged'.  GTYPE is LTYPE or 'changed'."),
+  N_("  GFMT may contain:\n\
+    %<  lines from FILE1\n\
+    %>  lines from FILE2\n\
+    %=  lines common to FILE1 and FILE2\n\
+    %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-style spec for LETTER\n\
+      LETTERs are as follows for new group, lower case for old group:\n\
+        F  first line number\n\
+        L  last line number\n\
+        N  number of lines = L-F+1\n\
+        E  F-1\n\
+        M  L+1"),
+  N_("  LFMT may contain:\n\
+    %L  contents of line\n\
+    %l  contents of line, excluding any trailing newline\n\
+    %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for input line number"),
+  N_("  Either GFMT or LFMT may contain:\n\
+    %%  %\n\
+    %c'C'  the single character C\n\
+    %c'\\OOO'  the character with octal code OOO"),
+  "",
+  N_("-l  --paginate  Pass the output through 'pr' to paginate it."),
+  N_("-t  --expand-tabs  Expand tabs to spaces in output."),
+  N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+  N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
+  N_("--suppress-blank-empty  Suppress space or tab before empty output lines."),
+  "",
+  N_("-r  --recursive  Recursively compare any subdirectories found."),
+  N_("-N  --new-file  Treat absent files as empty."),
+  N_("--unidirectional-new-file  Treat absent first files as empty."),
+  N_("-s  --report-identical-files  Report when two files are the same."),
+  N_("-x PAT  --exclude=PAT  Exclude files that match PAT."),
+  N_("-X FILE  --exclude-from=FILE  Exclude files that match any pattern in FILE."),
+  N_("-S FILE  --starting-file=FILE  Start with FILE when comparing directories."),
+  N_("--from-file=FILE1  Compare FILE1 to all operands.  FILE1 can be a directory."),
+  N_("--to-file=FILE2  Compare all operands to FILE2.  FILE2 can be a directory."),
+  "",
+  N_("--horizon-lines=NUM  Keep NUM lines of the common prefix and suffix."),
+  N_("-d  --minimal  Try hard to find a smaller set of changes."),
+  N_("--speed-large-files  Assume large files and many scattered small changes."),
+  "",
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  "",
+  N_("FILES are 'FILE1 FILE2' or 'DIR1 DIR2' or 'DIR FILE...' or 'FILE... DIR'."),
+  N_("If --from-file or --to-file is given, there are no restrictions on FILES."),
+  N_("If a FILE is '-', read standard input."),
+  N_("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILES\n"), program_name);
+
+  for (p = option_help_msgid;  *p;  p++)
+    {
+      if (!**p)
+	putchar ('\n');
+      else
+	{
+	  char const *msg = _(*p);
+	  char const *nl;
+	  while ((nl = strchr (msg, '\n')))
+	    {
+	      int msglen = nl + 1 - msg;
+	      printf ("  %.*s", msglen, msg);
+	      msg = nl + 1;
+	    }
+
+	  printf ("  %s\n" + 2 * (*msg != ' ' && *msg != '-'), msg);
+	}
+    }
+  emit_bug_reporting_address ();
+}
+
+/* Set VAR to VALUE, reporting an OPTION error if this is a
+   conflict.  */
+static void
+specify_value (char const **var, char const *value, char const *option)
+{
+  if (*var && strcmp (*var, value) != 0)
+    {
+      error (0, 0, _("conflicting %s option value '%s'"), option, value);
+      try_help (NULL, NULL);
+    }
+  *var = value;
+}
+
+/* Set the output style to STYLE, diagnosing conflicts.  */
+static void
+specify_style (enum output_style style)
+{
+  if (output_style != style)
+    {
+      if (output_style != OUTPUT_UNSPECIFIED)
+	try_help ("conflicting output style options", NULL);
+      output_style = style;
+    }
+}
+
+/* Set the last-modified time of *ST to be the current time.  */
+
+static void
+set_mtime_to_now (struct stat *st)
+{
+#ifdef STAT_TIMESPEC
+  gettime (&STAT_TIMESPEC (st, st_mtim));
+#else
+  struct timespec t;
+  gettime (&t);
+  st->st_mtime = t.tv_sec;
+# if defined STAT_TIMESPEC_NS
+  STAT_TIMESPEC_NS (st, st_mtim) = t.tv_nsec;
+# elif defined HAVE_STRUCT_STAT_ST_SPARE1
+  st->st_spare1 = t.tv_nsec / 1000;
+# endif
+#endif
+}
+
+/* Compare two files (or dirs) with parent comparison PARENT
+   and names NAME0 and NAME1.
+   (If PARENT is null, then the first name is just NAME0, etc.)
+   This is self-contained; it opens the files and closes them.
+
+   Value is EXIT_SUCCESS if files are the same, EXIT_FAILURE if
+   different, EXIT_TROUBLE if there is a problem opening them.  */
+
+static int
+compare_files (struct comparison const *parent,
+	       char const *name0,
+	       char const *name1)
+{
+  struct comparison cmp;
+#define DIR_P(f) (S_ISDIR (cmp.file[f].stat.st_mode) != 0)
+  register int f;
+  int status = EXIT_SUCCESS;
+  bool same_files;
+  char *free0;
+  char *free1;
+
+  /* If this is directory comparison, perhaps we have a file
+     that exists only in one of the directories.
+     If so, just print a message to that effect.  */
+
+  if (! ((name0 && name1)
+	 || (unidirectional_new_file && name1)
+	 || new_file))
+    {
+      char const *name = name0 ? name0 : name1;
+      char const *dir = parent->file[!name0].name;
+
+      /* See POSIX 1003.1-2001 for this format.  */
+      message ("Only in %s: %s\n", dir, name);
+
+      /* Return EXIT_FAILURE so that diff_dirs will return
+	 EXIT_FAILURE ("some files differ").  */
+      return EXIT_FAILURE;
+    }
+
+  memset (cmp.file, 0, sizeof cmp.file);
+  cmp.parent = parent;
+
+  /* cmp.file[f].desc markers */
+#define NONEXISTENT (-1) /* nonexistent file */
+#define UNOPENED (-2) /* unopened file (e.g. directory) */
+#define ERRNO_ENCODE(errno) (-3 - (errno)) /* encoded errno value */
+
+#define ERRNO_DECODE(desc) (-3 - (desc)) /* inverse of ERRNO_ENCODE */
+
+  cmp.file[0].desc = name0 ? UNOPENED : NONEXISTENT;
+  cmp.file[1].desc = name1 ? UNOPENED : NONEXISTENT;
+
+  /* Now record the full name of each file, including nonexistent ones.  */
+
+  if (!name0)
+    name0 = name1;
+  if (!name1)
+    name1 = name0;
+
+  if (!parent)
+    {
+      free0 = NULL;
+      free1 = NULL;
+      cmp.file[0].name = name0;
+      cmp.file[1].name = name1;
+    }
+  else
+    {
+      cmp.file[0].name = free0
+	= dir_file_pathname (parent->file[0].name, name0);
+      cmp.file[1].name = free1
+	= dir_file_pathname (parent->file[1].name, name1);
+    }
+
+  /* Stat the files.  */
+
+  for (f = 0; f < 2; f++)
+    {
+      if (cmp.file[f].desc != NONEXISTENT)
+	{
+	  if (f && file_name_cmp (cmp.file[f].name, cmp.file[0].name) == 0)
+	    {
+	      cmp.file[f].desc = cmp.file[0].desc;
+	      cmp.file[f].stat = cmp.file[0].stat;
+	    }
+	  else if (STREQ (cmp.file[f].name, "-"))
+	    {
+	      cmp.file[f].desc = STDIN_FILENO;
+	      if (O_BINARY && binary && ! isatty (STDIN_FILENO))
+		xfreopen (NULL, "rb", stdin);
+	      if (fstat (STDIN_FILENO, &cmp.file[f].stat) != 0)
+		cmp.file[f].desc = ERRNO_ENCODE (errno);
+	      else
+		{
+		  if (S_ISREG (cmp.file[f].stat.st_mode))
+		    {
+		      off_t pos = lseek (STDIN_FILENO, 0, SEEK_CUR);
+		      if (pos < 0)
+			cmp.file[f].desc = ERRNO_ENCODE (errno);
+		      else
+			cmp.file[f].stat.st_size =
+			  MAX (0, cmp.file[f].stat.st_size - pos);
+		    }
+
+		  /* POSIX 1003.1-2001 requires current time for
+		     stdin.  */
+		  set_mtime_to_now (&cmp.file[f].stat);
+		}
+	    }
+	  else if (stat (cmp.file[f].name, &cmp.file[f].stat) != 0)
+	    cmp.file[f].desc = ERRNO_ENCODE (errno);
+	}
+    }
+
+  /* Mark files as nonexistent as needed for -N and -P, if they are
+     inaccessible empty regular files (the kind of files that 'patch'
+     creates to indicate nonexistent backups), or if they are
+     top-level files that do not exist but their counterparts do
+     exist.  */
+  for (f = 0; f < 2; f++)
+    if ((new_file || (f == 0 && unidirectional_new_file))
+	&& (cmp.file[f].desc == UNOPENED
+	    ? (S_ISREG (cmp.file[f].stat.st_mode)
+	       && ! (cmp.file[f].stat.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO))
+	       && cmp.file[f].stat.st_size == 0)
+	    : (cmp.file[f].desc == ERRNO_ENCODE (ENOENT)
+	       && ! parent
+	       && cmp.file[1 - f].desc == UNOPENED)))
+      cmp.file[f].desc = NONEXISTENT;
+
+  for (f = 0; f < 2; f++)
+    if (cmp.file[f].desc == NONEXISTENT)
+      {
+	memset (&cmp.file[f].stat, 0, sizeof cmp.file[f].stat);
+	cmp.file[f].stat.st_mode = cmp.file[1 - f].stat.st_mode;
+      }
+
+  for (f = 0; f < 2; f++)
+    {
+      int e = ERRNO_DECODE (cmp.file[f].desc);
+      if (0 <= e)
+	{
+	  errno = e;
+	  perror_with_name (cmp.file[f].name);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  if (status == EXIT_SUCCESS && ! parent && DIR_P (0) != DIR_P (1))
+    {
+      /* If one is a directory, and it was specified in the command line,
+	 use the file in that dir with the other file's basename.  */
+
+      int fnm_arg = DIR_P (0);
+      int dir_arg = 1 - fnm_arg;
+      char const *fnm = cmp.file[fnm_arg].name;
+      char const *dir = cmp.file[dir_arg].name;
+      char const *filename = cmp.file[dir_arg].name = free0
+	= dir_file_pathname (dir, last_component (fnm));
+
+      if (STREQ (fnm, "-"))
+	fatal ("cannot compare '-' to a directory");
+
+      if (stat (filename, &cmp.file[dir_arg].stat) != 0)
+	{
+	  perror_with_name (filename);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  if (status != EXIT_SUCCESS)
+    {
+      /* One of the files should exist but does not.  */
+    }
+  else if (cmp.file[0].desc == NONEXISTENT
+	   && cmp.file[1].desc == NONEXISTENT)
+    {
+      /* Neither file "exists", so there's nothing to compare.  */
+    }
+  else if ((same_files
+	    = (cmp.file[0].desc != NONEXISTENT
+	       && cmp.file[1].desc != NONEXISTENT
+	       && 0 < same_file (&cmp.file[0].stat, &cmp.file[1].stat)
+	       && same_file_attributes (&cmp.file[0].stat,
+					&cmp.file[1].stat)))
+	   && no_diff_means_no_output)
+    {
+      /* The two named files are actually the same physical file.
+	 We know they are identical without actually reading them.  */
+    }
+  else if (DIR_P (0) & DIR_P (1))
+    {
+      if (output_style == OUTPUT_IFDEF)
+	fatal ("-D option not supported with directories");
+
+      /* If both are directories, compare the files in them.  */
+
+      if (parent && !recursive)
+	{
+	  /* But don't compare dir contents one level down
+	     unless -r was specified.
+	     See POSIX 1003.1-2001 for this format.  */
+	  message ("Common subdirectories: %s and %s\n",
+		   cmp.file[0].name, cmp.file[1].name);
+	}
+      else
+	status = diff_dirs (&cmp, compare_files);
+    }
+  else if ((DIR_P (0) | DIR_P (1))
+	   || (parent
+	       && (! S_ISREG (cmp.file[0].stat.st_mode)
+		   || ! S_ISREG (cmp.file[1].stat.st_mode))))
+    {
+      if (cmp.file[0].desc == NONEXISTENT || cmp.file[1].desc == NONEXISTENT)
+	{
+	  /* We have a subdirectory that exists only in one directory.  */
+
+	  if ((DIR_P (0) | DIR_P (1))
+	      && recursive
+	      && (new_file
+		  || (unidirectional_new_file
+		      && cmp.file[0].desc == NONEXISTENT)))
+	    status = diff_dirs (&cmp, compare_files);
+	  else
+	    {
+	      char const *dir;
+
+	      /* PARENT must be non-NULL here.  */
+	      assert (parent);
+	      dir = parent->file[cmp.file[0].desc == NONEXISTENT].name;
+
+	      /* See POSIX 1003.1-2001 for this format.  */
+	      message ("Only in %s: %s\n", dir, name0);
+
+	      status = EXIT_FAILURE;
+	    }
+	}
+      else
+	{
+	  /* We have two files that are not to be compared.  */
+
+	  /* See POSIX 1003.1-2001 for this format.  */
+	  message5 ("File %s is a %s while file %s is a %s\n",
+		    file_label[0] ? file_label[0] : cmp.file[0].name,
+		    file_type (&cmp.file[0].stat),
+		    file_label[1] ? file_label[1] : cmp.file[1].name,
+		    file_type (&cmp.file[1].stat));
+
+	  /* This is a difference.  */
+	  status = EXIT_FAILURE;
+	}
+    }
+  else if (files_can_be_treated_as_binary
+	   && S_ISREG (cmp.file[0].stat.st_mode)
+	   && S_ISREG (cmp.file[1].stat.st_mode)
+	   && cmp.file[0].stat.st_size != cmp.file[1].stat.st_size)
+    {
+      message ("Files %s and %s differ\n",
+	       file_label[0] ? file_label[0] : cmp.file[0].name,
+	       file_label[1] ? file_label[1] : cmp.file[1].name);
+      status = EXIT_FAILURE;
+    }
+  else
+    {
+      /* Both exist and neither is a directory.  */
+
+      /* Open the files and record their descriptors.  */
+
+      int oflags = O_RDONLY | (binary ? O_BINARY : 0);
+
+      if (cmp.file[0].desc == UNOPENED)
+	if ((cmp.file[0].desc = open (cmp.file[0].name, oflags, 0)) < 0)
+	  {
+	    perror_with_name (cmp.file[0].name);
+	    status = EXIT_TROUBLE;
+	  }
+      if (cmp.file[1].desc == UNOPENED)
+	{
+	  if (same_files)
+	    cmp.file[1].desc = cmp.file[0].desc;
+	  else if ((cmp.file[1].desc = open (cmp.file[1].name, oflags, 0)) < 0)
+	    {
+	      perror_with_name (cmp.file[1].name);
+	      status = EXIT_TROUBLE;
+	    }
+	}
+
+      /* Compare the files, if no error was found.  */
+
+      if (status == EXIT_SUCCESS)
+	status = diff_2_files (&cmp);
+
+      /* Close the file descriptors.  */
+
+      if (0 <= cmp.file[0].desc && close (cmp.file[0].desc) != 0)
+	{
+	  perror_with_name (cmp.file[0].name);
+	  status = EXIT_TROUBLE;
+	}
+      if (0 <= cmp.file[1].desc && cmp.file[0].desc != cmp.file[1].desc
+	  && close (cmp.file[1].desc) != 0)
+	{
+	  perror_with_name (cmp.file[1].name);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  /* Now the comparison has been done, if no error prevented it,
+     and STATUS is the value this function will return.  */
+
+  if (status == EXIT_SUCCESS)
+    {
+      if (report_identical_files && !DIR_P (0))
+	message ("Files %s and %s are identical\n",
+		 file_label[0] ? file_label[0] : cmp.file[0].name,
+		 file_label[1] ? file_label[1] : cmp.file[1].name);
+    }
+  else
+    {
+      /* Flush stdout so that the user sees differences immediately.
+	 This can hurt performance, unfortunately.  */
+      if (fflush (stdout) != 0)
+	pfatal_with_name (_("standard output"));
+    }
+
+  free (free0);
+  free (free1);
+
+  return status;
+}
diff --git a/test/diffutils-3.0-patch/diff.h b/test/diffutils-3.0-patch/diff.h
new file mode 100644
index 0000000..71b33f4
--- /dev/null
+++ b/test/diffutils-3.0-patch/diff.h
@@ -0,0 +1,373 @@
+/* Shared definitions for GNU DIFF
+
+   Copyright (C) 1988-1989, 1991-1995, 1998, 2001-2002, 2004, 2009-2010 Free
+   Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include <regex.h>
+#include <stdio.h>
+#include <unlocked-io.h>
+
+/* What kind of changes a hunk contains.  */
+enum changes
+{
+  /* No changes: lines common to both files.  */
+  UNCHANGED,
+
+  /* Deletes only: lines taken from just the first file.  */
+  OLD,
+
+  /* Inserts only: lines taken from just the second file.  */
+  NEW,
+
+  /* Both deletes and inserts: a hunk containing both old and new lines.  */
+  CHANGED
+};
+
+/* Variables for command line options */
+
+#ifndef GDIFF_MAIN
+# define XTERN extern
+#else
+# define XTERN
+#endif
+
+enum output_style
+{
+  /* No output style specified.  */
+  OUTPUT_UNSPECIFIED,
+
+  /* Default output style.  */
+  OUTPUT_NORMAL,
+
+  /* Output the differences with lines of context before and after (-c).  */
+  OUTPUT_CONTEXT,
+
+  /* Output the differences in a unified context diff format (-u).  */
+  OUTPUT_UNIFIED,
+
+  /* Output the differences as commands suitable for `ed' (-e).  */
+  OUTPUT_ED,
+
+  /* Output the diff as a forward ed script (-f).  */
+  OUTPUT_FORWARD_ED,
+
+  /* Like -f, but output a count of changed lines in each "command" (-n).  */
+  OUTPUT_RCS,
+
+  /* Output merged #ifdef'd file (-D).  */
+  OUTPUT_IFDEF,
+
+  /* Output sdiff style (-y).  */
+  OUTPUT_SDIFF
+};
+
+/* True for output styles that are robust,
+   i.e. can handle a file that ends in a non-newline.  */
+#define ROBUST_OUTPUT_STYLE(S) ((S) != OUTPUT_ED && (S) != OUTPUT_FORWARD_ED)
+
+XTERN enum output_style output_style;
+
+/* Nonzero if output cannot be generated for identical files.  */
+XTERN bool no_diff_means_no_output;
+
+/* Number of lines of context to show in each set of diffs.
+   This is zero when context is not to be shown.  */
+XTERN lin context;
+
+/* Consider all files as text files (-a).
+   Don't interpret codes over 0177 as implying a "binary file".  */
+XTERN bool text;
+
+/* Number of lines to keep in identical prefix and suffix.  */
+XTERN lin horizon_lines;
+
+/* The significance of white space during comparisons.  */
+XTERN enum
+{
+  /* All white space is significant (the default).  */
+  IGNORE_NO_WHITE_SPACE,
+
+  /* Ignore changes due to tab expansion (-E).  */
+  IGNORE_TAB_EXPANSION,
+
+  /* Ignore changes in horizontal white space (-b).  */
+  IGNORE_SPACE_CHANGE,
+
+  /* Ignore all horizontal white space (-w).  */
+  IGNORE_ALL_SPACE
+} ignore_white_space;
+
+/* Ignore changes that affect only blank lines (-B).  */
+XTERN bool ignore_blank_lines;
+
+/* Files can be compared byte-by-byte, as if they were binary.
+   This depends on various options.  */
+XTERN bool files_can_be_treated_as_binary;
+
+/* Ignore differences in case of letters (-i).  */
+XTERN bool ignore_case;
+
+/* Ignore differences in case of letters in file names.  */
+XTERN bool ignore_file_name_case;
+
+/* File labels for `-c' output headers (--label).  */
+XTERN char *file_label[2];
+
+/* Regexp to identify function-header lines (-F).  */
+XTERN struct re_pattern_buffer function_regexp;
+
+/* Ignore changes that affect only lines matching this regexp (-I).  */
+XTERN struct re_pattern_buffer ignore_regexp;
+
+/* Say only whether files differ, not how (-q).  */
+XTERN bool brief;
+
+/* Expand tabs in the output so the text lines up properly
+   despite the characters added to the front of each line (-t).  */
+XTERN bool expand_tabs;
+
+/* Number of columns between tab stops.  */
+XTERN size_t tabsize;
+
+/* Use a tab in the output, rather than a space, before the text of an
+   input line, so as to keep the proper alignment in the input line
+   without changing the characters in it (-T).  */
+XTERN bool initial_tab;
+
+/* Do not output an initial space or tab before the text of an empty line.  */
+XTERN bool suppress_blank_empty;
+
+/* Remove trailing carriage returns from input.  */
+XTERN bool strip_trailing_cr;
+
+/* In directory comparison, specify file to start with (-S).
+   This is used for resuming an aborted comparison.
+   All file names less than this name are ignored.  */
+XTERN char const *starting_file;
+
+/* Pipe each file's output through pr (-l).  */
+XTERN bool paginate;
+
+/* Line group formats for unchanged, old, new, and changed groups.  */
+XTERN char const *group_format[CHANGED + 1];
+
+/* Line formats for unchanged, old, and new lines.  */
+XTERN char const *line_format[NEW + 1];
+
+/* If using OUTPUT_SDIFF print extra information to help the sdiff filter.  */
+XTERN bool sdiff_merge_assist;
+
+/* Tell OUTPUT_SDIFF to show only the left version of common lines.  */
+XTERN bool left_column;
+
+/* Tell OUTPUT_SDIFF to not show common lines.  */
+XTERN bool suppress_common_lines;
+
+/* The half line width and column 2 offset for OUTPUT_SDIFF.  */
+XTERN size_t sdiff_half_width;
+XTERN size_t sdiff_column2_offset;
+
+/* String containing all the command options diff received,
+   with spaces between and at the beginning but none at the end.
+   If there were no options given, this string is empty.  */
+XTERN char *switch_string;
+
+/* Use heuristics for better speed with large files with a small
+   density of changes.  */
+XTERN bool speed_large_files;
+
+/* Patterns that match file names to be excluded.  */
+XTERN struct exclude *excluded;
+
+/* Don't discard lines.  This makes things slower (sometimes much
+   slower) but will find a guaranteed minimal set of changes.  */
+XTERN bool minimal;
+
+/* The strftime format to use for time strings.  */
+XTERN char const *time_format;
+
+/* The result of comparison is an "edit script": a chain of `struct change'.
+   Each `struct change' represents one place where some lines are deleted
+   and some are inserted.
+
+   LINE0 and LINE1 are the first affected lines in the two files (origin 0).
+   DELETED is the number of lines deleted here from file 0.
+   INSERTED is the number of lines inserted here in file 1.
+
+   If DELETED is 0 then LINE0 is the number of the line before
+   which the insertion was done; vice versa for INSERTED and LINE1.  */
+
+struct change
+{
+  struct change *link;		/* Previous or next edit command  */
+  lin inserted;			/* # lines of file 1 changed here.  */
+  lin deleted;			/* # lines of file 0 changed here.  */
+  lin line0;			/* Line number of 1st deleted line.  */
+  lin line1;			/* Line number of 1st inserted line.  */
+  bool ignore;			/* Flag used in context.c.  */
+};
+
+/* Structures that describe the input files.  */
+
+/* Data on one input file being compared.  */
+
+struct file_data {
+    int             desc;	/* File descriptor  */
+    char const      *name;	/* File name  */
+    struct stat     stat;	/* File status */
+
+    /* Buffer in which text of file is read.  */
+    word *buffer;
+
+    /* Allocated size of buffer, in bytes.  Always a multiple of
+       sizeof *buffer.  */
+    size_t bufsize;
+
+    /* Number of valid bytes now in the buffer.  */
+    size_t buffered;
+
+    /* Array of pointers to lines in the file.  */
+    char const **linbuf;
+
+    /* linbuf_base <= buffered_lines <= valid_lines <= alloc_lines.
+       linebuf[linbuf_base ... buffered_lines - 1] are possibly differing.
+       linebuf[linbuf_base ... valid_lines - 1] contain valid data.
+       linebuf[linbuf_base ... alloc_lines - 1] are allocated.  */
+    lin linbuf_base, buffered_lines, valid_lines, alloc_lines;
+
+    /* Pointer to end of prefix of this file to ignore when hashing.  */
+    char const *prefix_end;
+
+    /* Count of lines in the prefix.
+       There are this many lines in the file before linbuf[0].  */
+    lin prefix_lines;
+
+    /* Pointer to start of suffix of this file to ignore when hashing.  */
+    char const *suffix_begin;
+
+    /* Vector, indexed by line number, containing an equivalence code for
+       each line.  It is this vector that is actually compared with that
+       of another file to generate differences.  */
+    lin *equivs;
+
+    /* Vector, like the previous one except that
+       the elements for discarded lines have been squeezed out.  */
+    lin *undiscarded;
+
+    /* Vector mapping virtual line numbers (not counting discarded lines)
+       to real ones (counting those lines).  Both are origin-0.  */
+    lin *realindexes;
+
+    /* Total number of nondiscarded lines.  */
+    lin nondiscarded_lines;
+
+    /* Vector, indexed by real origin-0 line number,
+       containing 1 for a line that is an insertion or a deletion.
+       The results of comparison are stored here.  */
+    char *changed;
+
+    /* 1 if file ends in a line with no final newline.  */
+    bool missing_newline;
+
+    /* 1 if at end of file.  */
+    bool eof;
+
+    /* 1 more than the maximum equivalence value used for this or its
+       sibling file.  */
+    lin equiv_max;
+};
+
+/* The file buffer, considered as an array of bytes rather than
+   as an array of words.  */
+#define FILE_BUFFER(f) ((char *) (f)->buffer)
+
+/* Data on two input files being compared.  */
+
+struct comparison
+  {
+    struct file_data file[2];
+    struct comparison const *parent;  /* parent, if a recursive comparison */
+  };
+
+/* Describe the two files currently being compared.  */
+
+XTERN struct file_data files[2];
+
+/* Stdio stream to output diffs to.  */
+
+XTERN FILE *outfile;
+
+/* Declare various functions.  */
+
+/* analyze.c */
+int diff_2_files (struct comparison *);
+
+/* context.c */
+void print_context_header (struct file_data[], bool);
+void print_context_script (struct change *, bool);
+
+/* dir.c */
+int diff_dirs (struct comparison const *, int (*) (struct comparison const *, char const *, char const *));
+
+/* ed.c */
+void print_ed_script (struct change *);
+void pr_forward_ed_script (struct change *);
+
+/* ifdef.c */
+void print_ifdef_script (struct change *);
+
+/* io.c */
+void file_block_read (struct file_data *, size_t);
+bool read_files (struct file_data[], bool);
+
+/* normal.c */
+void print_normal_script (struct change *);
+
+/* rcs.c */
+void print_rcs_script (struct change *);
+
+/* side.c */
+void print_sdiff_script (struct change *);
+
+/* util.c */
+extern char const change_letter[4];
+extern char const pr_program[];
+char *concat (char const *, char const *, char const *);
+char *dir_file_pathname (char const *, char const *);
+bool lines_differ (char const *, char const *);
+lin translate_line_number (struct file_data const *, lin);
+struct change *find_change (struct change *);
+struct change *find_reverse_change (struct change *);
+void *zalloc (size_t);
+enum changes analyze_hunk (struct change *, lin *, lin *, lin *, lin *);
+void begin_output (void);
+void debug_script (struct change *);
+void fatal (char const *) __attribute__((noreturn));
+void finish_output (void);
+void message (char const *, char const *, char const *);
+void message5 (char const *, char const *, char const *, char const *, char const *);
+void output_1_line (char const *, char const *, char const *, char const *);
+void perror_with_name (char const *);
+void pfatal_with_name (char const *) __attribute__((noreturn));
+void print_1_line (char const *, char const * const *);
+void print_message_queue (void);
+void print_number_range (char, struct file_data *, lin, lin);
+void print_script (struct change *, struct change * (*) (struct change *), void (*) (struct change *));
+void setup_output (char const *, char const *, bool);
+void translate_range (struct file_data const *, lin, lin, long int *, long int *);
diff --git a/test/diffutils-3.0-patch/diff3 b/test/diffutils-3.0-patch/diff3
new file mode 100755
index 0000000000000000000000000000000000000000..598d54c8ccd17467f0214e0fa7f4394d78643544
GIT binary patch
literal 236056
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
Sx^?)SPqdW(BAQLa_<sRYj?IGr

literal 0
HcmV?d00001

diff --git a/test/diffutils-3.0-patch/diff3.c b/test/diffutils-3.0-patch/diff3.c
new file mode 100644
index 0000000..fbfb28b
--- /dev/null
+++ b/test/diffutils-3.0-patch/diff3.c
@@ -0,0 +1,1747 @@
+/* diff3 - compare three files line by line
+
+   Copyright (C) 1988-1989, 1992-1996, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+#include <unlocked-io.h>
+
+#include <c-stack.h>
+#include <cmpbuf.h>
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <inttostr.h>
+#include <progname.h>
+#include <sh-quote.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <xfreopen.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "diff3"
+
+#define AUTHORS \
+  proper_name ("Randy Smith")
+
+/* Internal data structures and macros for the diff3 program; includes
+   data structures for both diff3 diffs and normal diffs.  */
+
+/* Different files within a three way diff.  */
+#define	FILE0	0
+#define	FILE1	1
+#define	FILE2	2
+
+/* A three way diff is built from two two-way diffs; the file which
+   the two two-way diffs share is:  */
+#define	FILEC	FILE2
+
+/* Different files within a two way diff.
+   FC is the common file, FO the other file.  */
+#define FO 0
+#define FC 1
+
+/* The ranges are indexed by */
+#define	RANGE_START	0
+#define	RANGE_END	1
+
+enum diff_type {
+  ERROR,			/* Should not be used */
+  ADD,				/* Two way diff add */
+  CHANGE,			/* Two way diff change */
+  DELETE,			/* Two way diff delete */
+  DIFF_ALL,			/* All three are different */
+  DIFF_1ST,			/* Only the first is different */
+  DIFF_2ND,			/* Only the second */
+  DIFF_3RD			/* Only the third */
+};
+
+/* Two way diff */
+struct diff_block {
+  lin ranges[2][2];		/* Ranges are inclusive */
+  char **lines[2];		/* The actual lines (may contain nulls) */
+  size_t *lengths[2];		/* Line lengths (including newlines, if any) */
+  struct diff_block *next;
+};
+
+/* Three way diff */
+
+struct diff3_block {
+  enum diff_type correspond;	/* Type of diff */
+  lin ranges[3][2];		/* Ranges are inclusive */
+  char **lines[3];		/* The actual lines (may contain nulls) */
+  size_t *lengths[3];		/* Line lengths (including newlines, if any) */
+  struct diff3_block *next;
+};
+
+/* Access the ranges on a diff block.  */
+#define	D_LOWLINE(diff, filenum)	\
+  ((diff)->ranges[filenum][RANGE_START])
+#define	D_HIGHLINE(diff, filenum)	\
+  ((diff)->ranges[filenum][RANGE_END])
+#define	D_NUMLINES(diff, filenum)	\
+  (D_HIGHLINE (diff, filenum) - D_LOWLINE (diff, filenum) + 1)
+
+/* Access the line numbers in a file in a diff by relative line
+   numbers (i.e. line number within the diff itself).  Note that these
+   are lvalues and can be used for assignment.  */
+#define	D_RELNUM(diff, filenum, linenum)	\
+  ((diff)->lines[filenum][linenum])
+#define	D_RELLEN(diff, filenum, linenum)	\
+  ((diff)->lengths[filenum][linenum])
+
+/* And get at them directly, when that should be necessary.  */
+#define	D_LINEARRAY(diff, filenum)	\
+  ((diff)->lines[filenum])
+#define	D_LENARRAY(diff, filenum)	\
+  ((diff)->lengths[filenum])
+
+/* Next block.  */
+#define	D_NEXT(diff)	((diff)->next)
+
+/* Access the type of a diff3 block.  */
+#define	D3_TYPE(diff)	((diff)->correspond)
+
+/* Line mappings based on diffs.  The first maps off the top of the
+   diff, the second off of the bottom.  */
+#define	D_HIGH_MAPLINE(diff, fromfile, tofile, linenum)	\
+  ((linenum)						\
+   - D_HIGHLINE ((diff), (fromfile))			\
+   + D_HIGHLINE ((diff), (tofile)))
+
+#define	D_LOW_MAPLINE(diff, fromfile, tofile, linenum)	\
+  ((linenum)						\
+   - D_LOWLINE ((diff), (fromfile))			\
+   + D_LOWLINE ((diff), (tofile)))
+
+/* Options variables for flags set on command line.  */
+
+/* If nonzero, treat all files as text files, never as binary.  */
+static bool text;
+
+/* Remove trailing carriage returns from input.  */
+static bool strip_trailing_cr;
+
+/* If nonzero, write out an ed script instead of the standard diff3 format.  */
+static bool edscript;
+
+/* If nonzero, in the case of overlapping diffs (type DIFF_ALL),
+   preserve the lines which would normally be deleted from
+   file 1 with a special flagging mechanism.  */
+static bool flagging;
+
+/* Use a tab to align output lines (-T).  */
+static bool initial_tab;
+
+/* If nonzero, do not output information for overlapping diffs.  */
+static bool simple_only;
+
+/* If nonzero, do not output information for non-overlapping diffs.  */
+static bool overlap_only;
+
+/* If nonzero, show information for DIFF_2ND diffs.  */
+static bool show_2nd;
+
+/* If nonzero, include `:wq' at the end of the script
+   to write out the file being edited.   */
+static bool finalwrite;
+
+/* If nonzero, output a merged file.  */
+static bool merge;
+
+static char *read_diff (char const *, char const *, char **);
+static char *scan_diff_line (char *, char **, size_t *, char *, char);
+static enum diff_type process_diff_control (char **, struct diff_block *);
+static bool compare_line_list (char * const[], size_t const[], char * const[], size_t const[], lin);
+static bool copy_stringlist (char * const[], size_t const[], char *[], size_t[], lin);
+static bool output_diff3_edscript (FILE *, struct diff3_block *, int const[3], int const[3], char const *, char const *, char const *);
+static bool output_diff3_merge (FILE *, FILE *, struct diff3_block *, int const[3], int const[3], char const *, char const *, char const *);
+static struct diff3_block *create_diff3_block (lin, lin, lin, lin, lin, lin);
+static struct diff3_block *make_3way_diff (struct diff_block *, struct diff_block *);
+static struct diff3_block *reverse_diff3_blocklist (struct diff3_block *);
+static struct diff3_block *using_to_diff3_block (struct diff_block *[2], struct diff_block *[2], int, int, struct diff3_block const *);
+static struct diff_block *process_diff (char const *, char const *, struct diff_block **);
+static void check_stdout (void);
+static void fatal (char const *) __attribute__((noreturn));
+static void output_diff3 (FILE *, struct diff3_block *, int const[3], int const[3]);
+static void perror_with_exit (char const *) __attribute__((noreturn));
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void usage (void);
+
+static char const *diff_program = DEFAULT_DIFF_PROGRAM;
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  DIFF_PROGRAM_OPTION = CHAR_MAX + 1,
+  HELP_OPTION,
+  STRIP_TRAILING_CR_OPTION
+};
+
+static struct option const longopts[] =
+{
+  {"diff-program", 1, 0, DIFF_PROGRAM_OPTION},
+  {"easy-only", 0, 0, '3'},
+  {"ed", 0, 0, 'e'},
+  {"help", 0, 0, HELP_OPTION},
+  {"initial-tab", 0, 0, 'T'},
+  {"label", 1, 0, 'L'},
+  {"merge", 0, 0, 'm'},
+  {"overlap-only", 0, 0, 'x'},
+  {"show-all", 0, 0, 'A'},
+  {"show-overlap", 0, 0, 'E'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"text", 0, 0, 'a'},
+  {"version", 0, 0, 'v'},
+  {0, 0, 0, 0}
+};
+
+int
+main (int argc, char **argv)
+{
+  int c, i;
+  int common;
+  int mapping[3];
+  int rev_mapping[3];
+  int incompat = 0;
+  bool conflicts_found;
+  struct diff_block *thread0, *thread1, *last_block;
+  struct diff3_block *diff3;
+  int tag_count = 0;
+  char *tag_strings[3];
+  char *commonname;
+  char **file;
+  struct stat statb;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+
+  while ((c = getopt_long (argc, argv, "aeimvx3AEL:TX", longopts, 0)) != -1)
+    {
+      switch (c)
+	{
+	case 'a':
+	  text = true;
+	  break;
+	case 'A':
+	  show_2nd = true;
+	  flagging = true;
+	  incompat++;
+	  break;
+	case 'x':
+	  overlap_only = true;
+	  incompat++;
+	  break;
+	case '3':
+	  simple_only = true;
+	  incompat++;
+	  break;
+	case 'i':
+	  finalwrite = true;
+	  break;
+	case 'm':
+	  merge = true;
+	  break;
+	case 'X':
+	  overlap_only = true;
+	  /* Fall through.  */
+	case 'E':
+	  flagging = true;
+	  /* Fall through.  */
+	case 'e':
+	  incompat++;
+	  break;
+	case 'T':
+	  initial_tab = true;
+	  break;
+	case STRIP_TRAILING_CR_OPTION:
+	  strip_trailing_cr = true;
+	  break;
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+	case DIFF_PROGRAM_OPTION:
+	  diff_program = optarg;
+	  break;
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+	case 'L':
+	  /* Handle up to three -L options.  */
+	  if (tag_count < 3)
+	    {
+	      tag_strings[tag_count++] = optarg;
+	      break;
+	    }
+	  try_help ("too many file label options", 0);
+	default:
+	  try_help (0, 0);
+	}
+    }
+
+  edscript = incompat & ~merge;  /* -AeExX3 without -m implies ed script.  */
+  show_2nd |= ~incompat & merge;  /* -m without -AeExX3 implies -A.  */
+  flagging |= ~incompat & merge;
+
+  if (incompat > 1  /* Ensure at most one of -AeExX3.  */
+      || finalwrite & merge /* -i -m would rewrite input file.  */
+      || (tag_count && ! flagging)) /* -L requires one of -AEX.  */
+    try_help ("incompatible options", 0);
+
+  if (argc - optind != 3)
+    {
+      if (argc - optind < 3)
+	try_help ("missing operand after '%s'", argv[argc - 1]);
+      else
+	try_help ("extra operand '%s'", argv[optind + 3]);
+    }
+
+  file = &argv[optind];
+
+  for (i = tag_count; i < 3; i++)
+    tag_strings[i] = file[i];
+
+  /* Always compare file1 to file2, even if file2 is "-".
+     This is needed for -mAeExX3.  Using the file0 as
+     the common file would produce wrong results, because if the
+     file0-file1 diffs didn't line up with the file0-file2 diffs
+     (which is entirely possible since we don't use diff's -n option),
+     diff3 might report phantom changes from file1 to file2.
+
+     Also, try to compare file0 to file1, because this is where
+     changes are expected to come from.  Diffing between these pairs
+     of files is more likely to avoid phantom changes from file0 to file1.
+
+     Historically, the default common file was file2, so some older
+     applications (e.g. Emacs ediff) used file2 as the ancestor.  So,
+     for compatibility, if this is a 3-way diff (not a merge or
+     edscript), prefer file2 as the common file.  */
+
+  common = 2 - (edscript | merge);
+
+  if (STREQ (file[common], "-"))
+    {
+      /* Sigh.  We've got standard input as the common file.  We can't
+	 call diff twice on stdin.  Use the other arg as the common
+	 file instead.  */
+      common = 3 - common;
+      if (STREQ (file[0], "-") || STREQ (file[common], "-"))
+	fatal ("'-' specified for more than one input file");
+    }
+
+  mapping[0] = 0;
+  mapping[1] = 3 - common;
+  mapping[2] = common;
+
+  for (i = 0; i < 3; i++)
+    rev_mapping[mapping[i]] = i;
+
+  for (i = 0; i < 3; i++)
+    if (strcmp (file[i], "-") != 0)
+      {
+	if (stat (file[i], &statb) < 0)
+	  perror_with_exit (file[i]);
+	else if (S_ISDIR (statb.st_mode))
+	  error (EXIT_TROUBLE, EISDIR, "%s", file[i]);
+      }
+
+#ifdef SIGCHLD
+  /* System V fork+wait does not work if SIGCHLD is ignored.  */
+  signal (SIGCHLD, SIG_DFL);
+#endif
+
+  /* Invoke diff twice on two pairs of input files, combine the two
+     diffs, and output them.  */
+
+  commonname = file[rev_mapping[FILEC]];
+  thread1 = process_diff (file[rev_mapping[FILE1]], commonname, &last_block);
+  thread0 = process_diff (file[rev_mapping[FILE0]], commonname, &last_block);
+  diff3 = make_3way_diff (thread0, thread1);
+  if (edscript)
+    conflicts_found
+      = output_diff3_edscript (stdout, diff3, mapping, rev_mapping,
+			       tag_strings[0], tag_strings[1], tag_strings[2]);
+  else if (merge)
+    {
+      xfreopen (file[rev_mapping[FILE0]], "r", stdin);
+      conflicts_found
+	= output_diff3_merge (stdin, stdout, diff3, mapping, rev_mapping,
+			      tag_strings[0], tag_strings[1], tag_strings[2]);
+      if (ferror (stdin))
+	fatal ("read failed");
+    }
+  else
+    {
+      output_diff3 (stdout, diff3, mapping, rev_mapping);
+      conflicts_found = false;
+    }
+
+  check_stdout ();
+  exit (conflicts_found);
+  return conflicts_found;
+}
+
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0,
+	 _("Try '%s --help' for more information."), program_name);
+  abort ();
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    perror_with_exit (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-e  --ed  Output unmerged changes from OLDFILE to YOURFILE into MYFILE."),
+  N_("-E  --show-overlap  Output unmerged changes, bracketing conflicts."),
+  N_("-A  --show-all  Output all changes, bracketing conflicts."),
+  N_("-x  --overlap-only  Output overlapping changes."),
+  N_("-X  Output overlapping changes, bracketing them."),
+  N_("-3  --easy-only  Output unmerged nonoverlapping changes."),
+  "",
+  N_("-m  --merge  Output merged file instead of ed script (default -A)."),
+  N_("-L LABEL  --label=LABEL  Use LABEL instead of file name."),
+  N_("-i  Append 'w' and 'q' commands to ed scripts."),
+  N_("-a  --text  Treat all files as text."),
+  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+  N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
+  N_("--diff-program=PROGRAM  Use PROGRAM to compare files."),
+  "",
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... MYFILE OLDFILE YOURFILE\n"),
+	  program_name);
+  printf ("%s\n\n", _("Compare three files line by line."));
+  for (p = option_help_msgid;  *p;  p++)
+    if (**p)
+      printf ("  %s\n", _(*p));
+    else
+      putchar ('\n');
+  printf ("\n%s\n%s\n",
+	  _("If a FILE is '-', read standard input."),
+	  _("Exit status is 0 if successful, 1 if conflicts, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+/* Combine the two diffs together into one.
+   Here is the algorithm:
+
+     File2 is shared in common between the two diffs.
+     Diff02 is the diff between 0 and 2.
+     Diff12 is the diff between 1 and 2.
+
+	1) Find the range for the first block in File2.
+	    a) Take the lowest of the two ranges (in File2) in the two
+	       current blocks (one from each diff) as being the low
+	       water mark.  Assign the upper end of this block as
+	       being the high water mark and move the current block up
+	       one.  Mark the block just moved over as to be used.
+	    b) Check the next block in the diff that the high water
+	       mark is *not* from.
+
+	       *If* the high water mark is above
+	       the low end of the range in that block,
+
+		   mark that block as to be used and move the current
+		   block up.  Set the high water mark to the max of
+		   the high end of this block and the current.  Repeat b.
+
+	 2) Find the corresponding ranges in File0 (from the blocks
+	    in diff02; line per line outside of diffs) and in File1.
+	    Create a diff3_block, reserving space as indicated by the ranges.
+
+	 3) Copy all of the pointers for file2 in.  At least for now,
+	    do memcmp's between corresponding strings in the two diffs.
+
+	 4) Copy all of the pointers for file0 and 1 in.  Get what is
+	    needed from file2 (when there isn't a diff block, it's
+	    identical to file2 within the range between diff blocks).
+
+	 5) If the diff blocks used came from only one of the two
+	    strings of diffs, then that file (i.e. the one other than
+	    the common file in that diff) is the odd person out.  If
+	    diff blocks are used from both sets, check to see if files
+	    0 and 1 match:
+
+		Same number of lines?  If so, do a set of memcmp's (if
+	    a memcmp matches; copy the pointer over; it'll be easier
+	    later during comparisons).  If they match, 0 & 1 are the
+	    same.  If not, all three different.
+
+     Then do it again, until the blocks are exhausted.  */
+
+
+/* Make a three way diff (chain of diff3_block's) from two two way
+   diffs (chains of diff_block's).  Assume that each of the two diffs
+   passed are onto the same file (i.e. that each of the diffs were
+   made "to" the same file).  Return a three way diff pointer with
+   numbering FILE0 = the other file in diff02, FILE1 = the other file
+   in diff12, and FILEC = the common file.  */
+
+static struct diff3_block *
+make_3way_diff (struct diff_block *thread0, struct diff_block *thread1)
+{
+  /* Work on the two diffs passed to it as threads.  Thread number 0
+     is diff02, thread number 1 is diff12.  USING is the base of the
+     list of blocks to be used to construct each block of the three
+     way diff; if no blocks from a particular thread are to be used,
+     that element of USING is 0.  LAST_USING contains the last
+     elements on each of the using lists.
+
+     HIGH_WATER_MARK is the highest line number in the common file
+     described in any of the diffs in either of the USING lists.
+     HIGH_WATER_THREAD names the thread.  Similarly BASE_WATER_MARK
+     and BASE_WATER_THREAD describe the lowest line number in the
+     common file described in any of the diffs in either of the USING
+     lists.  HIGH_WATER_DIFF is the diff from which the
+     HIGH_WATER_MARK was taken.
+
+     HIGH_WATER_DIFF should always be equal to
+     LAST_USING[HIGH_WATER_THREAD].  OTHER_DIFF is the next diff to
+     check for higher water, and should always be equal to
+     CURRENT[HIGH_WATER_THREAD ^ 1].  OTHER_THREAD is the thread in
+     which the OTHER_DIFF is, and hence should always be equal to
+     HIGH_WATER_THREAD ^ 1.
+
+     LAST_DIFF is the last diff block produced by this routine, for
+     line correspondence purposes between that diff and the one
+     currently being worked on.  It is ZERO_DIFF before any blocks
+     have been created.  */
+
+  struct diff_block *using[2];
+  struct diff_block *last_using[2];
+  struct diff_block *current[2];
+
+  lin high_water_mark;
+
+  int high_water_thread;
+  int base_water_thread;
+  int other_thread;
+
+  struct diff_block *high_water_diff;
+  struct diff_block *other_diff;
+
+  struct diff3_block *result;
+  struct diff3_block *tmpblock;
+  struct diff3_block **result_end;
+
+  struct diff3_block const *last_diff3;
+
+  static struct diff3_block const zero_diff3;
+
+  /* Initialization */
+  result = 0;
+  result_end = &result;
+  current[0] = thread0; current[1] = thread1;
+  last_diff3 = &zero_diff3;
+
+  /* Sniff up the threads until we reach the end */
+
+  while (current[0] || current[1])
+    {
+      using[0] = using[1] = last_using[0] = last_using[1] = 0;
+
+      /* Setup low and high water threads, diffs, and marks.  */
+      if (!current[0])
+	base_water_thread = 1;
+      else if (!current[1])
+	base_water_thread = 0;
+      else
+	base_water_thread =
+	  (D_LOWLINE (current[0], FC) > D_LOWLINE (current[1], FC));
+
+      high_water_thread = base_water_thread;
+
+      high_water_diff = current[high_water_thread];
+
+      high_water_mark = D_HIGHLINE (high_water_diff, FC);
+
+      /* Make the diff you just got info from into the using class */
+      using[high_water_thread]
+	= last_using[high_water_thread]
+	= high_water_diff;
+      current[high_water_thread] = high_water_diff->next;
+      last_using[high_water_thread]->next = 0;
+
+      /* And mark the other diff */
+      other_thread = high_water_thread ^ 0x1;
+      other_diff = current[other_thread];
+
+      /* Shuffle up the ladder, checking the other diff to see if it
+	 needs to be incorporated.  */
+      while (other_diff
+	     && D_LOWLINE (other_diff, FC) <= high_water_mark + 1)
+	{
+
+	  /* Incorporate this diff into the using list.  Note that
+	     this doesn't take it off the current list */
+	  if (using[other_thread])
+	    last_using[other_thread]->next = other_diff;
+	  else
+	    using[other_thread] = other_diff;
+	  last_using[other_thread] = other_diff;
+
+	  /* Take it off the current list.  Note that this following
+	     code assumes that other_diff enters it equal to
+	     current[high_water_thread ^ 0x1] */
+	  current[other_thread] = current[other_thread]->next;
+	  other_diff->next = 0;
+
+	  /* Set the high_water stuff
+	     If this comparison is equal, then this is the last pass
+	     through this loop; since diff blocks within a given
+	     thread cannot overlap, the high_water_mark will be
+	     *below* the range_start of either of the next diffs.  */
+
+	  if (high_water_mark < D_HIGHLINE (other_diff, FC))
+	    {
+	      high_water_thread ^= 1;
+	      high_water_mark = D_HIGHLINE (other_diff, FC);
+	    }
+
+	  /* Set the other diff */
+	  other_thread = high_water_thread ^ 0x1;
+	  other_diff = current[other_thread];
+	}
+
+      /* The using lists contain a list of all of the blocks to be
+	 included in this diff3_block.  Create it.  */
+
+      tmpblock = using_to_diff3_block (using, last_using,
+				       base_water_thread, high_water_thread,
+				       last_diff3);
+
+      if (!tmpblock)
+	fatal ("internal error: screwup in format of diff blocks");
+
+      /* Put it on the list.  */
+      *result_end = tmpblock;
+      result_end = &tmpblock->next;
+
+      /* Set up corresponding lines correctly.  */
+      last_diff3 = tmpblock;
+    }
+  return result;
+}
+
+/* Take two lists of blocks (from two separate diff threads) and put
+   them together into one diff3 block.  Return a pointer to this diff3
+   block or 0 for failure.
+
+   All arguments besides using are for the convenience of the routine;
+   they could be derived from the using array.  LAST_USING is a pair
+   of pointers to the last blocks in the using structure.  LOW_THREAD
+   and HIGH_THREAD tell which threads contain the lowest and highest
+   line numbers for File0.  LAST_DIFF3 contains the last diff produced
+   in the calling routine.  This is used for lines mappings that
+   would still be identical to the state that diff ended in.
+
+   A distinction should be made in this routine between the two diffs
+   that are part of a normal two diff block, and the three diffs that
+   are part of a diff3_block.  */
+
+static struct diff3_block *
+using_to_diff3_block (struct diff_block *using[2],
+		      struct diff_block *last_using[2],
+		      int low_thread, int high_thread,
+		      struct diff3_block const *last_diff3)
+{
+  lin low[2], high[2];
+  struct diff3_block *result;
+  struct diff_block *ptr;
+  int d;
+  lin i;
+
+  /* Find the range in the common file.  */
+  lin lowc = D_LOWLINE (using[low_thread], FC);
+  lin highc = D_HIGHLINE (last_using[high_thread], FC);
+
+  /* Find the ranges in the other files.
+     If using[d] is null, that means that the file to which that diff
+     refers is equivalent to the common file over this range.  */
+
+  for (d = 0; d < 2; d++)
+    if (using[d])
+      {
+	low[d] = D_LOW_MAPLINE (using[d], FC, FO, lowc);
+	high[d] = D_HIGH_MAPLINE (last_using[d], FC, FO, highc);
+      }
+    else
+      {
+	low[d] = D_HIGH_MAPLINE (last_diff3, FILEC, FILE0 + d, lowc);
+	high[d] = D_HIGH_MAPLINE (last_diff3, FILEC, FILE0 + d, highc);
+      }
+
+  /* Create a block with the appropriate sizes */
+  result = create_diff3_block (low[0], high[0], low[1], high[1], lowc, highc);
+
+  /* Copy information for the common file.
+     Return with a zero if any of the compares failed.  */
+
+  for (d = 0; d < 2; d++)
+    for (ptr = using[d]; ptr; ptr = D_NEXT (ptr))
+      {
+	lin result_offset = D_LOWLINE (ptr, FC) - lowc;
+
+	if (!copy_stringlist (D_LINEARRAY (ptr, FC),
+			      D_LENARRAY (ptr, FC),
+			      D_LINEARRAY (result, FILEC) + result_offset,
+			      D_LENARRAY (result, FILEC) + result_offset,
+			      D_NUMLINES (ptr, FC)))
+	  return 0;
+      }
+
+  /* Copy information for file d.  First deal with anything that might be
+     before the first diff.  */
+
+  for (d = 0; d < 2; d++)
+    {
+      struct diff_block *u = using[d];
+      lin lo = low[d], hi = high[d];
+
+      for (i = 0;
+	   i + lo < (u ? D_LOWLINE (u, FO) : hi + 1);
+	   i++)
+	{
+	  D_RELNUM (result, FILE0 + d, i) = D_RELNUM (result, FILEC, i);
+	  D_RELLEN (result, FILE0 + d, i) = D_RELLEN (result, FILEC, i);
+	}
+
+      for (ptr = u; ptr; ptr = D_NEXT (ptr))
+	{
+	  lin result_offset = D_LOWLINE (ptr, FO) - lo;
+	  lin linec;
+
+	  if (!copy_stringlist (D_LINEARRAY (ptr, FO),
+				D_LENARRAY (ptr, FO),
+				D_LINEARRAY (result, FILE0 + d) + result_offset,
+				D_LENARRAY (result, FILE0 + d) + result_offset,
+				D_NUMLINES (ptr, FO)))
+	    return 0;
+
+	  /* Catch the lines between here and the next diff */
+	  linec = D_HIGHLINE (ptr, FC) + 1 - lowc;
+	  for (i = D_HIGHLINE (ptr, FO) + 1 - lo;
+	       i < (D_NEXT (ptr) ? D_LOWLINE (D_NEXT (ptr), FO) : hi + 1) - lo;
+	       i++)
+	    {
+	      D_RELNUM (result, FILE0 + d, i) = D_RELNUM (result, FILEC, linec);
+	      D_RELLEN (result, FILE0 + d, i) = D_RELLEN (result, FILEC, linec);
+	      linec++;
+	    }
+	}
+    }
+
+  /* Set correspond */
+  if (!using[0])
+    D3_TYPE (result) = DIFF_2ND;
+  else if (!using[1])
+    D3_TYPE (result) = DIFF_1ST;
+  else
+    {
+      lin nl0 = D_NUMLINES (result, FILE0);
+      lin nl1 = D_NUMLINES (result, FILE1);
+
+      if (nl0 != nl1
+	  || !compare_line_list (D_LINEARRAY (result, FILE0),
+				 D_LENARRAY (result, FILE0),
+				 D_LINEARRAY (result, FILE1),
+				 D_LENARRAY (result, FILE1),
+				 nl0))
+	D3_TYPE (result) = DIFF_ALL;
+      else
+	D3_TYPE (result) = DIFF_3RD;
+    }
+
+  return result;
+}
+
+/* Copy pointers from a list of strings to a different list of
+   strings.  If a spot in the second list is already filled, make sure
+   that it is filled with the same string; if not, return false, the copy
+   incomplete.  Upon successful completion of the copy, return true.  */
+
+static bool
+copy_stringlist (char * const fromptrs[], size_t const fromlengths[],
+		 char *toptrs[], size_t tolengths[],
+		 lin copynum)
+{
+  register char * const *f = fromptrs;
+  register char **t = toptrs;
+  register size_t const *fl = fromlengths;
+  register size_t *tl = tolengths;
+
+  while (copynum--)
+    {
+      if (*t)
+	{
+	  if (*fl != *tl || memcmp (*f, *t, *fl) != 0)
+	    return false;
+	}
+      else
+	{
+	  *t = *f;
+	  *tl = *fl;
+	}
+
+      t++; f++; tl++; fl++;
+    }
+
+  return true;
+}
+
+/* Create a diff3_block, with ranges as specified in the arguments.
+   Allocate the arrays for the various pointers (and zero them) based
+   on the arguments passed.  Return the block as a result.  */
+
+static struct diff3_block *
+create_diff3_block (lin low0, lin high0,
+		    lin low1, lin high1,
+		    lin low2, lin high2)
+{
+  struct diff3_block *result = xmalloc (sizeof *result);
+  lin numlines;
+
+  D3_TYPE (result) = ERROR;
+  D_NEXT (result) = 0;
+
+  /* Assign ranges */
+  D_LOWLINE (result, FILE0) = low0;
+  D_HIGHLINE (result, FILE0) = high0;
+  D_LOWLINE (result, FILE1) = low1;
+  D_HIGHLINE (result, FILE1) = high1;
+  D_LOWLINE (result, FILE2) = low2;
+  D_HIGHLINE (result, FILE2) = high2;
+
+  /* Allocate and zero space */
+  numlines = D_NUMLINES (result, FILE0);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE0) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE0) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE0) = 0;
+      D_LENARRAY (result, FILE0) = 0;
+    }
+
+  numlines = D_NUMLINES (result, FILE1);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE1) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE1) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE1) = 0;
+      D_LENARRAY (result, FILE1) = 0;
+    }
+
+  numlines = D_NUMLINES (result, FILE2);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE2) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE2) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE2) = 0;
+      D_LENARRAY (result, FILE2) = 0;
+    }
+
+  /* Return */
+  return result;
+}
+
+/* Compare two lists of lines of text.
+   Return 1 if they are equivalent, 0 if not.  */
+
+static bool
+compare_line_list (char * const list1[], size_t const lengths1[],
+		   char * const list2[], size_t const lengths2[],
+		   lin nl)
+{
+  char * const *l1 = list1;
+  char * const *l2 = list2;
+  size_t const *lgths1 = lengths1;
+  size_t const *lgths2 = lengths2;
+
+  while (nl--)
+    if (!*l1 || !*l2 || *lgths1 != *lgths2++
+	|| memcmp (*l1++, *l2++, *lgths1++) != 0)
+      return false;
+  return true;
+}
+
+/* Input and parse two way diffs.  */
+
+static struct diff_block *
+process_diff (char const *filea,
+	      char const *fileb,
+	      struct diff_block **last_block)
+{
+  char *diff_contents;
+  char *diff_limit;
+  char *scan_diff;
+  enum diff_type dt;
+  lin i;
+  struct diff_block *block_list;
+  struct diff_block **block_list_end = &block_list;
+  struct diff_block *bptr IF_LINT (= NULL);
+  size_t too_many_lines = (PTRDIFF_MAX
+			   / MIN (sizeof *bptr->lines[1],
+				  sizeof *bptr->lengths[1]));
+
+  diff_limit = read_diff (filea, fileb, &diff_contents);
+  scan_diff = diff_contents;
+
+  while (scan_diff < diff_limit)
+    {
+      bptr = xmalloc (sizeof *bptr);
+      bptr->lines[0] = bptr->lines[1] = 0;
+      bptr->lengths[0] = bptr->lengths[1] = 0;
+
+      dt = process_diff_control (&scan_diff, bptr);
+      if (dt == ERROR || *scan_diff != '\n')
+	{
+	  fprintf (stderr, _("%s: diff failed: "), program_name);
+	  do
+	    {
+	      putc (*scan_diff, stderr);
+	    }
+	  while (*scan_diff++ != '\n');
+	  exit (EXIT_TROUBLE);
+	}
+      scan_diff++;
+
+      /* Force appropriate ranges to be null, if necessary */
+      switch (dt)
+	{
+	case ADD:
+	  bptr->ranges[0][0]++;
+	  break;
+	case DELETE:
+	  bptr->ranges[1][0]++;
+	  break;
+	case CHANGE:
+	  break;
+	default:
+	  fatal ("internal error: invalid diff type in process_diff");
+	  break;
+	}
+
+      /* Allocate space for the pointers for the lines from filea, and
+	 parcel them out among these pointers */
+      if (dt != ADD)
+	{
+	  lin numlines = D_NUMLINES (bptr, 0);
+	  if (too_many_lines <= numlines)
+	    xalloc_die ();
+	  bptr->lines[0] = xmalloc (numlines * sizeof *bptr->lines[0]);
+	  bptr->lengths[0] = xmalloc (numlines * sizeof *bptr->lengths[0]);
+	  for (i = 0; i < numlines; i++)
+	    scan_diff = scan_diff_line (scan_diff,
+					&(bptr->lines[0][i]),
+					&(bptr->lengths[0][i]),
+					diff_limit,
+					'<');
+	}
+
+      /* Get past the separator for changes */
+      if (dt == CHANGE)
+	{
+	  if (strncmp (scan_diff, "---\n", 4))
+	    fatal ("invalid diff format; invalid change separator");
+	  scan_diff += 4;
+	}
+
+      /* Allocate space for the pointers for the lines from fileb, and
+	 parcel them out among these pointers */
+      if (dt != DELETE)
+	{
+	  lin numlines = D_NUMLINES (bptr, 1);
+	  if (too_many_lines <= numlines)
+	    xalloc_die ();
+	  bptr->lines[1] = xmalloc (numlines * sizeof *bptr->lines[1]);
+	  bptr->lengths[1] = xmalloc (numlines * sizeof *bptr->lengths[1]);
+	  for (i = 0; i < numlines; i++)
+	    scan_diff = scan_diff_line (scan_diff,
+					&(bptr->lines[1][i]),
+					&(bptr->lengths[1][i]),
+					diff_limit,
+					'>');
+	}
+
+      /* Place this block on the blocklist.  */
+      *block_list_end = bptr;
+      block_list_end = &bptr->next;
+    }
+
+  *block_list_end = NULL;
+  *last_block = bptr;
+  return block_list;
+}
+
+/* Skip tabs and spaces, and return the first character after them.  */
+
+static char *
+skipwhite (char *s)
+{
+  while (*s == ' ' || *s == '\t')
+    s++;
+  return s;
+}
+
+/* Read a nonnegative line number from S, returning the address of the
+   first character after the line number, and storing the number into
+   *PNUM.  Return 0 if S does not point to a valid line number.  */
+
+static char *
+readnum (char *s, lin *pnum)
+{
+  unsigned char c = *s;
+  lin num = 0;
+
+  if (! ISDIGIT (c))
+    return 0;
+
+  do
+    {
+      num = c - '0' + num * 10;
+      c = *++s;
+    }
+  while (ISDIGIT (c));
+
+  *pnum = num;
+  return s;
+}
+
+/* Parse a normal format diff control string.  Return the type of the
+   diff (ERROR if the format is bad).  All of the other important
+   information is filled into to the structure pointed to by db, and
+   the string pointer (whose location is passed to this routine) is
+   updated to point beyond the end of the string parsed.  Note that
+   only the ranges in the diff_block will be set by this routine.
+
+   If some specific pair of numbers has been reduced to a single
+   number, then both corresponding numbers in the diff block are set
+   to that number.  In general these numbers are interpreted as ranges
+   inclusive, unless being used by the ADD or DELETE commands.  It is
+   assumed that these will be special cased in a superior routine.   */
+
+static enum diff_type
+process_diff_control (char **string, struct diff_block *db)
+{
+  char *s = *string;
+  enum diff_type type;
+
+  /* Read first set of digits */
+  s = readnum (skipwhite (s), &db->ranges[0][RANGE_START]);
+  if (! s)
+    return ERROR;
+
+  /* Was that the only digit? */
+  s = skipwhite (s);
+  if (*s == ',')
+    {
+      s = readnum (s + 1, &db->ranges[0][RANGE_END]);
+      if (! s)
+	return ERROR;
+    }
+  else
+    db->ranges[0][RANGE_END] = db->ranges[0][RANGE_START];
+
+  /* Get the letter */
+  s = skipwhite (s);
+  switch (*s)
+    {
+    case 'a':
+      type = ADD;
+      break;
+    case 'c':
+      type = CHANGE;
+      break;
+    case 'd':
+      type = DELETE;
+      break;
+    default:
+      return ERROR;			/* Bad format */
+    }
+  s++;				/* Past letter */
+
+  /* Read second set of digits */
+  s = readnum (skipwhite (s), &db->ranges[1][RANGE_START]);
+  if (! s)
+    return ERROR;
+
+  /* Was that the only digit? */
+  s = skipwhite (s);
+  if (*s == ',')
+    {
+      s = readnum (s + 1, &db->ranges[1][RANGE_END]);
+      if (! s)
+	return ERROR;
+      s = skipwhite (s);		/* To move to end */
+    }
+  else
+    db->ranges[1][RANGE_END] = db->ranges[1][RANGE_START];
+
+  *string = s;
+  return type;
+}
+
+static char *
+read_diff (char const *filea,
+	   char const *fileb,
+	   char **output_placement)
+{
+  char *diff_result;
+  size_t current_chunk_size, total;
+  int fd, wstatus, status;
+  int werrno = 0;
+  struct stat pipestat;
+
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+
+  char const *argv[9];
+  char const **ap;
+  int fds[2];
+  pid_t pid;
+
+  ap = argv;
+  *ap++ = diff_program;
+  if (text)
+    *ap++ = "-a";
+  if (strip_trailing_cr)
+    *ap++ = "--strip-trailing-cr";
+  *ap++ = "--horizon-lines=100";
+  *ap++ = "--";
+  *ap++ = filea;
+  *ap++ = fileb;
+  *ap = 0;
+
+  if (pipe (fds) != 0)
+    perror_with_exit ("pipe");
+
+  pid = vfork ();
+  if (pid == 0)
+    {
+      /* Child */
+      close (fds[0]);
+      if (fds[1] != STDOUT_FILENO)
+	{
+	  dup2 (fds[1], STDOUT_FILENO);
+	  close (fds[1]);
+	}
+
+      /* The cast to (char **) is needed for portability to older
+	 hosts with a nonstandard prototype for execvp.  */
+      execvp (diff_program, (char **) argv);
+
+      _exit (errno == ENOENT ? 127 : 126);
+    }
+
+  if (pid == -1)
+    perror_with_exit ("fork");
+
+  close (fds[1]);		/* Prevent erroneous lack of EOF */
+  fd = fds[0];
+
+#else
+
+  FILE *fpipe;
+  char const args[] = " --horizon-lines=100 -- ";
+  char *command = xmalloc (shell_quote_length (diff_program)
+			   + sizeof "-a"
+			   + sizeof "--strip-trailing-cr"
+			   + sizeof args - 1
+			   + shell_quote_length (filea) + 1
+			   + shell_quote_length (fileb) + 1);
+  char *p = command;
+  p = shell_quote_copy (p, diff_program);
+  if (text)
+    {
+      strcpy (p, " -a");
+      p += 3;
+    }
+  if (strip_trailing_cr)
+    {
+      strcpy (p, " --strip-trailing-cr");
+      p += 20;
+    }
+  strcpy (p, args);
+  p += sizeof args - 1;
+  p = shell_quote_copy (p, filea);
+  *p++ = ' ';
+  p = shell_quote_copy (p, fileb);
+  *p = 0;
+  errno = 0;
+  fpipe = popen (command, "r");
+  if (!fpipe)
+    perror_with_exit (command);
+  free (command);
+  fd = fileno (fpipe);
+
+#endif
+
+  if (fstat (fd, &pipestat) != 0)
+    perror_with_exit ("fstat");
+  current_chunk_size = MAX (1, STAT_BLOCKSIZE (pipestat));
+  diff_result = xmalloc (current_chunk_size);
+  total = 0;
+
+  for (;;)
+    {
+      size_t bytes_to_read = current_chunk_size - total;
+      size_t bytes = block_read (fd, diff_result + total, bytes_to_read);
+      total += bytes;
+      if (bytes != bytes_to_read)
+	{
+	  if (bytes == SIZE_MAX)
+	    perror_with_exit (_("read failed"));
+	  break;
+	}
+      if (PTRDIFF_MAX / 2 <= current_chunk_size)
+	xalloc_die ();
+      current_chunk_size *= 2;
+      diff_result = xrealloc (diff_result, current_chunk_size);
+    }
+
+  if (total != 0 && diff_result[total-1] != '\n')
+    fatal ("invalid diff format; incomplete last line");
+
+  *output_placement = diff_result;
+
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+
+  wstatus = pclose (fpipe);
+  if (wstatus == -1)
+    werrno = errno;
+
+#else
+
+  if (close (fd) != 0)
+    perror_with_exit ("close");
+  if (waitpid (pid, &wstatus, 0) < 0)
+    perror_with_exit ("waitpid");
+
+#endif
+
+  status = ! werrno && WIFEXITED (wstatus) ? WEXITSTATUS (wstatus) : INT_MAX;
+
+  if (EXIT_TROUBLE <= status)
+    error (EXIT_TROUBLE, werrno,
+	   _(status == 126
+	     ? "subsidiary program '%s' could not be invoked"
+	     : status == 127
+	     ? "subsidiary program '%s' not found"
+	     : status == INT_MAX
+	     ? "subsidiary program '%s' failed"
+	     : "subsidiary program '%s' failed (exit status %d)"),
+	   diff_program, status);
+
+  return diff_result + total;
+}
+
+
+/* Scan a regular diff line (consisting of > or <, followed by a
+   space, followed by text (including nulls) up to a newline.
+
+   This next routine began life as a macro and many parameters in it
+   are used as call-by-reference values.  */
+static char *
+scan_diff_line (char *scan_ptr, char **set_start, size_t *set_length,
+		char *limit, char leadingchar)
+{
+  char *line_ptr;
+
+  if (!(scan_ptr[0] == leadingchar
+	&& scan_ptr[1] == ' '))
+    fatal ("invalid diff format; incorrect leading line chars");
+
+  *set_start = line_ptr = scan_ptr + 2;
+  while (*line_ptr++ != '\n')
+    continue;
+
+  /* Include newline if the original line ended in a newline,
+     or if an edit script is being generated.
+     Copy any missing newline message to stderr if an edit script is being
+     generated, because edit scripts cannot handle missing newlines.
+     Return the beginning of the next line.  */
+  *set_length = line_ptr - *set_start;
+  if (line_ptr < limit && *line_ptr == '\\')
+    {
+      if (edscript)
+	fprintf (stderr, "%s:", program_name);
+      else
+	--*set_length;
+      line_ptr++;
+      do
+	{
+	  if (edscript)
+	    putc (*line_ptr, stderr);
+	}
+      while (*line_ptr++ != '\n');
+    }
+
+  return line_ptr;
+}
+
+/* Output a three way diff passed as a list of diff3_block's.  The
+   argument MAPPING is indexed by external file number (in the
+   argument list) and contains the internal file number (from the diff
+   passed).  This is important because the user expects outputs in
+   terms of the argument list number, and the diff passed may have
+   been done slightly differently (if the last argument was "-", for
+   example).  REV_MAPPING is the inverse of MAPPING.  */
+
+static void
+output_diff3 (FILE *outputfile, struct diff3_block *diff,
+	      int const mapping[3], int const rev_mapping[3])
+{
+  int i;
+  int oddoneout;
+  char *cp;
+  struct diff3_block *ptr;
+  lin line;
+  size_t length;
+  int dontprint;
+  static int skew_increment[3] = { 2, 3, 1 }; /* 0==>2==>1==>3 */
+  char const *line_prefix = initial_tab ? "\t" : "  ";
+
+  for (ptr = diff; ptr; ptr = D_NEXT (ptr))
+    {
+      char x[2];
+
+      switch (ptr->correspond)
+	{
+	case DIFF_ALL:
+	  x[0] = 0;
+	  dontprint = 3;	/* Print them all */
+	  oddoneout = 3;	/* Nobody's odder than anyone else */
+	  break;
+	case DIFF_1ST:
+	case DIFF_2ND:
+	case DIFF_3RD:
+	  oddoneout = rev_mapping[ptr->correspond - DIFF_1ST];
+
+	  x[0] = oddoneout + '1';
+	  x[1] = 0;
+	  dontprint = oddoneout == 0;
+	  break;
+	default:
+	  fatal ("internal error: invalid diff type passed to output");
+	}
+      fprintf (outputfile, "====%s\n", x);
+
+      /* Go 0, 2, 1 if the first and third outputs are equivalent.  */
+      for (i = 0; i < 3;
+	   i = (oddoneout == 1 ? skew_increment[i] : i + 1))
+	{
+	  int realfile = mapping[i];
+	  lin lowt = D_LOWLINE (ptr, realfile);
+	  lin hight = D_HIGHLINE (ptr, realfile);
+	  long int llowt = lowt;
+	  long int lhight = hight;
+
+	  fprintf (outputfile, "%d:", i + 1);
+	  switch (lowt - hight)
+	    {
+	    case 1:
+	      fprintf (outputfile, "%lda\n", llowt - 1);
+	      break;
+	    case 0:
+	      fprintf (outputfile, "%ldc\n", llowt);
+	      break;
+	    default:
+	      fprintf (outputfile, "%ld,%ldc\n", llowt, lhight);
+	      break;
+	    }
+
+	  if (i == dontprint) continue;
+
+	  if (lowt <= hight)
+	    {
+	      line = 0;
+	      do
+		{
+		  fputs (line_prefix, outputfile);
+		  cp = D_RELNUM (ptr, realfile, line);
+		  length = D_RELLEN (ptr, realfile, line);
+		  fwrite (cp, sizeof (char), length, outputfile);
+		}
+	      while (++line < hight - lowt + 1);
+	      if (cp[length - 1] != '\n')
+		fprintf (outputfile, "\n\\ %s\n",
+			 _("No newline at end of file"));
+	    }
+	}
+    }
+}
+
+
+/* Output to OUTPUTFILE the lines of B taken from FILENUM.  Double any
+   initial '.'s; yield nonzero if any initial '.'s were doubled.  */
+
+static bool
+dotlines (FILE *outputfile, struct diff3_block *b, int filenum)
+{
+  lin i;
+  bool leading_dot = false;
+
+  for (i = 0;
+       i < D_NUMLINES (b, filenum);
+       i++)
+    {
+      char *line = D_RELNUM (b, filenum, i);
+      if (line[0] == '.')
+	{
+	  leading_dot = true;
+	  fputc ('.', outputfile);
+	}
+      fwrite (line, sizeof (char),
+	      D_RELLEN (b, filenum, i), outputfile);
+    }
+
+  return leading_dot;
+}
+
+/* Output to OUTPUTFILE a '.' line.  If LEADING_DOT is true, also
+   output a command that removes initial '.'s starting with line START
+   and continuing for NUM lines.  (START is long int, not lin, for
+   convenience with printf %ld formats.)  */
+
+static void
+undotlines (FILE *outputfile, bool leading_dot, long int start, lin num)
+{
+  fputs (".\n", outputfile);
+  if (leading_dot)
+    {
+      if (num == 1)
+	fprintf (outputfile, "%lds/^\\.//\n", start);
+      else
+	fprintf (outputfile, "%ld,%lds/^\\.//\n", start, start + num - 1);
+    }
+}
+
+/* Output a diff3 set of blocks as an ed script.  This script applies
+   the changes between file's 2 & 3 to file 1.  Take the precise
+   format of the ed script to be output from global variables set
+   during options processing.  Reverse the order of
+   the set of diff3 blocks in DIFF; this gets
+   around the problems involved with changing line numbers in an ed
+   script.
+
+   As in `output_diff3', the variable MAPPING maps from file number
+   according to the argument list to file number according to the diff
+   passed.  All files listed below are in terms of the argument list.
+   REV_MAPPING is the inverse of MAPPING.
+
+   FILE0, FILE1 and FILE2 are the strings to print as the names of the
+   three files.  These may be the actual names, or may be the
+   arguments specified with -L.
+
+   Return 1 if conflicts were found.  */
+
+static bool
+output_diff3_edscript (FILE *outputfile, struct diff3_block *diff,
+		       int const mapping[3], int const rev_mapping[3],
+		       char const *file0, char const *file1, char const *file2)
+{
+  bool leading_dot;
+  bool conflicts_found = false;
+  bool conflict;
+  struct diff3_block *b;
+
+  for (b = reverse_diff3_blocklist (diff); b; b = b->next)
+    {
+      /* Must do mapping correctly.  */
+      enum diff_type type
+	= (b->correspond == DIFF_ALL
+	   ? DIFF_ALL
+	   : DIFF_1ST + rev_mapping[b->correspond - DIFF_1ST]);
+
+      long int low0, high0;
+
+      /* If we aren't supposed to do this output block, skip it.  */
+      switch (type)
+	{
+	default: continue;
+	case DIFF_2ND: if (!show_2nd) continue; conflict = true; break;
+	case DIFF_3RD: if (overlap_only) continue; conflict = false; break;
+	case DIFF_ALL: if (simple_only) continue; conflict = flagging; break;
+	}
+
+      low0 = D_LOWLINE (b, mapping[FILE0]);
+      high0 = D_HIGHLINE (b, mapping[FILE0]);
+
+      if (conflict)
+	{
+	  conflicts_found = true;
+
+
+	  /* Mark end of conflict.  */
+
+	  fprintf (outputfile, "%lda\n", high0);
+	  leading_dot = false;
+	  if (type == DIFF_ALL)
+	    {
+	      if (show_2nd)
+		{
+		  /* Append lines from FILE1.  */
+		  fprintf (outputfile, "||||||| %s\n", file1);
+		  leading_dot = dotlines (outputfile, b, mapping[FILE1]);
+		}
+	      /* Append lines from FILE2.  */
+	      fputs ("=======\n", outputfile);
+	      leading_dot |= dotlines (outputfile, b, mapping[FILE2]);
+	    }
+	  fprintf (outputfile, ">>>>>>> %s\n", file2);
+	  undotlines (outputfile, leading_dot, high0 + 2,
+		      (D_NUMLINES (b, mapping[FILE1])
+		       + D_NUMLINES (b, mapping[FILE2]) + 1));
+
+
+	  /* Mark start of conflict.  */
+
+	  fprintf (outputfile, "%lda\n<<<<<<< %s\n", low0 - 1,
+		   type == DIFF_ALL ? file0 : file1);
+	  leading_dot = false;
+	  if (type == DIFF_2ND)
+	    {
+	      /* Prepend lines from FILE1.  */
+	      leading_dot = dotlines (outputfile, b, mapping[FILE1]);
+	      fputs ("=======\n", outputfile);
+	    }
+	  undotlines (outputfile, leading_dot, low0 + 1,
+		      D_NUMLINES (b, mapping[FILE1]));
+	}
+      else if (D_NUMLINES (b, mapping[FILE2]) == 0)
+	/* Write out a delete */
+	{
+	  if (low0 == high0)
+	    fprintf (outputfile, "%ldd\n", low0);
+	  else
+	    fprintf (outputfile, "%ld,%ldd\n", low0, high0);
+	}
+      else
+	/* Write out an add or change */
+	{
+	  switch (high0 - low0)
+	    {
+	    case -1:
+	      fprintf (outputfile, "%lda\n", high0);
+	      break;
+	    case 0:
+	      fprintf (outputfile, "%ldc\n", high0);
+	      break;
+	    default:
+	      fprintf (outputfile, "%ld,%ldc\n", low0, high0);
+	      break;
+	    }
+
+	  undotlines (outputfile, dotlines (outputfile, b, mapping[FILE2]),
+		      low0, D_NUMLINES (b, mapping[FILE2]));
+	}
+    }
+  if (finalwrite)
+    fputs ("w\nq\n", outputfile);
+  return conflicts_found;
+}
+
+/* Read from INFILE and output to OUTPUTFILE a set of diff3_blocks
+   DIFF as a merged file.  This acts like 'ed file0
+   <[output_diff3_edscript]', except that it works even for binary
+   data or incomplete lines.
+
+   As before, MAPPING maps from arg list file number to diff file
+   number, REV_MAPPING is its inverse, and FILE0, FILE1, and FILE2 are
+   the names of the files.
+
+   Return 1 if conflicts were found.  */
+
+static bool
+output_diff3_merge (FILE *infile, FILE *outputfile, struct diff3_block *diff,
+		    int const mapping[3], int const rev_mapping[3],
+		    char const *file0, char const *file1, char const *file2)
+{
+  int c;
+  lin i;
+  bool conflicts_found = false;
+  bool conflict;
+  struct diff3_block *b;
+  lin linesread = 0;
+
+  for (b = diff; b; b = b->next)
+    {
+      /* Must do mapping correctly.  */
+      enum diff_type type
+	= ((b->correspond == DIFF_ALL)
+	   ? DIFF_ALL
+	   : DIFF_1ST + rev_mapping[b->correspond - DIFF_1ST]);
+      char const *format_2nd = "<<<<<<< %s\n";
+
+      /* If we aren't supposed to do this output block, skip it.  */
+      switch (type)
+	{
+	default: continue;
+	case DIFF_2ND: if (!show_2nd) continue; conflict = true; break;
+	case DIFF_3RD: if (overlap_only) continue; conflict = false; break;
+	case DIFF_ALL: if (simple_only) continue; conflict = flagging;
+	  format_2nd = "||||||| %s\n";
+	  break;
+	}
+
+      /* Copy I lines from file 0.  */
+      i = D_LOWLINE (b, FILE0) - linesread - 1;
+      linesread += i;
+      while (0 <= --i)
+	do
+	  {
+	    c = getc (infile);
+	    if (c == EOF)
+	      {
+		if (ferror (infile))
+		  perror_with_exit (_("read failed"));
+		else if (feof (infile))
+		  fatal ("input file shrank");
+	      }
+	    putc (c, outputfile);
+	  }
+	while (c != '\n');
+
+      if (conflict)
+	{
+	  conflicts_found = true;
+
+	  if (type == DIFF_ALL)
+	    {
+	      /* Put in lines from FILE0 with bracket.  */
+	      fprintf (outputfile, "<<<<<<< %s\n", file0);
+	      for (i = 0;
+		   i < D_NUMLINES (b, mapping[FILE0]);
+		   i++)
+		fwrite (D_RELNUM (b, mapping[FILE0], i), sizeof (char),
+			D_RELLEN (b, mapping[FILE0], i), outputfile);
+	    }
+
+	  if (show_2nd)
+	    {
+	      /* Put in lines from FILE1 with bracket.  */
+	      fprintf (outputfile, format_2nd, file1);
+	      for (i = 0;
+		   i < D_NUMLINES (b, mapping[FILE1]);
+		   i++)
+		fwrite (D_RELNUM (b, mapping[FILE1], i), sizeof (char),
+			D_RELLEN (b, mapping[FILE1], i), outputfile);
+	    }
+
+	  fputs ("=======\n", outputfile);
+	}
+
+      /* Put in lines from FILE2.  */
+      for (i = 0;
+	   i < D_NUMLINES (b, mapping[FILE2]);
+	   i++)
+	fwrite (D_RELNUM (b, mapping[FILE2], i), sizeof (char),
+		D_RELLEN (b, mapping[FILE2], i), outputfile);
+
+      if (conflict)
+	fprintf (outputfile, ">>>>>>> %s\n", file2);
+
+      /* Skip I lines in file 0.  */
+      i = D_NUMLINES (b, FILE0);
+      linesread += i;
+      while (0 <= --i)
+	while ((c = getc (infile)) != '\n')
+	  if (c == EOF)
+	    {
+	      if (ferror (infile))
+		perror_with_exit (_("read failed"));
+	      else if (feof (infile))
+		{
+		  if (i || b->next)
+		    fatal ("input file shrank");
+		  return conflicts_found;
+		}
+	    }
+    }
+  /* Copy rest of common file.  */
+  while ((c = getc (infile)) != EOF || !(ferror (infile) | feof (infile)))
+    putc (c, outputfile);
+  return conflicts_found;
+}
+
+/* Reverse the order of the list of diff3 blocks.  */
+
+static struct diff3_block *
+reverse_diff3_blocklist (struct diff3_block *diff)
+{
+  register struct diff3_block *tmp, *next, *prev;
+
+  for (tmp = diff, prev = 0;  tmp;  tmp = next)
+    {
+      next = tmp->next;
+      tmp->next = prev;
+      prev = tmp;
+    }
+
+  return prev;
+}
+
+static void
+fatal (char const *msgid)
+{
+  error (EXIT_TROUBLE, 0, "%s", _(msgid));
+  abort ();
+}
+
+static void
+perror_with_exit (char const *string)
+{
+  error (EXIT_TROUBLE, errno, "%s", string);
+  abort ();
+}
diff --git a/test/diffutils-3.0-patch/dir.c b/test/diffutils-3.0-patch/dir.c
new file mode 100644
index 0000000..5e08318
--- /dev/null
+++ b/test/diffutils-3.0-patch/dir.c
@@ -0,0 +1,283 @@
+/* Read, sort and compare two directories.  Used for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006-2007,
+   2009-2010 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <error.h>
+#include <exclude.h>
+#include <setjmp.h>
+#include <xalloc.h>
+
+/* Read the directory named by DIR and store into DIRDATA a sorted vector
+   of filenames for its contents.  DIR->desc == -1 means this directory is
+   known to be nonexistent, so set DIRDATA to an empty vector.
+   Return -1 (setting errno) if error, 0 otherwise.  */
+
+struct dirdata
+{
+  size_t nnames;	/* Number of names.  */
+  char const **names;	/* Sorted names of files in dir, followed by 0.  */
+  char *data;	/* Allocated storage for file names.  */
+};
+
+/* Whether file names in directories should be compared with
+   locale-specific sorting.  */
+static bool locale_specific_sorting;
+
+/* Where to go if locale-specific sorting fails.  */
+static jmp_buf failed_locale_specific_sorting;
+
+static bool dir_loop (struct comparison const *, int);
+static int compare_names_for_qsort (void const *, void const *);
+
+
+/* Read a directory and get its vector of names.  */
+
+static bool
+dir_read (struct file_data const *dir, struct dirdata *dirdata)
+{
+  register struct dirent *next;
+  register size_t i;
+
+  /* Address of block containing the files that are described.  */
+  char const **names;
+
+  /* Number of files in directory.  */
+  size_t nnames;
+
+  /* Allocated and used storage for file name data.  */
+  char *data;
+  size_t data_alloc, data_used;
+
+  dirdata->names = 0;
+  dirdata->data = 0;
+  nnames = 0;
+  data = 0;
+
+  if (dir->desc != -1)
+    {
+      /* Open the directory and check for errors.  */
+      register DIR *reading = opendir (dir->name);
+      if (!reading)
+	return false;
+
+      /* Initialize the table of filenames.  */
+
+      data_alloc = 512;
+      data_used = 0;
+      dirdata->data = data = xmalloc (data_alloc);
+
+      /* Read the directory entries, and insert the subfiles
+	 into the `data' table.  */
+
+      while ((errno = 0, (next = readdir (reading)) != 0))
+	{
+	  char *d_name = next->d_name;
+	  size_t d_size = _D_EXACT_NAMLEN (next) + 1;
+
+	  /* Ignore "." and "..".  */
+	  if (d_name[0] == '.'
+	      && (d_name[1] == 0 || (d_name[1] == '.' && d_name[2] == 0)))
+	    continue;
+
+	  if (excluded_file_name (excluded, d_name))
+	    continue;
+
+	  while (data_alloc < data_used + d_size)
+	    {
+	      if (PTRDIFF_MAX / 2 <= data_alloc)
+		xalloc_die ();
+	      dirdata->data = data = xrealloc (data, data_alloc *= 2);
+	    }
+
+	  memcpy (data + data_used, d_name, d_size);
+	  data_used += d_size;
+	  nnames++;
+	}
+      if (errno)
+	{
+	  int e = errno;
+	  closedir (reading);
+	  errno = e;
+	  return false;
+	}
+#if CLOSEDIR_VOID
+      closedir (reading);
+#else
+      if (closedir (reading) != 0)
+	return false;
+#endif
+    }
+
+  /* Create the `names' table from the `data' table.  */
+  if (PTRDIFF_MAX / sizeof *names - 1 <= nnames)
+    xalloc_die ();
+  dirdata->names = names = xmalloc ((nnames + 1) * sizeof *names);
+  dirdata->nnames = nnames;
+  for (i = 0;  i < nnames;  i++)
+    {
+      names[i] = data;
+      data += strlen (data) + 1;
+    }
+  names[nnames] = 0;
+  return true;
+}
+
+/* Compare file names, returning a value compatible with strcmp.  */
+
+static int
+compare_names (char const *name1, char const *name2)
+{
+  if (locale_specific_sorting)
+    {
+      int r;
+      errno = 0;
+      if (ignore_file_name_case)
+	r = strcasecoll (name1, name2);
+      else
+	r = strcoll (name1, name2);
+      if (errno)
+	{
+	  error (0, errno, _("cannot compare file names '%s' and '%s'"),
+		 name1, name2);
+	  longjmp (failed_locale_specific_sorting, 1);
+	}
+      return r;
+    }
+
+  return (ignore_file_name_case
+	  ? strcasecmp (name1, name2)
+	  : file_name_cmp (name1, name2));
+}
+
+/* A wrapper for compare_names suitable as an argument for qsort.  */
+
+static int
+compare_names_for_qsort (void const *file1, void const *file2)
+{
+  char const *const *f1 = file1;
+  char const *const *f2 = file2;
+  return compare_names (*f1, *f2);
+}
+
+/* Compare the contents of two directories named in CMP.
+   This is a top-level routine; it does everything necessary for diff
+   on two directories.
+
+   CMP->file[0].desc == -1 says directory CMP->file[0] doesn't exist,
+   but pretend it is empty.  Likewise for CMP->file[1].
+
+   HANDLE_FILE is a caller-provided subroutine called to handle each file.
+   It gets three operands: CMP, name of file in dir 0, name of file in dir 1.
+   These names are relative to the original working directory.
+
+   For a file that appears in only one of the dirs, one of the name-args
+   to HANDLE_FILE is zero.
+
+   Returns the maximum of all the values returned by HANDLE_FILE,
+   or EXIT_TROUBLE if trouble is encountered in opening files.  */
+
+int
+diff_dirs (struct comparison const *cmp,
+	   int (*handle_file) (struct comparison const *,
+			       char const *, char const *))
+{
+  struct dirdata dirdata[2];
+  int volatile val = EXIT_SUCCESS;
+  int i;
+
+  if ((cmp->file[0].desc == -1 || dir_loop (cmp, 0))
+      && (cmp->file[1].desc == -1 || dir_loop (cmp, 1)))
+    {
+      error (0, 0, _("%s: recursive directory loop"),
+	     cmp->file[cmp->file[0].desc == -1].name);
+      return EXIT_TROUBLE;
+    }
+
+  /* Get contents of both dirs.  */
+  for (i = 0; i < 2; i++)
+    if (! dir_read (&cmp->file[i], &dirdata[i]))
+      {
+	perror_with_name (cmp->file[i].name);
+	val = EXIT_TROUBLE;
+      }
+
+  if (val == EXIT_SUCCESS)
+    {
+      char const **volatile names[2];
+      names[0] = dirdata[0].names;
+      names[1] = dirdata[1].names;
+
+      /* Use locale-specific sorting if possible, else native byte order.  */
+      locale_specific_sorting = true;
+      if (setjmp (failed_locale_specific_sorting))
+	locale_specific_sorting = false;
+
+      /* Sort the directories.  */
+      for (i = 0; i < 2; i++)
+	qsort (names[i], dirdata[i].nnames, sizeof *dirdata[i].names,
+	       compare_names_for_qsort);
+
+      /* If `-S name' was given, and this is the topmost level of comparison,
+	 ignore all file names less than the specified starting name.  */
+
+      if (starting_file && ! cmp->parent)
+	{
+	  while (*names[0] && compare_names (*names[0], starting_file) < 0)
+	    names[0]++;
+	  while (*names[1] && compare_names (*names[1], starting_file) < 0)
+	    names[1]++;
+	}
+
+      /* Loop while files remain in one or both dirs.  */
+      while (*names[0] || *names[1])
+	{
+	  /* Compare next name in dir 0 with next name in dir 1.
+	     At the end of a dir,
+	     pretend the "next name" in that dir is very large.  */
+	  int nameorder = (!*names[0] ? 1 : !*names[1] ? -1
+			   : compare_names (*names[0], *names[1]));
+	  int v1 = (*handle_file) (cmp,
+				   0 < nameorder ? 0 : *names[0]++,
+				   nameorder < 0 ? 0 : *names[1]++);
+	  if (val < v1)
+	    val = v1;
+	}
+    }
+
+  for (i = 0; i < 2; i++)
+    {
+      free (dirdata[i].names);
+      free (dirdata[i].data);
+    }
+
+  return val;
+}
+
+/* Return nonzero if CMP is looping recursively in argument I.  */
+
+static bool
+dir_loop (struct comparison const *cmp, int i)
+{
+  struct comparison const *p = cmp;
+  while ((p = p->parent))
+    if (0 < same_file (&p->file[i].stat, &cmp->file[i].stat))
+      return true;
+  return false;
+}
diff --git a/test/diffutils-3.0-patch/ed.c b/test/diffutils-3.0-patch/ed.c
new file mode 100644
index 0000000..08acf50
--- /dev/null
+++ b/test/diffutils-3.0-patch/ed.c
@@ -0,0 +1,175 @@
+/* Output routines for ed-script format.
+
+   Copyright (C) 1988-1989, 1991-1993, 1995, 1998, 2001, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+
+static void print_ed_hunk (struct change *);
+static void print_rcs_hunk (struct change *);
+static void pr_forward_ed_hunk (struct change *);
+
+/* Print our script as ed commands.  */
+
+void
+print_ed_script (struct change *script)
+{
+  print_script (script, find_reverse_change, print_ed_hunk);
+}
+
+/* Print a hunk of an ed diff */
+
+static void
+print_ed_hunk (struct change *hunk)
+{
+  lin f0, l0, f1, l1;
+  enum changes changes;
+
+#ifdef DEBUG
+  debug_script (hunk);
+#endif
+
+  /* Determine range of line numbers involved in each file.  */
+  changes = analyze_hunk (hunk, &f0, &l0, &f1, &l1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  /* Print out the line number header for this hunk */
+  print_number_range (',', &files[0], f0, l0);
+  fputc (change_letter[changes], outfile);
+  fputc ('\n', outfile);
+
+  /* Print new/changed lines from second file, if needed */
+  if (changes != OLD)
+    {
+      lin i;
+      bool insert_mode = true;
+
+      for (i = f1; i <= l1; i++)
+	{
+	  if (!insert_mode)
+	    {
+	      fputs ("a\n", outfile);
+	      insert_mode = true;
+	    }
+	  if (files[1].linbuf[i][0] == '.' && files[1].linbuf[i][1] == '\n')
+	    {
+	      /* The file's line is just a dot, and it would exit
+		 insert mode.  Precede the dot with another dot, exit
+		 insert mode and remove the extra dot.  */
+	      fputs ("..\n.\ns/.//\n", outfile);
+	      insert_mode = false;
+	    }
+	  else
+	    print_1_line ("", &files[1].linbuf[i]);
+	}
+
+      if (insert_mode)
+	fputs (".\n", outfile);
+    }
+}
+
+/* Print change script in the style of ed commands,
+   but print the changes in the order they appear in the input files,
+   which means that the commands are not truly useful with ed.
+   Because of the issue with lines containing just a dot, the output
+   is not even parseable.  */
+
+void
+pr_forward_ed_script (struct change *script)
+{
+  print_script (script, find_change, pr_forward_ed_hunk);
+}
+
+static void
+pr_forward_ed_hunk (struct change *hunk)
+{
+  lin i, f0, l0, f1, l1;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes = analyze_hunk (hunk, &f0, &l0, &f1, &l1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  fputc (change_letter[changes], outfile);
+  print_number_range (' ', files, f0, l0);
+  fputc ('\n', outfile);
+
+  /* If deletion only, print just the number range.  */
+
+  if (changes == OLD)
+    return;
+
+  /* For insertion (with or without deletion), print the number range
+     and the lines from file 2.  */
+
+  for (i = f1; i <= l1; i++)
+    print_1_line ("", &files[1].linbuf[i]);
+
+  fputs (".\n", outfile);
+}
+
+/* Print in a format somewhat like ed commands
+   except that each insert command states the number of lines it inserts.
+   This format is used for RCS.  */
+
+void
+print_rcs_script (struct change *script)
+{
+  print_script (script, find_change, print_rcs_hunk);
+}
+
+/* Print a hunk of an RCS diff */
+
+static void
+print_rcs_hunk (struct change *hunk)
+{
+  lin i, f0, l0, f1, l1;
+  long int tf0, tl0, tf1, tl1;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes = analyze_hunk (hunk, &f0, &l0, &f1, &l1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  translate_range (&files[0], f0, l0, &tf0, &tl0);
+
+  if (changes & OLD)
+    {
+      /* For deletion, print just the starting line number from file 0
+	 and the number of lines deleted.  */
+      fprintf (outfile, "d%ld %ld\n", tf0, tf0 <= tl0 ? tl0 - tf0 + 1 : 1);
+    }
+
+  if (changes & NEW)
+    {
+      /* Take last-line-number from file 0 and # lines from file 1.  */
+      translate_range (&files[1], f1, l1, &tf1, &tl1);
+      fprintf (outfile, "a%ld %ld\n", tl0, tf1 <= tl1 ? tl1 - tf1 + 1 : 1);
+
+      /* Print the inserted lines.  */
+      for (i = f1; i <= l1; i++)
+	print_1_line ("", &files[1].linbuf[i]);
+    }
+}
diff --git a/test/diffutils-3.0-patch/ifdef.c b/test/diffutils-3.0-patch/ifdef.c
new file mode 100644
index 0000000..a48f830
--- /dev/null
+++ b/test/diffutils-3.0-patch/ifdef.c
@@ -0,0 +1,430 @@
+/* #ifdef-format output routines for GNU DIFF.
+
+   Copyright (C) 1989, 1991-1994, 2001-2002, 2004, 2006, 2009-2010 Free
+   Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   GNU DIFF is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.  No author or distributor
+   accepts responsibility to anyone for the consequences of using it
+   or for whether it serves any particular purpose or works at all,
+   unless he says so in writing.  Refer to the GNU General Public
+   License for full details.
+
+   Everyone is granted permission to copy, modify and redistribute
+   GNU DIFF, but only under the conditions described in the
+   GNU General Public License.   A copy of this license is
+   supposed to have been given to you along with GNU DIFF so you
+   can know your rights and responsibilities.  It should be in a
+   file named COPYING.  Among other things, the copyright notice
+   and this notice must be preserved on all copies.  */
+
+#include "diff.h"
+
+#include <xalloc.h>
+
+struct group
+{
+  struct file_data const *file;
+  lin from, upto; /* start and limit lines for this group of lines */
+};
+
+static char const *format_group (FILE *, char const *, char,
+				 struct group const *);
+static char const *do_printf_spec (FILE *, char const *,
+				   struct file_data const *, lin,
+				   struct group const *);
+static char const *scan_char_literal (char const *, char *);
+static lin groups_letter_value (struct group const *, char);
+static void format_ifdef (char const *, lin, lin, lin, lin);
+static void print_ifdef_hunk (struct change *);
+static void print_ifdef_lines (FILE *, char const *, struct group const *);
+
+static lin next_line0;
+static lin next_line1;
+
+/* Print the edit-script SCRIPT as a merged #ifdef file.  */
+
+void
+print_ifdef_script (struct change *script)
+{
+  next_line0 = next_line1 = - files[0].prefix_lines;
+  print_script (script, find_change, print_ifdef_hunk);
+  if (next_line0 < files[0].valid_lines
+      || next_line1 < files[1].valid_lines)
+    {
+      begin_output ();
+      format_ifdef (group_format[UNCHANGED],
+		    next_line0, files[0].valid_lines,
+		    next_line1, files[1].valid_lines);
+    }
+}
+
+/* Print a hunk of an ifdef diff.
+   This is a contiguous portion of a complete edit script,
+   describing changes in consecutive lines.  */
+
+static void
+print_ifdef_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes = analyze_hunk (hunk, &first0, &last0, &first1, &last1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  /* Print lines up to this change.  */
+  if (next_line0 < first0 || next_line1 < first1)
+    format_ifdef (group_format[UNCHANGED],
+		  next_line0, first0,
+		  next_line1, first1);
+
+  /* Print this change.  */
+  next_line0 = last0 + 1;
+  next_line1 = last1 + 1;
+  format_ifdef (group_format[changes],
+		first0, next_line0,
+		first1, next_line1);
+}
+
+/* Print a set of lines according to FORMAT.
+   Lines BEG0 up to END0 are from the first file;
+   lines BEG1 up to END1 are from the second file.  */
+
+static void
+format_ifdef (char const *format, lin beg0, lin end0, lin beg1, lin end1)
+{
+  struct group groups[2];
+
+  groups[0].file = &files[0];
+  groups[0].from = beg0;
+  groups[0].upto = end0;
+  groups[1].file = &files[1];
+  groups[1].from = beg1;
+  groups[1].upto = end1;
+  format_group (outfile, format, 0, groups);
+}
+
+/* Print to file OUT a set of lines according to FORMAT.
+   The format ends at the first free instance of ENDCHAR.
+   Yield the address of the terminating character.
+   GROUPS specifies which lines to print.
+   If OUT is zero, do not actually print anything; just scan the format.  */
+
+static char const *
+format_group (register FILE *out, char const *format, char endchar,
+	      struct group const *groups)
+{
+  register char c;
+  register char const *f = format;
+
+  while ((c = *f) != endchar && c != 0)
+    {
+      char const *f1 = ++f;
+      if (c == '%')
+	switch ((c = *f++))
+	  {
+	  case '%':
+	    break;
+
+	  case '(':
+	    /* Print if-then-else format e.g. `%(n=1?thenpart:elsepart)'.  */
+	    {
+	      int i;
+	      uintmax_t value[2];
+	      FILE *thenout, *elseout;
+
+	      for (i = 0; i < 2; i++)
+		{
+		  if (ISDIGIT (*f))
+		    {
+		      char *fend;
+		      errno = 0;
+		      value[i] = strtoumax (f, &fend, 10);
+		      if (errno)
+			goto bad_format;
+		      f = fend;
+		    }
+		  else
+		    {
+		      value[i] = groups_letter_value (groups, *f);
+		      if (value[i] == -1)
+			goto bad_format;
+		      f++;
+		    }
+		  if (*f++ != "=?"[i])
+		    goto bad_format;
+		}
+	      if (value[0] == value[1])
+		thenout = out, elseout = 0;
+	      else
+		thenout = 0, elseout = out;
+	      f = format_group (thenout, f, ':', groups);
+	      if (*f)
+		{
+		  f = format_group (elseout, f + 1, ')', groups);
+		  if (*f)
+		    f++;
+		}
+	    }
+	    continue;
+
+	  case '<':
+	    /* Print lines deleted from first file.  */
+	    print_ifdef_lines (out, line_format[OLD], &groups[0]);
+	    continue;
+
+	  case '=':
+	    /* Print common lines.  */
+	    print_ifdef_lines (out, line_format[UNCHANGED], &groups[0]);
+	    continue;
+
+	  case '>':
+	    /* Print lines inserted from second file.  */
+	    print_ifdef_lines (out, line_format[NEW], &groups[1]);
+	    continue;
+
+	  default:
+	    f = do_printf_spec (out, f - 2, 0, 0, groups);
+	    if (f)
+	      continue;
+	    /* Fall through. */
+	  bad_format:
+	    c = '%';
+	    f = f1;
+	    break;
+	  }
+
+      if (out)
+	putc (c, out);
+    }
+
+  return f;
+}
+
+/* For the line group pair G, return the number corresponding to LETTER.
+   Return -1 if LETTER is not a group format letter.  */
+static lin
+groups_letter_value (struct group const *g, char letter)
+{
+  switch (letter)
+    {
+    case 'E': letter = 'e'; g++; break;
+    case 'F': letter = 'f'; g++; break;
+    case 'L': letter = 'l'; g++; break;
+    case 'M': letter = 'm'; g++; break;
+    case 'N': letter = 'n'; g++; break;
+    }
+
+  switch (letter)
+    {
+      case 'e': return translate_line_number (g->file, g->from) - 1;
+      case 'f': return translate_line_number (g->file, g->from);
+      case 'l': return translate_line_number (g->file, g->upto) - 1;
+      case 'm': return translate_line_number (g->file, g->upto);
+      case 'n': return g->upto - g->from;
+      default: return -1;
+    }
+}
+
+/* Print to file OUT, using FORMAT to print the line group GROUP.
+   But do nothing if OUT is zero.  */
+static void
+print_ifdef_lines (register FILE *out, char const *format,
+		   struct group const *group)
+{
+  struct file_data const *file = group->file;
+  char const * const *linbuf = file->linbuf;
+  lin from = group->from, upto = group->upto;
+
+  if (!out)
+    return;
+
+  /* If possible, use a single fwrite; it's faster.  */
+  if (!expand_tabs && format[0] == '%')
+    {
+      if (format[1] == 'l' && format[2] == '\n' && !format[3] && from < upto)
+	{
+	  fwrite (linbuf[from], sizeof (char),
+		  linbuf[upto] + (linbuf[upto][-1] != '\n') -  linbuf[from],
+		  out);
+	  return;
+	}
+      if (format[1] == 'L' && !format[2])
+	{
+	  fwrite (linbuf[from], sizeof (char),
+		  linbuf[upto] -  linbuf[from], out);
+	  return;
+	}
+    }
+
+  for (;  from < upto;  from++)
+    {
+      register char c;
+      register char const *f = format;
+
+      while ((c = *f++) != 0)
+	{
+	  char const *f1 = f;
+	  if (c == '%')
+	    switch ((c = *f++))
+	      {
+	      case '%':
+		break;
+
+	      case 'l':
+		output_1_line (linbuf[from],
+			       (linbuf[from + 1]
+				- (linbuf[from + 1][-1] == '\n')),
+			       0, 0);
+		continue;
+
+	      case 'L':
+		output_1_line (linbuf[from], linbuf[from + 1], 0, 0);
+		continue;
+
+	      default:
+		f = do_printf_spec (out, f - 2, file, from, 0);
+		if (f)
+		  continue;
+		c = '%';
+		f = f1;
+		break;
+	      }
+
+	  putc (c, out);
+	}
+    }
+}
+
+static char const *
+do_printf_spec (FILE *out, char const *spec,
+		struct file_data const *file, lin n,
+		struct group const *groups)
+{
+  char const *f = spec;
+  char c;
+  char c1;
+
+  /* Scan printf-style SPEC of the form %[-'0]*[0-9]*(.[0-9]*)?[cdoxX].  */
+  /* assert (*f == '%'); */
+  f++;
+  while ((c = *f++) == '-' || c == '\'' || c == '0')
+    continue;
+  while (ISDIGIT (c))
+    c = *f++;
+  if (c == '.')
+    while (ISDIGIT (c = *f++))
+      continue;
+  c1 = *f++;
+
+  switch (c)
+    {
+    case 'c':
+      if (c1 != '\'')
+	return 0;
+      else
+	{
+	  char value IF_LINT (= 0);
+	  f = scan_char_literal (f, &value);
+	  if (!f)
+	    return 0;
+	  if (out)
+	    putc (value, out);
+	}
+      break;
+
+    case 'd': case 'o': case 'x': case 'X':
+      {
+	lin value;
+
+	if (file)
+	  {
+	    if (c1 != 'n')
+	      return 0;
+	    value = translate_line_number (file, n);
+	  }
+	else
+	  {
+	    value = groups_letter_value (groups, c1);
+	    if (value < 0)
+	      return 0;
+	  }
+
+	if (out)
+	  {
+	    /* For example, if the spec is "%3xn", use the printf
+	       format spec "%3lx".  Here the spec prefix is "%3".  */
+	    long int long_value = value;
+	    size_t spec_prefix_len = f - spec - 2;
+#if HAVE_C_VARARRAYS
+	    char format[spec_prefix_len + 3];
+#else
+	    char *format = xmalloc (spec_prefix_len + 3);
+#endif
+	    char *p = format + spec_prefix_len;
+	    memcpy (format, spec, spec_prefix_len);
+	    *p++ = 'l';
+	    *p++ = c;
+	    *p = '\0';
+	    fprintf (out, format, long_value);
+#if ! HAVE_C_VARARRAYS
+	    free (format);
+#endif
+	  }
+      }
+      break;
+
+    default:
+      return 0;
+    }
+
+  return f;
+}
+
+/* Scan the character literal represented in the string LIT; LIT points just
+   after the initial apostrophe.  Put the literal's value into *VALPTR.
+   Yield the address of the first character after the closing apostrophe,
+   or a null pointer if the literal is ill-formed.  */
+static char const *
+scan_char_literal (char const *lit, char *valptr)
+{
+  register char const *p = lit;
+  char value;
+  ptrdiff_t digits;
+  char c = *p++;
+
+  switch (c)
+    {
+      case 0:
+      case '\'':
+	return NULL;
+
+      case '\\':
+	value = 0;
+	while ((c = *p++) != '\'')
+	  {
+	    unsigned int digit = c - '0';
+	    if (8 <= digit)
+	      return NULL;
+	    value = 8 * value + digit;
+	  }
+	digits = p - lit - 2;
+	if (! (1 <= digits && digits <= 3))
+	  return NULL;
+	break;
+
+      default:
+	value = c;
+	if (*p++ != '\'')
+	  return NULL;
+	break;
+    }
+
+  *valptr = value;
+  return p;
+}
diff --git a/test/diffutils-3.0-patch/io.c b/test/diffutils-3.0-patch/io.c
new file mode 100644
index 0000000..031be3d
--- /dev/null
+++ b/test/diffutils-3.0-patch/io.c
@@ -0,0 +1,845 @@
+/* File I/O for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <cmpbuf.h>
+#include <file-type.h>
+#include <xalloc.h>
+
+/* Rotate an unsigned value to the left.  */
+#define ROL(v, n) ((v) << (n) | (v) >> (sizeof (v) * CHAR_BIT - (n)))
+
+/* Given a hash value and a new character, return a new hash value.  */
+#define HASH(h, c) ((c) + ROL (h, 7))
+
+/* The type of a hash value.  */
+typedef size_t hash_value;
+verify (! TYPE_SIGNED (hash_value));
+
+/* Lines are put into equivalence classes of lines that match in lines_differ.
+   Each equivalence class is represented by one of these structures,
+   but only while the classes are being computed.
+   Afterward, each class is represented by a number.  */
+struct equivclass
+{
+  lin next;		/* Next item in this bucket.  */
+  hash_value hash;	/* Hash of lines in this class.  */
+  char const *line;	/* A line that fits this class.  */
+  size_t length;	/* That line's length, not counting its newline.  */
+};
+
+/* Hash-table: array of buckets, each being a chain of equivalence classes.
+   buckets[-1] is reserved for incomplete lines.  */
+static lin *buckets;
+
+/* Number of buckets in the hash table array, not counting buckets[-1].  */
+static size_t nbuckets;
+
+/* Array in which the equivalence classes are allocated.
+   The bucket-chains go through the elements in this array.
+   The number of an equivalence class is its index in this array.  */
+static struct equivclass *equivs;
+
+/* Index of first free element in the array `equivs'.  */
+static lin equivs_index;
+
+/* Number of elements allocated in the array `equivs'.  */
+static lin equivs_alloc;
+
+/* Read a block of data into a file buffer, checking for EOF and error.  */
+
+void
+file_block_read (struct file_data *current, size_t size)
+{
+  if (size && ! current->eof)
+    {
+      size_t s = block_read (current->desc,
+			     FILE_BUFFER (current) + current->buffered, size);
+      if (s == SIZE_MAX)
+	pfatal_with_name (current->name);
+      current->buffered += s;
+      current->eof = s < size;
+    }
+}
+
+/* Check for binary files and compare them for exact identity.  */
+
+/* Return 1 if BUF contains a non text character.
+   SIZE is the number of characters in BUF.  */
+
+#define binary_file_p(buf, size) (memchr (buf, 0, size) != 0)
+
+/* Get ready to read the current file.
+   Return nonzero if SKIP_TEST is zero,
+   and if it appears to be a binary file.  */
+
+static bool
+sip (struct file_data *current, bool skip_test)
+{
+  /* If we have a nonexistent file at this stage, treat it as empty.  */
+  if (current->desc < 0)
+    {
+      /* Leave room for a sentinel.  */
+      current->bufsize = sizeof (word);
+      current->buffer = xmalloc (current->bufsize);
+    }
+  else
+    {
+      current->bufsize = buffer_lcm (sizeof (word),
+				     STAT_BLOCKSIZE (current->stat),
+				     PTRDIFF_MAX - 2 * sizeof (word));
+      current->buffer = xmalloc (current->bufsize);
+
+      if (! skip_test)
+	{
+	  /* Check first part of file to see if it's a binary file.  */
+
+	  /* FIXME: if O_BINARY, this should revert to text mode
+	     if the file is not binary.  */
+
+	  file_block_read (current, current->bufsize);
+	  return binary_file_p (current->buffer, current->buffered);
+	}
+    }
+
+  current->buffered = 0;
+  current->eof = false;
+  return false;
+}
+
+/* Slurp the rest of the current file completely into memory.  */
+
+static void
+slurp (struct file_data *current)
+{
+  size_t cc;
+
+  if (current->desc < 0)
+    {
+      /* The file is nonexistent.  */
+      return;
+    }
+
+  if (S_ISREG (current->stat.st_mode))
+    {
+      /* It's a regular file; slurp in the rest all at once.  */
+
+      /* Get the size out of the stat block.
+	 Allocate just enough room for appended newline plus word sentinel,
+	 plus word-alignment since we want the buffer word-aligned.  */
+      size_t file_size = current->stat.st_size;
+      cc = file_size + 2 * sizeof (word) - file_size % sizeof (word);
+      if (file_size != current->stat.st_size || cc < file_size
+	  || PTRDIFF_MAX <= cc)
+	xalloc_die ();
+
+      if (current->bufsize < cc)
+	{
+	  current->bufsize = cc;
+	  current->buffer = xrealloc (current->buffer, cc);
+	}
+
+      /* Try to read at least 1 more byte than the size indicates, to
+	 detect whether the file is growing.  This is a nicety for
+	 users who run 'diff' on files while they are changing.  */
+
+      if (current->buffered <= file_size)
+	{
+	  file_block_read (current, file_size + 1 - current->buffered);
+	  if (current->buffered <= file_size)
+	    return;
+	}
+    }
+
+  /* It's not a regular file, or it's a growing regular file; read it,
+     growing the buffer as needed.  */
+
+  file_block_read (current, current->bufsize - current->buffered);
+
+  if (current->buffered)
+    {
+      while (current->buffered == current->bufsize)
+	{
+	  if (PTRDIFF_MAX / 2 - sizeof (word) < current->bufsize)
+	    xalloc_die ();
+	  current->bufsize *= 2;
+	  current->buffer = xrealloc (current->buffer, current->bufsize);
+	  file_block_read (current, current->bufsize - current->buffered);
+	}
+
+      /* Allocate just enough room for appended newline plus word
+	 sentinel, plus word-alignment.  */
+      cc = current->buffered + 2 * sizeof (word);
+      current->bufsize = cc - cc % sizeof (word);
+      current->buffer = xrealloc (current->buffer, current->bufsize);
+    }
+}
+
+/* Split the file into lines, simultaneously computing the equivalence
+   class for each line.  */
+
+static void
+find_and_hash_each_line (struct file_data *current)
+{
+  hash_value h;
+  char const *p = current->prefix_end;
+  unsigned char c;
+  lin i, *bucket;
+  size_t length;
+
+  /* Cache often-used quantities in local variables to help the compiler.  */
+  char const **linbuf = current->linbuf;
+  lin alloc_lines = current->alloc_lines;
+  lin line = 0;
+  lin linbuf_base = current->linbuf_base;
+  lin *cureqs = xmalloc (alloc_lines * sizeof *cureqs);
+  struct equivclass *eqs = equivs;
+  lin eqs_index = equivs_index;
+  lin eqs_alloc = equivs_alloc;
+  char const *suffix_begin = current->suffix_begin;
+  char const *bufend = FILE_BUFFER (current) + current->buffered;
+  bool diff_length_compare_anyway =
+    ignore_white_space != IGNORE_NO_WHITE_SPACE;
+  bool same_length_diff_contents_compare_anyway =
+    diff_length_compare_anyway | ignore_case;
+
+  while (p < suffix_begin)
+    {
+      char const *ip = p;
+
+      h = 0;
+
+      /* Hash this line until we find a newline.  */
+      if (ignore_case)
+	switch (ignore_white_space)
+	  {
+	  case IGNORE_ALL_SPACE:
+	    while ((c = *p++) != '\n')
+	      if (! isspace (c))
+		h = HASH (h, tolower (c));
+	    break;
+
+	  case IGNORE_SPACE_CHANGE:
+	    while ((c = *p++) != '\n')
+	      {
+		if (isspace (c))
+		  {
+		    do
+		      if ((c = *p++) == '\n')
+			goto hashing_done;
+		    while (isspace (c));
+
+		    h = HASH (h, ' ');
+		  }
+
+		/* C is now the first non-space.  */
+		h = HASH (h, tolower (c));
+	      }
+	    break;
+
+	  case IGNORE_TAB_EXPANSION:
+	    {
+	      size_t column = 0;
+	      while ((c = *p++) != '\n')
+		{
+		  size_t repetitions = 1;
+
+		  switch (c)
+		    {
+		    case '\b':
+		      column -= 0 < column;
+		      break;
+
+		    case '\t':
+		      c = ' ';
+		      repetitions = tabsize - column % tabsize;
+		      column = (column + repetitions < column
+				? 0
+				: column + repetitions);
+		      break;
+
+		    case '\r':
+		      column = 0;
+		      break;
+
+		    default:
+		      c = tolower (c);
+		      column++;
+		      break;
+		    }
+
+		  do
+		    h = HASH (h, c);
+		  while (--repetitions != 0);
+		}
+	    }
+	    break;
+
+	  default:
+	    while ((c = *p++) != '\n')
+	      h = HASH (h, tolower (c));
+	    break;
+	  }
+      else
+	switch (ignore_white_space)
+	  {
+	  case IGNORE_ALL_SPACE:
+	    while ((c = *p++) != '\n')
+	      if (! isspace (c))
+		h = HASH (h, c);
+	    break;
+
+	  case IGNORE_SPACE_CHANGE:
+	    while ((c = *p++) != '\n')
+	      {
+		if (isspace (c))
+		  {
+		    do
+		      if ((c = *p++) == '\n')
+			goto hashing_done;
+		    while (isspace (c));
+
+		    h = HASH (h, ' ');
+		  }
+
+		/* C is now the first non-space.  */
+		h = HASH (h, c);
+	      }
+	    break;
+
+	  case IGNORE_TAB_EXPANSION:
+	    {
+	      size_t column = 0;
+	      while ((c = *p++) != '\n')
+		{
+		  size_t repetitions = 1;
+
+		  switch (c)
+		    {
+		    case '\b':
+		      column -= 0 < column;
+		      break;
+
+		    case '\t':
+		      c = ' ';
+		      repetitions = tabsize - column % tabsize;
+		      column = (column + repetitions < column
+				? 0
+				: column + repetitions);
+		      break;
+
+		    case '\r':
+		      column = 0;
+		      break;
+
+		    default:
+		      column++;
+		      break;
+		    }
+
+		  do
+		    h = HASH (h, c);
+		  while (--repetitions != 0);
+		}
+	    }
+	    break;
+
+	  default:
+	    while ((c = *p++) != '\n')
+	      h = HASH (h, c);
+	    break;
+	  }
+
+   hashing_done:;
+
+      bucket = &buckets[h % nbuckets];
+      length = p - ip - 1;
+
+      if (p == bufend
+	  && current->missing_newline
+	  && ROBUST_OUTPUT_STYLE (output_style))
+	{
+	  /* The last line is incomplete and we do not silently
+	     complete lines.  If the line cannot compare equal to any
+	     complete line, put it into buckets[-1] so that it can
+	     compare equal only to the other file's incomplete line
+	     (if one exists).  */
+	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
+	    bucket = &buckets[-1];
+	}
+
+      for (i = *bucket;  ;  i = eqs[i].next)
+	if (!i)
+	  {
+	    /* Create a new equivalence class in this bucket.  */
+	    i = eqs_index++;
+	    if (i == eqs_alloc)
+	      {
+		if (PTRDIFF_MAX / (2 * sizeof *eqs) <= eqs_alloc)
+		  xalloc_die ();
+		eqs_alloc *= 2;
+		eqs = xrealloc (eqs, eqs_alloc * sizeof *eqs);
+	      }
+	    eqs[i].next = *bucket;
+	    eqs[i].hash = h;
+	    eqs[i].line = ip;
+	    eqs[i].length = length;
+	    *bucket = i;
+	    break;
+	  }
+	else if (eqs[i].hash == h)
+	  {
+	    char const *eqline = eqs[i].line;
+
+	    /* Reuse existing class if lines_differ reports the lines
+               equal.  */
+	    if (eqs[i].length == length)
+	      {
+		/* Reuse existing equivalence class if the lines are identical.
+		   This detects the common case of exact identity
+		   faster than lines_differ would.  */
+		if (memcmp (eqline, ip, length) == 0)
+		  break;
+		if (!same_length_diff_contents_compare_anyway)
+		  continue;
+	      }
+	    else if (!diff_length_compare_anyway)
+	      continue;
+
+	    if (! lines_differ (eqline, ip))
+	      break;
+	  }
+
+      /* Maybe increase the size of the line table.  */
+      if (line == alloc_lines)
+	{
+	  /* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
+	  if (PTRDIFF_MAX / 3 <= alloc_lines
+	      || PTRDIFF_MAX / sizeof *cureqs <= 2 * alloc_lines - linbuf_base
+	      || PTRDIFF_MAX / sizeof *linbuf <= alloc_lines - linbuf_base)
+	    xalloc_die ();
+	  alloc_lines = 2 * alloc_lines - linbuf_base;
+	  cureqs = xrealloc (cureqs, alloc_lines * sizeof *cureqs);
+	  linbuf += linbuf_base;
+	  linbuf = xrealloc (linbuf,
+			     (alloc_lines - linbuf_base) * sizeof *linbuf);
+	  linbuf -= linbuf_base;
+	}
+      linbuf[line] = ip;
+      cureqs[line] = i;
+      ++line;
+    }
+
+  current->buffered_lines = line;
+
+  for (i = 0;  ;  i++)
+    {
+      /* Record the line start for lines in the suffix that we care about.
+	 Record one more line start than lines,
+	 so that we can compute the length of any buffered line.  */
+      if (line == alloc_lines)
+	{
+	  /* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
+	  if (PTRDIFF_MAX / 3 <= alloc_lines
+	      || PTRDIFF_MAX / sizeof *cureqs <= 2 * alloc_lines - linbuf_base
+	      || PTRDIFF_MAX / sizeof *linbuf <= alloc_lines - linbuf_base)
+	    xalloc_die ();
+	  alloc_lines = 2 * alloc_lines - linbuf_base;
+	  linbuf += linbuf_base;
+	  linbuf = xrealloc (linbuf,
+			     (alloc_lines - linbuf_base) * sizeof *linbuf);
+	  linbuf -= linbuf_base;
+	}
+      linbuf[line] = p;
+
+      if (p == bufend)
+	{
+	  /* If the last line is incomplete and we do not silently
+	     complete lines, don't count its appended newline.  */
+	  if (current->missing_newline && ROBUST_OUTPUT_STYLE (output_style))
+	    linbuf[line]--;
+	  break;
+	}
+
+      if (context <= i && no_diff_means_no_output)
+	break;
+
+      line++;
+
+      while (*p++ != '\n')
+	continue;
+    }
+
+  /* Done with cache in local variables.  */
+  current->linbuf = linbuf;
+  current->valid_lines = line;
+  current->alloc_lines = alloc_lines;
+  current->equivs = cureqs;
+  equivs = eqs;
+  equivs_alloc = eqs_alloc;
+  equivs_index = eqs_index;
+}
+
+/* Prepare the text.  Make sure the text end is initialized.
+   Make sure text ends in a newline,
+   but remember that we had to add one.
+   Strip trailing CRs, if that was requested.  */
+
+static void
+prepare_text (struct file_data *current)
+{
+  size_t buffered = current->buffered;
+  char *p = FILE_BUFFER (current);
+  char *dst;
+
+  if (buffered == 0 || p[buffered - 1] == '\n')
+    current->missing_newline = false;
+  else
+    {
+      p[buffered++] = '\n';
+      current->missing_newline = true;
+    }
+
+  if (!p)
+    return;
+
+  /* Don't use uninitialized storage when planting or using sentinels.  */
+  memset (p + buffered, 0, sizeof (word));
+
+  if (strip_trailing_cr && (dst = memchr (p, '\r', buffered)))
+    {
+      char const *src = dst;
+      char const *srclim = p + buffered;
+
+      do
+	dst += ! ((*dst = *src++) == '\r' && *src == '\n');
+      while (src < srclim);
+
+      buffered -= src - dst;
+    }
+
+  current->buffered = buffered;
+}
+
+/* We have found N lines in a buffer of size S; guess the
+   proportionate number of lines that will be found in a buffer of
+   size T.  However, do not guess a number of lines so large that the
+   resulting line table might cause overflow in size calculations.  */
+static lin
+guess_lines (lin n, size_t s, size_t t)
+{
+  size_t guessed_bytes_per_line = n < 10 ? 32 : s / (n - 1);
+  lin guessed_lines = MAX (1, t / guessed_bytes_per_line);
+  return MIN (guessed_lines, PTRDIFF_MAX / (2 * sizeof (char *) + 1) - 5) + 5;
+}
+
+/* Given a vector of two file_data objects, find the identical
+   prefixes and suffixes of each object.  */
+
+static void
+find_identical_ends (struct file_data filevec[])
+{
+  word *w0, *w1;
+  char *p0, *p1, *buffer0, *buffer1;
+  char const *end0, *beg0;
+  char const **linbuf0, **linbuf1;
+  lin i, lines;
+  size_t n0, n1;
+  lin alloc_lines0, alloc_lines1;
+  lin buffered_prefix, prefix_count, prefix_mask;
+  lin middle_guess, suffix_guess;
+
+  slurp (&filevec[0]);
+  prepare_text (&filevec[0]);
+  if (filevec[0].desc != filevec[1].desc)
+    {
+      slurp (&filevec[1]);
+      prepare_text (&filevec[1]);
+    }
+  else
+    {
+      filevec[1].buffer = filevec[0].buffer;
+      filevec[1].bufsize = filevec[0].bufsize;
+      filevec[1].buffered = filevec[0].buffered;
+      filevec[1].missing_newline = filevec[0].missing_newline;
+    }
+
+  /* Find identical prefix.  */
+
+  w0 = filevec[0].buffer;
+  w1 = filevec[1].buffer;
+  p0 = buffer0 = (char *) w0;
+  p1 = buffer1 = (char *) w1;
+  n0 = filevec[0].buffered;
+  n1 = filevec[1].buffered;
+
+  if (p0 == p1)
+    /* The buffers are the same; sentinels won't work.  */
+    p0 = p1 += n1;
+  else
+    {
+      /* Insert end sentinels, in this case characters that are guaranteed
+	 to make the equality test false, and thus terminate the loop.  */
+
+      if (n0 < n1)
+	p0[n0] = ~p1[n0];
+      else
+	p1[n1] = ~p0[n1];
+
+      /* Loop until first mismatch, or to the sentinel characters.  */
+
+      /* Compare a word at a time for speed.  */
+      while (*w0 == *w1)
+	w0++, w1++;
+
+      /* Do the last few bytes of comparison a byte at a time.  */
+      p0 = (char *) w0;
+      p1 = (char *) w1;
+      while (*p0 == *p1)
+	p0++, p1++;
+
+      /* Don't mistakenly count missing newline as part of prefix.  */
+      if (ROBUST_OUTPUT_STYLE (output_style)
+	  && ((buffer0 + n0 - filevec[0].missing_newline < p0)
+	      !=
+	      (buffer1 + n1 - filevec[1].missing_newline < p1)))
+	p0--, p1--;
+    }
+
+  /* Now P0 and P1 point at the first nonmatching characters.  */
+
+  /* Skip back to last line-beginning in the prefix,
+     and then discard up to HORIZON_LINES lines from the prefix.  */
+  i = horizon_lines;
+  while (p0 != buffer0 && (p0[-1] != '\n' || i--))
+    p0--, p1--;
+
+  /* Record the prefix.  */
+  filevec[0].prefix_end = p0;
+  filevec[1].prefix_end = p1;
+
+  /* Find identical suffix.  */
+
+  /* P0 and P1 point beyond the last chars not yet compared.  */
+  p0 = buffer0 + n0;
+  p1 = buffer1 + n1;
+
+  if (! ROBUST_OUTPUT_STYLE (output_style)
+      || filevec[0].missing_newline == filevec[1].missing_newline)
+    {
+      end0 = p0;	/* Addr of last char in file 0.  */
+
+      /* Get value of P0 at which we should stop scanning backward:
+	 this is when either P0 or P1 points just past the last char
+	 of the identical prefix.  */
+      beg0 = filevec[0].prefix_end + (n0 < n1 ? 0 : n0 - n1);
+
+      /* Scan back until chars don't match or we reach that point.  */
+      while (p0 != beg0)
+	if (*--p0 != *--p1)
+	  {
+	    /* Point at the first char of the matching suffix.  */
+	    ++p0, ++p1;
+	    beg0 = p0;
+	    break;
+	  }
+
+      /* Are we at a line-beginning in both files?  If not, add the rest of
+	 this line to the main body.  Discard up to HORIZON_LINES lines from
+	 the identical suffix.  Also, discard one extra line,
+	 because shift_boundaries may need it.  */
+      i = horizon_lines + !((buffer0 == p0 || p0[-1] == '\n')
+			    &&
+			    (buffer1 == p1 || p1[-1] == '\n'));
+      while (i-- && p0 != end0)
+	while (*p0++ != '\n')
+	  continue;
+
+      p1 += p0 - beg0;
+    }
+
+  /* Record the suffix.  */
+  filevec[0].suffix_begin = p0;
+  filevec[1].suffix_begin = p1;
+
+  /* Calculate number of lines of prefix to save.
+
+     prefix_count == 0 means save the whole prefix;
+     we need this for options like -D that output the whole file,
+     or for enormous contexts (to avoid worrying about arithmetic overflow).
+     We also need it for options like -F that output some preceding line;
+     at least we will need to find the last few lines,
+     but since we don't know how many, it's easiest to find them all.
+
+     Otherwise, prefix_count != 0.  Save just prefix_count lines at start
+     of the line buffer; they'll be moved to the proper location later.
+     Handle 1 more line than the context says (because we count 1 too many),
+     rounded up to the next power of 2 to speed index computation.  */
+
+  if (no_diff_means_no_output && ! function_regexp.fastmap
+      && context < LIN_MAX / 4 && context < n0)
+    {
+      middle_guess = guess_lines (0, 0, p0 - filevec[0].prefix_end);
+      suffix_guess = guess_lines (0, 0, buffer0 + n0 - p0);
+      for (prefix_count = 1;  prefix_count <= context;  prefix_count *= 2)
+	continue;
+      alloc_lines0 = (prefix_count + middle_guess
+		      + MIN (context, suffix_guess));
+    }
+  else
+    {
+      prefix_count = 0;
+      alloc_lines0 = guess_lines (0, 0, n0);
+    }
+
+  prefix_mask = prefix_count - 1;
+  lines = 0;
+  linbuf0 = xmalloc (alloc_lines0 * sizeof *linbuf0);
+  p0 = buffer0;
+
+  /* If the prefix is needed, find the prefix lines.  */
+  if (! (no_diff_means_no_output
+	 && filevec[0].prefix_end == p0
+	 && filevec[1].prefix_end == p1))
+    {
+      end0 = filevec[0].prefix_end;
+      while (p0 != end0)
+	{
+	  lin l = lines++ & prefix_mask;
+	  if (l == alloc_lines0)
+	    {
+	      if (PTRDIFF_MAX / (2 * sizeof *linbuf0) <= alloc_lines0)
+		xalloc_die ();
+	      alloc_lines0 *= 2;
+	      linbuf0 = xrealloc (linbuf0, alloc_lines0 * sizeof *linbuf0);
+	    }
+	  linbuf0[l] = p0;
+	  while (*p0++ != '\n')
+	    continue;
+	}
+    }
+  buffered_prefix = prefix_count && context < lines ? context : lines;
+
+  /* Allocate line buffer 1.  */
+
+  middle_guess = guess_lines (lines, p0 - buffer0, p1 - filevec[1].prefix_end);
+  suffix_guess = guess_lines (lines, p0 - buffer0, buffer1 + n1 - p1);
+  alloc_lines1 = buffered_prefix + middle_guess + MIN (context, suffix_guess);
+  if (alloc_lines1 < buffered_prefix
+      || PTRDIFF_MAX / sizeof *linbuf1 <= alloc_lines1)
+    xalloc_die ();
+  linbuf1 = xmalloc (alloc_lines1 * sizeof *linbuf1);
+
+  if (buffered_prefix != lines)
+    {
+      /* Rotate prefix lines to proper location.  */
+      for (i = 0;  i < buffered_prefix;  i++)
+	linbuf1[i] = linbuf0[(lines - context + i) & prefix_mask];
+      for (i = 0;  i < buffered_prefix;  i++)
+	linbuf0[i] = linbuf1[i];
+    }
+
+  /* Initialize line buffer 1 from line buffer 0.  */
+  for (i = 0; i < buffered_prefix; i++)
+    linbuf1[i] = linbuf0[i] - buffer0 + buffer1;
+
+  /* Record the line buffer, adjusted so that
+     linbuf[0] points at the first differing line.  */
+  filevec[0].linbuf = linbuf0 + buffered_prefix;
+  filevec[1].linbuf = linbuf1 + buffered_prefix;
+  filevec[0].linbuf_base = filevec[1].linbuf_base = - buffered_prefix;
+  filevec[0].alloc_lines = alloc_lines0 - buffered_prefix;
+  filevec[1].alloc_lines = alloc_lines1 - buffered_prefix;
+  filevec[0].prefix_lines = filevec[1].prefix_lines = lines;
+}
+
+/* If 1 < k, then (2**k - prime_offset[k]) is the largest prime less
+   than 2**k.  This table is derived from Chris K. Caldwell's list
+   <http://www.utm.edu/research/primes/lists/2small/>.  */
+
+static unsigned char const prime_offset[] =
+{
+  0, 0, 1, 1, 3, 1, 3, 1, 5, 3, 3, 9, 3, 1, 3, 19, 15, 1, 5, 1, 3, 9, 3,
+  15, 3, 39, 5, 39, 57, 3, 35, 1, 5, 9, 41, 31, 5, 25, 45, 7, 87, 21,
+  11, 57, 17, 55, 21, 115, 59, 81, 27, 129, 47, 111, 33, 55, 5, 13, 27,
+  55, 93, 1, 57, 25
+};
+
+/* Verify that this host's size_t is not too wide for the above table.  */
+
+verify (sizeof (size_t) * CHAR_BIT <= sizeof prime_offset);
+
+/* Given a vector of two file_data objects, read the file associated
+   with each one, and build the table of equivalence classes.
+   Return nonzero if either file appears to be a binary file.
+   If PRETEND_BINARY is nonzero, pretend they are binary regardless.  */
+
+bool
+read_files (struct file_data filevec[], bool pretend_binary)
+{
+  int i;
+  bool skip_test = text | pretend_binary;
+  bool appears_binary = pretend_binary | sip (&filevec[0], skip_test);
+
+  if (filevec[0].desc != filevec[1].desc)
+    appears_binary |= sip (&filevec[1], skip_test | appears_binary);
+  else
+    {
+      filevec[1].buffer = filevec[0].buffer;
+      filevec[1].bufsize = filevec[0].bufsize;
+      filevec[1].buffered = filevec[0].buffered;
+    }
+  if (appears_binary)
+    {
+      /* FIXME: If O_BINARY, this should set both files to binary mode.  */
+      return true;
+    }
+
+  find_identical_ends (filevec);
+
+  equivs_alloc = filevec[0].alloc_lines + filevec[1].alloc_lines + 1;
+  if (PTRDIFF_MAX / sizeof *equivs <= equivs_alloc)
+    xalloc_die ();
+  equivs = xmalloc (equivs_alloc * sizeof *equivs);
+  /* Equivalence class 0 is permanently safe for lines that were not
+     hashed.  Real equivalence classes start at 1.  */
+  equivs_index = 1;
+
+  /* Allocate (one plus) a prime number of hash buckets.  Use a prime
+     number between 1/3 and 2/3 of the value of equiv_allocs,
+     approximately.  */
+  for (i = 9; (size_t) 1 << i < equivs_alloc / 3; i++)
+    continue;
+  nbuckets = ((size_t) 1 << i) - prime_offset[i];
+  if (PTRDIFF_MAX / sizeof *buckets <= nbuckets)
+    xalloc_die ();
+  buckets = zalloc ((nbuckets + 1) * sizeof *buckets);
+  buckets++;
+
+  for (i = 0; i < 2; i++)
+    find_and_hash_each_line (&filevec[i]);
+
+  filevec[0].equiv_max = filevec[1].equiv_max = equivs_index;
+
+  free (equivs);
+  free (buckets - 1);
+
+  return false;
+}
diff --git a/test/diffutils-3.0-patch/normal.c b/test/diffutils-3.0-patch/normal.c
new file mode 100644
index 0000000..154efaa
--- /dev/null
+++ b/test/diffutils-3.0-patch/normal.c
@@ -0,0 +1,69 @@
+/* Normal-format output routines for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1993, 1995, 1998, 2001, 2006, 2009-2010 Free
+   Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+
+static void print_normal_hunk (struct change *);
+
+/* Print the edit-script SCRIPT as a normal diff.
+   INF points to an array of descriptions of the two files.  */
+
+void
+print_normal_script (struct change *script)
+{
+  print_script (script, find_change, print_normal_hunk);
+}
+
+/* Print a hunk of a normal diff.
+   This is a contiguous portion of a complete edit script,
+   describing changes in consecutive lines.  */
+
+static void
+print_normal_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1;
+  register lin i;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes = analyze_hunk (hunk, &first0, &last0, &first1, &last1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  /* Print out the line number header for this hunk */
+  print_number_range (',', &files[0], first0, last0);
+  fputc (change_letter[changes], outfile);
+  print_number_range (',', &files[1], first1, last1);
+  fputc ('\n', outfile);
+
+  /* Print the lines that the first file has.  */
+  if (changes & OLD)
+    for (i = first0; i <= last0; i++)
+      print_1_line ("<", &files[0].linbuf[i]);
+
+  if (changes == CHANGED)
+    fputs ("---\n", outfile);
+
+  /* Print the lines that the second file has.  */
+  if (changes & NEW)
+    for (i = first1; i <= last1; i++)
+      print_1_line (">", &files[1].linbuf[i]);
+}
diff --git a/test/diffutils-3.0-patch/paths.h b/test/diffutils-3.0-patch/paths.h
new file mode 100644
index 0000000..86dc41c
--- /dev/null
+++ b/test/diffutils-3.0-patch/paths.h
@@ -0,0 +1,2 @@
+#define DEFAULT_DIFF_PROGRAM "diff"
+#define LOCALEDIR "/usr/local/share/locale"
diff --git a/test/diffutils-3.0-patch/sdiff b/test/diffutils-3.0-patch/sdiff
new file mode 100755
index 0000000000000000000000000000000000000000..bfaebec8fda50d8ccea7a6b16515e83bcf6ac302
GIT binary patch
literal 184496
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

literal 0
HcmV?d00001

diff --git a/test/diffutils-3.0-patch/sdiff.c b/test/diffutils-3.0-patch/sdiff.c
new file mode 100644
index 0000000..5bbecd8
--- /dev/null
+++ b/test/diffutils-3.0-patch/sdiff.c
@@ -0,0 +1,1236 @@
+/* sdiff - side-by-side merge of file differences
+
+   Copyright (C) 1992-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2010 Free
+   Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+#include <unlocked-io.h>
+
+#include <c-stack.h>
+#include <dirname.h>
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <progname.h>
+#include <sh-quote.h>
+#include <version-etc.h>
+#include <xalloc.h>
+
+/* The official name of this program (e.g., no `g' prefix).  */
+#define PROGRAM_NAME "sdiff"
+
+#define AUTHORS \
+  proper_name ("Thomas Lord")
+
+/* Size of chunks read from files which must be parsed into lines.  */
+#define SDIFF_BUFSIZE ((size_t) 65536)
+
+static char const *editor_program = DEFAULT_EDITOR_PROGRAM;
+static char const **diffargv;
+
+static char * volatile tmpname;
+static FILE *tmp;
+
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+static pid_t volatile diffpid;
+#endif
+
+struct line_filter;
+
+static void catchsig (int);
+static bool edit (struct line_filter *, char const *, lin, lin, struct line_filter *, char const *, lin, lin, FILE *);
+static bool interact (struct line_filter *, struct line_filter *, char const *, struct line_filter *, char const *, FILE *);
+static void checksigs (void);
+static void diffarg (char const *);
+static void fatal (char const *) __attribute__((noreturn));
+static void perror_fatal (char const *) __attribute__((noreturn));
+static void trapsigs (void);
+static void untrapsig (int);
+
+#define NUM_SIGS (sizeof sigs / sizeof *sigs)
+static int const sigs[] = {
+#ifdef SIGHUP
+       SIGHUP,
+#endif
+#ifdef SIGQUIT
+       SIGQUIT,
+#endif
+#ifdef SIGTERM
+       SIGTERM,
+#endif
+#ifdef SIGXCPU
+       SIGXCPU,
+#endif
+#ifdef SIGXFSZ
+       SIGXFSZ,
+#endif
+#ifdef SIGPIPE
+       SIGPIPE,
+# define handler_index_of_SIGPIPE (NUM_SIGS - 2)
+#endif
+       SIGINT
+#define handler_index_of_SIGINT (NUM_SIGS - 1)
+};
+
+#if HAVE_SIGACTION
+  /* Prefer `sigaction' if available, since `signal' can lose signals.  */
+  static struct sigaction initial_action[NUM_SIGS];
+# define initial_handler(i) (initial_action[i].sa_handler)
+  static void signal_handler (int, void (*) (int));
+#else
+  static void (*initial_action[NUM_SIGS]) ();
+# define initial_handler(i) (initial_action[i])
+# define signal_handler(sig, handler) signal (sig, handler)
+#endif
+
+#if ! HAVE_SIGPROCMASK
+# define sigset_t int
+# define sigemptyset(s) (*(s) = 0)
+# ifndef sigmask
+#  define sigmask(sig) (1 << ((sig) - 1))
+# endif
+# define sigaddset(s, sig) (*(s) |= sigmask (sig))
+# ifndef SIG_BLOCK
+#  define SIG_BLOCK 0
+# endif
+# ifndef SIG_SETMASK
+#  define SIG_SETMASK (! SIG_BLOCK)
+# endif
+# if ! HAVE_SIGBLOCK
+#  define sigblock(mask) (mask)
+#  define sigsetmask(mask) (mask)
+# endif
+# define sigprocmask(how, n, o) \
+    ((how) == SIG_BLOCK \
+     ? ((o) ? (*(sigset_t *) (o) = sigblock (*(n))) : sigblock (*(n))) \
+     : sigsetmask (*(n)))
+#endif
+
+static bool diraccess (char const *);
+static int temporary_file (void);
+
+/* Options: */
+
+/* Name of output file if -o specified.  */
+static char const *output;
+
+/* Do not print common lines.  */
+static bool suppress_common_lines;
+
+/* Value for the long option that does not have single-letter equivalents.  */
+enum
+{
+  DIFF_PROGRAM_OPTION = CHAR_MAX + 1,
+  HELP_OPTION,
+  STRIP_TRAILING_CR_OPTION,
+  TABSIZE_OPTION
+};
+
+static struct option const longopts[] =
+{
+  {"diff-program", 1, 0, DIFF_PROGRAM_OPTION},
+  {"expand-tabs", 0, 0, 't'},
+  {"help", 0, 0, HELP_OPTION},
+  {"ignore-all-space", 0, 0, 'W'}, /* swap W and w for historical reasons */
+  {"ignore-blank-lines", 0, 0, 'B'},
+  {"ignore-case", 0, 0, 'i'},
+  {"ignore-matching-lines", 1, 0, 'I'},
+  {"ignore-space-change", 0, 0, 'b'},
+  {"ignore-tab-expansion", 0, 0, 'E'},
+  {"left-column", 0, 0, 'l'},
+  {"minimal", 0, 0, 'd'},
+  {"output", 1, 0, 'o'},
+  {"speed-large-files", 0, 0, 'H'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"suppress-common-lines", 0, 0, 's'},
+  {"tabsize", 1, 0, TABSIZE_OPTION},
+  {"text", 0, 0, 'a'},
+  {"version", 0, 0, 'v'},
+  {"width", 1, 0, 'w'},
+  {0, 0, 0, 0}
+};
+
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+	 program_name);
+  abort ();
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    perror_fatal (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-o FILE  --output=FILE  Operate interactively, sending output to FILE."),
+  "",
+  N_("-i  --ignore-case  Consider upper- and lower-case to be the same."),
+  N_("-E  --ignore-tab-expansion  Ignore changes due to tab expansion."),
+  N_("-b  --ignore-space-change  Ignore changes in the amount of white space."),
+  N_("-W  --ignore-all-space  Ignore all white space."),
+  N_("-B  --ignore-blank-lines  Ignore changes whose lines are all blank."),
+  N_("-I RE  --ignore-matching-lines=RE  Ignore changes whose lines all match RE."),
+  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+  N_("-a  --text  Treat all files as text."),
+  "",
+  N_("-w NUM  --width=NUM  Output at most NUM (default 130) print columns."),
+  N_("-l  --left-column  Output only the left column of common lines."),
+  N_("-s  --suppress-common-lines  Do not output common lines."),
+  "",
+  N_("-t  --expand-tabs  Expand tabs to spaces in output."),
+  N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
+  "",
+  N_("-d  --minimal  Try hard to find a smaller set of changes."),
+  N_("-H  --speed-large-files  Assume large files and many scattered small changes."),
+  N_("--diff-program=PROGRAM  Use PROGRAM to compare files."),
+  "",
+  N_("-v  --version  Output version info."),
+  N_("--help  Output this help."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILE1 FILE2\n"), program_name);
+  printf ("%s\n\n", _("Side-by-side merge of file differences."));
+  for (p = option_help_msgid;  *p;  p++)
+    if (**p)
+      printf ("  %s\n", _(*p));
+    else
+      putchar ('\n');
+  printf ("\n%s\n%s\n",
+	  _("If a FILE is '-', read standard input."),
+	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+/* Clean up after a signal or other failure.  This function is
+   async-signal-safe.  */
+static void
+cleanup (int signo __attribute__((unused)))
+{
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+  if (0 < diffpid)
+    kill (diffpid, SIGPIPE);
+#endif
+  if (tmpname)
+    unlink (tmpname);
+}
+
+static void exiterr (void) __attribute__((noreturn));
+static void
+exiterr (void)
+{
+  cleanup (0);
+  untrapsig (0);
+  checksigs ();
+  exit (EXIT_TROUBLE);
+}
+
+static void
+fatal (char const *msgid)
+{
+  error (0, 0, "%s", _(msgid));
+  exiterr ();
+}
+
+static void
+perror_fatal (char const *msg)
+{
+  int e = errno;
+  checksigs ();
+  error (0, e, "%s", msg);
+  exiterr ();
+}
+
+static void
+check_child_status (int werrno, int wstatus, int max_ok_status,
+		    char const *subsidiary_program)
+{
+  int status = (! werrno && WIFEXITED (wstatus)
+		? WEXITSTATUS (wstatus)
+		: INT_MAX);
+
+  if (max_ok_status < status)
+    {
+      error (0, werrno,
+	     _(status == 126
+	       ? "subsidiary program '%s' could not be invoked"
+	       : status == 127
+	       ? "subsidiary program '%s' not found"
+	       : status == INT_MAX
+	       ? "subsidiary program '%s' failed"
+	       : "subsidiary program '%s' failed (exit status %d)"),
+	     subsidiary_program, status);
+      exiterr ();
+    }
+}
+
+static FILE *
+ck_fopen (char const *fname, char const *type)
+{
+  FILE *r = fopen (fname, type);
+  if (! r)
+    perror_fatal (fname);
+  return r;
+}
+
+static void
+ck_fclose (FILE *f)
+{
+  if (fclose (f))
+    perror_fatal ("fclose");
+}
+
+static size_t
+ck_fread (char *buf, size_t size, FILE *f)
+{
+  size_t r = fread (buf, sizeof (char), size, f);
+  if (r == 0 && ferror (f))
+    perror_fatal (_("read failed"));
+  return r;
+}
+
+static void
+ck_fwrite (char const *buf, size_t size, FILE *f)
+{
+  if (fwrite (buf, sizeof (char), size, f) != size)
+    perror_fatal (_("write failed"));
+}
+
+static void
+ck_fflush (FILE *f)
+{
+  if (fflush (f) != 0)
+    perror_fatal (_("write failed"));
+}
+
+static char const *
+expand_name (char *name, bool is_dir, char const *other_name)
+{
+  if (STREQ (name, "-"))
+    fatal ("cannot interactively merge standard input");
+  if (! is_dir)
+    return name;
+  else
+    {
+      /* Yield NAME/BASE, where BASE is OTHER_NAME's basename.  */
+      char const *base = last_component (other_name);
+      size_t namelen = strlen (name), baselen = base_len (base);
+      bool insert_slash = *last_component (name) && name[namelen - 1] != '/';
+      char *r = xmalloc (namelen + insert_slash + baselen + 1);
+      memcpy (r, name, namelen);
+      r[namelen] = '/';
+      memcpy (r + namelen + insert_slash, base, baselen);
+      r[namelen + insert_slash + baselen] = '\0';
+      return r;
+    }
+}
+
+struct line_filter {
+  FILE *infile;
+  char *bufpos;
+  char *buffer;
+  char *buflim;
+};
+
+static void
+lf_init (struct line_filter *lf, FILE *infile)
+{
+  lf->infile = infile;
+  lf->bufpos = lf->buffer = lf->buflim = xmalloc (SDIFF_BUFSIZE + 1);
+  lf->buflim[0] = '\n';
+}
+
+/* Fill an exhausted line_filter buffer from its INFILE */
+static size_t
+lf_refill (struct line_filter *lf)
+{
+  size_t s = ck_fread (lf->buffer, SDIFF_BUFSIZE, lf->infile);
+  lf->bufpos = lf->buffer;
+  lf->buflim = lf->buffer + s;
+  lf->buflim[0] = '\n';
+  checksigs ();
+  return s;
+}
+
+/* Advance LINES on LF's infile, copying lines to OUTFILE */
+static void
+lf_copy (struct line_filter *lf, lin lines, FILE *outfile)
+{
+  char *start = lf->bufpos;
+
+  while (lines)
+    {
+      lf->bufpos = (char *) memchr (lf->bufpos, '\n', lf->buflim - lf->bufpos);
+      if (! lf->bufpos)
+	{
+	  ck_fwrite (start, lf->buflim - start, outfile);
+	  if (! lf_refill (lf))
+	    return;
+	  start = lf->bufpos;
+	}
+      else
+	{
+	  --lines;
+	  ++lf->bufpos;
+	}
+    }
+
+  ck_fwrite (start, lf->bufpos - start, outfile);
+}
+
+/* Advance LINES on LF's infile without doing output */
+static void
+lf_skip (struct line_filter *lf, lin lines)
+{
+  while (lines)
+    {
+      lf->bufpos = (char *) memchr (lf->bufpos, '\n', lf->buflim - lf->bufpos);
+      if (! lf->bufpos)
+	{
+	  if (! lf_refill (lf))
+	    break;
+	}
+      else
+	{
+	  --lines;
+	  ++lf->bufpos;
+	}
+    }
+}
+
+/* Snarf a line into a buffer.  Return EOF if EOF, 0 if error, 1 if OK.  */
+static int
+lf_snarf (struct line_filter *lf, char *buffer, size_t bufsize)
+{
+  for (;;)
+    {
+      char *start = lf->bufpos;
+      char *next = (char *) memchr (start, '\n', lf->buflim + 1 - start);
+      size_t s = next - start;
+      if (bufsize <= s)
+	return 0;
+      memcpy (buffer, start, s);
+      if (next < lf->buflim)
+	{
+	  buffer[s] = 0;
+	  lf->bufpos = next + 1;
+	  return 1;
+	}
+      if (! lf_refill (lf))
+	return s ? 0 : EOF;
+      buffer += s;
+      bufsize -= s;
+    }
+}
+
+int
+main (int argc, char *argv[])
+{
+  int opt;
+  char const *prog;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (cleanup);
+
+  prog = getenv ("EDITOR");
+  if (prog)
+    editor_program = prog;
+
+  diffarg (DEFAULT_DIFF_PROGRAM);
+
+  /* parse command line args */
+  while ((opt = getopt_long (argc, argv, "abBdEHiI:lo:stvw:W", longopts, 0))
+	 != -1)
+    {
+      switch (opt)
+	{
+	case 'a':
+	  diffarg ("-a");
+	  break;
+
+	case 'b':
+	  diffarg ("-b");
+	  break;
+
+	case 'B':
+	  diffarg ("-B");
+	  break;
+
+	case 'd':
+	  diffarg ("-d");
+	  break;
+
+	case 'E':
+	  diffarg ("-E");
+	  break;
+
+	case 'H':
+	  diffarg ("-H");
+	  break;
+
+	case 'i':
+	  diffarg ("-i");
+	  break;
+
+	case 'I':
+	  diffarg ("-I");
+	  diffarg (optarg);
+	  break;
+
+	case 'l':
+	  diffarg ("--left-column");
+	  break;
+
+	case 'o':
+	  output = optarg;
+	  break;
+
+	case 's':
+	  suppress_common_lines = true;
+	  break;
+
+	case 't':
+	  diffarg ("-t");
+	  break;
+
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case 'w':
+	  diffarg ("-W");
+	  diffarg (optarg);
+	  break;
+
+	case 'W':
+	  diffarg ("-w");
+	  break;
+
+	case DIFF_PROGRAM_OPTION:
+	  diffargv[0] = optarg;
+	  break;
+
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case STRIP_TRAILING_CR_OPTION:
+	  diffarg ("--strip-trailing-cr");
+	  break;
+
+	case TABSIZE_OPTION:
+	  diffarg ("--tabsize");
+	  diffarg (optarg);
+	  break;
+
+	default:
+	  try_help (0, 0);
+	}
+    }
+
+  if (argc - optind != 2)
+    {
+      if (argc - optind < 2)
+	try_help ("missing operand after '%s'", argv[argc - 1]);
+      else
+	try_help ("extra operand '%s'", argv[optind + 2]);
+    }
+
+  if (! output)
+    {
+      /* easy case: diff does everything for us */
+      if (suppress_common_lines)
+	diffarg ("--suppress-common-lines");
+      diffarg ("-y");
+      diffarg ("--");
+      diffarg (argv[optind]);
+      diffarg (argv[optind + 1]);
+      diffarg (0);
+      execvp (diffargv[0], (char **) diffargv);
+      perror_fatal (diffargv[0]);
+    }
+  else
+    {
+      char const *lname, *rname;
+      FILE *left, *right, *out, *diffout;
+      bool interact_ok;
+      struct line_filter lfilt;
+      struct line_filter rfilt;
+      struct line_filter diff_filt;
+      bool leftdir = diraccess (argv[optind]);
+      bool rightdir = diraccess (argv[optind + 1]);
+
+      if (leftdir & rightdir)
+	fatal ("both files to be compared are directories");
+
+      lname = expand_name (argv[optind], leftdir, argv[optind + 1]);
+      left = ck_fopen (lname, "r");
+      rname = expand_name (argv[optind + 1], rightdir, argv[optind]);
+      right = ck_fopen (rname, "r");
+      out = ck_fopen (output, "w");
+
+      diffarg ("--sdiff-merge-assist");
+      diffarg ("--");
+      diffarg (argv[optind]);
+      diffarg (argv[optind + 1]);
+      diffarg (0);
+
+      trapsigs ();
+
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+      {
+	size_t cmdsize = 1;
+	char *p, *command;
+	int i;
+
+	for (i = 0;  diffargv[i];  i++)
+	  cmdsize += shell_quote_length (diffargv[i]) + 1;
+	command = p = xmalloc (cmdsize);
+	for (i = 0;  diffargv[i];  i++)
+	  {
+	    p = shell_quote_copy (p, diffargv[i]);
+	    *p++ = ' ';
+	  }
+	p[-1] = 0;
+	errno = 0;
+	diffout = popen (command, "r");
+	if (! diffout)
+	  perror_fatal (command);
+	free (command);
+      }
+#else
+      {
+	int diff_fds[2];
+# if HAVE_WORKING_VFORK
+	sigset_t procmask;
+	sigset_t blocked;
+# endif
+
+	if (pipe (diff_fds) != 0)
+	  perror_fatal ("pipe");
+
+# if HAVE_WORKING_VFORK
+	/* Block SIGINT and SIGPIPE.  */
+	sigemptyset (&blocked);
+	sigaddset (&blocked, SIGINT);
+	sigaddset (&blocked, SIGPIPE);
+	sigprocmask (SIG_BLOCK, &blocked, &procmask);
+# endif
+	diffpid = vfork ();
+	if (diffpid < 0)
+	  perror_fatal ("fork");
+	if (! diffpid)
+	  {
+	    /* Alter the child's SIGINT and SIGPIPE handlers;
+	       this may munge the parent.
+	       The child ignores SIGINT in case the user interrupts the editor.
+	       The child does not ignore SIGPIPE, even if the parent does.  */
+	    if (initial_handler (handler_index_of_SIGINT) != SIG_IGN)
+	      signal_handler (SIGINT, SIG_IGN);
+	    signal_handler (SIGPIPE, SIG_DFL);
+# if HAVE_WORKING_VFORK
+	    /* Stop blocking SIGINT and SIGPIPE in the child.  */
+	    sigprocmask (SIG_SETMASK, &procmask, 0);
+# endif
+	    close (diff_fds[0]);
+	    if (diff_fds[1] != STDOUT_FILENO)
+	      {
+		dup2 (diff_fds[1], STDOUT_FILENO);
+		close (diff_fds[1]);
+	      }
+
+	    execvp (diffargv[0], (char **) diffargv);
+	    _exit (errno == ENOENT ? 127 : 126);
+	  }
+
+# if HAVE_WORKING_VFORK
+	/* Restore the parent's SIGINT and SIGPIPE behavior.  */
+	if (initial_handler (handler_index_of_SIGINT) != SIG_IGN)
+	  signal_handler (SIGINT, catchsig);
+	if (initial_handler (handler_index_of_SIGPIPE) != SIG_IGN)
+	  signal_handler (SIGPIPE, catchsig);
+	else
+	  signal_handler (SIGPIPE, SIG_IGN);
+
+	/* Stop blocking SIGINT and SIGPIPE in the parent.  */
+	sigprocmask (SIG_SETMASK, &procmask, 0);
+# endif
+
+	close (diff_fds[1]);
+	diffout = fdopen (diff_fds[0], "r");
+	if (! diffout)
+	  perror_fatal ("fdopen");
+      }
+#endif
+
+      lf_init (&diff_filt, diffout);
+      lf_init (&lfilt, left);
+      lf_init (&rfilt, right);
+
+      interact_ok = interact (&diff_filt, &lfilt, lname, &rfilt, rname, out);
+
+      ck_fclose (left);
+      ck_fclose (right);
+      ck_fclose (out);
+
+      {
+	int wstatus;
+	int werrno = 0;
+
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+	wstatus = pclose (diffout);
+	if (wstatus == -1)
+	  werrno = errno;
+#else
+	ck_fclose (diffout);
+	while (waitpid (diffpid, &wstatus, 0) < 0)
+	  if (errno == EINTR)
+	    checksigs ();
+	  else
+	    perror_fatal ("waitpid");
+	diffpid = 0;
+#endif
+
+	if (tmpname)
+	  {
+	    unlink (tmpname);
+	    tmpname = 0;
+	  }
+
+	if (! interact_ok)
+	  exiterr ();
+
+	check_child_status (werrno, wstatus, EXIT_FAILURE, diffargv[0]);
+	untrapsig (0);
+	checksigs ();
+	exit (WEXITSTATUS (wstatus));
+      }
+    }
+  return EXIT_SUCCESS;			/* Fool `-Wall'.  */
+}
+
+static void
+diffarg (char const *a)
+{
+  static size_t diffargs, diffarglim;
+
+  if (diffargs == diffarglim)
+    {
+      if (! diffarglim)
+	diffarglim = 16;
+      else if (PTRDIFF_MAX / (2 * sizeof *diffargv) <= diffarglim)
+	xalloc_die ();
+      else
+	diffarglim *= 2;
+      diffargv = xrealloc (diffargv, diffarglim * sizeof *diffargv);
+    }
+  diffargv[diffargs++] = a;
+}
+
+/* Signal handling */
+
+static bool volatile ignore_SIGINT;
+static int volatile signal_received;
+static bool sigs_trapped;
+
+static void
+catchsig (int s)
+{
+#if ! HAVE_SIGACTION
+  signal (s, SIG_IGN);
+#endif
+  if (! (s == SIGINT && ignore_SIGINT))
+    signal_received = s;
+}
+
+#if HAVE_SIGACTION
+static struct sigaction catchaction;
+
+static void
+signal_handler (int sig, void (*handler) (int))
+{
+  catchaction.sa_handler = handler;
+  sigaction (sig, &catchaction, 0);
+}
+#endif
+
+static void
+trapsigs (void)
+{
+  int i;
+
+#if HAVE_SIGACTION
+  catchaction.sa_flags = SA_RESTART;
+  sigemptyset (&catchaction.sa_mask);
+  for (i = 0;  i < NUM_SIGS;  i++)
+    sigaddset (&catchaction.sa_mask, sigs[i]);
+#endif
+
+  for (i = 0;  i < NUM_SIGS;  i++)
+    {
+#if HAVE_SIGACTION
+      sigaction (sigs[i], 0, &initial_action[i]);
+#else
+      initial_action[i] = signal (sigs[i], SIG_IGN);
+#endif
+      if (initial_handler (i) != SIG_IGN)
+	signal_handler (sigs[i], catchsig);
+    }
+
+#ifdef SIGCHLD
+  /* System V fork+wait does not work if SIGCHLD is ignored.  */
+  signal (SIGCHLD, SIG_DFL);
+#endif
+
+  sigs_trapped = true;
+}
+
+/* Untrap signal S, or all trapped signals if S is zero.  */
+static void
+untrapsig (int s)
+{
+  int i;
+
+  if (sigs_trapped)
+    for (i = 0;  i < NUM_SIGS;  i++)
+      if ((! s || sigs[i] == s)  &&  initial_handler (i) != SIG_IGN)
+	{
+#if HAVE_SIGACTION
+	  sigaction (sigs[i], &initial_action[i], 0);
+#else
+	  signal (sigs[i], initial_action[i]);
+#endif
+	}
+}
+
+/* Exit if a signal has been received.  */
+static void
+checksigs (void)
+{
+  int s = signal_received;
+  if (s)
+    {
+      cleanup (0);
+
+      /* Yield an exit status indicating that a signal was received.  */
+      untrapsig (s);
+      kill (getpid (), s);
+
+      /* That didn't work, so exit with error status.  */
+      exit (EXIT_TROUBLE);
+    }
+}
+
+static void
+give_help (void)
+{
+  fprintf (stderr, "%s", _("\
+ed:\tEdit then use both versions, each decorated with a header.\n\
+eb:\tEdit then use both versions.\n\
+el or e1:\tEdit then use the left version.\n\
+er or e2:\tEdit then use the right version.\n\
+e:\tDiscard both versions then edit a new one.\n\
+l or 1:\tUse the left version.\n\
+r or 2:\tUse the right version.\n\
+s:\tSilently include common lines.\n\
+v:\tVerbosely include common lines.\n\
+q:\tQuit.\n\
+"));
+}
+
+static int
+skip_white (void)
+{
+  int c;
+  for (;;)
+    {
+      c = getchar ();
+      if (! isspace (c) || c == '\n')
+	break;
+      checksigs ();
+    }
+  if (ferror (stdin))
+    perror_fatal (_("read failed"));
+  return c;
+}
+
+static void
+flush_line (void)
+{
+  int c;
+  while ((c = getchar ()) != '\n' && c != EOF)
+    continue;
+  if (ferror (stdin))
+    perror_fatal (_("read failed"));
+}
+
+
+/* interpret an edit command */
+static bool
+edit (struct line_filter *left, char const *lname, lin lline, lin llen,
+      struct line_filter *right, char const *rname, lin rline, lin rlen,
+      FILE *outfile)
+{
+  for (;;)
+    {
+      int cmd0 IF_LINT (= 0);
+      int cmd1 IF_LINT (= 0);
+      bool gotcmd = false;
+
+      while (! gotcmd)
+	{
+	  if (putchar ('%') != '%')
+	    perror_fatal (_("write failed"));
+	  ck_fflush (stdout);
+
+	  cmd0 = skip_white ();
+	  switch (cmd0)
+	    {
+	    case '1': case '2': case 'l': case 'r':
+	    case 's': case 'v': case 'q':
+	      if (skip_white () != '\n')
+		{
+		  give_help ();
+		  flush_line ();
+		  continue;
+		}
+	      gotcmd = true;
+	      break;
+
+	    case 'e':
+	      cmd1 = skip_white ();
+	      switch (cmd1)
+		{
+		case '1': case '2': case 'b': case 'd': case 'l': case 'r':
+		  if (skip_white () != '\n')
+		    {
+		      give_help ();
+		      flush_line ();
+		      continue;
+		    }
+		  gotcmd = true;
+		  break;
+		case '\n':
+		  gotcmd = true;
+		  break;
+		default:
+		  give_help ();
+		  flush_line ();
+		  continue;
+		}
+	      break;
+
+	    case EOF:
+	      if (feof (stdin))
+		{
+		  gotcmd = true;
+		  cmd0 = 'q';
+		  break;
+		}
+	      /* Fall through.  */
+	    default:
+	      flush_line ();
+	      /* Fall through.  */
+	    case '\n':
+	      give_help ();
+	      continue;
+	    }
+	}
+
+      switch (cmd0)
+	{
+	case '1': case 'l':
+	  lf_copy (left, llen, outfile);
+	  lf_skip (right, rlen);
+	  return true;
+	case '2': case 'r':
+	  lf_copy (right, rlen, outfile);
+	  lf_skip (left, llen);
+	  return true;
+	case 's':
+	  suppress_common_lines = true;
+	  break;
+	case 'v':
+	  suppress_common_lines = false;
+	  break;
+	case 'q':
+	  return false;
+	case 'e':
+	  {
+	    int fd;
+
+	    if (tmpname)
+	      tmp = fopen (tmpname, "w");
+	    else
+	      {
+		if ((fd = temporary_file ()) < 0)
+		  perror_fatal ("mkstemp");
+		tmp = fdopen (fd, "w");
+	      }
+
+	    if (! tmp)
+	      perror_fatal (tmpname);
+
+	    switch (cmd1)
+	      {
+	      case 'd':
+		if (llen)
+		  {
+		    if (llen == 1)
+		      fprintf (tmp, "--- %s %ld\n", lname, (long int) lline);
+		    else
+		      fprintf (tmp, "--- %s %ld,%ld\n", lname,
+			       (long int) lline,
+			       (long int) (lline + llen - 1));
+		  }
+		/* Fall through.  */
+	      case '1': case 'b': case 'l':
+		lf_copy (left, llen, tmp);
+		break;
+
+	      default:
+		lf_skip (left, llen);
+		break;
+	      }
+
+	    switch (cmd1)
+	      {
+	      case 'd':
+		if (rlen)
+		  {
+		    if (rlen == 1)
+		      fprintf (tmp, "+++ %s %ld\n", rname, (long int) rline);
+		    else
+		      fprintf (tmp, "+++ %s %ld,%ld\n", rname,
+			       (long int) rline,
+			       (long int) (rline + rlen - 1));
+		  }
+		/* Fall through.  */
+	      case '2': case 'b': case 'r':
+		lf_copy (right, rlen, tmp);
+		break;
+
+	      default:
+		lf_skip (right, rlen);
+		break;
+	      }
+
+	    ck_fclose (tmp);
+
+	    {
+	      int wstatus;
+	      int werrno = 0;
+	      ignore_SIGINT = true;
+	      checksigs ();
+
+	      {
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+		char *command =
+		  xmalloc (shell_quote_length (editor_program)
+			   + 1 + strlen (tmpname) + 1);
+		sprintf (shell_quote_copy (command, editor_program),
+			 " %s", tmpname);
+		wstatus = system (command);
+		if (wstatus == -1)
+		  werrno = errno;
+		free (command);
+#else
+		pid_t pid;
+
+		pid = vfork ();
+		if (pid == 0)
+		  {
+		    char const *argv[3];
+		    int i = 0;
+
+		    argv[i++] = editor_program;
+		    argv[i++] = tmpname;
+		    argv[i] = 0;
+
+		    execvp (editor_program, (char **) argv);
+		    _exit (errno == ENOENT ? 127 : 126);
+		  }
+
+		if (pid < 0)
+		  perror_fatal ("fork");
+
+		while (waitpid (pid, &wstatus, 0) < 0)
+		  if (errno == EINTR)
+		    checksigs ();
+		  else
+		    perror_fatal ("waitpid");
+#endif
+	      }
+
+	      ignore_SIGINT = false;
+	      check_child_status (werrno, wstatus, EXIT_SUCCESS,
+				  editor_program);
+	    }
+
+	    {
+	      char buf[SDIFF_BUFSIZE];
+	      size_t size;
+	      tmp = ck_fopen (tmpname, "r");
+	      while ((size = ck_fread (buf, SDIFF_BUFSIZE, tmp)) != 0)
+		{
+		  checksigs ();
+		  ck_fwrite (buf, size, outfile);
+		}
+	      ck_fclose (tmp);
+	    }
+	    return true;
+	  }
+	default:
+	  give_help ();
+	  break;
+	}
+    }
+}
+
+/* Alternately reveal bursts of diff output and handle user commands.  */
+static bool
+interact (struct line_filter *diff,
+	  struct line_filter *left, char const *lname,
+	  struct line_filter *right, char const *rname,
+	  FILE *outfile)
+{
+  lin lline = 1, rline = 1;
+
+  for (;;)
+    {
+      char diff_help[256];
+      int snarfed = lf_snarf (diff, diff_help, sizeof diff_help);
+
+      if (snarfed <= 0)
+	return snarfed != 0;
+
+      checksigs ();
+
+      if (diff_help[0] == ' ')
+	puts (diff_help + 1);
+      else
+	{
+	  char *numend;
+	  uintmax_t val;
+	  lin llen, rlen, lenmax;
+	  errno = 0;
+	  llen = val = strtoumax (diff_help + 1, &numend, 10);
+	  if (llen < 0 || llen != val || errno || *numend != ',')
+	    fatal (diff_help);
+	  rlen = val = strtoumax (numend + 1, &numend, 10);
+	  if (rlen < 0 || rlen != val || errno || *numend)
+	    fatal (diff_help);
+
+	  lenmax = MAX (llen, rlen);
+
+	  switch (diff_help[0])
+	    {
+	    case 'i':
+	      if (suppress_common_lines)
+		lf_skip (diff, lenmax);
+	      else
+		lf_copy (diff, lenmax, stdout);
+
+	      lf_copy (left, llen, outfile);
+	      lf_skip (right, rlen);
+	      break;
+
+	    case 'c':
+	      lf_copy (diff, lenmax, stdout);
+	      if (! edit (left, lname, lline, llen,
+			  right, rname, rline, rlen,
+			  outfile))
+		return false;
+	      break;
+
+	    default:
+	      fatal (diff_help);
+	    }
+
+	  lline += llen;
+	  rline += rlen;
+	}
+    }
+}
+
+/* Return true if DIR is an existing directory.  */
+static bool
+diraccess (char const *dir)
+{
+  struct stat buf;
+  return stat (dir, &buf) == 0 && S_ISDIR (buf.st_mode);
+}
+
+#ifndef P_tmpdir
+# define P_tmpdir "/tmp"
+#endif
+#ifndef TMPDIR_ENV
+# define TMPDIR_ENV "TMPDIR"
+#endif
+
+/* Open a temporary file and return its file descriptor.  Put into
+   tmpname the address of a newly allocated buffer that holds the
+   file's name.  Use the prefix "sdiff".  */
+static int
+temporary_file (void)
+{
+  char const *tmpdir = getenv (TMPDIR_ENV);
+  char const *dir = tmpdir ? tmpdir : P_tmpdir;
+  char *buf = xmalloc (strlen (dir) + 1 + 5 + 6 + 1);
+  int fd;
+  int e;
+  sigset_t procmask;
+  sigset_t blocked;
+  sprintf (buf, "%s/sdiffXXXXXX", dir);
+  sigemptyset (&blocked);
+  sigaddset (&blocked, SIGINT);
+  sigprocmask (SIG_BLOCK, &blocked, &procmask);
+  fd = mkstemp (buf);
+  e = errno;
+  if (0 <= fd)
+    tmpname = buf;
+  sigprocmask (SIG_SETMASK, &procmask, 0);
+  errno = e;
+  return fd;
+}
diff --git a/test/diffutils-3.0-patch/side.c b/test/diffutils-3.0-patch/side.c
new file mode 100644
index 0000000..6aa96a9
--- /dev/null
+++ b/test/diffutils-3.0-patch/side.c
@@ -0,0 +1,320 @@
+/* sdiff-format output routines for GNU DIFF.
+
+   Copyright (C) 1991-1993, 1998, 2001-2002, 2004, 2009-2010 Free Software
+   Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   GNU DIFF is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.  No author or distributor
+   accepts responsibility to anyone for the consequences of using it
+   or for whether it serves any particular purpose or works at all,
+   unless he says so in writing.  Refer to the GNU General Public
+   License for full details.
+
+   Everyone is granted permission to copy, modify and redistribute
+   GNU DIFF, but only under the conditions described in the
+   GNU General Public License.   A copy of this license is
+   supposed to have been given to you along with GNU DIFF so you
+   can know your rights and responsibilities.  It should be in a
+   file named COPYING.  Among other things, the copyright notice
+   and this notice must be preserved on all copies.  */
+
+#include "diff.h"
+
+#include <wchar.h>
+
+static void print_sdiff_common_lines (lin, lin);
+static void print_sdiff_hunk (struct change *);
+
+/* Next line number to be printed in the two input files.  */
+static lin next0, next1;
+
+/* Print the edit-script SCRIPT as a sdiff style output.  */
+
+void
+print_sdiff_script (struct change *script)
+{
+  begin_output ();
+
+  next0 = next1 = - files[0].prefix_lines;
+  print_script (script, find_change, print_sdiff_hunk);
+
+  print_sdiff_common_lines (files[0].valid_lines, files[1].valid_lines);
+}
+
+/* Tab from column FROM to column TO, where FROM <= TO.  Yield TO.  */
+
+static size_t
+tab_from_to (size_t from, size_t to)
+{
+  FILE *out = outfile;
+  size_t tab;
+  size_t tab_size = tabsize;
+
+  if (!expand_tabs)
+    for (tab = from + tab_size - from % tab_size;  tab <= to;  tab += tab_size)
+      {
+	putc ('\t', out);
+	from = tab;
+      }
+  while (from++ < to)
+    putc (' ', out);
+  return to;
+}
+
+/* Print the text for half an sdiff line.  This means truncate to
+   width observing tabs, and trim a trailing newline.  Return the
+   last column written (not the number of chars).  */
+
+static size_t
+print_half_line (char const *const *line, size_t indent, size_t out_bound)
+{
+  FILE *out = outfile;
+  register size_t in_position = 0;
+  register size_t out_position = 0;
+  register char const *text_pointer = line[0];
+  register char const *text_limit = line[1];
+  mbstate_t mbstate = { 0 };
+
+  while (text_pointer < text_limit)
+    {
+      char const *tp0 = text_pointer;
+      register char c = *text_pointer++;
+
+      switch (c)
+	{
+	case '\t':
+	  {
+	    size_t spaces = tabsize - in_position % tabsize;
+	    if (in_position == out_position)
+	      {
+		size_t tabstop = out_position + spaces;
+		if (expand_tabs)
+		  {
+		    if (out_bound < tabstop)
+		      tabstop = out_bound;
+		    for (;  out_position < tabstop;  out_position++)
+		      putc (' ', out);
+		  }
+		else
+		  if (tabstop < out_bound)
+		    {
+		      out_position = tabstop;
+		      putc (c, out);
+		    }
+	      }
+	    in_position += spaces;
+	  }
+	  break;
+
+	case '\r':
+	  {
+	    putc (c, out);
+	    tab_from_to (0, indent);
+	    in_position = out_position = 0;
+	  }
+	  break;
+
+	case '\b':
+	  if (in_position != 0 && --in_position < out_bound)
+	    {
+	      if (out_position <= in_position)
+		/* Add spaces to make up for suppressed tab past out_bound.  */
+		for (;  out_position < in_position;  out_position++)
+		  putc (' ', out);
+	      else
+		{
+		  out_position = in_position;
+		  putc (c, out);
+		}
+	    }
+	  break;
+
+	default:
+	  {
+	    wchar_t wc;
+	    size_t bytes = mbrtowc (&wc, tp0, text_limit - tp0, &mbstate);
+
+	    if (0 < bytes && bytes < (size_t) -2)
+	      {
+		int width = wcwidth (wc);
+		if (0 < width)
+		  in_position += width;
+		if (in_position <= out_bound)
+		  {
+		    out_position = in_position;
+		    fwrite (tp0, 1, bytes, stdout);
+		  }
+		text_pointer = tp0 + bytes;
+		break;
+	      }
+	  }
+	  /* Fall through.  */
+	case '\f':
+	case '\v':
+	  if (in_position < out_bound)
+	    putc (c, out);
+	  break;
+
+	case ' ': case '!': case '"': case '#': case '%':
+	case '&': case '\'': case '(': case ')': case '*':
+	case '+': case ',': case '-': case '.': case '/':
+	case '0': case '1': case '2': case '3': case '4':
+	case '5': case '6': case '7': case '8': case '9':
+	case ':': case ';': case '<': case '=': case '>':
+	case '?':
+	case 'A': case 'B': case 'C': case 'D': case 'E':
+	case 'F': case 'G': case 'H': case 'I': case 'J':
+	case 'K': case 'L': case 'M': case 'N': case 'O':
+	case 'P': case 'Q': case 'R': case 'S': case 'T':
+	case 'U': case 'V': case 'W': case 'X': case 'Y':
+	case 'Z':
+	case '[': case '\\': case ']': case '^': case '_':
+	case 'a': case 'b': case 'c': case 'd': case 'e':
+	case 'f': case 'g': case 'h': case 'i': case 'j':
+	case 'k': case 'l': case 'm': case 'n': case 'o':
+	case 'p': case 'q': case 'r': case 's': case 't':
+	case 'u': case 'v': case 'w': case 'x': case 'y':
+	case 'z': case '{': case '|': case '}': case '~':
+	  /* These characters are printable ASCII characters.  */
+	  if (in_position++ < out_bound)
+	    {
+	      out_position = in_position;
+	      putc (c, out);
+	    }
+	  break;
+
+	case '\n':
+	  return out_position;
+	}
+    }
+
+  return out_position;
+}
+
+/* Print side by side lines with a separator in the middle.
+   0 parameters are taken to indicate white space text.
+   Blank lines that can easily be caught are reduced to a single newline.  */
+
+static void
+print_1sdiff_line (char const *const *left, char sep,
+		   char const *const *right)
+{
+  FILE *out = outfile;
+  size_t hw = sdiff_half_width;
+  size_t c2o = sdiff_column2_offset;
+  size_t col = 0;
+  bool put_newline = false;
+
+  if (left)
+    {
+      put_newline |= left[1][-1] == '\n';
+      col = print_half_line (left, 0, hw);
+    }
+
+  if (sep != ' ')
+    {
+      col = tab_from_to (col, (hw + c2o - 1) / 2) + 1;
+      if (sep == '|' && put_newline != (right[1][-1] == '\n'))
+	sep = put_newline ? '/' : '\\';
+      putc (sep, out);
+    }
+
+  if (right)
+    {
+      put_newline |= right[1][-1] == '\n';
+      if (**right != '\n')
+	{
+	  col = tab_from_to (col, c2o);
+	  print_half_line (right, col, hw);
+	}
+    }
+
+  if (put_newline)
+    putc ('\n', out);
+}
+
+/* Print lines common to both files in side-by-side format.  */
+static void
+print_sdiff_common_lines (lin limit0, lin limit1)
+{
+  lin i0 = next0, i1 = next1;
+
+  if (!suppress_common_lines && (i0 != limit0 || i1 != limit1))
+    {
+      if (sdiff_merge_assist)
+	{
+	  long int len0 = limit0 - i0;
+	  long int len1 = limit1 - i1;
+	  fprintf (outfile, "i%ld,%ld\n", len0, len1);
+	}
+
+      if (!left_column)
+	{
+	  while (i0 != limit0 && i1 != limit1)
+	    print_1sdiff_line (&files[0].linbuf[i0++], ' ',
+			       &files[1].linbuf[i1++]);
+	  while (i1 != limit1)
+	    print_1sdiff_line (0, ')', &files[1].linbuf[i1++]);
+	}
+      while (i0 != limit0)
+	print_1sdiff_line (&files[0].linbuf[i0++], '(', 0);
+    }
+
+  next0 = limit0;
+  next1 = limit1;
+}
+
+/* Print a hunk of an sdiff diff.
+   This is a contiguous portion of a complete edit script,
+   describing changes in consecutive lines.  */
+
+static void
+print_sdiff_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1;
+  register lin i, j;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes =
+    analyze_hunk (hunk, &first0, &last0, &first1, &last1);
+  if (!changes)
+    return;
+
+  /* Print out lines up to this change.  */
+  print_sdiff_common_lines (first0, first1);
+
+  if (sdiff_merge_assist)
+    {
+      long int len0 = last0 - first0 + 1;
+      long int len1 = last1 - first1 + 1;
+      fprintf (outfile, "c%ld,%ld\n", len0, len1);
+    }
+
+  /* Print ``xxx  |  xxx '' lines */
+  if (changes == CHANGED)
+    {
+      for (i = first0, j = first1;  i <= last0 && j <= last1;  i++, j++)
+	print_1sdiff_line (&files[0].linbuf[i], '|', &files[1].linbuf[j]);
+      changes = (i <= last0 ? OLD : 0) + (j <= last1 ? NEW : 0);
+      next0 = first0 = i;
+      next1 = first1 = j;
+    }
+
+  /* Print ``     >  xxx '' lines */
+  if (changes & NEW)
+    {
+      for (j = first1; j <= last1; ++j)
+	print_1sdiff_line (0, '>', &files[1].linbuf[j]);
+      next1 = j;
+    }
+
+  /* Print ``xxx  <     '' lines */
+  if (changes & OLD)
+    {
+      for (i = first0; i <= last0; ++i)
+	print_1sdiff_line (&files[0].linbuf[i], '<', 0);
+      next0 = i;
+    }
+}
diff --git a/test/diffutils-3.0-patch/system.h b/test/diffutils-3.0-patch/system.h
new file mode 100644
index 0000000..8942296
--- /dev/null
+++ b/test/diffutils-3.0-patch/system.h
@@ -0,0 +1,228 @@
+/* System dependent declarations.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+/* Use this to suppress gcc's `...may be used before initialized' warnings. */
+#ifdef lint
+# define IF_LINT(Code) Code
+#else
+# define IF_LINT(Code) /* empty */
+#endif
+
+/* Define `__attribute__' and `volatile' first
+   so that they're used consistently in all system includes.  */
+#if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 6) || __STRICT_ANSI__
+# define __attribute__(x)
+#endif
+
+#include <verify.h>
+
+#include <sys/types.h>
+
+#include <sys/stat.h>
+#include "stat-macros.h"
+
+#ifndef STAT_BLOCKSIZE
+# if HAVE_STRUCT_STAT_ST_BLKSIZE
+#  define STAT_BLOCKSIZE(s) ((s).st_blksize)
+# else
+#  define STAT_BLOCKSIZE(s) (8 * 1024)
+# endif
+#endif
+
+#include <unistd.h>
+
+#include <fcntl.h>
+#include <time.h>
+
+#include <sys/wait.h>
+#ifndef WEXITSTATUS
+# define WEXITSTATUS(stat_val) ((unsigned int) (stat_val) >> 8)
+#endif
+#ifndef WIFEXITED
+# define WIFEXITED(stat_val) (((stat_val) & 255) == 0)
+#endif
+
+#include <dirent.h>
+#ifndef _D_EXACT_NAMLEN
+# define _D_EXACT_NAMLEN(dp) strlen ((dp)->d_name)
+#endif
+
+#include <stdlib.h>
+#define EXIT_TROUBLE 2
+
+#include <limits.h>
+#include <locale.h>
+#include <stddef.h>
+#include <inttypes.h>
+
+#include <string.h>
+#if ! HAVE_STRCASECOLL
+# if HAVE_STRICOLL || defined stricoll
+#  define strcasecoll(a, b) stricoll (a, b)
+# else
+#  define strcasecoll(a, b) strcasecmp (a, b) /* best we can do */
+# endif
+#endif
+#if ! (HAVE_STRCASECMP || defined strcasecmp)
+int strcasecmp (char const *, char const *);
+#endif
+
+#include <gettext.h>
+#if ! ENABLE_NLS
+# undef textdomain
+# define textdomain(Domainname) /* empty */
+# undef bindtextdomain
+# define bindtextdomain(Domainname, Dirname) /* empty */
+#endif
+
+#define _(msgid) gettext (msgid)
+#define N_(msgid) msgid
+
+#include <ctype.h>
+
+/* ISDIGIT differs from isdigit, as follows:
+   - Its arg may be any int or unsigned int; it need not be an unsigned char.
+   - It's guaranteed to evaluate its argument exactly once.
+   - It's typically faster.
+   POSIX 1003.1-2001 says that only '0' through '9' are digits.
+   Prefer ISDIGIT to isdigit unless it's important to use the locale's
+   definition of `digit' even when the host does not conform to POSIX.  */
+#define ISDIGIT(c) ((unsigned int) (c) - '0' <= 9)
+
+#include <errno.h>
+
+#include <signal.h>
+#ifndef SA_RESTART
+# ifdef SA_INTERRUPT /* e.g. SunOS 4.1.x */
+#  define SA_RESTART SA_INTERRUPT
+# else
+#  define SA_RESTART 0
+# endif
+#endif
+#if !defined SIGCHLD && defined SIGCLD
+# define SIGCHLD SIGCLD
+#endif
+
+#undef MIN
+#undef MAX
+#define MIN(a, b) ((a) <= (b) ? (a) : (b))
+#define MAX(a, b) ((a) >= (b) ? (a) : (b))
+
+#include <stdbool.h>
+
+#if HAVE_VFORK_H
+# include <vfork.h>
+#endif
+
+#if ! HAVE_WORKING_VFORK
+# define vfork fork
+#endif
+
+#include <intprops.h>
+#include "propername.h"
+
+/* Type used for fast comparison of several bytes at a time.  */
+
+#ifndef word
+# define word uintmax_t
+#endif
+
+/* The integer type of a line number.  Since files are read into main
+   memory, ptrdiff_t should be wide enough.  */
+
+typedef ptrdiff_t lin;
+#define LIN_MAX PTRDIFF_MAX
+verify (TYPE_SIGNED (lin));
+verify (sizeof (ptrdiff_t) <= sizeof (lin));
+verify (sizeof (lin) <= sizeof (long int));
+
+/* This section contains POSIX-compliant defaults for macros
+   that are meant to be overridden by hand in config.h as needed.  */
+
+#ifndef file_name_cmp
+# define file_name_cmp strcmp
+#endif
+
+#ifndef initialize_main
+# define initialize_main(argcp, argvp)
+#endif
+
+#ifndef NULL_DEVICE
+# define NULL_DEVICE "/dev/null"
+#endif
+
+/* Do struct stat *S, *T describe the same special file?  */
+#ifndef same_special_file
+# if HAVE_ST_RDEV && defined S_ISBLK && defined S_ISCHR
+#  define same_special_file(s, t) \
+     (((S_ISBLK ((s)->st_mode) && S_ISBLK ((t)->st_mode)) \
+       || (S_ISCHR ((s)->st_mode) && S_ISCHR ((t)->st_mode))) \
+      && (s)->st_rdev == (t)->st_rdev)
+# else
+#  define same_special_file(s, t) 0
+# endif
+#endif
+
+/* Do struct stat *S, *T describe the same file?  Answer -1 if unknown.  */
+#ifndef same_file
+# define same_file(s, t) \
+    ((((s)->st_ino == (t)->st_ino) && ((s)->st_dev == (t)->st_dev)) \
+     || same_special_file (s, t))
+#endif
+
+/* Do struct stat *S, *T have the same file attributes?
+
+   POSIX says that two files are identical if st_ino and st_dev are
+   the same, but many file systems incorrectly assign the same (device,
+   inode) pair to two distinct files, including:
+
+   - GNU/Linux NFS servers that export all local file systems as a
+     single NFS file system, if a local device number (st_dev) exceeds
+     255, or if a local inode number (st_ino) exceeds 16777215.
+
+   - Network Appliance NFS servers in snapshot directories; see
+     Network Appliance bug #195.
+
+   - ClearCase MVFS; see bug id ATRia04618.
+
+   Check whether two files that purport to be the same have the same
+   attributes, to work around instances of this common bug.  Do not
+   inspect all attributes, only attributes useful in checking for this
+   bug.
+
+   It's possible for two distinct files on a buggy file system to have
+   the same attributes, but it's not worth slowing down all
+   implementations (or complicating the configuration) to cater to
+   these rare cases in buggy implementations.  */
+
+#ifndef same_file_attributes
+# define same_file_attributes(s, t) \
+   ((s)->st_mode == (t)->st_mode \
+    && (s)->st_nlink == (t)->st_nlink \
+    && (s)->st_uid == (t)->st_uid \
+    && (s)->st_gid == (t)->st_gid \
+    && (s)->st_size == (t)->st_size \
+    && (s)->st_mtime == (t)->st_mtime \
+    && (s)->st_ctime == (t)->st_ctime)
+#endif
+
+#define STREQ(a, b) (strcmp (a, b) == 0)
diff --git a/test/diffutils-3.0-patch/util.c b/test/diffutils-3.0-patch/util.c
new file mode 100644
index 0000000..d18bf38
--- /dev/null
+++ b/test/diffutils-3.0-patch/util.c
@@ -0,0 +1,788 @@
+/* Support routines for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
+   Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <dirname.h>
+#include <error.h>
+#include <sh-quote.h>
+#include <xalloc.h>
+
+char const pr_program[] = PR_PROGRAM;
+
+/* Queue up one-line messages to be printed at the end,
+   when -l is specified.  Each message is recorded with a `struct msg'.  */
+
+struct msg
+{
+  struct msg *next;
+  char args[1]; /* Format + 4 args, each '\0' terminated, concatenated.  */
+};
+
+/* Head of the chain of queues messages.  */
+
+static struct msg *msg_chain;
+
+/* Tail of the chain of queues messages.  */
+
+static struct msg **msg_chain_end = &msg_chain;
+
+/* Use when a system call returns non-zero status.
+   NAME should normally be the file name.  */
+
+void
+perror_with_name (char const *name)
+{
+  error (0, errno, "%s", name);
+}
+
+/* Use when a system call returns non-zero status and that is fatal.  */
+
+void
+pfatal_with_name (char const *name)
+{
+  int e = errno;
+  print_message_queue ();
+  error (EXIT_TROUBLE, e, "%s", name);
+  abort ();
+}
+
+/* Print an error message containing MSGID, then exit.  */
+
+void
+fatal (char const *msgid)
+{
+  print_message_queue ();
+  error (EXIT_TROUBLE, 0, "%s", _(msgid));
+  abort ();
+}
+
+/* Like printf, except if -l in effect then save the message and print later.
+   This is used for things like "Only in ...".  */
+
+void
+message (char const *format_msgid, char const *arg1, char const *arg2)
+{
+  message5 (format_msgid, arg1, arg2, 0, 0);
+}
+
+void
+message5 (char const *format_msgid, char const *arg1, char const *arg2,
+	  char const *arg3, char const *arg4)
+{
+  if (paginate)
+    {
+      char *p;
+      char const *arg[5];
+      int i;
+      size_t size[5];
+      size_t total_size = offsetof (struct msg, args);
+      struct msg *new;
+
+      arg[0] = format_msgid;
+      arg[1] = arg1;
+      arg[2] = arg2;
+      arg[3] = arg3 ? arg3 : "";
+      arg[4] = arg4 ? arg4 : "";
+
+      for (i = 0;  i < 5;  i++)
+	total_size += size[i] = strlen (arg[i]) + 1;
+
+      new = xmalloc (total_size);
+
+      for (i = 0, p = new->args;  i < 5;  p += size[i++])
+	memcpy (p, arg[i], size[i]);
+
+      *msg_chain_end = new;
+      new->next = 0;
+      msg_chain_end = &new->next;
+    }
+  else
+    {
+      if (sdiff_merge_assist)
+	putchar (' ');
+      printf (_(format_msgid), arg1, arg2, arg3, arg4);
+    }
+}
+
+/* Output all the messages that were saved up by calls to `message'.  */
+
+void
+print_message_queue (void)
+{
+  char const *arg[5];
+  int i;
+  struct msg *m = msg_chain;
+
+  while (m)
+    {
+      struct msg *next = m->next;
+      arg[0] = m->args;
+      for (i = 0;  i < 4;  i++)
+	arg[i + 1] = arg[i] + strlen (arg[i]) + 1;
+      printf (_(arg[0]), arg[1], arg[2], arg[3], arg[4]);
+      free (m);
+      m = next;
+    }
+}
+
+/* Call before outputting the results of comparing files NAME0 and NAME1
+   to set up OUTFILE, the stdio stream for the output to go to.
+
+   Usually, OUTFILE is just stdout.  But when -l was specified
+   we fork off a `pr' and make OUTFILE a pipe to it.
+   `pr' then outputs to our stdout.  */
+
+static char const *current_name0;
+static char const *current_name1;
+static bool currently_recursive;
+
+void
+setup_output (char const *name0, char const *name1, bool recursive)
+{
+  current_name0 = name0;
+  current_name1 = name1;
+  currently_recursive = recursive;
+  outfile = 0;
+}
+
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+static pid_t pr_pid;
+#endif
+
+void
+begin_output (void)
+{
+  char *name;
+
+  if (outfile != 0)
+    return;
+
+  /* Construct the header of this piece of diff.  */
+  name = xmalloc (strlen (current_name0) + strlen (current_name1)
+		  + strlen (switch_string) + 7);
+
+  /* POSIX 1003.1-2001 specifies this format.  But there are some bugs in
+     the standard: it says that we must print only the last component
+     of the pathnames, and it requires two spaces after "diff" if
+     there are no options.  These requirements are silly and do not
+     match historical practice.  */
+  sprintf (name, "diff%s %s %s", switch_string, current_name0, current_name1);
+
+  if (paginate)
+    {
+      if (fflush (stdout) != 0)
+	pfatal_with_name (_("write failed"));
+
+      /* Make OUTFILE a pipe to a subsidiary `pr'.  */
+      {
+#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+	int pipes[2];
+
+	if (pipe (pipes) != 0)
+	  pfatal_with_name ("pipe");
+
+	pr_pid = vfork ();
+	if (pr_pid < 0)
+	  pfatal_with_name ("fork");
+
+	if (pr_pid == 0)
+	  {
+	    close (pipes[1]);
+	    if (pipes[0] != STDIN_FILENO)
+	      {
+		if (dup2 (pipes[0], STDIN_FILENO) < 0)
+		  pfatal_with_name ("dup2");
+		close (pipes[0]);
+	      }
+
+	    execl (pr_program, pr_program, "-h", name, (char *) 0);
+	    _exit (errno == ENOENT ? 127 : 126);
+	  }
+	else
+	  {
+	    close (pipes[0]);
+	    outfile = fdopen (pipes[1], "w");
+	    if (!outfile)
+	      pfatal_with_name ("fdopen");
+	  }
+#else
+	char *command = xmalloc (sizeof pr_program - 1 + 7
+				 + shell_quote_length (name) + 1);
+	char *p;
+	sprintf (command, "%s -f -h ", pr_program);
+	p = command + sizeof pr_program - 1 + 7;
+	p = shell_quote_copy (p, name);
+	*p = 0;
+	errno = 0;
+	outfile = popen (command, "w");
+	if (!outfile)
+	  pfatal_with_name (command);
+	free (command);
+#endif
+      }
+    }
+  else
+    {
+
+      /* If -l was not specified, output the diff straight to `stdout'.  */
+
+      outfile = stdout;
+
+      /* If handling multiple files (because scanning a directory),
+	 print which files the following output is about.  */
+      if (currently_recursive)
+	printf ("%s\n", name);
+    }
+
+  free (name);
+
+  /* A special header is needed at the beginning of context output.  */
+  switch (output_style)
+    {
+    case OUTPUT_CONTEXT:
+      print_context_header (files, false);
+      break;
+
+    case OUTPUT_UNIFIED:
+      print_context_header (files, true);
+      break;
+
+    default:
+      break;
+    }
+}
+
+/* Call after the end of output of diffs for one file.
+   Close OUTFILE and get rid of the `pr' subfork.  */
+
+void
+finish_output (void)
+{
+  if (outfile != 0 && outfile != stdout)
+    {
+      int status;
+      int wstatus;
+      int werrno = 0;
+      if (ferror (outfile))
+	fatal ("write failed");
+#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+      wstatus = pclose (outfile);
+      if (wstatus == -1)
+	werrno = errno;
+#else
+      if (fclose (outfile) != 0)
+	pfatal_with_name (_("write failed"));
+      if (waitpid (pr_pid, &wstatus, 0) < 0)
+	pfatal_with_name ("waitpid");
+#endif
+      status = (! werrno && WIFEXITED (wstatus)
+		? WEXITSTATUS (wstatus)
+		: INT_MAX);
+      if (status)
+	error (EXIT_TROUBLE, werrno,
+	       _(status == 126
+		 ? "subsidiary program '%s' could not be invoked"
+		 : status == 127
+		 ? "subsidiary program '%s' not found"
+		 : status == INT_MAX
+		 ? "subsidiary program '%s' failed"
+		 : "subsidiary program '%s' failed (exit status %d)"),
+	       pr_program, status);
+    }
+
+  outfile = 0;
+}
+
+/* Compare two lines (typically one from each input file)
+   according to the command line options.
+   For efficiency, this is invoked only when the lines do not match exactly
+   but an option like -i might cause us to ignore the difference.
+   Return nonzero if the lines differ.  */
+
+bool
+lines_differ (char const *s1, char const *s2)
+{
+  register char const *t1 = s1;
+  register char const *t2 = s2;
+  size_t column = 0;
+
+  while (1)
+    {
+      register unsigned char c1 = *t1++;
+      register unsigned char c2 = *t2++;
+
+      /* Test for exact char equality first, since it's a common case.  */
+      if (c1 != c2)
+	{
+	  switch (ignore_white_space)
+	    {
+	    case IGNORE_ALL_SPACE:
+	      /* For -w, just skip past any white space.  */
+	      while (isspace (c1) && c1 != '\n') c1 = *t1++;
+	      while (isspace (c2) && c2 != '\n') c2 = *t2++;
+	      break;
+
+	    case IGNORE_SPACE_CHANGE:
+	      /* For -b, advance past any sequence of white space in
+		 line 1 and consider it just one space, or nothing at
+		 all if it is at the end of the line.  */
+	      if (isspace (c1))
+		{
+		  while (c1 != '\n')
+		    {
+		      c1 = *t1++;
+		      if (! isspace (c1))
+			{
+			  --t1;
+			  c1 = ' ';
+			  break;
+			}
+		    }
+		}
+
+	      /* Likewise for line 2.  */
+	      if (isspace (c2))
+		{
+		  while (c2 != '\n')
+		    {
+		      c2 = *t2++;
+		      if (! isspace (c2))
+			{
+			  --t2;
+			  c2 = ' ';
+			  break;
+			}
+		    }
+		}
+
+	      if (c1 != c2)
+		{
+		  /* If we went too far when doing the simple test
+		     for equality, go back to the first non-white-space
+		     character in both sides and try again.  */
+		  if (c2 == ' ' && c1 != '\n'
+		      && s1 + 1 < t1
+		      && isspace ((unsigned char) t1[-2]))
+		    {
+		      --t1;
+		      continue;
+		    }
+		  if (c1 == ' ' && c2 != '\n'
+		      && s2 + 1 < t2
+		      && isspace ((unsigned char) t2[-2]))
+		    {
+		      --t2;
+		      continue;
+		    }
+		}
+
+	      break;
+
+	    case IGNORE_TAB_EXPANSION:
+	      if ((c1 == ' ' && c2 == '\t')
+		  || (c1 == '\t' && c2 == ' '))
+		{
+		  size_t column2 = column;
+		  for (;; c1 = *t1++)
+		    {
+		      if (c1 == ' ')
+			column++;
+		      else if (c1 == '\t')
+			column += tabsize - column % tabsize;
+		      else
+			break;
+		    }
+		  for (;; c2 = *t2++)
+		    {
+		      if (c2 == ' ')
+			column2++;
+		      else if (c2 == '\t')
+			column2 += tabsize - column2 % tabsize;
+		      else
+			break;
+		    }
+		  if (column != column2)
+		    return true;
+		}
+	      break;
+
+	    case IGNORE_NO_WHITE_SPACE:
+	      break;
+	    }
+
+	  /* Lowercase all letters if -i is specified.  */
+
+	  if (ignore_case)
+	    {
+	      c1 = tolower (c1);
+	      c2 = tolower (c2);
+	    }
+
+	  if (c1 != c2)
+	    break;
+	}
+      if (c1 == '\n')
+	return false;
+
+      column += c1 == '\t' ? tabsize - column % tabsize : 1;
+    }
+
+  return true;
+}
+
+/* Find the consecutive changes at the start of the script START.
+   Return the last link before the first gap.  */
+
+struct change *
+find_change (struct change *start)
+{
+  return start;
+}
+
+struct change *
+find_reverse_change (struct change *start)
+{
+  return start;
+}
+
+/* Divide SCRIPT into pieces by calling HUNKFUN and
+   print each piece with PRINTFUN.
+   Both functions take one arg, an edit script.
+
+   HUNKFUN is called with the tail of the script
+   and returns the last link that belongs together with the start
+   of the tail.
+
+   PRINTFUN takes a subscript which belongs together (with a null
+   link at the end) and prints it.  */
+
+void
+print_script (struct change *script,
+	      struct change * (*hunkfun) (struct change *),
+	      void (*printfun) (struct change *))
+{
+  struct change *next = script;
+
+  while (next)
+    {
+      struct change *this, *end;
+
+      /* Find a set of changes that belong together.  */
+      this = next;
+      end = (*hunkfun) (next);
+
+      /* Disconnect them from the rest of the changes,
+	 making them a hunk, and remember the rest for next iteration.  */
+      next = end->link;
+      end->link = 0;
+#ifdef DEBUG
+      debug_script (this);
+#endif
+
+      /* Print this hunk.  */
+      (*printfun) (this);
+
+      /* Reconnect the script so it will all be freed properly.  */
+      end->link = next;
+    }
+}
+
+/* Print the text of a single line LINE,
+   flagging it with the characters in LINE_FLAG (which say whether
+   the line is inserted, deleted, changed, etc.).  LINE_FLAG must not
+   end in a blank, unless it is a single blank.  */
+
+void
+print_1_line (char const *line_flag, char const *const *line)
+{
+  char const *base = line[0], *limit = line[1]; /* Help the compiler.  */
+  FILE *out = outfile; /* Help the compiler some more.  */
+  char const *flag_format = 0;
+
+  /* If -T was specified, use a Tab between the line-flag and the text.
+     Otherwise use a Space (as Unix diff does).
+     Print neither space nor tab if line-flags are empty.
+     But omit trailing blanks if requested.  */
+
+  if (line_flag && *line_flag)
+    {
+      char const *flag_format_1 = flag_format = initial_tab ? "%s\t" : "%s ";
+      char const *line_flag_1 = line_flag;
+
+      if (suppress_blank_empty && **line == '\n')
+	{
+	  flag_format_1 = "%s";
+
+	  /* This hack to omit trailing blanks takes advantage of the
+	     fact that the only way that LINE_FLAG can end in a blank
+	     is when LINE_FLAG consists of a single blank.  */
+	  line_flag_1 += *line_flag_1 == ' ';
+	}
+
+      fprintf (out, flag_format_1, line_flag_1);
+    }
+
+  output_1_line (base, limit, flag_format, line_flag);
+
+  if ((!line_flag || line_flag[0]) && limit[-1] != '\n')
+    fprintf (out, "\n\\ %s\n", _("No newline at end of file"));
+}
+
+/* Output a line from BASE up to LIMIT.
+   With -t, expand white space characters to spaces, and if FLAG_FORMAT
+   is nonzero, output it with argument LINE_FLAG after every
+   internal carriage return, so that tab stops continue to line up.  */
+
+void
+output_1_line (char const *base, char const *limit, char const *flag_format,
+	       char const *line_flag)
+{
+  if (!expand_tabs)
+    fwrite (base, sizeof (char), limit - base, outfile);
+  else
+    {
+      register FILE *out = outfile;
+      register unsigned char c;
+      register char const *t = base;
+      register size_t column = 0;
+      size_t tab_size = tabsize;
+
+      while (t < limit)
+	switch ((c = *t++))
+	  {
+	  case '\t':
+	    {
+	      size_t spaces = tab_size - column % tab_size;
+	      column += spaces;
+	      do
+		putc (' ', out);
+	      while (--spaces);
+	    }
+	    break;
+
+	  case '\r':
+	    putc (c, out);
+	    if (flag_format && t < limit && *t != '\n')
+	      fprintf (out, flag_format, line_flag);
+	    column = 0;
+	    break;
+
+	  case '\b':
+	    if (column == 0)
+	      continue;
+	    column--;
+	    putc (c, out);
+	    break;
+
+	  default:
+	    column += isprint (c) != 0;
+	    putc (c, out);
+	    break;
+	  }
+    }
+}
+
+char const change_letter[] = { 0, 'd', 'a', 'c' };
+
+/* Translate an internal line number (an index into diff's table of lines)
+   into an actual line number in the input file.
+   The internal line number is I.  FILE points to the data on the file.
+
+   Internal line numbers count from 0 starting after the prefix.
+   Actual line numbers count from 1 within the entire file.  */
+
+lin
+translate_line_number (struct file_data const *file, lin i)
+{
+  return i + file->prefix_lines + 1;
+}
+
+/* Translate a line number range.  This is always done for printing,
+   so for convenience translate to long int rather than lin, so that the
+   caller can use printf with "%ld" without casting.  */
+
+void
+translate_range (struct file_data const *file,
+		 lin a, lin b,
+		 long int *aptr, long int *bptr)
+{
+  *aptr = translate_line_number (file, a - 1) + 1;
+  *bptr = translate_line_number (file, b + 1) - 1;
+}
+
+/* Print a pair of line numbers with SEPCHAR, translated for file FILE.
+   If the two numbers are identical, print just one number.
+
+   Args A and B are internal line numbers.
+   We print the translated (real) line numbers.  */
+
+void
+print_number_range (char sepchar, struct file_data *file, lin a, lin b)
+{
+  long int trans_a, trans_b;
+  translate_range (file, a, b, &trans_a, &trans_b);
+
+  /* Note: we can have B < A in the case of a range of no lines.
+     In this case, we should print the line number before the range,
+     which is B.  */
+  if (trans_b > trans_a)
+    fprintf (outfile, "%ld%c%ld", trans_a, sepchar, trans_b);
+  else
+    fprintf (outfile, "%ld", trans_b);
+}
+
+/* Look at a hunk of edit script and report the range of lines in each file
+   that it applies to.  HUNK is the start of the hunk, which is a chain
+   of `struct change'.  The first and last line numbers of file 0 are stored in
+   *FIRST0 and *LAST0, and likewise for file 1 in *FIRST1 and *LAST1.
+   Note that these are internal line numbers that count from 0.
+
+   If no lines from file 0 are deleted, then FIRST0 is LAST0+1.
+
+   Return UNCHANGED if only ignorable lines are inserted or deleted,
+   OLD if lines of file 0 are deleted,
+   NEW if lines of file 1 are inserted,
+   and CHANGED if both kinds of changes are found. */
+
+enum changes
+analyze_hunk (struct change *hunk,
+	      lin *first0, lin *last0,
+	      lin *first1, lin *last1)
+{
+  struct change *next;
+  lin l0, l1;
+  lin show_from, show_to;
+  lin i;
+  bool trivial = ignore_blank_lines || ignore_regexp.fastmap;
+  size_t trivial_length = ignore_blank_lines - 1;
+    /* If 0, ignore zero-length lines;
+       if SIZE_MAX, do not ignore lines just because of their length.  */
+  bool skip_leading_white_space =
+    (ignore_blank_lines && IGNORE_SPACE_CHANGE <= ignore_white_space);
+
+  char const * const *linbuf0 = files[0].linbuf;  /* Help the compiler.  */
+  char const * const *linbuf1 = files[1].linbuf;
+
+  show_from = show_to = 0;
+
+  *first0 = hunk->line0;
+  *first1 = hunk->line1;
+
+  next = hunk;
+  do
+    {
+      l0 = next->line0 + next->deleted - 1;
+      l1 = next->line1 + next->inserted - 1;
+      show_from += next->deleted;
+      show_to += next->inserted;
+
+      for (i = next->line0; i <= l0 && trivial; i++)
+	{
+	  char const *line = linbuf0[i];
+	  char const *newline = linbuf0[i + 1] - 1;
+	  size_t len = newline - line;
+	  char const *p = line;
+	  if (skip_leading_white_space)
+	    while (isspace ((unsigned char) *p) && *p != '\n')
+	      p++;
+	  if (newline - p != trivial_length
+	      && (! ignore_regexp.fastmap
+		  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
+	    trivial = 0;
+	}
+
+      for (i = next->line1; i <= l1 && trivial; i++)
+	{
+	  char const *line = linbuf1[i];
+	  char const *newline = linbuf1[i + 1] - 1;
+	  size_t len = newline - line;
+	  char const *p = line;
+	  if (skip_leading_white_space)
+	    while (isspace ((unsigned char) *p) && *p != '\n')
+	      p++;
+	  if (newline - p != trivial_length
+	      && (! ignore_regexp.fastmap
+		  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
+	    trivial = 0;
+	}
+    }
+  while ((next = next->link) != 0);
+
+  *last0 = l0;
+  *last1 = l1;
+
+  /* If all inserted or deleted lines are ignorable,
+     tell the caller to ignore this hunk.  */
+
+  if (trivial)
+    return UNCHANGED;
+
+  return (show_from ? OLD : UNCHANGED) | (show_to ? NEW : UNCHANGED);
+}
+
+/* Concatenate three strings, returning a newly malloc'd string.  */
+
+char *
+concat (char const *s1, char const *s2, char const *s3)
+{
+  char *new = xmalloc (strlen (s1) + strlen (s2) + strlen (s3) + 1);
+  sprintf (new, "%s%s%s", s1, s2, s3);
+  return new;
+}
+
+/* Yield a new block of SIZE bytes, initialized to zero.  */
+
+void *
+zalloc (size_t size)
+{
+  void *p = xmalloc (size);
+  memset (p, 0, size);
+  return p;
+}
+
+/* Yield the newly malloc'd pathname
+   of the file in DIR whose filename is FILE.  */
+
+char *
+dir_file_pathname (char const *dir, char const *file)
+{
+  char const *base = last_component (dir);
+  size_t baselen = base_len (base);
+  bool omit_slash = baselen == 0 || base[baselen - 1] == '/';
+  return concat (dir, "/" + omit_slash, file);
+}
+
+void
+debug_script (struct change *sp)
+{
+  fflush (stdout);
+
+  for (; sp; sp = sp->link)
+    {
+      long int line0 = sp->line0;
+      long int line1 = sp->line1;
+      long int deleted = sp->deleted;
+      long int inserted = sp->inserted;
+      fprintf (stderr, "%3ld %3ld delete %ld insert %ld\n",
+	       line0, line1, deleted, inserted);
+    }
+
+  fflush (stderr);
+}
diff --git a/test/diffutils-3.0/Makefile.am b/test/diffutils-3.0/Makefile.am
new file mode 100644
index 0000000..50acad9
--- /dev/null
+++ b/test/diffutils-3.0/Makefile.am
@@ -0,0 +1,80 @@
+# Automakefile for GNU diffutils programs.
+
+# Copyright (C) 2001-2002, 2006, 2009-2013, 2015-2017 Free Software Foundation,
+# Inc.
+
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+bin_PROGRAMS = cmp diff diff3 sdiff
+
+localedir = $(datadir)/locale
+
+AM_CPPFLAGS = -I../lib -I$(top_srcdir)/lib
+AM_CFLAGS = $(WARN_CFLAGS) $(WERROR_CFLAGS)
+
+LDADD = \
+  libver.a \
+  ../lib/libdiffutils.a \
+  $(LIBCSTACK) \
+  $(LIBINTL) \
+  $(LIBICONV) \
+  $(LIBSIGSEGV) \
+  $(LIB_CLOCK_GETTIME)
+
+diff_LDADD = $(LDADD)
+cmp_LDADD = $(LDADD)
+sdiff_LDADD = $(LDADD)
+diff3_LDADD = $(LDADD)
+
+cmp_SOURCES = cmp.c
+diff3_SOURCES = diff3.c
+sdiff_SOURCES = sdiff.c
+diff_SOURCES = \
+  analyze.c context.c diff.c dir.c ed.c ifdef.c io.c \
+  normal.c side.c util.c
+noinst_HEADERS =	\
+  die.h			\
+  diff.h		\
+  system.h
+
+MOSTLYCLEANFILES = paths.h paths.ht
+
+cmp.$(OBJEXT) diff3.$(OBJEXT) diff.$(OBJEXT) sdiff.$(OBJEXT): paths.h
+
+gdiff = `echo diff|sed '$(transform)'`
+BUILT_SOURCES = paths.h
+paths.h: Makefile.am
+	$(AM_V_GEN)(echo '#define DEFAULT_DIFF_PROGRAM "'$(gdiff)'"' && \
+	  echo '#define LOCALEDIR "$(localedir)"') >$@t && mv $@t $@
+
+noinst_LIBRARIES = libver.a
+nodist_libver_a_SOURCES = version.c version.h
+
+BUILT_SOURCES += version.c
+version.c: Makefile
+	$(AM_V_GEN)rm -f $@
+	$(AM_V_at)printf '#include <config.h>\n' > $@t
+	$(AM_V_at)printf 'char const *Version = "$(PACKAGE_VERSION)";\n' >> $@t
+	$(AM_V_at)chmod a-w $@t
+	$(AM_V_at)mv $@t $@
+
+BUILT_SOURCES += version.h
+version.h: Makefile
+	$(AM_V_GEN)rm -f $@
+	$(AM_V_at)printf 'extern char const *Version;\n' > $@t
+	$(AM_V_at)chmod a-w $@t
+	$(AM_V_at)mv $@t $@
+
+DISTCLEANFILES = version.c version.h
+MAINTAINERCLEANFILES = $(BUILT_SOURCES)
diff --git a/test/diffutils-3.0/analyze.c b/test/diffutils-3.0/analyze.c
new file mode 100644
index 0000000..403ae73
--- /dev/null
+++ b/test/diffutils-3.0/analyze.c
@@ -0,0 +1,716 @@
+/* Analyze file differences for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006-2007,
+   2009-2013, 2015-2017 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <cmpbuf.h>
+#include <error.h>
+#include <file-type.h>
+#include <xalloc.h>
+
+/* The core of the Diff algorithm.  */
+#define ELEMENT lin
+#define EQUAL(x,y) ((x) == (y))
+#define OFFSET lin
+#define EXTRA_CONTEXT_FIELDS /* none */
+#define NOTE_DELETE(c, xoff) (files[0].changed[files[0].realindexes[xoff]] = 1)
+#define NOTE_INSERT(c, yoff) (files[1].changed[files[1].realindexes[yoff]] = 1)
+#define USE_HEURISTIC 1
+#include <diffseq.h>
+
+/* Discard lines from one file that have no matches in the other file.
+
+   A line which is discarded will not be considered by the actual
+   comparison algorithm; it will be as if that line were not in the file.
+   The file's 'realindexes' table maps virtual line numbers
+   (which don't count the discarded lines) into real line numbers;
+   this is how the actual comparison algorithm produces results
+   that are comprehensible when the discarded lines are counted.
+
+   When we discard a line, we also mark it as a deletion or insertion
+   so that it will be printed in the output.  */
+
+static void
+discard_confusing_lines (struct file_data filevec[])
+{
+  int f;
+  lin i;
+  char *discarded[2];
+  lin *equiv_count[2];
+  lin *p;
+
+  /* Allocate our results.  */
+  p = xmalloc ((filevec[0].buffered_lines + filevec[1].buffered_lines)
+	       * (2 * sizeof *p));
+  for (f = 0; f < 2; f++)
+    {
+      filevec[f].undiscarded = p;  p += filevec[f].buffered_lines;
+      filevec[f].realindexes = p;  p += filevec[f].buffered_lines;
+    }
+
+  /* Set up equiv_count[F][I] as the number of lines in file F
+     that fall in equivalence class I.  */
+
+  p = zalloc (filevec[0].equiv_max * (2 * sizeof *p));
+  equiv_count[0] = p;
+  equiv_count[1] = p + filevec[0].equiv_max;
+
+  for (i = 0; i < filevec[0].buffered_lines; ++i)
+    ++equiv_count[0][filevec[0].equivs[i]];
+  for (i = 0; i < filevec[1].buffered_lines; ++i)
+    ++equiv_count[1][filevec[1].equivs[i]];
+
+  /* Set up tables of which lines are going to be discarded.  */
+
+  discarded[0] = zalloc (filevec[0].buffered_lines
+			 + filevec[1].buffered_lines);
+  discarded[1] = discarded[0] + filevec[0].buffered_lines;
+
+  /* Mark to be discarded each line that matches no line of the other file.
+     If a line matches many lines, mark it as provisionally discardable.  */
+
+  for (f = 0; f < 2; f++)
+    {
+      size_t end = filevec[f].buffered_lines;
+      char *discards = discarded[f];
+      lin *counts = equiv_count[1 - f];
+      lin *equivs = filevec[f].equivs;
+      size_t many = 5;
+      size_t tem = end / 64;
+
+      /* Multiply MANY by approximate square root of number of lines.
+	 That is the threshold for provisionally discardable lines.  */
+      while ((tem = tem >> 2) > 0)
+	many *= 2;
+
+      for (i = 0; i < end; i++)
+	{
+	  lin nmatch;
+	  if (equivs[i] == 0)
+	    continue;
+	  nmatch = counts[equivs[i]];
+	  if (nmatch == 0)
+	    discards[i] = 1;
+	  else if (nmatch > many)
+	    discards[i] = 2;
+	}
+    }
+
+  /* Don't really discard the provisional lines except when they occur
+     in a run of discardables, with nonprovisionals at the beginning
+     and end.  */
+
+  for (f = 0; f < 2; f++)
+    {
+      lin end = filevec[f].buffered_lines;
+      register char *discards = discarded[f];
+
+      for (i = 0; i < end; i++)
+	{
+	  /* Cancel provisional discards not in middle of run of discards.  */
+	  if (discards[i] == 2)
+	    discards[i] = 0;
+	  else if (discards[i] != 0)
+	    {
+	      /* We have found a nonprovisional discard.  */
+	      register lin j;
+	      lin length;
+	      lin provisional = 0;
+
+	      /* Find end of this run of discardable lines.
+		 Count how many are provisionally discardable.  */
+	      for (j = i; j < end; j++)
+		{
+		  if (discards[j] == 0)
+		    break;
+		  if (discards[j] == 2)
+		    ++provisional;
+		}
+
+	      /* Cancel provisional discards at end, and shrink the run.  */
+	      while (j > i && discards[j - 1] == 2)
+		discards[--j] = 0, --provisional;
+
+	      /* Now we have the length of a run of discardable lines
+		 whose first and last are not provisional.  */
+	      length = j - i;
+
+	      /* If 1/4 of the lines in the run are provisional,
+		 cancel discarding of all provisional lines in the run.  */
+	      if (provisional * 4 > length)
+		{
+		  while (j > i)
+		    if (discards[--j] == 2)
+		      discards[j] = 0;
+		}
+	      else
+		{
+		  register lin consec;
+		  lin minimum = 1;
+		  lin tem = length >> 2;
+
+		  /* MINIMUM is approximate square root of LENGTH/4.
+		     A subrun of two or more provisionals can stand
+		     when LENGTH is at least 16.
+		     A subrun of 4 or more can stand when LENGTH >= 64.  */
+		  while (0 < (tem >>= 2))
+		    minimum <<= 1;
+		  minimum++;
+
+		  /* Cancel any subrun of MINIMUM or more provisionals
+		     within the larger run.  */
+		  for (j = 0, consec = 0; j < length; j++)
+		    if (discards[i + j] != 2)
+		      consec = 0;
+		    else if (minimum == ++consec)
+		      /* Back up to start of subrun, to cancel it all.  */
+		      j -= consec;
+		    else if (minimum < consec)
+		      discards[i + j] = 0;
+
+		  /* Scan from beginning of run
+		     until we find 3 or more nonprovisionals in a row
+		     or until the first nonprovisional at least 8 lines in.
+		     Until that point, cancel any provisionals.  */
+		  for (j = 0, consec = 0; j < length; j++)
+		    {
+		      if (j >= 8 && discards[i + j] == 1)
+			break;
+		      if (discards[i + j] == 2)
+			consec = 0, discards[i + j] = 0;
+		      else if (discards[i + j] == 0)
+			consec = 0;
+		      else
+			consec++;
+		      if (consec == 3)
+			break;
+		    }
+
+		  /* I advances to the last line of the run.  */
+		  i += length - 1;
+
+		  /* Same thing, from end.  */
+		  for (j = 0, consec = 0; j < length; j++)
+		    {
+		      if (j >= 8 && discards[i - j] == 1)
+			break;
+		      if (discards[i - j] == 2)
+			consec = 0, discards[i - j] = 0;
+		      else if (discards[i - j] == 0)
+			consec = 0;
+		      else
+			consec++;
+		      if (consec == 3)
+			break;
+		    }
+		}
+	    }
+	}
+    }
+
+  /* Actually discard the lines. */
+  for (f = 0; f < 2; f++)
+    {
+      char *discards = discarded[f];
+      lin end = filevec[f].buffered_lines;
+      lin j = 0;
+      for (i = 0; i < end; ++i)
+	if (minimal || discards[i] == 0)
+	  {
+	    filevec[f].undiscarded[j] = filevec[f].equivs[i];
+	    filevec[f].realindexes[j++] = i;
+	  }
+	else
+	  filevec[f].changed[i] = 1;
+      filevec[f].nondiscarded_lines = j;
+    }
+
+  free (discarded[0]);
+  free (equiv_count[0]);
+}
+
+/* Adjust inserts/deletes of identical lines to join changes
+   as much as possible.
+
+   We do something when a run of changed lines include a
+   line at one end and have an excluded, identical line at the other.
+   We are free to choose which identical line is included.
+   'compareseq' usually chooses the one at the beginning,
+   but usually it is cleaner to consider the following identical line
+   to be the "change".  */
+
+static void
+shift_boundaries (struct file_data filevec[])
+{
+  int f;
+
+  for (f = 0; f < 2; f++)
+    {
+      char *changed = filevec[f].changed;
+      char *other_changed = filevec[1 - f].changed;
+      lin const *equivs = filevec[f].equivs;
+      lin i = 0;
+      lin j = 0;
+      lin i_end = filevec[f].buffered_lines;
+
+      while (1)
+	{
+	  lin runlength, start, corresponding;
+
+	  /* Scan forwards to find beginning of another run of changes.
+	     Also keep track of the corresponding point in the other file.  */
+
+	  while (i < i_end && !changed[i])
+	    {
+	      while (other_changed[j++])
+		continue;
+	      i++;
+	    }
+
+	  if (i == i_end)
+	    break;
+
+	  start = i;
+
+	  /* Find the end of this run of changes.  */
+
+	  while (changed[++i])
+	    continue;
+	  while (other_changed[j])
+	    j++;
+
+	  do
+	    {
+	      /* Record the length of this run of changes, so that
+		 we can later determine whether the run has grown.  */
+	      runlength = i - start;
+
+	      /* Move the changed region back, so long as the
+		 previous unchanged line matches the last changed one.
+		 This merges with previous changed regions.  */
+
+	      while (start && equivs[start - 1] == equivs[i - 1])
+		{
+		  changed[--start] = 1;
+		  changed[--i] = 0;
+		  while (changed[start - 1])
+		    start--;
+		  while (other_changed[--j])
+		    continue;
+		}
+
+	      /* Set CORRESPONDING to the end of the changed run, at the last
+		 point where it corresponds to a changed run in the other file.
+		 CORRESPONDING == I_END means no such point has been found.  */
+	      corresponding = other_changed[j - 1] ? i : i_end;
+
+	      /* Move the changed region forward, so long as the
+		 first changed line matches the following unchanged one.
+		 This merges with following changed regions.
+		 Do this second, so that if there are no merges,
+		 the changed region is moved forward as far as possible.  */
+
+	      while (i != i_end && equivs[start] == equivs[i])
+		{
+		  changed[start++] = 0;
+		  changed[i++] = 1;
+		  while (changed[i])
+		    i++;
+		  while (other_changed[++j])
+		    corresponding = i;
+		}
+	    }
+	  while (runlength != i - start);
+
+	  /* If possible, move the fully-merged run of changes
+	     back to a corresponding run in the other file.  */
+
+	  while (corresponding < i)
+	    {
+	      changed[--start] = 1;
+	      changed[--i] = 0;
+	      while (other_changed[--j])
+		continue;
+	    }
+	}
+    }
+}
+
+/* Cons an additional entry onto the front of an edit script OLD.
+   LINE0 and LINE1 are the first affected lines in the two files (origin 0).
+   DELETED is the number of lines deleted here from file 0.
+   INSERTED is the number of lines inserted here in file 1.
+
+   If DELETED is 0 then LINE0 is the number of the line before
+   which the insertion was done; vice versa for INSERTED and LINE1.  */
+
+static struct change *
+add_change (lin line0, lin line1, lin deleted, lin inserted,
+	    struct change *old)
+{
+  struct change *new = xmalloc (sizeof *new);
+
+  new->line0 = line0;
+  new->line1 = line1;
+  new->inserted = inserted;
+  new->deleted = deleted;
+  new->link = old;
+  return new;
+}
+
+/* Scan the tables of which lines are inserted and deleted,
+   producing an edit script in reverse order.  */
+
+static struct change *
+build_reverse_script (struct file_data const filevec[])
+{
+  struct change *script = 0;
+  char *changed0 = filevec[0].changed;
+  char *changed1 = filevec[1].changed;
+  lin len0 = filevec[0].buffered_lines;
+  lin len1 = filevec[1].buffered_lines;
+
+  /* Note that changedN[lenN] does exist, and is 0.  */
+
+  lin i0 = 0, i1 = 0;
+
+  while (i0 < len0 || i1 < len1)
+    {
+      if (changed0[i0] | changed1[i1])
+	{
+	  lin line0 = i0, line1 = i1;
+
+	  /* Find # lines changed here in each file.  */
+	  while (changed0[i0]) ++i0;
+	  while (changed1[i1]) ++i1;
+
+	  /* Record this change.  */
+	  script = add_change (line0, line1, i0 - line0, i1 - line1, script);
+	}
+
+      /* We have reached lines in the two files that match each other.  */
+      i0++, i1++;
+    }
+
+  return script;
+}
+
+/* Scan the tables of which lines are inserted and deleted,
+   producing an edit script in forward order.  */
+
+static struct change *
+build_script (struct file_data const filevec[])
+{
+  struct change *script = 0;
+  char *changed0 = filevec[0].changed;
+  char *changed1 = filevec[1].changed;
+  lin i0 = filevec[0].buffered_lines, i1 = filevec[1].buffered_lines;
+
+  /* Note that changedN[-1] does exist, and is 0.  */
+
+  while (i0 >= 0 || i1 >= 0)
+    {
+      if (changed0[i0 - 1] | changed1[i1 - 1])
+	{
+	  lin line0 = i0, line1 = i1;
+
+	  /* Find # lines changed here in each file.  */
+	  while (changed0[i0 - 1]) --i0;
+	  while (changed1[i1 - 1]) --i1;
+
+	  /* Record this change.  */
+	  script = add_change (i0, i1, line0 - i0, line1 - i1, script);
+	}
+
+      /* We have reached lines in the two files that match each other.  */
+      i0--, i1--;
+    }
+
+  return script;
+}
+
+/* If CHANGES, briefly report that two files differed.  */
+static void
+briefly_report (int changes, struct file_data const filevec[])
+{
+  if (changes)
+    message ((brief
+	      ? _("Files %s and %s differ\n")
+	      : _("Binary files %s and %s differ\n")),
+	     file_label[0] ? file_label[0] : filevec[0].name,
+	     file_label[1] ? file_label[1] : filevec[1].name);
+}
+
+/* Report the differences of two files.  */
+int
+diff_2_files (struct comparison *cmp)
+{
+  int f;
+  struct change *e, *p;
+  struct change *script;
+  int changes;
+
+
+  /* If we have detected that either file is binary,
+     compare the two files as binary.  This can happen
+     only when the first chunk is read.
+     Also, --brief without any --ignore-* options means
+     we can speed things up by treating the files as binary.  */
+
+  if (read_files (cmp->file, files_can_be_treated_as_binary))
+    {
+      /* Files with different lengths must be different.  */
+      if (cmp->file[0].stat.st_size != cmp->file[1].stat.st_size
+	  && 0 < cmp->file[0].stat.st_size
+	  && 0 < cmp->file[1].stat.st_size
+	  && (cmp->file[0].desc < 0 || S_ISREG (cmp->file[0].stat.st_mode))
+	  && (cmp->file[1].desc < 0 || S_ISREG (cmp->file[1].stat.st_mode)))
+	changes = 1;
+
+      /* Standard input equals itself.  */
+      else if (cmp->file[0].desc == cmp->file[1].desc)
+	changes = 0;
+
+      else
+	/* Scan both files, a buffer at a time, looking for a difference.  */
+	{
+	  /* Allocate same-sized buffers for both files.  */
+	  size_t lcm_max = PTRDIFF_MAX - 1;
+	  size_t buffer_size =
+	    buffer_lcm (sizeof (word),
+			buffer_lcm (STAT_BLOCKSIZE (cmp->file[0].stat),
+				    STAT_BLOCKSIZE (cmp->file[1].stat),
+				    lcm_max),
+			lcm_max);
+	  for (f = 0; f < 2; f++)
+	    cmp->file[f].buffer = xrealloc (cmp->file[f].buffer, buffer_size);
+
+	  for (;; cmp->file[0].buffered = cmp->file[1].buffered = 0)
+	    {
+	      /* Read a buffer's worth from both files.  */
+	      for (f = 0; f < 2; f++)
+		if (0 <= cmp->file[f].desc)
+		  file_block_read (&cmp->file[f],
+				   buffer_size - cmp->file[f].buffered);
+
+	      /* If the buffers differ, the files differ.  */
+	      if (cmp->file[0].buffered != cmp->file[1].buffered
+		  || memcmp (cmp->file[0].buffer,
+			     cmp->file[1].buffer,
+			     cmp->file[0].buffered))
+		{
+		  changes = 1;
+		  break;
+		}
+
+	      /* If we reach end of file, the files are the same.  */
+	      if (cmp->file[0].buffered != buffer_size)
+		{
+		  changes = 0;
+		  break;
+		}
+	    }
+	}
+
+      briefly_report (changes, cmp->file);
+    }
+  else
+    {
+      struct context ctxt;
+      lin diags;
+      lin too_expensive;
+
+      /* Allocate vectors for the results of comparison:
+	 a flag for each line of each file, saying whether that line
+	 is an insertion or deletion.
+	 Allocate an extra element, always 0, at each end of each vector.  */
+
+      size_t s = cmp->file[0].buffered_lines + cmp->file[1].buffered_lines + 4;
+      char *flag_space = zalloc (s);
+      cmp->file[0].changed = flag_space + 1;
+      cmp->file[1].changed = flag_space + cmp->file[0].buffered_lines + 3;
+
+      /* Some lines are obviously insertions or deletions
+	 because they don't match anything.  Detect them now, and
+	 avoid even thinking about them in the main comparison algorithm.  */
+
+      discard_confusing_lines (cmp->file);
+
+      /* Now do the main comparison algorithm, considering just the
+	 undiscarded lines.  */
+
+      ctxt.xvec = cmp->file[0].undiscarded;
+      ctxt.yvec = cmp->file[1].undiscarded;
+      diags = (cmp->file[0].nondiscarded_lines
+	       + cmp->file[1].nondiscarded_lines + 3);
+      ctxt.fdiag = xmalloc (diags * (2 * sizeof *ctxt.fdiag));
+      ctxt.bdiag = ctxt.fdiag + diags;
+      ctxt.fdiag += cmp->file[1].nondiscarded_lines + 1;
+      ctxt.bdiag += cmp->file[1].nondiscarded_lines + 1;
+
+      ctxt.heuristic = speed_large_files;
+
+      /* Set TOO_EXPENSIVE to be the approximate square root of the
+	 input size, bounded below by 4096.  4096 seems to be good for
+	 circa-2016 CPUs; see Bug#16848 and Bug#24715.  */
+      too_expensive = 1;
+      for (;  diags != 0;  diags >>= 2)
+	too_expensive <<= 1;
+      ctxt.too_expensive = MAX (4096, too_expensive);
+
+      files[0] = cmp->file[0];
+      files[1] = cmp->file[1];
+
+      compareseq (0, cmp->file[0].nondiscarded_lines,
+		  0, cmp->file[1].nondiscarded_lines, minimal, &ctxt);
+
+      free (ctxt.fdiag - (cmp->file[1].nondiscarded_lines + 1));
+
+      /* Modify the results slightly to make them prettier
+	 in cases where that can validly be done.  */
+
+      shift_boundaries (cmp->file);
+
+      /* Get the results of comparison in the form of a chain
+	 of 'struct change's -- an edit script.  */
+
+      if (output_style == OUTPUT_ED)
+	script = build_reverse_script (cmp->file);
+      else
+	script = build_script (cmp->file);
+
+      /* Set CHANGES if we had any diffs.
+	 If some changes are ignored, we must scan the script to decide.  */
+      if (ignore_blank_lines || ignore_regexp.fastmap)
+	{
+	  struct change *next = script;
+	  changes = 0;
+
+	  while (next && changes == 0)
+	    {
+	      struct change *this, *end;
+	      lin first0, last0, first1, last1;
+
+	      /* Find a set of changes that belong together.  */
+	      this = next;
+	      end = find_change (next);
+
+	      /* Disconnect them from the rest of the changes, making them
+		 a hunk, and remember the rest for next iteration.  */
+	      next = end->link;
+	      end->link = 0;
+
+	      /* Determine whether this hunk is really a difference.  */
+	      if (analyze_hunk (this, &first0, &last0, &first1, &last1))
+		changes = 1;
+
+	      /* Reconnect the script so it will all be freed properly.  */
+	      end->link = next;
+	    }
+	}
+      else
+	changes = (script != 0);
+
+      if (brief)
+	briefly_report (changes, cmp->file);
+      else
+	{
+	  if (changes || !no_diff_means_no_output)
+	    {
+	      /* Record info for starting up output,
+		 to be used if and when we have some output to print.  */
+	      setup_output (file_label[0] ? file_label[0] : cmp->file[0].name,
+			    file_label[1] ? file_label[1] : cmp->file[1].name,
+			    cmp->parent != 0);
+
+	      switch (output_style)
+		{
+		case OUTPUT_CONTEXT:
+		  print_context_script (script, false);
+		  break;
+
+		case OUTPUT_UNIFIED:
+		  print_context_script (script, true);
+		  break;
+
+		case OUTPUT_ED:
+		  print_ed_script (script);
+		  break;
+
+		case OUTPUT_FORWARD_ED:
+		  pr_forward_ed_script (script);
+		  break;
+
+		case OUTPUT_RCS:
+		  print_rcs_script (script);
+		  break;
+
+		case OUTPUT_NORMAL:
+		  print_normal_script (script);
+		  break;
+
+		case OUTPUT_IFDEF:
+		  print_ifdef_script (script);
+		  break;
+
+		case OUTPUT_SDIFF:
+		  print_sdiff_script (script);
+		  break;
+
+		default:
+		  abort ();
+		}
+
+	      finish_output ();
+	    }
+	}
+
+      free (cmp->file[0].undiscarded);
+
+      free (flag_space);
+
+      for (f = 0; f < 2; f++)
+	{
+	  free (cmp->file[f].equivs);
+	  free (cmp->file[f].linbuf + cmp->file[f].linbuf_base);
+	}
+
+      for (e = script; e; e = p)
+	{
+	  p = e->link;
+	  free (e);
+	}
+
+      if (! ROBUST_OUTPUT_STYLE (output_style))
+	for (f = 0; f < 2; ++f)
+	  if (cmp->file[f].missing_newline)
+	    {
+	      error (0, 0, "%s: %s\n",
+		     file_label[f] ? file_label[f] : cmp->file[f].name,
+		     _("No newline at end of file"));
+	      changes = 2;
+	    }
+    }
+
+  if (cmp->file[0].buffer != cmp->file[1].buffer)
+    free (cmp->file[0].buffer);
+  free (cmp->file[1].buffer);
+
+  return changes;
+}
diff --git a/test/diffutils-3.0/cmp.c b/test/diffutils-3.0/cmp.c
new file mode 100644
index 0000000..bc39153
--- /dev/null
+++ b/test/diffutils-3.0/cmp.c
@@ -0,0 +1,693 @@
+/* cmp - compare two files byte by byte
+
+   Copyright (C) 1990-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2013,
+   2015-2017 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+
+#include <c-stack.h>
+#include <cmpbuf.h>
+#include "die.h"
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <hard-locale.h>
+#include <inttostr.h>
+#include <progname.h>
+#include <unlocked-io.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <binary-io.h>
+#include <xstrtol.h>
+
+/* The official name of this program (e.g., no 'g' prefix).  */
+#define PROGRAM_NAME "cmp"
+
+#define AUTHORS \
+  proper_name_utf8 ("Torbjorn Granlund", "Torbj\303\266rn Granlund"), \
+  proper_name ("David MacKenzie")
+
+#if defined LC_MESSAGES && ENABLE_NLS
+# define hard_locale_LC_MESSAGES hard_locale (LC_MESSAGES)
+#else
+# define hard_locale_LC_MESSAGES 0
+#endif
+
+static int cmp (void);
+static off_t file_position (int);
+static size_t block_compare (word const *, word const *) _GL_ATTRIBUTE_PURE;
+static size_t count_newlines (char *, size_t);
+static void sprintc (char *, unsigned char);
+
+/* Filenames of the compared files.  */
+static char const *file[2];
+
+/* File descriptors of the files.  */
+static int file_desc[2];
+
+/* Status of the files.  */
+static struct stat stat_buf[2];
+
+/* Read buffers for the files.  */
+static word *buffer[2];
+
+/* Optimal block size for the files.  */
+static size_t buf_size;
+
+/* Initial prefix to ignore for each file.  */
+static off_t ignore_initial[2];
+
+/* Number of bytes to compare.  */
+static uintmax_t bytes = UINTMAX_MAX;
+
+/* Output format.  */
+static enum comparison_type
+  {
+    type_first_diff,	/* Print the first difference.  */
+    type_all_diffs,	/* Print all differences.  */
+    type_no_stdout,	/* Do not output to stdout; only stderr.  */
+    type_status		/* Exit status only.  */
+  } comparison_type;
+
+/* If nonzero, print values of bytes quoted like cat -t does. */
+static bool opt_print_bytes;
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  HELP_OPTION = CHAR_MAX + 1
+};
+
+static struct option const long_options[] =
+{
+  {"print-bytes", 0, 0, 'b'},
+  {"print-chars", 0, 0, 'c'}, /* obsolescent as of diffutils 2.7.3 */
+  {"ignore-initial", 1, 0, 'i'},
+  {"verbose", 0, 0, 'l'},
+  {"bytes", 1, 0, 'n'},
+  {"silent", 0, 0, 's'},
+  {"quiet", 0, 0, 's'},
+  {"version", 0, 0, 'v'},
+  {"help", 0, 0, HELP_OPTION},
+  {0, 0, 0, 0}
+};
+
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  die (EXIT_TROUBLE, 0,
+	 _("Try '%s --help' for more information."), program_name);
+}
+
+static char const valid_suffixes[] = "kKMGTPEZY0";
+
+/* Update ignore_initial[F] according to the result of parsing an
+   *operand ARGPTR of --ignore-initial, updating *ARGPTR to point
+   *after the operand.  If DELIMITER is nonzero, the operand may be
+   *followed by DELIMITER; otherwise it must be null-terminated.  */
+static void
+specify_ignore_initial (int f, char **argptr, char delimiter)
+{
+  uintmax_t val;
+  char const *arg = *argptr;
+  strtol_error e = xstrtoumax (arg, argptr, 0, &val, valid_suffixes);
+  if (! (e == LONGINT_OK
+	 || (e == LONGINT_INVALID_SUFFIX_CHAR && **argptr == delimiter))
+      || TYPE_MAXIMUM (off_t) < val)
+    try_help ("invalid --ignore-initial value '%s'", arg);
+  if (ignore_initial[f] < val)
+    ignore_initial[f] = val;
+}
+
+/* Specify the output format.  */
+static void
+specify_comparison_type (enum comparison_type t)
+{
+  if (comparison_type && comparison_type != t)
+    try_help ("options -l and -s are incompatible", 0);
+  comparison_type = t;
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    die (EXIT_TROUBLE, 0, "%s", _("write failed"));
+  else if (fclose (stdout) != 0)
+    die (EXIT_TROUBLE, errno, "%s", _("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-b, --print-bytes          print differing bytes"),
+  N_("-i, --ignore-initial=SKIP         skip first SKIP bytes of both inputs"),
+  N_("-i, --ignore-initial=SKIP1:SKIP2  skip first SKIP1 bytes of FILE1 and\n"
+     "                                      first SKIP2 bytes of FILE2"),
+  N_("-l, --verbose              output byte numbers and differing byte values"),
+  N_("-n, --bytes=LIMIT          compare at most LIMIT bytes"),
+  N_("-s, --quiet, --silent      suppress all normal output"),
+  N_("    --help                 display this help and exit"),
+  N_("-v, --version              output version information and exit"),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILE1 [FILE2 [SKIP1 [SKIP2]]]\n"),
+	  program_name);
+  printf ("%s\n", _("Compare two files byte by byte."));
+  printf ("\n%s\n\n",
+_("The optional SKIP1 and SKIP2 specify the number of bytes to skip\n"
+  "at the beginning of each file (zero by default)."));
+
+  fputs (_("\
+Mandatory arguments to long options are mandatory for short options too.\n\
+"), stdout);
+  for (p = option_help_msgid;  *p;  p++)
+    printf ("  %s\n", _(*p));
+  printf ("\n%s\n\n%s\n%s\n",
+	  _("SKIP values may be followed by the following multiplicative suffixes:\n\
+kB 1000, K 1024, MB 1,000,000, M 1,048,576,\n\
+GB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y."),
+	  _("If a FILE is '-' or missing, read standard input."),
+	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+int
+main (int argc, char **argv)
+{
+  int c, f, exit_status;
+  size_t words_per_buffer;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+
+  /* Parse command line options.  */
+
+  while ((c = getopt_long (argc, argv, "bci:ln:sv", long_options, 0))
+	 != -1)
+    switch (c)
+      {
+      case 'b':
+      case 'c': /* 'c' is obsolescent as of diffutils 2.7.3 */
+	opt_print_bytes = true;
+	break;
+
+      case 'i':
+	specify_ignore_initial (0, &optarg, ':');
+	if (*optarg++ == ':')
+	  specify_ignore_initial (1, &optarg, 0);
+	else if (ignore_initial[1] < ignore_initial[0])
+	  ignore_initial[1] = ignore_initial[0];
+	break;
+
+      case 'l':
+	specify_comparison_type (type_all_diffs);
+	break;
+
+      case 'n':
+	{
+	  uintmax_t n;
+	  if (xstrtoumax (optarg, 0, 0, &n, valid_suffixes) != LONGINT_OK)
+	    try_help ("invalid --bytes value '%s'", optarg);
+	  if (n < bytes)
+	    bytes = n;
+	}
+	break;
+
+      case 's':
+	specify_comparison_type (type_status);
+	break;
+
+      case 'v':
+	version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version,
+		     AUTHORS, (char *) NULL);
+	check_stdout ();
+	return EXIT_SUCCESS;
+
+      case HELP_OPTION:
+	usage ();
+	check_stdout ();
+	return EXIT_SUCCESS;
+
+      default:
+	try_help (0, 0);
+      }
+
+  if (optind == argc)
+    try_help ("missing operand after '%s'", argv[argc - 1]);
+
+  file[0] = argv[optind++];
+  file[1] = optind < argc ? argv[optind++] : "-";
+
+  for (f = 0; f < 2 && optind < argc; f++)
+    {
+      char *arg = argv[optind++];
+      specify_ignore_initial (f, &arg, 0);
+    }
+
+  if (optind < argc)
+    try_help ("extra operand '%s'", argv[optind]);
+
+  for (f = 0; f < 2; f++)
+    {
+      /* If file[1] is "-", treat it first; this avoids a misdiagnostic if
+	 stdin is closed and opening file[0] yields file descriptor 0.  */
+      int f1 = f ^ (STREQ (file[1], "-"));
+
+      /* Two files with the same name and offset are identical.
+	 But wait until we open the file once, for proper diagnostics.  */
+      if (f && ignore_initial[0] == ignore_initial[1]
+	  && file_name_cmp (file[0], file[1]) == 0)
+	return EXIT_SUCCESS;
+
+      if (STREQ (file[f1], "-"))
+	{
+	  file_desc[f1] = STDIN_FILENO;
+	  if (O_BINARY && ! isatty (STDIN_FILENO))
+	    set_binary_mode (STDIN_FILENO, O_BINARY);
+	}
+      else
+	file_desc[f1] = open (file[f1], O_RDONLY | O_BINARY, 0);
+
+      if (file_desc[f1] < 0 || fstat (file_desc[f1], stat_buf + f1) != 0)
+	{
+	  if (file_desc[f1] < 0 && comparison_type == type_status)
+	    exit (EXIT_TROUBLE);
+	  else
+	    die (EXIT_TROUBLE, errno, "%s", file[f1]);
+	}
+    }
+
+  /* If the files are links to the same inode and have the same file position,
+     they are identical.  */
+
+  if (0 < same_file (&stat_buf[0], &stat_buf[1])
+      && same_file_attributes (&stat_buf[0], &stat_buf[1])
+      && file_position (0) == file_position (1))
+    return EXIT_SUCCESS;
+
+  /* If output is redirected to the null device, we can avoid some of
+     the work.  */
+
+  if (comparison_type != type_status)
+    {
+      struct stat outstat, nullstat;
+
+      if (fstat (STDOUT_FILENO, &outstat) == 0
+	  && stat (NULL_DEVICE, &nullstat) == 0
+	  && 0 < same_file (&outstat, &nullstat))
+	comparison_type = type_no_stdout;
+    }
+
+  /* If only a return code is needed,
+     and if both input descriptors are associated with plain files,
+     conclude that the files differ if they have different sizes
+     and if more bytes will be compared than are in the smaller file.  */
+
+  if (comparison_type == type_status
+      && S_ISREG (stat_buf[0].st_mode)
+      && S_ISREG (stat_buf[1].st_mode))
+    {
+      off_t s0 = stat_buf[0].st_size - file_position (0);
+      off_t s1 = stat_buf[1].st_size - file_position (1);
+      if (s0 < 0)
+	s0 = 0;
+      if (s1 < 0)
+	s1 = 0;
+      if (s0 != s1 && MIN (s0, s1) < bytes)
+	exit (EXIT_FAILURE);
+    }
+
+  /* Get the optimal block size of the files.  */
+
+  buf_size = buffer_lcm (STAT_BLOCKSIZE (stat_buf[0]),
+			 STAT_BLOCKSIZE (stat_buf[1]),
+			 PTRDIFF_MAX - sizeof (word));
+
+  /* Allocate word-aligned buffers, with space for sentinels at the end.  */
+
+  words_per_buffer = (buf_size + 2 * sizeof (word) - 1) / sizeof (word);
+  buffer[0] = xmalloc (2 * sizeof (word) * words_per_buffer);
+  buffer[1] = buffer[0] + words_per_buffer;
+
+  exit_status = cmp ();
+
+  for (f = 0; f < 2; f++)
+    if (close (file_desc[f]) != 0)
+      die (EXIT_TROUBLE, errno, "%s", file[f]);
+  if (exit_status != EXIT_SUCCESS && comparison_type < type_no_stdout)
+    check_stdout ();
+  exit (exit_status);
+  return exit_status;
+}
+
+/* Compare the two files already open on 'file_desc[0]' and 'file_desc[1]',
+   using 'buffer[0]' and 'buffer[1]'.
+   Return EXIT_SUCCESS if identical, EXIT_FAILURE if different,
+   >1 if error.  */
+
+static int
+cmp (void)
+{
+  bool at_line_start = true;
+  off_t line_number = 1;	/* Line number (1...) of difference. */
+  off_t byte_number = 1;	/* Byte number (1...) of difference. */
+  uintmax_t remaining = bytes;	/* Remaining number of bytes to compare.  */
+  size_t read0, read1;		/* Number of bytes read from each file. */
+  size_t first_diff;		/* Offset (0...) in buffers of 1st diff. */
+  size_t smaller;		/* The lesser of 'read0' and 'read1'. */
+  word *buffer0 = buffer[0];
+  word *buffer1 = buffer[1];
+  char *buf0 = (char *) buffer0;
+  char *buf1 = (char *) buffer1;
+  int differing = 0;
+  int f;
+  int offset_width IF_LINT (= 0);
+
+  if (comparison_type == type_all_diffs)
+    {
+      off_t byte_number_max = MIN (bytes, TYPE_MAXIMUM (off_t));
+
+      for (f = 0; f < 2; f++)
+	if (S_ISREG (stat_buf[f].st_mode))
+	  {
+	    off_t file_bytes = stat_buf[f].st_size - file_position (f);
+	    if (file_bytes < byte_number_max)
+	      byte_number_max = file_bytes;
+	  }
+
+      for (offset_width = 1; (byte_number_max /= 10) != 0; offset_width++)
+	continue;
+    }
+
+  for (f = 0; f < 2; f++)
+    {
+      off_t ig = ignore_initial[f];
+      if (ig && file_position (f) == -1)
+	{
+	  /* lseek failed; read and discard the ignored initial prefix.  */
+	  do
+	    {
+	      size_t bytes_to_read = MIN (ig, buf_size);
+	      size_t r = block_read (file_desc[f], buf0, bytes_to_read);
+	      if (r != bytes_to_read)
+		{
+		  if (r == SIZE_MAX)
+		    die (EXIT_TROUBLE, errno, "%s", file[f]);
+		  break;
+		}
+	      ig -= r;
+	    }
+	  while (ig);
+	}
+    }
+
+  do
+    {
+      size_t bytes_to_read = buf_size;
+
+      if (remaining != UINTMAX_MAX)
+	{
+	  if (remaining < bytes_to_read)
+	    bytes_to_read = remaining;
+	  remaining -= bytes_to_read;
+	}
+
+      read0 = block_read (file_desc[0], buf0, bytes_to_read);
+      if (read0 == SIZE_MAX)
+	die (EXIT_TROUBLE, errno, "%s", file[0]);
+      read1 = block_read (file_desc[1], buf1, bytes_to_read);
+      if (read1 == SIZE_MAX)
+	die (EXIT_TROUBLE, errno, "%s", file[1]);
+
+      smaller = MIN (read0, read1);
+
+      /* Optimize the common case where the buffers are the same.  */
+      if (memcmp (buf0, buf1, smaller) == 0)
+	first_diff = smaller;
+      else
+	{
+	  /* Insert sentinels for the block compare.  */
+	  buf0[read0] = ~buf1[read0];
+	  buf1[read1] = ~buf0[read1];
+
+	  first_diff = block_compare (buffer0, buffer1);
+	}
+
+      byte_number += first_diff;
+      if (comparison_type == type_first_diff && first_diff != 0)
+	{
+	  line_number += count_newlines (buf0, first_diff);
+	  at_line_start = buf0[first_diff - 1] == '\n';
+	}
+
+      if (first_diff < smaller)
+	{
+	  switch (comparison_type)
+	    {
+	    case type_first_diff:
+	      {
+		char byte_buf[INT_BUFSIZE_BOUND (off_t)];
+		char line_buf[INT_BUFSIZE_BOUND (off_t)];
+		char const *byte_num = offtostr (byte_number, byte_buf);
+		char const *line_num = offtostr (line_number, line_buf);
+		if (!opt_print_bytes)
+		  {
+		    /* See POSIX for this format.  This message is
+		       used only in the POSIX locale, so it need not
+		       be translated.  */
+		    static char const char_message[] =
+		      "%s %s differ: char %s, line %s\n";
+
+		    /* The POSIX rationale recommends using the word
+		       "byte" outside the POSIX locale.  Some gettext
+		       implementations translate even in the POSIX
+		       locale if certain other environment variables
+		       are set, so use "byte" if a translation is
+		       available, or if outside the POSIX locale.  */
+		    static char const byte_msgid[] =
+		      N_("%s %s differ: byte %s, line %s\n");
+		    char const *byte_message = _(byte_msgid);
+		    bool use_byte_message = (byte_message != byte_msgid
+					     || hard_locale_LC_MESSAGES);
+
+		    printf (use_byte_message ? byte_message : char_message,
+			    file[0], file[1], byte_num, line_num);
+		  }
+		else
+		  {
+		    unsigned char c0 = buf0[first_diff];
+		    unsigned char c1 = buf1[first_diff];
+		    char s0[5];
+		    char s1[5];
+		    sprintc (s0, c0);
+		    sprintc (s1, c1);
+		    printf (_("%s %s differ: byte %s, line %s is %3o %s %3o %s\n"),
+			    file[0], file[1], byte_num, line_num,
+			    c0, s0, c1, s1);
+		  }
+	      }
+	      FALLTHROUGH;
+	    case type_status:
+	      return EXIT_FAILURE;
+
+	    case type_all_diffs:
+	      do
+		{
+		  unsigned char c0 = buf0[first_diff];
+		  unsigned char c1 = buf1[first_diff];
+		  if (c0 != c1)
+		    {
+		      char byte_buf[INT_BUFSIZE_BOUND (off_t)];
+		      char const *byte_num = offtostr (byte_number, byte_buf);
+		      if (!opt_print_bytes)
+			{
+			  /* See POSIX for this format.  */
+			  printf ("%*s %3o %3o\n",
+				  offset_width, byte_num, c0, c1);
+			}
+		      else
+			{
+			  char s0[5];
+			  char s1[5];
+			  sprintc (s0, c0);
+			  sprintc (s1, c1);
+			  printf ("%*s %3o %-4s %3o %s\n",
+				  offset_width, byte_num, c0, s0, c1, s1);
+			}
+		    }
+		  byte_number++;
+		  first_diff++;
+		}
+	      while (first_diff < smaller);
+	      differing = -1;
+	      break;
+
+	    case type_no_stdout:
+	      differing = 1;
+	      break;
+	    }
+	}
+
+      if (read0 != read1)
+	{
+	  if (differing <= 0 && comparison_type != type_status)
+	    {
+	      char const *shorter_file = file[read1 < read0];
+
+	      /* POSIX says that each of these format strings must be
+		 "cmp: EOF on %s", optionally followed by a blank and
+		 extra text sans newline, then terminated by "\n".  */
+	      if (byte_number == 1)
+		fprintf (stderr, _("cmp: EOF on %s which is empty\n"),
+			 shorter_file);
+	      else
+		{
+		  char byte_buf[INT_BUFSIZE_BOUND (off_t)];
+		  char const *byte_num = offtostr (byte_number - 1, byte_buf);
+
+		  if (comparison_type == type_first_diff)
+		    {
+		      char line_buf[INT_BUFSIZE_BOUND (off_t)];
+		      char const *line_num
+			= offtostr (line_number - at_line_start, line_buf);
+		      fprintf (stderr,
+			       (at_line_start
+				? _("cmp: EOF on %s after byte %s, line %s\n")
+				: _("cmp: EOF on %s after byte %s,"
+				    " in line %s\n")),
+			       shorter_file, byte_num, line_num);
+		    }
+		  else
+		    fprintf (stderr,
+			     _("cmp: EOF on %s after byte %s\n"),
+			     shorter_file, byte_num);
+		}
+	    }
+
+	  return EXIT_FAILURE;
+	}
+    }
+  while (differing <= 0 && read0 == buf_size);
+
+  return differing == 0 ? EXIT_SUCCESS : EXIT_FAILURE;
+}
+
+/* Compare two blocks of memory P0 and P1 until they differ.
+   If the blocks are not guaranteed to be different, put sentinels at the ends
+   of the blocks before calling this function.
+
+   Return the offset of the first byte that differs.  */
+
+static size_t
+block_compare (word const *p0, word const *p1)
+{
+  word const *l0, *l1;
+  char const *c0, *c1;
+
+  /* Find the rough position of the first difference by reading words,
+     not bytes.  */
+
+  for (l0 = p0, l1 = p1;  *l0 == *l1;  l0++, l1++)
+    continue;
+
+  /* Find the exact differing position (endianness independent).  */
+
+  for (c0 = (char const *) l0, c1 = (char const *) l1;
+       *c0 == *c1;
+       c0++, c1++)
+    continue;
+
+  return c0 - (char const *) p0;
+}
+
+/* Return the number of newlines in BUF, of size BUFSIZE,
+   where BUF[NBYTES] is available for use as a sentinel.  */
+
+static size_t
+count_newlines (char *buf, size_t bufsize)
+{
+  size_t count = 0;
+  char *p;
+  char *lim = buf + bufsize;
+  *lim = '\n';
+  for (p = buf; (p = rawmemchr (p, '\n')) != lim; p++)
+    count++;
+  return count;
+}
+
+/* Put into BUF the unsigned char C, making unprintable bytes
+   visible by quoting like cat -t does.  */
+
+static void
+sprintc (char *buf, unsigned char c)
+{
+  if (! isprint (c))
+    {
+      if (c >= 128)
+	{
+	  *buf++ = 'M';
+	  *buf++ = '-';
+	  c -= 128;
+	}
+      if (c < 32)
+	{
+	  *buf++ = '^';
+	  c += 64;
+	}
+      else if (c == 127)
+	{
+	  *buf++ = '^';
+	  c = '?';
+	}
+    }
+
+  *buf++ = c;
+  *buf = 0;
+}
+
+/* Position file F to ignore_initial[F] bytes from its initial position,
+   and yield its new position.  Don't try more than once.  */
+
+static off_t
+file_position (int f)
+{
+  static bool positioned[2];
+  static off_t position[2];
+
+  if (! positioned[f])
+    {
+      positioned[f] = true;
+      position[f] = lseek (file_desc[f], ignore_initial[f], SEEK_CUR);
+    }
+  return position[f];
+}
diff --git a/test/diffutils-3.0/context.c b/test/diffutils-3.0/context.c
new file mode 100644
index 0000000..e96007d
--- /dev/null
+++ b/test/diffutils-3.0/context.c
@@ -0,0 +1,537 @@
+/* Context-format output routines for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1991-1995, 1998, 2001-2002, 2004, 2006, 2009-2013,
+   2015-2017 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include "c-ctype.h"
+#include <stat-time.h>
+#include <strftime.h>
+
+static char const *find_function (char const * const *, lin);
+static struct change *find_hunk (struct change *);
+static void mark_ignorable (struct change *);
+static void pr_context_hunk (struct change *);
+static void pr_unidiff_hunk (struct change *);
+
+/* Last place find_function started searching from.  */
+static lin find_function_last_search;
+
+/* The value find_function returned when it started searching there.  */
+static lin find_function_last_match;
+
+/* Print a label for a context diff, with a file name and date or a label.  */
+
+static void
+print_context_label (char const *mark,
+		     struct file_data *inf,
+		     char const *name,
+		     char const *label)
+{
+  if (label)
+    fprintf (outfile, "%s %s\n", mark, label);
+  else
+    {
+      char buf[MAX (INT_STRLEN_BOUND (int) + 32,
+		    INT_STRLEN_BOUND (time_t) + 11)];
+      struct tm const *tm = localtime (&inf->stat.st_mtime);
+      int nsec = get_stat_mtime_ns (&inf->stat);
+      if (! (tm && nstrftime (buf, sizeof buf, time_format, tm, 0, nsec)))
+	{
+	  verify (TYPE_IS_INTEGER (time_t));
+	  if (LONG_MIN <= TYPE_MINIMUM (time_t)
+	      && TYPE_MAXIMUM (time_t) <= LONG_MAX)
+	    {
+	      long int sec = inf->stat.st_mtime;
+	      sprintf (buf, "%ld.%.9d", sec, nsec);
+	    }
+	  else if (TYPE_MAXIMUM (time_t) <= INTMAX_MAX)
+	    {
+	      intmax_t sec = inf->stat.st_mtime;
+	      sprintf (buf, "%"PRIdMAX".%.9d", sec, nsec);
+	    }
+	  else
+	    {
+	      uintmax_t sec = inf->stat.st_mtime;
+	      sprintf (buf, "%"PRIuMAX".%.9d", sec, nsec);
+	    }
+	}
+      fprintf (outfile, "%s %s\t%s\n", mark, name, buf);
+    }
+}
+
+/* Print a header for a context diff, with the file names and dates.  */
+
+void
+print_context_header (struct file_data inf[], char const *const *names, bool unidiff)
+{
+  set_color_context (HEADER_CONTEXT);
+  if (unidiff)
+    {
+      print_context_label ("---", &inf[0], names[0], file_label[0]);
+      print_context_label ("+++", &inf[1], names[1], file_label[1]);
+    }
+  else
+    {
+      print_context_label ("***", &inf[0], names[0], file_label[0]);
+      print_context_label ("---", &inf[1], names[1], file_label[1]);
+    }
+  set_color_context (RESET_CONTEXT);
+}
+
+/* Print an edit script in context format.  */
+
+void
+print_context_script (struct change *script, bool unidiff)
+{
+  if (ignore_blank_lines || ignore_regexp.fastmap)
+    mark_ignorable (script);
+  else
+    {
+      struct change *e;
+      for (e = script; e; e = e->link)
+	e->ignore = false;
+    }
+
+  find_function_last_search = - files[0].prefix_lines;
+  find_function_last_match = LIN_MAX;
+
+  if (unidiff)
+    print_script (script, find_hunk, pr_unidiff_hunk);
+  else
+    print_script (script, find_hunk, pr_context_hunk);
+}
+
+/* Print a pair of line numbers with a comma, translated for file FILE.
+   If the second number is not greater, use the first in place of it.
+
+   Args A and B are internal line numbers.
+   We print the translated (real) line numbers.  */
+
+static void
+print_context_number_range (struct file_data const *file, lin a, lin b)
+{
+  printint trans_a, trans_b;
+  translate_range (file, a, b, &trans_a, &trans_b);
+
+  /* We can have B <= A in the case of a range of no lines.
+     In this case, we should print the line number before the range,
+     which is B.
+
+     POSIX 1003.1-2001 requires two line numbers separated by a comma
+     even if the line numbers are the same.  However, this does not
+     match existing practice and is surely an error in the
+     specification.  */
+
+  if (trans_b <= trans_a)
+    fprintf (outfile, "%"pI"d", trans_b);
+  else
+    fprintf (outfile, "%"pI"d,%"pI"d", trans_a, trans_b);
+}
+
+/* Print FUNCTION in a context header.  */
+static void
+print_context_function (FILE *out, char const *function)
+{
+  int i, j;
+  putc (' ', out);
+  for (i = 0; c_isspace ((unsigned char) function[i]) && function[i] != '\n'; i++)
+    continue;
+  for (j = i; j < i + 40 && function[j] != '\n'; j++)
+    continue;
+  while (i < j && c_isspace ((unsigned char) function[j - 1]))
+    j--;
+  fwrite (function + i, sizeof (char), j - i, out);
+}
+
+/* Print a portion of an edit script in context format.
+   HUNK is the beginning of the portion to be printed.
+   The end is marked by a 'link' that has been nulled out.
+
+   Prints out lines from both files, and precedes each
+   line with the appropriate flag-character.  */
+
+static void
+pr_context_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1, i;
+  char const *prefix;
+  char const *function;
+  FILE *out;
+
+  /* Determine range of line numbers involved in each file.  */
+
+  enum changes changes = analyze_hunk (hunk, &first0, &last0, &first1, &last1);
+  if (! changes)
+    return;
+
+  /* Include a context's width before and after.  */
+
+  i = - files[0].prefix_lines;
+  first0 = MAX (first0 - context, i);
+  first1 = MAX (first1 - context, i);
+  if (last0 < files[0].valid_lines - context)
+    last0 += context;
+  else
+    last0 = files[0].valid_lines - 1;
+  if (last1 < files[1].valid_lines - context)
+    last1 += context;
+  else
+    last1 = files[1].valid_lines - 1;
+
+  /* If desired, find the preceding function definition line in file 0.  */
+  function = NULL;
+  if (function_regexp.fastmap)
+    function = find_function (files[0].linbuf, first0);
+
+  begin_output ();
+  out = outfile;
+
+  fputs ("***************", out);
+
+  if (function)
+    print_context_function (out, function);
+
+  putc ('\n', out);
+  set_color_context (LINE_NUMBER_CONTEXT);
+  fputs ("*** ", out);
+  print_context_number_range (&files[0], first0, last0);
+  fputs (" ****", out);
+  set_color_context (RESET_CONTEXT);
+  putc ('\n', out);
+
+  if (changes & OLD)
+    {
+      struct change *next = hunk;
+
+      if (first0 <= last0)
+        set_color_context (DELETE_CONTEXT);
+
+      for (i = first0; i <= last0; i++)
+	{
+	  /* Skip past changes that apply (in file 0)
+	     only to lines before line I.  */
+
+	  while (next && next->line0 + next->deleted <= i)
+	    next = next->link;
+
+	  /* Compute the marking for line I.  */
+
+	  prefix = " ";
+	  if (next && next->line0 <= i)
+            {
+              /* The change NEXT covers this line.
+                 If lines were inserted here in file 1, this is "changed".
+                 Otherwise it is "deleted".  */
+              prefix = (next->inserted > 0 ? "!" : "-");
+            }
+	  print_1_line_nl (prefix, &files[0].linbuf[i], true);
+          if (i == last0)
+            set_color_context (RESET_CONTEXT);
+          if (files[0].linbuf[i + 1][-1] == '\n')
+            putc ('\n', out);
+	}
+    }
+
+  set_color_context (LINE_NUMBER_CONTEXT);
+  fputs ("--- ", out);
+  print_context_number_range (&files[1], first1, last1);
+  fputs (" ----", out);
+  set_color_context (RESET_CONTEXT);
+  putc ('\n', out);
+
+  if (changes & NEW)
+    {
+      struct change *next = hunk;
+
+      if (first1 <= last1)
+        set_color_context (ADD_CONTEXT);
+
+      for (i = first1; i <= last1; i++)
+	{
+	  /* Skip past changes that apply (in file 1)
+	     only to lines before line I.  */
+
+	  while (next && next->line1 + next->inserted <= i)
+	    next = next->link;
+
+	  /* Compute the marking for line I.  */
+
+	  prefix = " ";
+	  if (next && next->line1 <= i)
+            {
+              /* The change NEXT covers this line.
+                 If lines were deleted here in file 0, this is "changed".
+                 Otherwise it is "inserted".  */
+              prefix = (next->deleted > 0 ? "!" : "+");
+            }
+	  print_1_line_nl (prefix, &files[1].linbuf[i], true);
+          if (i == last1)
+            set_color_context (RESET_CONTEXT);
+          if (files[1].linbuf[i + 1][-1] == '\n')
+            putc ('\n', out);
+	}
+    }
+}
+
+/* Print a pair of line numbers with a comma, translated for file FILE.
+   If the second number is smaller, use the first in place of it.
+   If the numbers are equal, print just one number.
+
+   Args A and B are internal line numbers.
+   We print the translated (real) line numbers.  */
+
+static void
+print_unidiff_number_range (struct file_data const *file, lin a, lin b)
+{
+  printint trans_a, trans_b;
+  translate_range (file, a, b, &trans_a, &trans_b);
+
+  /* We can have B < A in the case of a range of no lines.
+     In this case, we print the line number before the range,
+     which is B.  It would be more logical to print A, but
+     'patch' expects B in order to detect diffs against empty files.  */
+  if (trans_b <= trans_a)
+    fprintf (outfile, trans_b < trans_a ? "%"pI"d,0" : "%"pI"d", trans_b);
+  else
+    fprintf (outfile, "%"pI"d,%"pI"d", trans_a, trans_b - trans_a + 1);
+}
+
+/* Print a portion of an edit script in unidiff format.
+   HUNK is the beginning of the portion to be printed.
+   The end is marked by a 'link' that has been nulled out.
+
+   Prints out lines from both files, and precedes each
+   line with the appropriate flag-character.  */
+
+static void
+pr_unidiff_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1;
+  lin i, j, k;
+  struct change *next;
+  char const *function;
+  FILE *out;
+
+  /* Determine range of line numbers involved in each file.  */
+
+  if (! analyze_hunk (hunk, &first0, &last0, &first1, &last1))
+    return;
+
+  /* Include a context's width before and after.  */
+
+  i = - files[0].prefix_lines;
+  first0 = MAX (first0 - context, i);
+  first1 = MAX (first1 - context, i);
+  if (last0 < files[0].valid_lines - context)
+    last0 += context;
+  else
+    last0 = files[0].valid_lines - 1;
+  if (last1 < files[1].valid_lines - context)
+    last1 += context;
+  else
+    last1 = files[1].valid_lines - 1;
+
+  /* If desired, find the preceding function definition line in file 0.  */
+  function = NULL;
+  if (function_regexp.fastmap)
+    function = find_function (files[0].linbuf, first0);
+
+  begin_output ();
+  out = outfile;
+
+  set_color_context (LINE_NUMBER_CONTEXT);
+  fputs ("@@ -", out);
+  print_unidiff_number_range (&files[0], first0, last0);
+  fputs (" +", out);
+  print_unidiff_number_range (&files[1], first1, last1);
+  fputs (" @@", out);
+  set_color_context (RESET_CONTEXT);
+
+  if (function)
+    print_context_function (out, function);
+
+  putc ('\n', out);
+
+  next = hunk;
+  i = first0;
+  j = first1;
+
+  while (i <= last0 || j <= last1)
+    {
+
+      /* If the line isn't a difference, output the context from file 0. */
+
+      if (!next || i < next->line0)
+	{
+	  char const *const *line = &files[0].linbuf[i++];
+	  if (! (suppress_blank_empty && **line == '\n'))
+	    putc (initial_tab ? '\t' : ' ', out);
+	  print_1_line (NULL, line);
+	  j++;
+	}
+      else
+	{
+	  /* For each difference, first output the deleted part. */
+
+	  k = next->deleted;
+          if (k)
+            set_color_context (DELETE_CONTEXT);
+
+	  while (k--)
+	    {
+	      char const * const *line = &files[0].linbuf[i++];
+	      putc ('-', out);
+	      if (initial_tab && ! (suppress_blank_empty && **line == '\n'))
+		putc ('\t', out);
+	      print_1_line_nl (NULL, line, true);
+
+              if (!k)
+                set_color_context (RESET_CONTEXT);
+
+              if (line[1][-1] == '\n')
+                putc ('\n', out);
+	    }
+
+	  /* Then output the inserted part. */
+
+	  k = next->inserted;
+          if (k)
+            set_color_context (ADD_CONTEXT);
+
+          while (k--)
+	    {
+	      char const * const *line = &files[1].linbuf[j++];
+	      putc ('+', out);
+	      if (initial_tab && ! (suppress_blank_empty && **line == '\n'))
+		putc ('\t', out);
+	      print_1_line_nl (NULL, line, true);
+
+              if (!k)
+                set_color_context (RESET_CONTEXT);
+
+              if (line[1][-1] == '\n')
+                putc ('\n', out);
+	    }
+
+	  /* We're done with this hunk, so on to the next! */
+
+	  next = next->link;
+	}
+    }
+}
+
+/* Scan a (forward-ordered) edit script for the first place that more than
+   2*CONTEXT unchanged lines appear, and return a pointer
+   to the 'struct change' for the last change before those lines.  */
+
+static struct change * _GL_ATTRIBUTE_PURE
+find_hunk (struct change *start)
+{
+  struct change *prev;
+  lin top0, top1;
+  lin thresh;
+
+  /* Threshold distance is CONTEXT if the second change is ignorable,
+     2 * CONTEXT + 1 otherwise.  Integer overflow can't happen, due
+     to CONTEXT_LIM.  */
+  lin ignorable_threshold = context;
+  lin non_ignorable_threshold = 2 * context + 1;
+
+  do
+    {
+      /* Compute number of first line in each file beyond this changed.  */
+      top0 = start->line0 + start->deleted;
+      top1 = start->line1 + start->inserted;
+      prev = start;
+      start = start->link;
+      thresh = (start && start->ignore
+		? ignorable_threshold
+		: non_ignorable_threshold);
+      /* It is not supposed to matter which file we check in the end-test.
+	 If it would matter, crash.  */
+      if (start && start->line0 - top0 != start->line1 - top1)
+	abort ();
+    } while (start
+	     /* Keep going if less than THRESH lines
+		elapse before the affected line.  */
+	     && start->line0 - top0 < thresh);
+
+  return prev;
+}
+
+/* Set the 'ignore' flag properly in each change in SCRIPT.
+   It should be 1 if all the lines inserted or deleted in that change
+   are ignorable lines.  */
+
+static void
+mark_ignorable (struct change *script)
+{
+  while (script)
+    {
+      struct change *next = script->link;
+      lin first0, last0, first1, last1;
+
+      /* Turn this change into a hunk: detach it from the others.  */
+      script->link = NULL;
+
+      /* Determine whether this change is ignorable.  */
+      script->ignore = ! analyze_hunk (script,
+				       &first0, &last0, &first1, &last1);
+
+      /* Reconnect the chain as before.  */
+      script->link = next;
+
+      /* Advance to the following change.  */
+      script = next;
+    }
+}
+
+/* Find the last function-header line in LINBUF prior to line number LINENUM.
+   This is a line containing a match for the regexp in 'function_regexp'.
+   Return the address of the text, or NULL if no function-header is found.  */
+
+static char const *
+find_function (char const * const *linbuf, lin linenum)
+{
+  lin i = linenum;
+  lin last = find_function_last_search;
+  find_function_last_search = i;
+
+  while (last <= --i)
+    {
+      /* See if this line is what we want.  */
+      char const *line = linbuf[i];
+      size_t linelen = linbuf[i + 1] - line - 1;
+
+      /* FIXME: re_search's size args should be size_t, not int.  */
+      int len = MIN (linelen, INT_MAX);
+
+      if (0 <= re_search (&function_regexp, line, len, 0, len, NULL))
+	{
+	  find_function_last_match = i;
+	  return line;
+	}
+    }
+  /* If we search back to where we started searching the previous time,
+     find the line we found last time.  */
+  if (find_function_last_match != LIN_MAX)
+    return linbuf[find_function_last_match];
+
+  return NULL;
+}
diff --git a/test/diffutils-3.0/die.h b/test/diffutils-3.0/die.h
new file mode 100644
index 0000000..8835d80
--- /dev/null
+++ b/test/diffutils-3.0/die.h
@@ -0,0 +1,31 @@
+/* Report an error and exit.
+   Copyright 2016-2017 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#ifndef DIE_H
+# define DIE_H
+
+# include <error.h>
+# include <stdbool.h>
+# include <verify.h>
+
+/* Like 'error (STATUS, ...)', except STATUS must be a nonzero constant.
+   This may pacify the compiler or help it generate better code.  */
+# define die(status, ...) \
+  verify_expr (status, (error (status, __VA_ARGS__), assume (false)))
+
+#endif /* DIE_H */
diff --git a/test/diffutils-3.0/diff.c b/test/diffutils-3.0/diff.c
new file mode 100644
index 0000000..df3338c
--- /dev/null
+++ b/test/diffutils-3.0/diff.c
@@ -0,0 +1,1473 @@
+/* diff - compare files line by line
+
+   Copyright (C) 1988-1989, 1992-1994, 1996, 1998, 2001-2002, 2004, 2006-2007,
+   2009-2013, 2015-2017 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#define GDIFF_MAIN
+#include "diff.h"
+#include "die.h"
+#include <assert.h>
+#include "paths.h"
+#include <c-stack.h>
+#include <dirname.h>
+#include <error.h>
+#include <exclude.h>
+#include <exitfail.h>
+#include <filenamecat.h>
+#include <file-type.h>
+#include <fnmatch.h>
+#include <getopt.h>
+#include <hard-locale.h>
+#include <prepargs.h>
+#include <progname.h>
+#include <sh-quote.h>
+#include <stat-time.h>
+#include <timespec.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <xreadlink.h>
+#include <binary-io.h>
+
+/* The official name of this program (e.g., no 'g' prefix).  */
+#define PROGRAM_NAME "diff"
+
+#define AUTHORS \
+  proper_name ("Paul Eggert"), \
+  proper_name ("Mike Haertel"), \
+  proper_name ("David Hayes"), \
+  proper_name ("Richard Stallman"), \
+  proper_name ("Len Tower")
+
+#ifndef GUTTER_WIDTH_MINIMUM
+# define GUTTER_WIDTH_MINIMUM 3
+#endif
+
+struct regexp_list
+{
+  char *regexps;	/* chars representing disjunction of the regexps */
+  size_t len;		/* chars used in 'regexps' */
+  size_t size;		/* size malloc'ed for 'regexps'; 0 if not malloc'ed */
+  bool multiple_regexps;/* Does 'regexps' represent a disjunction?  */
+  struct re_pattern_buffer *buf;
+};
+
+static int compare_files (struct comparison const *, char const *, char const *);
+static void add_regexp (struct regexp_list *, char const *);
+static void summarize_regexp_list (struct regexp_list *);
+static void specify_style (enum output_style);
+static void specify_value (char const **, char const *, char const *);
+static void specify_colors_style (char const *);
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void check_stdout (void);
+static void usage (void);
+
+/* If comparing directories, compare their common subdirectories
+   recursively.  */
+static bool recursive;
+
+/* In context diffs, show previous lines that match these regexps.  */
+static struct regexp_list function_regexp_list;
+
+/* Ignore changes affecting only lines that match these regexps.  */
+static struct regexp_list ignore_regexp_list;
+
+#if O_BINARY
+/* Use binary I/O when reading and writing data (--binary).
+   On POSIX hosts, this has no effect.  */
+static bool binary;
+#else
+enum { binary = true };
+#endif
+
+/* If one file is missing, treat it as present but empty (-N).  */
+static bool new_file;
+
+/* If the first file is missing, treat it as present but empty
+   (--unidirectional-new-file).  */
+static bool unidirectional_new_file;
+
+/* Report files compared that are the same (-s).
+   Normally nothing is output when that happens.  */
+static bool report_identical_files;
+
+static char const shortopts[] =
+"0123456789abBcC:dD:eEfF:hHiI:lL:nNpPqrsS:tTuU:vwW:x:X:yZ";
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  BINARY_OPTION = CHAR_MAX + 1,
+  FROM_FILE_OPTION,
+  HELP_OPTION,
+  HORIZON_LINES_OPTION,
+  IGNORE_FILE_NAME_CASE_OPTION,
+  INHIBIT_HUNK_MERGE_OPTION,
+  LEFT_COLUMN_OPTION,
+  LINE_FORMAT_OPTION,
+  NO_DEREFERENCE_OPTION,
+  NO_IGNORE_FILE_NAME_CASE_OPTION,
+  NORMAL_OPTION,
+  SDIFF_MERGE_ASSIST_OPTION,
+  STRIP_TRAILING_CR_OPTION,
+  SUPPRESS_BLANK_EMPTY_OPTION,
+  SUPPRESS_COMMON_LINES_OPTION,
+  TABSIZE_OPTION,
+  TO_FILE_OPTION,
+
+  /* These options must be in sequence.  */
+  UNCHANGED_LINE_FORMAT_OPTION,
+  OLD_LINE_FORMAT_OPTION,
+  NEW_LINE_FORMAT_OPTION,
+
+  /* These options must be in sequence.  */
+  UNCHANGED_GROUP_FORMAT_OPTION,
+  OLD_GROUP_FORMAT_OPTION,
+  NEW_GROUP_FORMAT_OPTION,
+  CHANGED_GROUP_FORMAT_OPTION,
+
+  COLOR_OPTION,
+  COLOR_PALETTE_OPTION,
+
+  PRESUME_OUTPUT_TTY_OPTION,
+};
+
+static char const group_format_option[][sizeof "--unchanged-group-format"] =
+  {
+    "--unchanged-group-format",
+    "--old-group-format",
+    "--new-group-format",
+    "--changed-group-format"
+  };
+
+static char const line_format_option[][sizeof "--unchanged-line-format"] =
+  {
+    "--unchanged-line-format",
+    "--old-line-format",
+    "--new-line-format"
+  };
+
+static struct option const longopts[] =
+{
+  {"binary", 0, 0, BINARY_OPTION},
+  {"brief", 0, 0, 'q'},
+  {"changed-group-format", 1, 0, CHANGED_GROUP_FORMAT_OPTION},
+  {"color", 2, 0, COLOR_OPTION},
+  {"context", 2, 0, 'C'},
+  {"ed", 0, 0, 'e'},
+  {"exclude", 1, 0, 'x'},
+  {"exclude-from", 1, 0, 'X'},
+  {"expand-tabs", 0, 0, 't'},
+  {"forward-ed", 0, 0, 'f'},
+  {"from-file", 1, 0, FROM_FILE_OPTION},
+  {"help", 0, 0, HELP_OPTION},
+  {"horizon-lines", 1, 0, HORIZON_LINES_OPTION},
+  {"ifdef", 1, 0, 'D'},
+  {"ignore-all-space", 0, 0, 'w'},
+  {"ignore-blank-lines", 0, 0, 'B'},
+  {"ignore-case", 0, 0, 'i'},
+  {"ignore-file-name-case", 0, 0, IGNORE_FILE_NAME_CASE_OPTION},
+  {"ignore-matching-lines", 1, 0, 'I'},
+  {"ignore-space-change", 0, 0, 'b'},
+  {"ignore-tab-expansion", 0, 0, 'E'},
+  {"ignore-trailing-space", 0, 0, 'Z'},
+  {"inhibit-hunk-merge", 0, 0, INHIBIT_HUNK_MERGE_OPTION},
+  {"initial-tab", 0, 0, 'T'},
+  {"label", 1, 0, 'L'},
+  {"left-column", 0, 0, LEFT_COLUMN_OPTION},
+  {"line-format", 1, 0, LINE_FORMAT_OPTION},
+  {"minimal", 0, 0, 'd'},
+  {"new-file", 0, 0, 'N'},
+  {"new-group-format", 1, 0, NEW_GROUP_FORMAT_OPTION},
+  {"new-line-format", 1, 0, NEW_LINE_FORMAT_OPTION},
+  {"no-dereference", 0, 0, NO_DEREFERENCE_OPTION},
+  {"no-ignore-file-name-case", 0, 0, NO_IGNORE_FILE_NAME_CASE_OPTION},
+  {"normal", 0, 0, NORMAL_OPTION},
+  {"old-group-format", 1, 0, OLD_GROUP_FORMAT_OPTION},
+  {"old-line-format", 1, 0, OLD_LINE_FORMAT_OPTION},
+  {"paginate", 0, 0, 'l'},
+  {"palette", 1, 0, COLOR_PALETTE_OPTION},
+  {"rcs", 0, 0, 'n'},
+  {"recursive", 0, 0, 'r'},
+  {"report-identical-files", 0, 0, 's'},
+  {"sdiff-merge-assist", 0, 0, SDIFF_MERGE_ASSIST_OPTION},
+  {"show-c-function", 0, 0, 'p'},
+  {"show-function-line", 1, 0, 'F'},
+  {"side-by-side", 0, 0, 'y'},
+  {"speed-large-files", 0, 0, 'H'},
+  {"starting-file", 1, 0, 'S'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"suppress-blank-empty", 0, 0, SUPPRESS_BLANK_EMPTY_OPTION},
+  {"suppress-common-lines", 0, 0, SUPPRESS_COMMON_LINES_OPTION},
+  {"tabsize", 1, 0, TABSIZE_OPTION},
+  {"text", 0, 0, 'a'},
+  {"to-file", 1, 0, TO_FILE_OPTION},
+  {"unchanged-group-format", 1, 0, UNCHANGED_GROUP_FORMAT_OPTION},
+  {"unchanged-line-format", 1, 0, UNCHANGED_LINE_FORMAT_OPTION},
+  {"unidirectional-new-file", 0, 0, 'P'},
+  {"unified", 2, 0, 'U'},
+  {"version", 0, 0, 'v'},
+  {"width", 1, 0, 'W'},
+
+  /* This is solely for testing.  Do not document.  */
+  {"-presume-output-tty", no_argument, NULL, PRESUME_OUTPUT_TTY_OPTION},
+  {0, 0, 0, 0}
+};
+
+/* Return a string containing the command options with which diff was invoked.
+   Spaces appear between what were separate ARGV-elements.
+   There is a space at the beginning but none at the end.
+   If there were no options, the result is an empty string.
+
+   Arguments: OPTIONVEC, a vector containing separate ARGV-elements, and COUNT,
+   the length of that vector.  */
+
+static char *
+option_list (char **optionvec, int count)
+{
+  int i;
+  size_t size = 1;
+  char *result;
+  char *p;
+
+  for (i = 0; i < count; i++)
+    size += 1 + shell_quote_length (optionvec[i]);
+
+  p = result = xmalloc (size);
+
+  for (i = 0; i < count; i++)
+    {
+      *p++ = ' ';
+      p = shell_quote_copy (p, optionvec[i]);
+    }
+
+  *p = '\0';
+  return result;
+}
+
+
+/* Return an option value suitable for add_exclude.  */
+
+static int
+exclude_options (void)
+{
+  return EXCLUDE_WILDCARDS | (ignore_file_name_case ? FNM_CASEFOLD : 0);
+}
+
+int
+main (int argc, char **argv)
+{
+  int exit_status = EXIT_SUCCESS;
+  int c;
+  int i;
+  int prev = -1;
+  lin ocontext = -1;
+  bool explicit_context = false;
+  size_t width = 0;
+  bool show_c_function = false;
+  char const *from_file = NULL;
+  char const *to_file = NULL;
+  uintmax_t numval;
+  char *numend;
+
+  /* Do our initializations.  */
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+  function_regexp_list.buf = &function_regexp;
+  ignore_regexp_list.buf = &ignore_regexp;
+  re_set_syntax (RE_SYNTAX_GREP | RE_NO_POSIX_BACKTRACKING);
+  excluded = new_exclude ();
+  presume_output_tty = false;
+
+  /* Decode the options.  */
+
+  while ((c = getopt_long (argc, argv, shortopts, longopts, NULL)) != -1)
+    {
+      switch (c)
+	{
+	case 0:
+	  break;
+
+	case '0':
+	case '1':
+	case '2':
+	case '3':
+	case '4':
+	case '5':
+	case '6':
+	case '7':
+	case '8':
+	case '9':
+	  ocontext = (! ISDIGIT (prev)
+		      ? c - '0'
+		      : (ocontext - (c - '0' <= CONTEXT_MAX % 10)
+			 < CONTEXT_MAX / 10)
+		      ? 10 * ocontext + (c - '0')
+		      : CONTEXT_MAX);
+	  break;
+
+	case 'a':
+	  text = true;
+	  break;
+
+	case 'b':
+	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
+	    ignore_white_space = IGNORE_SPACE_CHANGE;
+	  break;
+
+	case 'Z':
+	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
+	    ignore_white_space |= IGNORE_TRAILING_SPACE;
+	  break;
+
+	case 'B':
+	  ignore_blank_lines = true;
+	  break;
+
+	case 'C':
+	case 'U':
+	  {
+	    if (optarg)
+	      {
+		numval = strtoumax (optarg, &numend, 10);
+		if (*numend)
+		  try_help ("invalid context length '%s'", optarg);
+		if (CONTEXT_MAX < numval)
+		  numval = CONTEXT_MAX;
+	      }
+	    else
+	      numval = 3;
+
+	    specify_style (c == 'U' ? OUTPUT_UNIFIED : OUTPUT_CONTEXT);
+	    if (context < numval)
+	      context = numval;
+	    explicit_context = true;
+	  }
+	  break;
+
+	case 'c':
+	  specify_style (OUTPUT_CONTEXT);
+	  if (context < 3)
+	    context = 3;
+	  break;
+
+	case 'd':
+	  minimal = true;
+	  break;
+
+	case 'D':
+	  specify_style (OUTPUT_IFDEF);
+	  {
+	    static char const C_ifdef_group_formats[] =
+	      "%%=%c#ifndef %s\n%%<#endif /* ! %s */\n%c#ifdef %s\n%%>#endif /* %s */\n%c#ifndef %s\n%%<#else /* %s */\n%%>#endif /* %s */\n";
+	    char *b = xmalloc (sizeof C_ifdef_group_formats
+			       + 7 * strlen (optarg) - 14 /* 7*"%s" */
+			       - 8 /* 5*"%%" + 3*"%c" */);
+	    sprintf (b, C_ifdef_group_formats,
+		     0,
+		     optarg, optarg, 0,
+		     optarg, optarg, 0,
+		     optarg, optarg, optarg);
+	    for (i = 0; i < sizeof group_format / sizeof group_format[0]; i++)
+	      {
+		specify_value (&group_format[i], b, "-D");
+		b += strlen (b) + 1;
+	      }
+	  }
+	  break;
+
+	case 'e':
+	  specify_style (OUTPUT_ED);
+	  break;
+
+	case 'E':
+	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
+	    ignore_white_space |= IGNORE_TAB_EXPANSION;
+	  break;
+
+	case 'f':
+	  specify_style (OUTPUT_FORWARD_ED);
+	  break;
+
+	case 'F':
+	  add_regexp (&function_regexp_list, optarg);
+	  break;
+
+	case 'h':
+	  /* Split the files into chunks for faster processing.
+	     Usually does not change the result.
+
+	     This currently has no effect.  */
+	  break;
+
+	case 'H':
+	  speed_large_files = true;
+	  break;
+
+	case 'i':
+	  ignore_case = true;
+	  break;
+
+	case 'I':
+	  add_regexp (&ignore_regexp_list, optarg);
+	  break;
+
+	case 'l':
+	  if (!pr_program[0])
+	    try_help ("pagination not supported on this host", NULL);
+	  paginate = true;
+#ifdef SIGCHLD
+	  /* Pagination requires forking and waiting, and
+	     System V fork+wait does not work if SIGCHLD is ignored.  */
+	  signal (SIGCHLD, SIG_DFL);
+#endif
+	  break;
+
+	case 'L':
+	  if (!file_label[0])
+	    file_label[0] = optarg;
+	  else if (!file_label[1])
+	    file_label[1] = optarg;
+	  else
+	    fatal ("too many file label options");
+	  break;
+
+	case 'n':
+	  specify_style (OUTPUT_RCS);
+	  break;
+
+	case 'N':
+	  new_file = true;
+	  break;
+
+	case 'p':
+	  show_c_function = true;
+	  add_regexp (&function_regexp_list, "^[[:alpha:]$_]");
+	  break;
+
+	case 'P':
+	  unidirectional_new_file = true;
+	  break;
+
+	case 'q':
+	  brief = true;
+	  break;
+
+	case 'r':
+	  recursive = true;
+	  break;
+
+	case 's':
+	  report_identical_files = true;
+	  break;
+
+	case 'S':
+	  specify_value (&starting_file, optarg, "-S");
+	  break;
+
+	case 't':
+	  expand_tabs = true;
+	  break;
+
+	case 'T':
+	  initial_tab = true;
+	  break;
+
+	case 'u':
+	  specify_style (OUTPUT_UNIFIED);
+	  if (context < 3)
+	    context = 3;
+	  break;
+
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case 'w':
+	  ignore_white_space = IGNORE_ALL_SPACE;
+	  break;
+
+	case 'x':
+	  add_exclude (excluded, optarg, exclude_options ());
+	  break;
+
+	case 'X':
+	  if (add_exclude_file (add_exclude, excluded, optarg,
+				exclude_options (), '\n'))
+	    pfatal_with_name (optarg);
+	  break;
+
+	case 'y':
+	  specify_style (OUTPUT_SDIFF);
+	  break;
+
+	case 'W':
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+	    try_help ("invalid width '%s'", optarg);
+	  if (width != numval)
+	    {
+	      if (width)
+		fatal ("conflicting width options");
+	      width = numval;
+	    }
+	  break;
+
+	case BINARY_OPTION:
+#if O_BINARY
+	  binary = true;
+	  if (! isatty (STDOUT_FILENO))
+	    set_binary_mode (STDOUT_FILENO, O_BINARY);
+#endif
+	  break;
+
+	case FROM_FILE_OPTION:
+	  specify_value (&from_file, optarg, "--from-file");
+	  break;
+
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case HORIZON_LINES_OPTION:
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (*numend)
+	    try_help ("invalid horizon length '%s'", optarg);
+	  horizon_lines = MAX (horizon_lines, MIN (numval, LIN_MAX));
+	  break;
+
+	case IGNORE_FILE_NAME_CASE_OPTION:
+	  ignore_file_name_case = true;
+	  break;
+
+	case INHIBIT_HUNK_MERGE_OPTION:
+	  /* This option is obsolete, but accept it for backward
+             compatibility.  */
+	  break;
+
+	case LEFT_COLUMN_OPTION:
+	  left_column = true;
+	  break;
+
+	case LINE_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  for (i = 0; i < sizeof line_format / sizeof line_format[0]; i++)
+	    specify_value (&line_format[i], optarg, "--line-format");
+	  break;
+
+	case NO_DEREFERENCE_OPTION:
+	  no_dereference_symlinks = true;
+	  break;
+
+	case NO_IGNORE_FILE_NAME_CASE_OPTION:
+	  ignore_file_name_case = false;
+	  break;
+
+	case NORMAL_OPTION:
+	  specify_style (OUTPUT_NORMAL);
+	  break;
+
+	case SDIFF_MERGE_ASSIST_OPTION:
+	  specify_style (OUTPUT_SDIFF);
+	  sdiff_merge_assist = true;
+	  break;
+
+	case STRIP_TRAILING_CR_OPTION:
+	  strip_trailing_cr = true;
+	  break;
+
+	case SUPPRESS_BLANK_EMPTY_OPTION:
+	  suppress_blank_empty = true;
+	  break;
+
+	case SUPPRESS_COMMON_LINES_OPTION:
+	  suppress_common_lines = true;
+	  break;
+
+	case TABSIZE_OPTION:
+	  numval = strtoumax (optarg, &numend, 10);
+	  if (! (0 < numval && numval <= SIZE_MAX - GUTTER_WIDTH_MINIMUM)
+	      || *numend)
+	    try_help ("invalid tabsize '%s'", optarg);
+	  if (tabsize != numval)
+	    {
+	      if (tabsize)
+		fatal ("conflicting tabsize options");
+	      tabsize = numval;
+	    }
+	  break;
+
+	case TO_FILE_OPTION:
+	  specify_value (&to_file, optarg, "--to-file");
+	  break;
+
+	case UNCHANGED_LINE_FORMAT_OPTION:
+	case OLD_LINE_FORMAT_OPTION:
+	case NEW_LINE_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  c -= UNCHANGED_LINE_FORMAT_OPTION;
+	  specify_value (&line_format[c], optarg, line_format_option[c]);
+	  break;
+
+	case UNCHANGED_GROUP_FORMAT_OPTION:
+	case OLD_GROUP_FORMAT_OPTION:
+	case NEW_GROUP_FORMAT_OPTION:
+	case CHANGED_GROUP_FORMAT_OPTION:
+	  specify_style (OUTPUT_IFDEF);
+	  c -= UNCHANGED_GROUP_FORMAT_OPTION;
+	  specify_value (&group_format[c], optarg, group_format_option[c]);
+	  break;
+
+	case COLOR_OPTION:
+	  specify_colors_style (optarg);
+	  break;
+
+	case COLOR_PALETTE_OPTION:
+	  set_color_palette (optarg);
+	  break;
+
+        case PRESUME_OUTPUT_TTY_OPTION:
+          presume_output_tty = true;
+          break;
+
+	default:
+	  try_help (NULL, NULL);
+	}
+      prev = c;
+    }
+
+  if (colors_style == AUTO)
+    {
+      char const *t = getenv ("TERM");
+      if (t && STREQ (t, "dumb"))
+        colors_style = NEVER;
+    }
+
+  if (output_style == OUTPUT_UNSPECIFIED)
+    {
+      if (show_c_function)
+	{
+	  specify_style (OUTPUT_CONTEXT);
+	  if (ocontext < 0)
+	    context = 3;
+	}
+      else
+	specify_style (OUTPUT_NORMAL);
+    }
+
+  if (output_style != OUTPUT_CONTEXT || hard_locale (LC_TIME))
+    {
+#if (defined STAT_TIMESPEC || defined STAT_TIMESPEC_NS \
+     || defined HAVE_STRUCT_STAT_ST_SPARE1)
+      time_format = "%Y-%m-%d %H:%M:%S.%N %z";
+#else
+      time_format = "%Y-%m-%d %H:%M:%S %z";
+#endif
+    }
+  else
+    {
+      /* See POSIX 1003.1-2001 for this format.  */
+      time_format = "%a %b %e %T %Y";
+    }
+
+  if (0 <= ocontext
+      && (output_style == OUTPUT_CONTEXT
+	  || output_style == OUTPUT_UNIFIED)
+      && (context < ocontext
+	  || (ocontext < context && ! explicit_context)))
+    context = ocontext;
+
+  if (! tabsize)
+    tabsize = 8;
+  if (! width)
+    width = 130;
+
+  {
+    /* Maximize first the half line width, and then the gutter width,
+       according to the following constraints:
+
+	1.  Two half lines plus a gutter must fit in a line.
+	2.  If the half line width is nonzero:
+	    a.  The gutter width is at least GUTTER_WIDTH_MINIMUM.
+	    b.  If tabs are not expanded to spaces,
+		a half line plus a gutter is an integral number of tabs,
+		so that tabs in the right column line up.  */
+
+    size_t t = expand_tabs ? 1 : tabsize;
+    size_t w = width;
+    size_t t_plus_g = t + GUTTER_WIDTH_MINIMUM;
+    size_t unaligned_off = (w >> 1) + (t_plus_g >> 1) + (w & t_plus_g & 1);
+    size_t off = unaligned_off - unaligned_off % t;
+    sdiff_half_width = (off <= GUTTER_WIDTH_MINIMUM || w <= off
+			? 0
+			: MIN (off - GUTTER_WIDTH_MINIMUM, w - off));
+    sdiff_column2_offset = sdiff_half_width ? off : w;
+  }
+
+  /* Make the horizon at least as large as the context, so that
+     shift_boundaries has more freedom to shift the first and last hunks.  */
+  if (horizon_lines < context)
+    horizon_lines = context;
+
+  summarize_regexp_list (&function_regexp_list);
+  summarize_regexp_list (&ignore_regexp_list);
+
+  if (output_style == OUTPUT_IFDEF)
+    {
+      for (i = 0; i < sizeof line_format / sizeof line_format[0]; i++)
+	if (!line_format[i])
+	  line_format[i] = "%l\n";
+      if (!group_format[OLD])
+	group_format[OLD]
+	  = group_format[CHANGED] ? group_format[CHANGED] : "%<";
+      if (!group_format[NEW])
+	group_format[NEW]
+	  = group_format[CHANGED] ? group_format[CHANGED] : "%>";
+      if (!group_format[UNCHANGED])
+	group_format[UNCHANGED] = "%=";
+      if (!group_format[CHANGED])
+	group_format[CHANGED] = concat (group_format[OLD],
+					group_format[NEW], "");
+    }
+
+  no_diff_means_no_output =
+    (output_style == OUTPUT_IFDEF ?
+      (!*group_format[UNCHANGED]
+       || (STREQ (group_format[UNCHANGED], "%=")
+	   && !*line_format[UNCHANGED]))
+     : (output_style != OUTPUT_SDIFF) | suppress_common_lines);
+
+  files_can_be_treated_as_binary =
+    (brief & binary
+     & ~ (ignore_blank_lines | ignore_case | strip_trailing_cr
+	  | (ignore_regexp_list.regexps || ignore_white_space)));
+
+  switch_string = option_list (argv + 1, optind - 1);
+
+  if (from_file)
+    {
+      if (to_file)
+	fatal ("--from-file and --to-file both specified");
+      else
+	for (; optind < argc; optind++)
+	  {
+	    int status = compare_files (NULL, from_file, argv[optind]);
+	    if (exit_status < status)
+	      exit_status = status;
+	  }
+    }
+  else
+    {
+      if (to_file)
+	for (; optind < argc; optind++)
+	  {
+	    int status = compare_files (NULL, argv[optind], to_file);
+	    if (exit_status < status)
+	      exit_status = status;
+	  }
+      else
+	{
+	  if (argc - optind != 2)
+	    {
+	      if (argc - optind < 2)
+		try_help ("missing operand after '%s'", argv[argc - 1]);
+	      else
+		try_help ("extra operand '%s'", argv[optind + 2]);
+	    }
+
+	  exit_status = compare_files (NULL, argv[optind], argv[optind + 1]);
+	}
+    }
+
+  /* Print any messages that were saved up for last.  */
+  print_message_queue ();
+
+  check_stdout ();
+  exit (exit_status);
+  return exit_status;
+}
+
+/* Append to REGLIST the regexp PATTERN.  */
+
+static void
+add_regexp (struct regexp_list *reglist, char const *pattern)
+{
+  size_t patlen = strlen (pattern);
+  char const *m = re_compile_pattern (pattern, patlen, reglist->buf);
+
+  if (m != 0)
+    error (EXIT_TROUBLE, 0, "%s: %s", pattern, m);
+  else
+    {
+      char *regexps = reglist->regexps;
+      size_t len = reglist->len;
+      bool multiple_regexps = reglist->multiple_regexps = regexps != 0;
+      size_t newlen = reglist->len = len + 2 * multiple_regexps + patlen;
+      size_t size = reglist->size;
+
+      if (size <= newlen)
+	{
+	  if (!size)
+	    size = 1;
+
+	  do size *= 2;
+	  while (size <= newlen);
+
+	  reglist->size = size;
+	  reglist->regexps = regexps = xrealloc (regexps, size);
+	}
+      if (multiple_regexps)
+	{
+	  regexps[len++] = '\\';
+	  regexps[len++] = '|';
+	}
+      memcpy (regexps + len, pattern, patlen + 1);
+    }
+}
+
+/* Ensure that REGLIST represents the disjunction of its regexps.
+   This is done here, rather than earlier, to avoid O(N^2) behavior.  */
+
+static void
+summarize_regexp_list (struct regexp_list *reglist)
+{
+  if (reglist->regexps)
+    {
+      /* At least one regexp was specified.  Allocate a fastmap for it.  */
+      reglist->buf->fastmap = xmalloc (1 << CHAR_BIT);
+      if (reglist->multiple_regexps)
+	{
+	  /* Compile the disjunction of the regexps.
+	     (If just one regexp was specified, it is already compiled.)  */
+	  char const *m = re_compile_pattern (reglist->regexps, reglist->len,
+					      reglist->buf);
+	  if (m)
+	    die (EXIT_TROUBLE, 0, "%s: %s", reglist->regexps, m);
+	}
+    }
+}
+
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  die (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+	 program_name);
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    pfatal_with_name (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("    --normal                  output a normal diff (the default)"),
+  N_("-q, --brief                   report only when files differ"),
+  N_("-s, --report-identical-files  report when two files are the same"),
+  N_("-c, -C NUM, --context[=NUM]   output NUM (default 3) lines of copied context"),
+  N_("-u, -U NUM, --unified[=NUM]   output NUM (default 3) lines of unified context"),
+  N_("-e, --ed                      output an ed script"),
+  N_("-n, --rcs                     output an RCS format diff"),
+  N_("-y, --side-by-side            output in two columns"),
+  N_("-W, --width=NUM               output at most NUM (default 130) print columns"),
+  N_("    --left-column             output only the left column of common lines"),
+  N_("    --suppress-common-lines   do not output common lines"),
+  "",
+  N_("-p, --show-c-function         show which C function each change is in"),
+  N_("-F, --show-function-line=RE   show the most recent line matching RE"),
+  N_("    --label LABEL             use LABEL instead of file name and timestamp\n"
+     "                                (can be repeated)"),
+  "",
+  N_("-t, --expand-tabs             expand tabs to spaces in output"),
+  N_("-T, --initial-tab             make tabs line up by prepending a tab"),
+  N_("    --tabsize=NUM             tab stops every NUM (default 8) print columns"),
+  N_("    --suppress-blank-empty    suppress space or tab before empty output lines"),
+  N_("-l, --paginate                pass output through 'pr' to paginate it"),
+  "",
+  N_("-r, --recursive                 recursively compare any subdirectories found"),
+  N_("    --no-dereference            don't follow symbolic links"),
+  N_("-N, --new-file                  treat absent files as empty"),
+  N_("    --unidirectional-new-file   treat absent first files as empty"),
+  N_("    --ignore-file-name-case     ignore case when comparing file names"),
+  N_("    --no-ignore-file-name-case  consider case when comparing file names"),
+  N_("-x, --exclude=PAT               exclude files that match PAT"),
+  N_("-X, --exclude-from=FILE         exclude files that match any pattern in FILE"),
+  N_("-S, --starting-file=FILE        start with FILE when comparing directories"),
+  N_("    --from-file=FILE1           compare FILE1 to all operands;\n"
+     "                                  FILE1 can be a directory"),
+  N_("    --to-file=FILE2             compare all operands to FILE2;\n"
+     "                                  FILE2 can be a directory"),
+  "",
+  N_("-i, --ignore-case               ignore case differences in file contents"),
+  N_("-E, --ignore-tab-expansion      ignore changes due to tab expansion"),
+  N_("-Z, --ignore-trailing-space     ignore white space at line end"),
+  N_("-b, --ignore-space-change       ignore changes in the amount of white space"),
+  N_("-w, --ignore-all-space          ignore all white space"),
+  N_("-B, --ignore-blank-lines        ignore changes where lines are all blank"),
+  N_("-I, --ignore-matching-lines=RE  ignore changes where all lines match RE"),
+  "",
+  N_("-a, --text                      treat all files as text"),
+  N_("    --strip-trailing-cr         strip trailing carriage return on input"),
+#if O_BINARY
+  N_("    --binary                    read and write data in binary mode"),
+#endif
+  "",
+  N_("-D, --ifdef=NAME                output merged file with '#ifdef NAME' diffs"),
+  N_("    --GTYPE-group-format=GFMT   format GTYPE input groups with GFMT"),
+  N_("    --line-format=LFMT          format all input lines with LFMT"),
+  N_("    --LTYPE-line-format=LFMT    format LTYPE input lines with LFMT"),
+  N_("  These format options provide fine-grained control over the output\n"
+     "    of diff, generalizing -D/--ifdef."),
+  N_("  LTYPE is 'old', 'new', or 'unchanged'.  GTYPE is LTYPE or 'changed'."),
+  N_("  GFMT (only) may contain:\n\
+    %<  lines from FILE1\n\
+    %>  lines from FILE2\n\
+    %=  lines common to FILE1 and FILE2\n\
+    %[-][WIDTH][.[PREC]]{doxX}LETTER  printf-style spec for LETTER\n\
+      LETTERs are as follows for new group, lower case for old group:\n\
+        F  first line number\n\
+        L  last line number\n\
+        N  number of lines = L-F+1\n\
+        E  F-1\n\
+        M  L+1\n\
+    %(A=B?T:E)  if A equals B then T else E"),
+  N_("  LFMT (only) may contain:\n\
+    %L  contents of line\n\
+    %l  contents of line, excluding any trailing newline\n\
+    %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for input line number"),
+  N_("  Both GFMT and LFMT may contain:\n\
+    %%  %\n\
+    %c'C'  the single character C\n\
+    %c'\\OOO'  the character with octal code OOO\n\
+    C    the character C (other characters represent themselves)"),
+  "",
+  N_("-d, --minimal            try hard to find a smaller set of changes"),
+  N_("    --horizon-lines=NUM  keep NUM lines of the common prefix and suffix"),
+  N_("    --speed-large-files  assume large files and many scattered small changes"),
+  N_("    --color[=WHEN]       colorize the output; WHEN can be 'never', 'always',\n"
+     "                           or 'auto' (the default)"),
+  N_("    --palette=PALETTE    the colors to use when --color is active; PALETTE is\n"
+     "                           a colon-separated list of terminfo capabilities"),
+  "",
+  N_("    --help               display this help and exit"),
+  N_("-v, --version            output version information and exit"),
+  "",
+  N_("FILES are 'FILE1 FILE2' or 'DIR1 DIR2' or 'DIR FILE' or 'FILE DIR'."),
+  N_("If --from-file or --to-file is given, there are no restrictions on FILE(s)."),
+  N_("If a FILE is '-', read standard input."),
+  N_("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILES\n"), program_name);
+  printf ("%s\n\n", _("Compare FILES line by line."));
+
+  fputs (_("\
+Mandatory arguments to long options are mandatory for short options too.\n\
+"), stdout);
+
+  for (p = option_help_msgid;  *p;  p++)
+    {
+      if (!**p)
+	putchar ('\n');
+      else
+	{
+	  char const *msg = _(*p);
+	  char const *nl;
+	  while ((nl = strchr (msg, '\n')))
+	    {
+	      int msglen = nl + 1 - msg;
+	      printf ("  %.*s", msglen, msg);
+	      msg = nl + 1;
+	    }
+
+	  printf ("  %s\n" + 2 * (*msg != ' ' && *msg != '-'), msg);
+	}
+    }
+  emit_bug_reporting_address ();
+}
+
+/* Set VAR to VALUE, reporting an OPTION error if this is a
+   conflict.  */
+static void
+specify_value (char const **var, char const *value, char const *option)
+{
+  if (*var && ! STREQ (*var, value))
+    {
+      error (0, 0, _("conflicting %s option value '%s'"), option, value);
+      try_help (NULL, NULL);
+    }
+  *var = value;
+}
+
+/* Set the output style to STYLE, diagnosing conflicts.  */
+static void
+specify_style (enum output_style style)
+{
+  if (output_style != style)
+    {
+      if (output_style != OUTPUT_UNSPECIFIED)
+	try_help ("conflicting output style options", NULL);
+      output_style = style;
+    }
+}
+
+/* Set the color mode.  */
+static void
+specify_colors_style (char const *value)
+{
+  if (value == NULL || STREQ (value, "auto"))
+    colors_style = AUTO;
+  else if (STREQ (value, "always"))
+    colors_style = ALWAYS;
+  else if (STREQ (value, "never"))
+    colors_style = NEVER;
+  else
+    try_help ("invalid color '%s'", value);
+}
+
+
+/* Set the last-modified time of *ST to be the current time.  */
+
+static void
+set_mtime_to_now (struct stat *st)
+{
+#ifdef STAT_TIMESPEC
+  gettime (&STAT_TIMESPEC (st, st_mtim));
+#else
+  struct timespec t;
+  gettime (&t);
+  st->st_mtime = t.tv_sec;
+# if defined STAT_TIMESPEC_NS
+  STAT_TIMESPEC_NS (st, st_mtim) = t.tv_nsec;
+# elif defined HAVE_STRUCT_STAT_ST_SPARE1
+  st->st_spare1 = t.tv_nsec / 1000;
+# endif
+#endif
+}
+
+/* Compare two files (or dirs) with parent comparison PARENT
+   and names NAME0 and NAME1.
+   (If PARENT is null, then the first name is just NAME0, etc.)
+   This is self-contained; it opens the files and closes them.
+
+   Value is EXIT_SUCCESS if files are the same, EXIT_FAILURE if
+   different, EXIT_TROUBLE if there is a problem opening them.  */
+
+static int
+compare_files (struct comparison const *parent,
+	       char const *name0,
+	       char const *name1)
+{
+  struct comparison cmp;
+#define DIR_P(f) (S_ISDIR (cmp.file[f].stat.st_mode) != 0)
+  register int f;
+  int status = EXIT_SUCCESS;
+  bool same_files;
+  char *free0;
+  char *free1;
+
+  /* If this is directory comparison, perhaps we have a file
+     that exists only in one of the directories.
+     If so, just print a message to that effect.  */
+
+  if (! ((name0 && name1)
+	 || (unidirectional_new_file && name1)
+	 || new_file))
+    {
+      char const *name = name0 ? name0 : name1;
+      char const *dir = parent->file[!name0].name;
+
+      /* See POSIX 1003.1-2001 for this format.  */
+      message ("Only in %s: %s\n", dir, name);
+
+      /* Return EXIT_FAILURE so that diff_dirs will return
+	 EXIT_FAILURE ("some files differ").  */
+      return EXIT_FAILURE;
+    }
+
+  memset (cmp.file, 0, sizeof cmp.file);
+  cmp.parent = parent;
+
+  /* cmp.file[f].desc markers */
+#define NONEXISTENT (-1) /* nonexistent file */
+#define UNOPENED (-2) /* unopened file (e.g. directory) */
+#define ERRNO_ENCODE(errno) (-3 - (errno)) /* encoded errno value */
+
+#define ERRNO_DECODE(desc) (-3 - (desc)) /* inverse of ERRNO_ENCODE */
+
+  cmp.file[0].desc = name0 ? UNOPENED : NONEXISTENT;
+  cmp.file[1].desc = name1 ? UNOPENED : NONEXISTENT;
+
+  /* Now record the full name of each file, including nonexistent ones.  */
+
+  if (!name0)
+    name0 = name1;
+  if (!name1)
+    name1 = name0;
+
+  if (!parent)
+    {
+      free0 = NULL;
+      free1 = NULL;
+      cmp.file[0].name = name0;
+      cmp.file[1].name = name1;
+    }
+  else
+    {
+      cmp.file[0].name = free0
+	= file_name_concat (parent->file[0].name, name0, NULL);
+      cmp.file[1].name = free1
+	= file_name_concat (parent->file[1].name, name1, NULL);
+    }
+
+  /* Stat the files.  */
+
+  for (f = 0; f < 2; f++)
+    {
+      if (cmp.file[f].desc != NONEXISTENT)
+	{
+	  if (f && file_name_cmp (cmp.file[f].name, cmp.file[0].name) == 0)
+	    {
+	      cmp.file[f].desc = cmp.file[0].desc;
+	      cmp.file[f].stat = cmp.file[0].stat;
+	    }
+	  else if (STREQ (cmp.file[f].name, "-"))
+	    {
+	      cmp.file[f].desc = STDIN_FILENO;
+	      if (binary && ! isatty (STDIN_FILENO))
+		set_binary_mode (STDIN_FILENO, O_BINARY);
+	      if (fstat (STDIN_FILENO, &cmp.file[f].stat) != 0)
+		cmp.file[f].desc = ERRNO_ENCODE (errno);
+	      else
+		{
+		  if (S_ISREG (cmp.file[f].stat.st_mode))
+		    {
+		      off_t pos = lseek (STDIN_FILENO, 0, SEEK_CUR);
+		      if (pos < 0)
+			cmp.file[f].desc = ERRNO_ENCODE (errno);
+		      else
+			cmp.file[f].stat.st_size =
+			  MAX (0, cmp.file[f].stat.st_size - pos);
+		    }
+
+		  /* POSIX 1003.1-2001 requires current time for
+		     stdin.  */
+		  set_mtime_to_now (&cmp.file[f].stat);
+		}
+	    }
+	  else if ((no_dereference_symlinks
+		    ? lstat (cmp.file[f].name, &cmp.file[f].stat)
+		    : stat (cmp.file[f].name, &cmp.file[f].stat))
+		   != 0)
+	    cmp.file[f].desc = ERRNO_ENCODE (errno);
+	}
+    }
+
+  /* Mark files as nonexistent as needed for -N and -P, if they are
+     inaccessible empty regular files (the kind of files that 'patch'
+     creates to indicate nonexistent backups), or if they are
+     top-level files that do not exist but their counterparts do
+     exist.  */
+  for (f = 0; f < 2; f++)
+    if ((new_file || (f == 0 && unidirectional_new_file))
+	&& (cmp.file[f].desc == UNOPENED
+	    ? (S_ISREG (cmp.file[f].stat.st_mode)
+	       && ! (cmp.file[f].stat.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO))
+	       && cmp.file[f].stat.st_size == 0)
+	    : ((cmp.file[f].desc == ERRNO_ENCODE (ENOENT)
+		|| cmp.file[f].desc == ERRNO_ENCODE (EBADF))
+	       && ! parent
+	       && (cmp.file[1 - f].desc == UNOPENED
+		   || cmp.file[1 - f].desc == STDIN_FILENO))))
+      cmp.file[f].desc = NONEXISTENT;
+
+  for (f = 0; f < 2; f++)
+    if (cmp.file[f].desc == NONEXISTENT)
+      {
+	memset (&cmp.file[f].stat, 0, sizeof cmp.file[f].stat);
+	cmp.file[f].stat.st_mode = cmp.file[1 - f].stat.st_mode;
+      }
+
+  for (f = 0; f < 2; f++)
+    {
+      int e = ERRNO_DECODE (cmp.file[f].desc);
+      if (0 <= e)
+	{
+	  errno = e;
+	  perror_with_name (cmp.file[f].name);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  if (status == EXIT_SUCCESS && ! parent && DIR_P (0) != DIR_P (1))
+    {
+      /* If one is a directory, and it was specified in the command line,
+	 use the file in that dir with the other file's basename.  */
+
+      int fnm_arg = DIR_P (0);
+      int dir_arg = 1 - fnm_arg;
+      char const *fnm = cmp.file[fnm_arg].name;
+      char const *dir = cmp.file[dir_arg].name;
+      char const *filename = cmp.file[dir_arg].name = free0
+	= find_dir_file_pathname (dir, last_component (fnm));
+
+      if (STREQ (fnm, "-"))
+	fatal ("cannot compare '-' to a directory");
+
+      if ((no_dereference_symlinks
+	   ? lstat (filename, &cmp.file[dir_arg].stat)
+	   : stat (filename, &cmp.file[dir_arg].stat))
+	  != 0)
+	{
+	  perror_with_name (filename);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  if (status != EXIT_SUCCESS)
+    {
+      /* One of the files should exist but does not.  */
+    }
+  else if (cmp.file[0].desc == NONEXISTENT
+	   && cmp.file[1].desc == NONEXISTENT)
+    {
+      /* Neither file "exists", so there's nothing to compare.  */
+    }
+  else if ((same_files
+	    = (cmp.file[0].desc != NONEXISTENT
+	       && cmp.file[1].desc != NONEXISTENT
+	       && 0 < same_file (&cmp.file[0].stat, &cmp.file[1].stat)
+	       && same_file_attributes (&cmp.file[0].stat,
+					&cmp.file[1].stat)))
+	   && no_diff_means_no_output)
+    {
+      /* The two named files are actually the same physical file.
+	 We know they are identical without actually reading them.  */
+    }
+  else if (DIR_P (0) & DIR_P (1))
+    {
+      if (output_style == OUTPUT_IFDEF)
+	fatal ("-D option not supported with directories");
+
+      /* If both are directories, compare the files in them.  */
+
+      if (parent && !recursive)
+	{
+	  /* But don't compare dir contents one level down
+	     unless -r was specified.
+	     See POSIX 1003.1-2001 for this format.  */
+	  message ("Common subdirectories: %s and %s\n",
+		   cmp.file[0].name, cmp.file[1].name);
+	}
+      else
+	status = diff_dirs (&cmp, compare_files);
+    }
+  else if ((DIR_P (0) | DIR_P (1))
+	   || (parent
+	       && !((S_ISREG (cmp.file[0].stat.st_mode)
+		     || S_ISLNK (cmp.file[0].stat.st_mode))
+		    && (S_ISREG (cmp.file[1].stat.st_mode)
+			|| S_ISLNK  (cmp.file[1].stat.st_mode)))))
+    {
+      if (cmp.file[0].desc == NONEXISTENT || cmp.file[1].desc == NONEXISTENT)
+	{
+	  /* We have a subdirectory that exists only in one directory.  */
+
+	  if ((DIR_P (0) | DIR_P (1))
+	      && recursive
+	      && (new_file
+		  || (unidirectional_new_file
+		      && cmp.file[0].desc == NONEXISTENT)))
+	    status = diff_dirs (&cmp, compare_files);
+	  else
+	    {
+	      char const *dir;
+
+	      /* PARENT must be non-NULL here.  */
+	      assert (parent);
+	      dir = parent->file[cmp.file[0].desc == NONEXISTENT].name;
+
+	      /* See POSIX 1003.1-2001 for this format.  */
+	      message ("Only in %s: %s\n", dir, name0);
+
+	      status = EXIT_FAILURE;
+	    }
+	}
+      else
+	{
+	  /* We have two files that are not to be compared.  */
+
+	  /* See POSIX 1003.1-2001 for this format.  */
+	  message5 ("File %s is a %s while file %s is a %s\n",
+		    file_label[0] ? file_label[0] : cmp.file[0].name,
+		    file_type (&cmp.file[0].stat),
+		    file_label[1] ? file_label[1] : cmp.file[1].name,
+		    file_type (&cmp.file[1].stat));
+
+	  /* This is a difference.  */
+	  status = EXIT_FAILURE;
+	}
+    }
+  else if (S_ISLNK (cmp.file[0].stat.st_mode)
+	   || S_ISLNK (cmp.file[1].stat.st_mode))
+    {
+      /* We get here only if we use lstat(), not stat().  */
+      assert (no_dereference_symlinks);
+
+      if (S_ISLNK (cmp.file[0].stat.st_mode)
+	  && S_ISLNK (cmp.file[1].stat.st_mode))
+	{
+	  /* Compare the values of the symbolic links.  */
+	  char *link_value[2] = { NULL, NULL };
+
+	  for (f = 0; f < 2; f++)
+	    {
+	      link_value[f] = xreadlink (cmp.file[f].name);
+	      if (link_value[f] == NULL)
+		{
+		  perror_with_name (cmp.file[f].name);
+		  status = EXIT_TROUBLE;
+		  break;
+		}
+	    }
+	  if (status == EXIT_SUCCESS)
+	    {
+	      if ( ! STREQ (link_value[0], link_value[1]))
+		{
+		  message ("Symbolic links %s and %s differ\n",
+			   cmp.file[0].name, cmp.file[1].name);
+		  /* This is a difference.  */
+		  status = EXIT_FAILURE;
+		}
+	    }
+	  for (f = 0; f < 2; f++)
+	    free (link_value[f]);
+	}
+      else
+	{
+	  /* We have two files that are not to be compared, because
+	     one of them is a symbolic link and the other one is not.  */
+
+	  message5 ("File %s is a %s while file %s is a %s\n",
+		    file_label[0] ? file_label[0] : cmp.file[0].name,
+		    file_type (&cmp.file[0].stat),
+		    file_label[1] ? file_label[1] : cmp.file[1].name,
+		    file_type (&cmp.file[1].stat));
+
+	  /* This is a difference.  */
+	  status = EXIT_FAILURE;
+	}
+    }
+  else if (files_can_be_treated_as_binary
+	   && S_ISREG (cmp.file[0].stat.st_mode)
+	   && S_ISREG (cmp.file[1].stat.st_mode)
+	   && cmp.file[0].stat.st_size != cmp.file[1].stat.st_size
+	   && 0 < cmp.file[0].stat.st_size
+	   && 0 < cmp.file[1].stat.st_size)
+    {
+      message ("Files %s and %s differ\n",
+	       file_label[0] ? file_label[0] : cmp.file[0].name,
+	       file_label[1] ? file_label[1] : cmp.file[1].name);
+      status = EXIT_FAILURE;
+    }
+  else
+    {
+      /* Both exist and neither is a directory.  */
+
+      /* Open the files and record their descriptors.  */
+
+      int oflags = O_RDONLY | (binary ? O_BINARY : 0);
+
+      if (cmp.file[0].desc == UNOPENED)
+	if ((cmp.file[0].desc = open (cmp.file[0].name, oflags, 0)) < 0)
+	  {
+	    perror_with_name (cmp.file[0].name);
+	    status = EXIT_TROUBLE;
+	  }
+      if (cmp.file[1].desc == UNOPENED)
+	{
+	  if (same_files)
+	    cmp.file[1].desc = cmp.file[0].desc;
+	  else if ((cmp.file[1].desc = open (cmp.file[1].name, oflags, 0)) < 0)
+	    {
+	      perror_with_name (cmp.file[1].name);
+	      status = EXIT_TROUBLE;
+	    }
+	}
+
+      /* Compare the files, if no error was found.  */
+
+      if (status == EXIT_SUCCESS)
+	status = diff_2_files (&cmp);
+
+      /* Close the file descriptors.  */
+
+      if (0 <= cmp.file[0].desc && close (cmp.file[0].desc) != 0)
+	{
+	  perror_with_name (cmp.file[0].name);
+	  status = EXIT_TROUBLE;
+	}
+      if (0 <= cmp.file[1].desc && cmp.file[0].desc != cmp.file[1].desc
+	  && close (cmp.file[1].desc) != 0)
+	{
+	  perror_with_name (cmp.file[1].name);
+	  status = EXIT_TROUBLE;
+	}
+    }
+
+  /* Now the comparison has been done, if no error prevented it,
+     and STATUS is the value this function will return.  */
+
+  if (status == EXIT_SUCCESS)
+    {
+      if (report_identical_files && !DIR_P (0))
+	message ("Files %s and %s are identical\n",
+		 file_label[0] ? file_label[0] : cmp.file[0].name,
+		 file_label[1] ? file_label[1] : cmp.file[1].name);
+    }
+  else
+    {
+      /* Flush stdout so that the user sees differences immediately.
+	 This can hurt performance, unfortunately.  */
+      if (fflush (stdout) != 0)
+	pfatal_with_name (_("standard output"));
+    }
+
+  free (free0);
+  free (free1);
+
+  return status;
+}
diff --git a/test/diffutils-3.0/diff.h b/test/diffutils-3.0/diff.h
new file mode 100644
index 0000000..c8cf436
--- /dev/null
+++ b/test/diffutils-3.0/diff.h
@@ -0,0 +1,423 @@
+/* Shared definitions for GNU DIFF
+
+   Copyright (C) 1988-1989, 1991-1995, 1998, 2001-2002, 2004, 2009-2013,
+   2015-2017 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include <regex.h>
+#include <stdio.h>
+#include <unlocked-io.h>
+
+/* What kind of changes a hunk contains.  */
+enum changes
+{
+  /* No changes: lines common to both files.  */
+  UNCHANGED,
+
+  /* Deletes only: lines taken from just the first file.  */
+  OLD,
+
+  /* Inserts only: lines taken from just the second file.  */
+  NEW,
+
+  /* Both deletes and inserts: a hunk containing both old and new lines.  */
+  CHANGED
+};
+
+/* When colors should be used in the output.  */
+enum colors_style
+{
+  /* Never output colors.  */
+  NEVER,
+
+  /* Output colors if the output is a terminal.  */
+  AUTO,
+
+  /* Always output colors.  */
+  ALWAYS,
+};
+
+/* Variables for command line options */
+
+#ifndef GDIFF_MAIN
+# define XTERN extern
+#else
+# define XTERN
+#endif
+
+enum output_style
+{
+  /* No output style specified.  */
+  OUTPUT_UNSPECIFIED,
+
+  /* Default output style.  */
+  OUTPUT_NORMAL,
+
+  /* Output the differences with lines of context before and after (-c).  */
+  OUTPUT_CONTEXT,
+
+  /* Output the differences in a unified context diff format (-u).  */
+  OUTPUT_UNIFIED,
+
+  /* Output the differences as commands suitable for 'ed' (-e).  */
+  OUTPUT_ED,
+
+  /* Output the diff as a forward ed script (-f).  */
+  OUTPUT_FORWARD_ED,
+
+  /* Like -f, but output a count of changed lines in each "command" (-n).  */
+  OUTPUT_RCS,
+
+  /* Output merged #ifdef'd file (-D).  */
+  OUTPUT_IFDEF,
+
+  /* Output sdiff style (-y).  */
+  OUTPUT_SDIFF
+};
+
+/* True for output styles that are robust,
+   i.e. can handle a file that ends in a non-newline.  */
+#define ROBUST_OUTPUT_STYLE(S) ((S) != OUTPUT_ED && (S) != OUTPUT_FORWARD_ED)
+
+XTERN enum output_style output_style;
+
+/* Define the current color context used to print a line.  */
+XTERN enum colors_style colors_style;
+
+/* Nonzero if output cannot be generated for identical files.  */
+XTERN bool no_diff_means_no_output;
+
+/* Number of lines of context to show in each set of diffs.
+   This is zero when context is not to be shown.  */
+XTERN lin context;
+
+/* Consider all files as text files (-a).
+   Don't interpret codes over 0177 as implying a "binary file".  */
+XTERN bool text;
+
+/* Number of lines to keep in identical prefix and suffix.  */
+XTERN lin horizon_lines;
+
+/* The significance of white space during comparisons.  */
+enum DIFF_white_space
+{
+  /* All white space is significant (the default).  */
+  IGNORE_NO_WHITE_SPACE,
+
+  /* Ignore changes due to tab expansion (-E).  */
+  IGNORE_TAB_EXPANSION,
+
+  /* Ignore changes in trailing horizontal white space (-Z).  */
+  IGNORE_TRAILING_SPACE,
+
+  /* IGNORE_TAB_EXPANSION and IGNORE_TRAILING_SPACE are a special case
+     because they are independent and can be ORed together, yielding
+     IGNORE_TAB_EXPANSION_AND_TRAILING_SPACE.  */
+  IGNORE_TAB_EXPANSION_AND_TRAILING_SPACE,
+
+  /* Ignore changes in horizontal white space (-b).  */
+  IGNORE_SPACE_CHANGE,
+
+  /* Ignore all horizontal white space (-w).  */
+  IGNORE_ALL_SPACE
+};
+XTERN enum DIFF_white_space ignore_white_space;
+
+/* Ignore changes that affect only blank lines (-B).  */
+XTERN bool ignore_blank_lines;
+
+/* Files can be compared byte-by-byte, as if they were binary.
+   This depends on various options.  */
+XTERN bool files_can_be_treated_as_binary;
+
+/* Ignore differences in case of letters (-i).  */
+XTERN bool ignore_case;
+
+/* Ignore differences in case of letters in file names.  */
+XTERN bool ignore_file_name_case;
+
+/* Act on symbolic links themselves rather than on their target
+   (--no-dereference).  */
+XTERN bool no_dereference_symlinks;
+
+/* File labels for '-c' output headers (--label).  */
+XTERN char *file_label[2];
+
+/* Regexp to identify function-header lines (-F).  */
+XTERN struct re_pattern_buffer function_regexp;
+
+/* Ignore changes that affect only lines matching this regexp (-I).  */
+XTERN struct re_pattern_buffer ignore_regexp;
+
+/* Say only whether files differ, not how (-q).  */
+XTERN bool brief;
+
+/* Expand tabs in the output so the text lines up properly
+   despite the characters added to the front of each line (-t).  */
+XTERN bool expand_tabs;
+
+/* Number of columns between tab stops.  */
+XTERN size_t tabsize;
+
+/* Use a tab in the output, rather than a space, before the text of an
+   input line, so as to keep the proper alignment in the input line
+   without changing the characters in it (-T).  */
+XTERN bool initial_tab;
+
+/* Do not output an initial space or tab before the text of an empty line.  */
+XTERN bool suppress_blank_empty;
+
+/* Remove trailing carriage returns from input.  */
+XTERN bool strip_trailing_cr;
+
+/* In directory comparison, specify file to start with (-S).
+   This is used for resuming an aborted comparison.
+   All file names less than this name are ignored.  */
+XTERN char const *starting_file;
+
+/* Pipe each file's output through pr (-l).  */
+XTERN bool paginate;
+
+/* Line group formats for unchanged, old, new, and changed groups.  */
+XTERN char const *group_format[CHANGED + 1];
+
+/* Line formats for unchanged, old, and new lines.  */
+XTERN char const *line_format[NEW + 1];
+
+/* If using OUTPUT_SDIFF print extra information to help the sdiff filter.  */
+XTERN bool sdiff_merge_assist;
+
+/* Tell OUTPUT_SDIFF to show only the left version of common lines.  */
+XTERN bool left_column;
+
+/* Tell OUTPUT_SDIFF to not show common lines.  */
+XTERN bool suppress_common_lines;
+
+/* The half line width and column 2 offset for OUTPUT_SDIFF.  */
+XTERN size_t sdiff_half_width;
+XTERN size_t sdiff_column2_offset;
+
+/* String containing all the command options diff received,
+   with spaces between and at the beginning but none at the end.
+   If there were no options given, this string is empty.  */
+XTERN char *switch_string;
+
+/* Use heuristics for better speed with large files with a small
+   density of changes.  */
+XTERN bool speed_large_files;
+
+/* Patterns that match file names to be excluded.  */
+XTERN struct exclude *excluded;
+
+/* Don't discard lines.  This makes things slower (sometimes much
+   slower) but will find a guaranteed minimal set of changes.  */
+XTERN bool minimal;
+
+/* The strftime format to use for time strings.  */
+XTERN char const *time_format;
+
+/* The result of comparison is an "edit script": a chain of 'struct change'.
+   Each 'struct change' represents one place where some lines are deleted
+   and some are inserted.
+
+   LINE0 and LINE1 are the first affected lines in the two files (origin 0).
+   DELETED is the number of lines deleted here from file 0.
+   INSERTED is the number of lines inserted here in file 1.
+
+   If DELETED is 0 then LINE0 is the number of the line before
+   which the insertion was done; vice versa for INSERTED and LINE1.  */
+
+struct change
+{
+  struct change *link;		/* Previous or next edit command  */
+  lin inserted;			/* # lines of file 1 changed here.  */
+  lin deleted;			/* # lines of file 0 changed here.  */
+  lin line0;			/* Line number of 1st deleted line.  */
+  lin line1;			/* Line number of 1st inserted line.  */
+  bool ignore;			/* Flag used in context.c.  */
+};
+
+/* Structures that describe the input files.  */
+
+/* Data on one input file being compared.  */
+
+struct file_data {
+    int             desc;	/* File descriptor  */
+    char const      *name;	/* File name  */
+    struct stat     stat;	/* File status */
+
+    /* Buffer in which text of file is read.  */
+    word *buffer;
+
+    /* Allocated size of buffer, in bytes.  Always a multiple of
+       sizeof *buffer.  */
+    size_t bufsize;
+
+    /* Number of valid bytes now in the buffer.  */
+    size_t buffered;
+
+    /* Array of pointers to lines in the file.  */
+    char const **linbuf;
+
+    /* linbuf_base <= buffered_lines <= valid_lines <= alloc_lines.
+       linebuf[linbuf_base ... buffered_lines - 1] are possibly differing.
+       linebuf[linbuf_base ... valid_lines - 1] contain valid data.
+       linebuf[linbuf_base ... alloc_lines - 1] are allocated.  */
+    lin linbuf_base, buffered_lines, valid_lines, alloc_lines;
+
+    /* Pointer to end of prefix of this file to ignore when hashing.  */
+    char const *prefix_end;
+
+    /* Count of lines in the prefix.
+       There are this many lines in the file before linbuf[0].  */
+    lin prefix_lines;
+
+    /* Pointer to start of suffix of this file to ignore when hashing.  */
+    char const *suffix_begin;
+
+    /* Vector, indexed by line number, containing an equivalence code for
+       each line.  It is this vector that is actually compared with that
+       of another file to generate differences.  */
+    lin *equivs;
+
+    /* Vector, like the previous one except that
+       the elements for discarded lines have been squeezed out.  */
+    lin *undiscarded;
+
+    /* Vector mapping virtual line numbers (not counting discarded lines)
+       to real ones (counting those lines).  Both are origin-0.  */
+    lin *realindexes;
+
+    /* Total number of nondiscarded lines.  */
+    lin nondiscarded_lines;
+
+    /* Vector, indexed by real origin-0 line number,
+       containing 1 for a line that is an insertion or a deletion.
+       The results of comparison are stored here.  */
+    char *changed;
+
+    /* 1 if file ends in a line with no final newline.  */
+    bool missing_newline;
+
+    /* 1 if at end of file.  */
+    bool eof;
+
+    /* 1 more than the maximum equivalence value used for this or its
+       sibling file.  */
+    lin equiv_max;
+};
+
+/* The file buffer, considered as an array of bytes rather than
+   as an array of words.  */
+#define FILE_BUFFER(f) ((char *) (f)->buffer)
+
+/* Data on two input files being compared.  */
+
+struct comparison
+  {
+    struct file_data file[2];
+    struct comparison const *parent;  /* parent, if a recursive comparison */
+  };
+
+/* Describe the two files currently being compared.  */
+
+XTERN struct file_data files[2];
+
+/* Stdio stream to output diffs to.  */
+
+XTERN FILE *outfile;
+
+/* Declare various functions.  */
+
+/* analyze.c */
+extern int diff_2_files (struct comparison *);
+
+/* context.c */
+extern void print_context_header (struct file_data[], char const * const *, bool);
+extern void print_context_script (struct change *, bool);
+
+/* dir.c */
+extern int diff_dirs (struct comparison const *,
+                      int (*) (struct comparison const *,
+                               char const *, char const *));
+extern char *find_dir_file_pathname (char const *, char const *);
+
+/* ed.c */
+extern void print_ed_script (struct change *);
+extern void pr_forward_ed_script (struct change *);
+
+/* ifdef.c */
+extern void print_ifdef_script (struct change *);
+
+/* io.c */
+extern void file_block_read (struct file_data *, size_t);
+extern bool read_files (struct file_data[], bool);
+
+/* normal.c */
+extern void print_normal_script (struct change *);
+
+/* rcs.c */
+extern void print_rcs_script (struct change *);
+
+/* side.c */
+extern void print_sdiff_script (struct change *);
+
+/* util.c */
+extern char const change_letter[4];
+extern char const pr_program[];
+extern char *concat (char const *, char const *, char const *);
+extern bool lines_differ (char const *, char const *) _GL_ATTRIBUTE_PURE;
+extern lin translate_line_number (struct file_data const *, lin);
+extern struct change *find_change (struct change *);
+extern struct change *find_reverse_change (struct change *);
+extern void *zalloc (size_t);
+extern enum changes analyze_hunk (struct change *, lin *, lin *, lin *, lin *);
+extern void begin_output (void);
+extern void debug_script (struct change *);
+extern void fatal (char const *) __attribute__((noreturn));
+extern void finish_output (void);
+extern void message (char const *, char const *, char const *);
+extern void message5 (char const *, char const *, char const *,
+                      char const *, char const *);
+extern void output_1_line (char const *, char const *, char const *,
+                           char const *);
+extern void perror_with_name (char const *);
+extern void pfatal_with_name (char const *) __attribute__((noreturn));
+extern void print_1_line (char const *, char const * const *);
+extern void print_1_line_nl (char const *, char const * const *, bool);
+extern void print_message_queue (void);
+extern void print_number_range (char, struct file_data *, lin, lin);
+extern void print_script (struct change *, struct change * (*) (struct change *),
+                          void (*) (struct change *));
+extern void setup_output (char const *, char const *, bool);
+extern void translate_range (struct file_data const *, lin, lin,
+                             printint *, printint *);
+
+enum color_context
+{
+  HEADER_CONTEXT,
+  ADD_CONTEXT,
+  DELETE_CONTEXT,
+  RESET_CONTEXT,
+  LINE_NUMBER_CONTEXT,
+};
+
+XTERN bool presume_output_tty;
+
+extern void set_color_context (enum color_context color_context);
+extern void set_color_palette (char const *palette);
diff --git a/test/diffutils-3.0/diff3.c b/test/diffutils-3.0/diff3.c
new file mode 100644
index 0000000..5f3c7cb
--- /dev/null
+++ b/test/diffutils-3.0/diff3.c
@@ -0,0 +1,1790 @@
+/* diff3 - compare three files line by line
+
+   Copyright (C) 1988-1989, 1992-1996, 1998, 2001-2002, 2004, 2006, 2009-2013,
+   2015-2017 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+#include <unlocked-io.h>
+
+#include <c-stack.h>
+#include <cmpbuf.h>
+#include "die.h"
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <progname.h>
+#include <system-quote.h>
+#include <version-etc.h>
+#include <xalloc.h>
+#include <xfreopen.h>
+
+/* The official name of this program (e.g., no 'g' prefix).  */
+#define PROGRAM_NAME "diff3"
+
+#define AUTHORS \
+  proper_name ("Randy Smith")
+
+/* Internal data structures and macros for the diff3 program; includes
+   data structures for both diff3 diffs and normal diffs.  */
+
+/* Different files within a three way diff.  */
+#define	FILE0	0
+#define	FILE1	1
+#define	FILE2	2
+
+/* A three way diff is built from two two-way diffs; the file which
+   the two two-way diffs share is:  */
+#define	FILEC	FILE2
+
+/* Different files within a two way diff.
+   FC is the common file, FO the other file.  */
+#define FO 0
+#define FC 1
+
+/* The ranges are indexed by */
+#define	RANGE_START	0
+#define	RANGE_END	1
+
+enum diff_type {
+  ERROR,			/* Should not be used */
+  ADD,				/* Two way diff add */
+  CHANGE,			/* Two way diff change */
+  DELETE,			/* Two way diff delete */
+  DIFF_ALL,			/* All three are different */
+  DIFF_1ST,			/* Only the first is different */
+  DIFF_2ND,			/* Only the second */
+  DIFF_3RD			/* Only the third */
+};
+
+/* Two way diff */
+struct diff_block {
+  lin ranges[2][2];		/* Ranges are inclusive */
+  char **lines[2];		/* The actual lines (may contain nulls) */
+  size_t *lengths[2];		/* Line lengths (including newlines, if any) */
+  struct diff_block *next;
+#ifdef lint
+  struct diff_block *n2;	/* Used only when freeing.  */
+#endif
+};
+
+/* Three way diff */
+
+struct diff3_block {
+  enum diff_type correspond;	/* Type of diff */
+  lin ranges[3][2];		/* Ranges are inclusive */
+  char **lines[3];		/* The actual lines (may contain nulls) */
+  size_t *lengths[3];		/* Line lengths (including newlines, if any) */
+  struct diff3_block *next;
+};
+
+/* Access the ranges on a diff block.  */
+#define	D_LOWLINE(diff, filenum)	\
+  ((diff)->ranges[filenum][RANGE_START])
+#define	D_HIGHLINE(diff, filenum)	\
+  ((diff)->ranges[filenum][RANGE_END])
+#define	D_NUMLINES(diff, filenum)	\
+  (D_HIGHLINE (diff, filenum) - D_LOWLINE (diff, filenum) + 1)
+
+/* Access the line numbers in a file in a diff by relative line
+   numbers (i.e. line number within the diff itself).  Note that these
+   are lvalues and can be used for assignment.  */
+#define	D_RELNUM(diff, filenum, linenum)	\
+  ((diff)->lines[filenum][linenum])
+#define	D_RELLEN(diff, filenum, linenum)	\
+  ((diff)->lengths[filenum][linenum])
+
+/* And get at them directly, when that should be necessary.  */
+#define	D_LINEARRAY(diff, filenum)	\
+  ((diff)->lines[filenum])
+#define	D_LENARRAY(diff, filenum)	\
+  ((diff)->lengths[filenum])
+
+/* Next block.  */
+#define	D_NEXT(diff)	((diff)->next)
+
+/* Access the type of a diff3 block.  */
+#define	D3_TYPE(diff)	((diff)->correspond)
+
+/* Line mappings based on diffs.  The first maps off the top of the
+   diff, the second off of the bottom.  */
+#define	D_HIGH_MAPLINE(diff, fromfile, tofile, linenum)	\
+  ((linenum)						\
+   - D_HIGHLINE ((diff), (fromfile))			\
+   + D_HIGHLINE ((diff), (tofile)))
+
+#define	D_LOW_MAPLINE(diff, fromfile, tofile, linenum)	\
+  ((linenum)						\
+   - D_LOWLINE ((diff), (fromfile))			\
+   + D_LOWLINE ((diff), (tofile)))
+
+/* Options variables for flags set on command line.  */
+
+/* If nonzero, treat all files as text files, never as binary.  */
+static bool text;
+
+/* Remove trailing carriage returns from input.  */
+static bool strip_trailing_cr;
+
+/* If nonzero, write out an ed script instead of the standard diff3 format.  */
+static bool edscript;
+
+/* If nonzero, in the case of overlapping diffs (type DIFF_ALL),
+   preserve the lines which would normally be deleted from
+   file 1 with a special flagging mechanism.  */
+static bool flagging;
+
+/* Use a tab to align output lines (-T).  */
+static bool initial_tab;
+
+/* If nonzero, do not output information for overlapping diffs.  */
+static bool simple_only;
+
+/* If nonzero, do not output information for non-overlapping diffs.  */
+static bool overlap_only;
+
+/* If nonzero, show information for DIFF_2ND diffs.  */
+static bool show_2nd;
+
+/* If nonzero, include ':wq' at the end of the script
+   to write out the file being edited.   */
+static bool finalwrite;
+
+/* If nonzero, output a merged file.  */
+static bool merge;
+
+static char *read_diff (char const *, char const *, char **);
+static char *scan_diff_line (char *, char **, size_t *, char *, char);
+static enum diff_type process_diff_control (char **, struct diff_block *);
+static bool compare_line_list (char * const[], size_t const[], char * const[], size_t const[], lin);
+static bool copy_stringlist (char * const[], size_t const[], char *[], size_t[], lin);
+static bool output_diff3_edscript (FILE *, struct diff3_block *, int const[3], int const[3], char const *, char const *, char const *);
+static bool output_diff3_merge (FILE *, FILE *, struct diff3_block *, int const[3], int const[3], char const *, char const *, char const *);
+static struct diff3_block *create_diff3_block (lin, lin, lin, lin, lin, lin);
+static struct diff3_block *make_3way_diff (struct diff_block *, struct diff_block *);
+static struct diff3_block *reverse_diff3_blocklist (struct diff3_block *);
+static struct diff3_block *using_to_diff3_block (struct diff_block *[2], struct diff_block *[2], int, int, struct diff3_block const *);
+static struct diff_block *process_diff (char const *, char const *, struct diff_block **, char **);
+static void check_stdout (void);
+static void fatal (char const *) __attribute__((noreturn));
+static void output_diff3 (FILE *, struct diff3_block *, int const[3], int const[3]);
+static void perror_with_exit (char const *) __attribute__((noreturn));
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void usage (void);
+
+static char const *diff_program = DEFAULT_DIFF_PROGRAM;
+
+/* Values for long options that do not have single-letter equivalents.  */
+enum
+{
+  DIFF_PROGRAM_OPTION = CHAR_MAX + 1,
+  HELP_OPTION,
+  STRIP_TRAILING_CR_OPTION
+};
+
+static struct option const longopts[] =
+{
+  {"diff-program", 1, 0, DIFF_PROGRAM_OPTION},
+  {"easy-only", 0, 0, '3'},
+  {"ed", 0, 0, 'e'},
+  {"help", 0, 0, HELP_OPTION},
+  {"initial-tab", 0, 0, 'T'},
+  {"label", 1, 0, 'L'},
+  {"merge", 0, 0, 'm'},
+  {"overlap-only", 0, 0, 'x'},
+  {"show-all", 0, 0, 'A'},
+  {"show-overlap", 0, 0, 'E'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"text", 0, 0, 'a'},
+  {"version", 0, 0, 'v'},
+  {0, 0, 0, 0}
+};
+
+static void
+free_diff_block (struct diff_block *p)
+{
+#ifndef lint
+  (void)p;
+#else
+  while (p)
+    {
+      free (p->lines[0]);
+      free (p->lines[1]);
+      free (p->lengths[0]);
+      free (p->lengths[1]);
+      struct diff_block *next = p->n2;
+      free (p);
+      p = next;
+    }
+#endif
+}
+
+/* Copy each next pointer to n2, since make_3way_diff would clobber the former,
+   yet we will still need something to free these buffers.  */
+static void
+next_to_n2 (struct diff_block *p)
+{
+#ifndef lint
+  (void)p;
+#else
+  while (p)
+    p = p->n2 = p->next;
+#endif
+}
+
+int
+main (int argc, char **argv)
+{
+  int c, i;
+  int common;
+  int mapping[3];
+  int rev_mapping[3];
+  int incompat = 0;
+  bool conflicts_found;
+  struct diff_block *thread0, *thread1, *last_block;
+  struct diff3_block *diff3;
+  int tag_count = 0;
+  char *tag_strings[3];
+  char *commonname;
+  char **file;
+  struct stat statb;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (0);
+
+  while ((c = getopt_long (argc, argv, "aeimvx3AEL:TX", longopts, 0)) != -1)
+    {
+      switch (c)
+	{
+	case 'a':
+	  text = true;
+	  break;
+	case 'A':
+	  show_2nd = true;
+	  flagging = true;
+	  incompat++;
+	  break;
+	case 'x':
+	  overlap_only = true;
+	  incompat++;
+	  break;
+	case '3':
+	  simple_only = true;
+	  incompat++;
+	  break;
+	case 'i':
+	  finalwrite = true;
+	  break;
+	case 'm':
+	  merge = true;
+	  break;
+	case 'X':
+	  overlap_only = true;
+	  FALLTHROUGH;
+	case 'E':
+	  flagging = true;
+	  FALLTHROUGH;
+	case 'e':
+	  incompat++;
+	  break;
+	case 'T':
+	  initial_tab = true;
+	  break;
+	case STRIP_TRAILING_CR_OPTION:
+	  strip_trailing_cr = true;
+	  break;
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+	case DIFF_PROGRAM_OPTION:
+	  diff_program = optarg;
+	  break;
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+	case 'L':
+	  /* Handle up to three -L options.  */
+	  if (tag_count < 3)
+	    {
+	      tag_strings[tag_count++] = optarg;
+	      break;
+	    }
+	  try_help ("too many file label options", 0);
+	default:
+	  try_help (0, 0);
+	}
+    }
+
+  /* -AeExX3 without -m implies ed script.  */
+  edscript = incompat & ~(int) merge;
+
+  show_2nd |= ~incompat & merge;  /* -m without -AeExX3 implies -A.  */
+  flagging |= ~incompat & merge;
+
+  if (incompat > 1  /* Ensure at most one of -AeExX3.  */
+      || finalwrite & merge /* -i -m would rewrite input file.  */
+      || (tag_count && ! flagging)) /* -L requires one of -AEX.  */
+    try_help ("incompatible options", 0);
+
+  if (argc - optind != 3)
+    {
+      if (argc - optind < 3)
+	try_help ("missing operand after '%s'", argv[argc - 1]);
+      else
+	try_help ("extra operand '%s'", argv[optind + 3]);
+    }
+
+  file = &argv[optind];
+
+  for (i = tag_count; i < 3; i++)
+    tag_strings[i] = file[i];
+
+  /* Always compare file1 to file2, even if file2 is "-".
+     This is needed for -mAeExX3.  Using the file0 as
+     the common file would produce wrong results, because if the
+     file0-file1 diffs didn't line up with the file0-file2 diffs
+     (which is entirely possible since we don't use diff's -n option),
+     diff3 might report phantom changes from file1 to file2.
+
+     Also, try to compare file0 to file1, because this is where
+     changes are expected to come from.  Diffing between these pairs
+     of files is more likely to avoid phantom changes from file0 to file1.
+
+     Historically, the default common file was file2, so some older
+     applications (e.g. Emacs ediff) used file2 as the ancestor.  So,
+     for compatibility, if this is a 3-way diff (not a merge or
+     edscript), prefer file2 as the common file.  */
+
+  common = 2 - (edscript | merge);
+
+  if (STREQ (file[common], "-"))
+    {
+      /* Sigh.  We've got standard input as the common file.  We can't
+	 call diff twice on stdin.  Use the other arg as the common
+	 file instead.  */
+      common = 3 - common;
+      if (STREQ (file[0], "-") || STREQ (file[common], "-"))
+	fatal ("'-' specified for more than one input file");
+    }
+
+  mapping[0] = 0;
+  mapping[1] = 3 - common;
+  mapping[2] = common;
+
+  for (i = 0; i < 3; i++)
+    rev_mapping[mapping[i]] = i;
+
+  for (i = 0; i < 3; i++)
+    if (! STREQ (file[i], "-"))
+      {
+	if (stat (file[i], &statb) < 0)
+	  perror_with_exit (file[i]);
+	else if (S_ISDIR (statb.st_mode))
+	  die (EXIT_TROUBLE, EISDIR, "%s", file[i]);
+      }
+
+#ifdef SIGCHLD
+  /* System V fork+wait does not work if SIGCHLD is ignored.  */
+  signal (SIGCHLD, SIG_DFL);
+#endif
+
+  /* Invoke diff twice on two pairs of input files, combine the two
+     diffs, and output them.  */
+
+  char *b0, *b1;
+  commonname = file[rev_mapping[FILEC]];
+  thread1 = process_diff (file[rev_mapping[FILE1]], commonname, &last_block, &b1);
+  thread0 = process_diff (file[rev_mapping[FILE0]], commonname, &last_block, &b0);
+
+  next_to_n2 (thread0);
+  next_to_n2 (thread1);
+
+  diff3 = make_3way_diff (thread0, thread1);
+
+  free_diff_block (thread0);
+  free_diff_block (thread1);
+
+  if (edscript)
+    conflicts_found
+      = output_diff3_edscript (stdout, diff3, mapping, rev_mapping,
+			       tag_strings[0], tag_strings[1], tag_strings[2]);
+  else if (merge)
+    {
+      xfreopen (file[rev_mapping[FILE0]], "r", stdin);
+      conflicts_found
+	= output_diff3_merge (stdin, stdout, diff3, mapping, rev_mapping,
+			      tag_strings[0], tag_strings[1], tag_strings[2]);
+      if (ferror (stdin))
+	fatal ("read failed");
+    }
+  else
+    {
+      output_diff3 (stdout, diff3, mapping, rev_mapping);
+      conflicts_found = false;
+    }
+
+  free (b0);
+  free (b1);
+  check_stdout ();
+  exit (conflicts_found);
+}
+
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  die (EXIT_TROUBLE, 0,
+	 _("Try '%s --help' for more information."), program_name);
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    perror_with_exit (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-A, --show-all              output all changes, bracketing conflicts"),
+  "",
+  N_("-e, --ed                    output ed script incorporating changes\n"
+     "                                from OLDFILE to YOURFILE into MYFILE"),
+  N_("-E, --show-overlap          like -e, but bracket conflicts"),
+  N_("-3, --easy-only             like -e, but incorporate only nonoverlapping changes"),
+  N_("-x, --overlap-only          like -e, but incorporate only overlapping changes"),
+  N_("-X                          like -x, but bracket conflicts"),
+  N_("-i                          append 'w' and 'q' commands to ed scripts"),
+  "",
+  N_("-m, --merge                 output actual merged file, according to\n"
+     "                                -A if no other options are given"),
+  "",
+  N_("-a, --text                  treat all files as text"),
+  N_("    --strip-trailing-cr     strip trailing carriage return on input"),
+  N_("-T, --initial-tab           make tabs line up by prepending a tab"),
+  N_("    --diff-program=PROGRAM  use PROGRAM to compare files"),
+  N_("-L, --label=LABEL           use LABEL instead of file name\n"
+     "                                (can be repeated up to three times)"),
+  "",
+  N_("    --help                  display this help and exit"),
+  N_("-v, --version               output version information and exit"),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... MYFILE OLDFILE YOURFILE\n"),
+	  program_name);
+  printf ("%s\n\n", _("Compare three files line by line."));
+
+  fputs (_("\
+Mandatory arguments to long options are mandatory for short options too.\n\
+"), stdout);
+  for (p = option_help_msgid;  *p;  p++)
+    if (**p)
+      printf ("  %s\n", _(*p));
+    else
+      putchar ('\n');
+  fputs (_("\n\
+The default output format is a somewhat human-readable representation of\n\
+the changes.\n\
+\n\
+The -e, -E, -x, -X (and corresponding long) options cause an ed script\n\
+to be output instead of the default.\n\
+\n\
+Finally, the -m (--merge) option causes diff3 to do the merge internally\n\
+and output the actual merged file.  For unusual input, this is more\n\
+robust than using ed.\n"), stdout);
+  printf ("\n%s\n%s\n",
+	  _("If a FILE is '-', read standard input."),
+	  _("Exit status is 0 if successful, 1 if conflicts, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+/* Combine the two diffs together into one.
+   Here is the algorithm:
+
+     File2 is shared in common between the two diffs.
+     Diff02 is the diff between 0 and 2.
+     Diff12 is the diff between 1 and 2.
+
+	1) Find the range for the first block in File2.
+	    a) Take the lowest of the two ranges (in File2) in the two
+	       current blocks (one from each diff) as being the low
+	       water mark.  Assign the upper end of this block as
+	       being the high water mark and move the current block up
+	       one.  Mark the block just moved over as to be used.
+	    b) Check the next block in the diff that the high water
+	       mark is *not* from.
+
+	       *If* the high water mark is above
+	       the low end of the range in that block,
+
+		   mark that block as to be used and move the current
+		   block up.  Set the high water mark to the max of
+		   the high end of this block and the current.  Repeat b.
+
+	 2) Find the corresponding ranges in File0 (from the blocks
+	    in diff02; line per line outside of diffs) and in File1.
+	    Create a diff3_block, reserving space as indicated by the ranges.
+
+	 3) Copy all of the pointers for file2 in.  At least for now,
+	    do memcmp's between corresponding strings in the two diffs.
+
+	 4) Copy all of the pointers for file0 and 1 in.  Get what is
+	    needed from file2 (when there isn't a diff block, it's
+	    identical to file2 within the range between diff blocks).
+
+	 5) If the diff blocks used came from only one of the two
+	    strings of diffs, then that file (i.e. the one other than
+	    the common file in that diff) is the odd person out.  If
+	    diff blocks are used from both sets, check to see if files
+	    0 and 1 match:
+
+		Same number of lines?  If so, do a set of memcmp's (if
+	    a memcmp matches; copy the pointer over; it'll be easier
+	    later during comparisons).  If they match, 0 & 1 are the
+	    same.  If not, all three different.
+
+     Then do it again, until the blocks are exhausted.  */
+
+
+/* Make a three way diff (chain of diff3_block's) from two two way
+   diffs (chains of diff_block's).  Assume that each of the two diffs
+   passed are onto the same file (i.e. that each of the diffs were
+   made "to" the same file).  Return a three way diff pointer with
+   numbering FILE0 = the other file in diff02, FILE1 = the other file
+   in diff12, and FILEC = the common file.  */
+
+static struct diff3_block *
+make_3way_diff (struct diff_block *thread0, struct diff_block *thread1)
+{
+  /* Work on the two diffs passed to it as threads.  Thread number 0
+     is diff02, thread number 1 is diff12.  USING is the base of the
+     list of blocks to be used to construct each block of the three
+     way diff; if no blocks from a particular thread are to be used,
+     that element of USING is 0.  LAST_USING contains the last
+     elements on each of the using lists.
+
+     HIGH_WATER_MARK is the highest line number in the common file
+     described in any of the diffs in either of the USING lists.
+     HIGH_WATER_THREAD names the thread.  Similarly BASE_WATER_MARK
+     and BASE_WATER_THREAD describe the lowest line number in the
+     common file described in any of the diffs in either of the USING
+     lists.  HIGH_WATER_DIFF is the diff from which the
+     HIGH_WATER_MARK was taken.
+
+     HIGH_WATER_DIFF should always be equal to
+     LAST_USING[HIGH_WATER_THREAD].  OTHER_DIFF is the next diff to
+     check for higher water, and should always be equal to
+     CURRENT[HIGH_WATER_THREAD ^ 1].  OTHER_THREAD is the thread in
+     which the OTHER_DIFF is, and hence should always be equal to
+     HIGH_WATER_THREAD ^ 1.
+
+     LAST_DIFF is the last diff block produced by this routine, for
+     line correspondence purposes between that diff and the one
+     currently being worked on.  It is ZERO_DIFF before any blocks
+     have been created.  */
+
+  struct diff_block *using[2];
+  struct diff_block *last_using[2];
+  struct diff_block *current[2];
+
+  lin high_water_mark;
+
+  int high_water_thread;
+  int base_water_thread;
+  int other_thread;
+
+  struct diff_block *high_water_diff;
+  struct diff_block *other_diff;
+
+  struct diff3_block *result;
+  struct diff3_block *tmpblock;
+  struct diff3_block **result_end;
+
+  struct diff3_block const *last_diff3;
+
+  static struct diff3_block const zero_diff3;
+
+  /* Initialization */
+  result = 0;
+  result_end = &result;
+  current[0] = thread0; current[1] = thread1;
+  last_diff3 = &zero_diff3;
+
+  /* Sniff up the threads until we reach the end */
+
+  while (current[0] || current[1])
+    {
+      using[0] = using[1] = last_using[0] = last_using[1] = 0;
+
+      /* Setup low and high water threads, diffs, and marks.  */
+      if (!current[0])
+	base_water_thread = 1;
+      else if (!current[1])
+	base_water_thread = 0;
+      else
+	base_water_thread =
+	  (D_LOWLINE (current[0], FC) > D_LOWLINE (current[1], FC));
+
+      high_water_thread = base_water_thread;
+
+      high_water_diff = current[high_water_thread];
+
+      high_water_mark = D_HIGHLINE (high_water_diff, FC);
+
+      /* Make the diff you just got info from into the using class */
+      using[high_water_thread]
+	= last_using[high_water_thread]
+	= high_water_diff;
+      current[high_water_thread] = high_water_diff->next;
+      last_using[high_water_thread]->next = 0;
+
+      /* And mark the other diff */
+      other_thread = high_water_thread ^ 0x1;
+      other_diff = current[other_thread];
+
+      /* Shuffle up the ladder, checking the other diff to see if it
+	 needs to be incorporated.  */
+      while (other_diff
+	     && D_LOWLINE (other_diff, FC) <= high_water_mark + 1)
+	{
+
+	  /* Incorporate this diff into the using list.  Note that
+	     this doesn't take it off the current list */
+	  if (using[other_thread])
+	    last_using[other_thread]->next = other_diff;
+	  else
+	    using[other_thread] = other_diff;
+	  last_using[other_thread] = other_diff;
+
+	  /* Take it off the current list.  Note that this following
+	     code assumes that other_diff enters it equal to
+	     current[high_water_thread ^ 0x1] */
+	  current[other_thread] = current[other_thread]->next;
+	  other_diff->next = 0;
+
+	  /* Set the high_water stuff
+	     If this comparison is equal, then this is the last pass
+	     through this loop; since diff blocks within a given
+	     thread cannot overlap, the high_water_mark will be
+	     *below* the range_start of either of the next diffs.  */
+
+	  if (high_water_mark < D_HIGHLINE (other_diff, FC))
+	    {
+	      high_water_thread ^= 1;
+	      high_water_mark = D_HIGHLINE (other_diff, FC);
+	    }
+
+	  /* Set the other diff */
+	  other_thread = high_water_thread ^ 0x1;
+	  other_diff = current[other_thread];
+	}
+
+      /* The using lists contain a list of all of the blocks to be
+	 included in this diff3_block.  Create it.  */
+
+      tmpblock = using_to_diff3_block (using, last_using,
+				       base_water_thread, high_water_thread,
+				       last_diff3);
+
+      if (!tmpblock)
+	fatal ("internal error: screwup in format of diff blocks");
+
+      /* Put it on the list.  */
+      *result_end = tmpblock;
+      result_end = &tmpblock->next;
+
+      /* Set up corresponding lines correctly.  */
+      last_diff3 = tmpblock;
+    }
+  return result;
+}
+
+/* Take two lists of blocks (from two separate diff threads) and put
+   them together into one diff3 block.  Return a pointer to this diff3
+   block or 0 for failure.
+
+   All arguments besides using are for the convenience of the routine;
+   they could be derived from the using array.  LAST_USING is a pair
+   of pointers to the last blocks in the using structure.  LOW_THREAD
+   and HIGH_THREAD tell which threads contain the lowest and highest
+   line numbers for File0.  LAST_DIFF3 contains the last diff produced
+   in the calling routine.  This is used for lines mappings that
+   would still be identical to the state that diff ended in.
+
+   A distinction should be made in this routine between the two diffs
+   that are part of a normal two diff block, and the three diffs that
+   are part of a diff3_block.  */
+
+static struct diff3_block *
+using_to_diff3_block (struct diff_block *using[2],
+		      struct diff_block *last_using[2],
+		      int low_thread, int high_thread,
+		      struct diff3_block const *last_diff3)
+{
+  lin low[2], high[2];
+  struct diff3_block *result;
+  struct diff_block *ptr;
+  int d;
+  lin i;
+
+  /* Find the range in the common file.  */
+  lin lowc = D_LOWLINE (using[low_thread], FC);
+  lin highc = D_HIGHLINE (last_using[high_thread], FC);
+
+  /* Find the ranges in the other files.
+     If using[d] is null, that means that the file to which that diff
+     refers is equivalent to the common file over this range.  */
+
+  for (d = 0; d < 2; d++)
+    if (using[d])
+      {
+	low[d] = D_LOW_MAPLINE (using[d], FC, FO, lowc);
+	high[d] = D_HIGH_MAPLINE (last_using[d], FC, FO, highc);
+      }
+    else
+      {
+	low[d] = D_HIGH_MAPLINE (last_diff3, FILEC, FILE0 + d, lowc);
+	high[d] = D_HIGH_MAPLINE (last_diff3, FILEC, FILE0 + d, highc);
+      }
+
+  /* Create a block with the appropriate sizes */
+  result = create_diff3_block (low[0], high[0], low[1], high[1], lowc, highc);
+
+  /* Copy information for the common file.
+     Return with a zero if any of the compares failed.  */
+
+  for (d = 0; d < 2; d++)
+    for (ptr = using[d]; ptr; ptr = D_NEXT (ptr))
+      {
+	lin result_offset = D_LOWLINE (ptr, FC) - lowc;
+
+	if (!copy_stringlist (D_LINEARRAY (ptr, FC),
+			      D_LENARRAY (ptr, FC),
+			      D_LINEARRAY (result, FILEC) + result_offset,
+			      D_LENARRAY (result, FILEC) + result_offset,
+			      D_NUMLINES (ptr, FC)))
+	  return 0;
+      }
+
+  /* Copy information for file d.  First deal with anything that might be
+     before the first diff.  */
+
+  for (d = 0; d < 2; d++)
+    {
+      struct diff_block *u = using[d];
+      lin lo = low[d], hi = high[d];
+
+      for (i = 0;
+	   i + lo < (u ? D_LOWLINE (u, FO) : hi + 1);
+	   i++)
+	{
+	  D_RELNUM (result, FILE0 + d, i) = D_RELNUM (result, FILEC, i);
+	  D_RELLEN (result, FILE0 + d, i) = D_RELLEN (result, FILEC, i);
+	}
+
+      for (ptr = u; ptr; ptr = D_NEXT (ptr))
+	{
+	  lin result_offset = D_LOWLINE (ptr, FO) - lo;
+	  lin linec;
+
+	  if (!copy_stringlist (D_LINEARRAY (ptr, FO),
+				D_LENARRAY (ptr, FO),
+				D_LINEARRAY (result, FILE0 + d) + result_offset,
+				D_LENARRAY (result, FILE0 + d) + result_offset,
+				D_NUMLINES (ptr, FO)))
+	    return 0;
+
+	  /* Catch the lines between here and the next diff */
+	  linec = D_HIGHLINE (ptr, FC) + 1 - lowc;
+	  for (i = D_HIGHLINE (ptr, FO) + 1 - lo;
+	       i < (D_NEXT (ptr) ? D_LOWLINE (D_NEXT (ptr), FO) : hi + 1) - lo;
+	       i++)
+	    {
+	      D_RELNUM (result, FILE0 + d, i) = D_RELNUM (result, FILEC, linec);
+	      D_RELLEN (result, FILE0 + d, i) = D_RELLEN (result, FILEC, linec);
+	      linec++;
+	    }
+	}
+    }
+
+  /* Set correspond */
+  if (!using[0])
+    D3_TYPE (result) = DIFF_2ND;
+  else if (!using[1])
+    D3_TYPE (result) = DIFF_1ST;
+  else
+    {
+      lin nl0 = D_NUMLINES (result, FILE0);
+      lin nl1 = D_NUMLINES (result, FILE1);
+
+      if (nl0 != nl1
+	  || !compare_line_list (D_LINEARRAY (result, FILE0),
+				 D_LENARRAY (result, FILE0),
+				 D_LINEARRAY (result, FILE1),
+				 D_LENARRAY (result, FILE1),
+				 nl0))
+	D3_TYPE (result) = DIFF_ALL;
+      else
+	D3_TYPE (result) = DIFF_3RD;
+    }
+
+  return result;
+}
+
+/* Copy pointers from a list of strings to a different list of
+   strings.  If a spot in the second list is already filled, make sure
+   that it is filled with the same string; if not, return false, the copy
+   incomplete.  Upon successful completion of the copy, return true.  */
+
+static bool
+copy_stringlist (char * const fromptrs[], size_t const fromlengths[],
+		 char *toptrs[], size_t tolengths[],
+		 lin copynum)
+{
+  register char * const *f = fromptrs;
+  register char **t = toptrs;
+  register size_t const *fl = fromlengths;
+  register size_t *tl = tolengths;
+
+  while (copynum--)
+    {
+      if (*t)
+	{
+	  if (*fl != *tl || memcmp (*f, *t, *fl) != 0)
+	    return false;
+	}
+      else
+	{
+	  *t = *f;
+	  *tl = *fl;
+	}
+
+      t++; f++; tl++; fl++;
+    }
+
+  return true;
+}
+
+/* Create a diff3_block, with ranges as specified in the arguments.
+   Allocate the arrays for the various pointers (and zero them) based
+   on the arguments passed.  Return the block as a result.  */
+
+static struct diff3_block *
+create_diff3_block (lin low0, lin high0,
+		    lin low1, lin high1,
+		    lin low2, lin high2)
+{
+  struct diff3_block *result = xmalloc (sizeof *result);
+  lin numlines;
+
+  D3_TYPE (result) = ERROR;
+  D_NEXT (result) = 0;
+
+  /* Assign ranges */
+  D_LOWLINE (result, FILE0) = low0;
+  D_HIGHLINE (result, FILE0) = high0;
+  D_LOWLINE (result, FILE1) = low1;
+  D_HIGHLINE (result, FILE1) = high1;
+  D_LOWLINE (result, FILE2) = low2;
+  D_HIGHLINE (result, FILE2) = high2;
+
+  /* Allocate and zero space */
+  numlines = D_NUMLINES (result, FILE0);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE0) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE0) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE0) = 0;
+      D_LENARRAY (result, FILE0) = 0;
+    }
+
+  numlines = D_NUMLINES (result, FILE1);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE1) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE1) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE1) = 0;
+      D_LENARRAY (result, FILE1) = 0;
+    }
+
+  numlines = D_NUMLINES (result, FILE2);
+  if (numlines)
+    {
+      D_LINEARRAY (result, FILE2) = xcalloc (numlines, sizeof (char *));
+      D_LENARRAY (result, FILE2) = xcalloc (numlines, sizeof (size_t));
+    }
+  else
+    {
+      D_LINEARRAY (result, FILE2) = 0;
+      D_LENARRAY (result, FILE2) = 0;
+    }
+
+  /* Return */
+  return result;
+}
+
+/* Compare two lists of lines of text.
+   Return 1 if they are equivalent, 0 if not.  */
+
+static bool
+compare_line_list (char * const list1[], size_t const lengths1[],
+		   char * const list2[], size_t const lengths2[],
+		   lin nl)
+{
+  char * const *l1 = list1;
+  char * const *l2 = list2;
+  size_t const *lgths1 = lengths1;
+  size_t const *lgths2 = lengths2;
+
+  while (nl--)
+    if (!*l1 || !*l2 || *lgths1 != *lgths2++
+	|| memcmp (*l1++, *l2++, *lgths1++) != 0)
+      return false;
+  return true;
+}
+
+/* Input and parse two way diffs.  */
+
+static struct diff_block *
+process_diff (char const *filea,
+	      char const *fileb,
+	      struct diff_block **last_block,
+	      char **buf_to_free)
+{
+  char *diff_contents;
+  char *diff_limit;
+  char *scan_diff;
+  enum diff_type dt;
+  lin i;
+  struct diff_block *block_list;
+  struct diff_block **block_list_end = &block_list;
+  struct diff_block *bptr IF_LINT (= NULL);
+  size_t too_many_lines = (PTRDIFF_MAX
+			   / MIN (sizeof *bptr->lines[1],
+				  sizeof *bptr->lengths[1]));
+
+  diff_limit = read_diff (filea, fileb, &diff_contents);
+  *buf_to_free = diff_contents;
+  scan_diff = diff_contents;
+
+  while (scan_diff < diff_limit)
+    {
+      bptr = xmalloc (sizeof *bptr);
+      bptr->lines[0] = bptr->lines[1] = 0;
+      bptr->lengths[0] = bptr->lengths[1] = 0;
+
+      dt = process_diff_control (&scan_diff, bptr);
+      if (dt == ERROR || *scan_diff != '\n')
+	{
+	  fprintf (stderr, _("%s: diff failed: "), program_name);
+	  do
+	    {
+	      putc (*scan_diff, stderr);
+	    }
+	  while (*scan_diff++ != '\n');
+	  exit (EXIT_TROUBLE);
+	}
+      scan_diff++;
+
+      /* Force appropriate ranges to be null, if necessary */
+      switch (dt)
+	{
+	case ADD:
+	  bptr->ranges[0][0]++;
+	  break;
+	case DELETE:
+	  bptr->ranges[1][0]++;
+	  break;
+	case CHANGE:
+	  break;
+	default:
+	  fatal ("internal error: invalid diff type in process_diff");
+	  break;
+	}
+
+      /* Allocate space for the pointers for the lines from filea, and
+	 parcel them out among these pointers */
+      if (dt != ADD)
+	{
+	  lin numlines = D_NUMLINES (bptr, 0);
+	  if (too_many_lines <= numlines)
+	    xalloc_die ();
+	  bptr->lines[0] = xmalloc (numlines * sizeof *bptr->lines[0]);
+	  bptr->lengths[0] = xmalloc (numlines * sizeof *bptr->lengths[0]);
+	  for (i = 0; i < numlines; i++)
+	    scan_diff = scan_diff_line (scan_diff,
+					&(bptr->lines[0][i]),
+					&(bptr->lengths[0][i]),
+					diff_limit,
+					'<');
+	}
+
+      /* Get past the separator for changes */
+      if (dt == CHANGE)
+	{
+	  if (strncmp (scan_diff, "---\n", 4))
+	    fatal ("invalid diff format; invalid change separator");
+	  scan_diff += 4;
+	}
+
+      /* Allocate space for the pointers for the lines from fileb, and
+	 parcel them out among these pointers */
+      if (dt != DELETE)
+	{
+	  lin numlines = D_NUMLINES (bptr, 1);
+	  if (too_many_lines <= numlines)
+	    xalloc_die ();
+	  bptr->lines[1] = xmalloc (numlines * sizeof *bptr->lines[1]);
+	  bptr->lengths[1] = xmalloc (numlines * sizeof *bptr->lengths[1]);
+	  for (i = 0; i < numlines; i++)
+	    scan_diff = scan_diff_line (scan_diff,
+					&(bptr->lines[1][i]),
+					&(bptr->lengths[1][i]),
+					diff_limit,
+					'>');
+	}
+
+      /* Place this block on the blocklist.  */
+      *block_list_end = bptr;
+      block_list_end = &bptr->next;
+    }
+
+  *block_list_end = NULL;
+  *last_block = bptr;
+  return block_list;
+}
+
+/* Skip tabs and spaces, and return the first character after them.  */
+
+static char * _GL_ATTRIBUTE_PURE
+skipwhite (char *s)
+{
+  while (*s == ' ' || *s == '\t')
+    s++;
+  return s;
+}
+
+/* Read a nonnegative line number from S, returning the address of the
+   first character after the line number, and storing the number into
+   *PNUM.  Return 0 if S does not point to a valid line number.  */
+
+static char *
+readnum (char *s, lin *pnum)
+{
+  unsigned char c = *s;
+  lin num = 0;
+
+  if (! ISDIGIT (c))
+    return 0;
+
+  do
+    {
+      num = c - '0' + num * 10;
+      c = *++s;
+    }
+  while (ISDIGIT (c));
+
+  *pnum = num;
+  return s;
+}
+
+/* Parse a normal format diff control string.  Return the type of the
+   diff (ERROR if the format is bad).  All of the other important
+   information is filled into to the structure pointed to by db, and
+   the string pointer (whose location is passed to this routine) is
+   updated to point beyond the end of the string parsed.  Note that
+   only the ranges in the diff_block will be set by this routine.
+
+   If some specific pair of numbers has been reduced to a single
+   number, then both corresponding numbers in the diff block are set
+   to that number.  In general these numbers are interpreted as ranges
+   inclusive, unless being used by the ADD or DELETE commands.  It is
+   assumed that these will be special cased in a superior routine.   */
+
+static enum diff_type
+process_diff_control (char **string, struct diff_block *db)
+{
+  char *s = *string;
+  enum diff_type type;
+
+  /* Read first set of digits */
+  s = readnum (skipwhite (s), &db->ranges[0][RANGE_START]);
+  if (! s)
+    return ERROR;
+
+  /* Was that the only digit? */
+  s = skipwhite (s);
+  if (*s == ',')
+    {
+      s = readnum (s + 1, &db->ranges[0][RANGE_END]);
+      if (! s)
+	return ERROR;
+    }
+  else
+    db->ranges[0][RANGE_END] = db->ranges[0][RANGE_START];
+
+  /* Get the letter */
+  s = skipwhite (s);
+  switch (*s)
+    {
+    case 'a':
+      type = ADD;
+      break;
+    case 'c':
+      type = CHANGE;
+      break;
+    case 'd':
+      type = DELETE;
+      break;
+    default:
+      return ERROR;			/* Bad format */
+    }
+  s++;				/* Past letter */
+
+  /* Read second set of digits */
+  s = readnum (skipwhite (s), &db->ranges[1][RANGE_START]);
+  if (! s)
+    return ERROR;
+
+  /* Was that the only digit? */
+  s = skipwhite (s);
+  if (*s == ',')
+    {
+      s = readnum (s + 1, &db->ranges[1][RANGE_END]);
+      if (! s)
+	return ERROR;
+      s = skipwhite (s);		/* To move to end */
+    }
+  else
+    db->ranges[1][RANGE_END] = db->ranges[1][RANGE_START];
+
+  *string = s;
+  return type;
+}
+
+static char *
+read_diff (char const *filea,
+	   char const *fileb,
+	   char **output_placement)
+{
+  char *diff_result;
+  size_t current_chunk_size, total;
+  int fd, wstatus, status;
+  int werrno = 0;
+  struct stat pipestat;
+  char const *argv[9];
+  char const **ap;
+#if HAVE_WORKING_FORK
+  int fds[2];
+  pid_t pid;
+#else
+  FILE *fpipe;
+  char *command;
+#endif
+
+  ap = argv;
+  *ap++ = diff_program;
+  if (text)
+    *ap++ = "-a";
+  if (strip_trailing_cr)
+    *ap++ = "--strip-trailing-cr";
+  *ap++ = "--horizon-lines=100";
+  *ap++ = "--";
+  *ap++ = filea;
+  *ap++ = fileb;
+  *ap = 0;
+
+#if HAVE_WORKING_FORK
+
+  if (pipe (fds) != 0)
+    perror_with_exit ("pipe");
+
+  pid = fork ();
+  if (pid == 0)
+    {
+      /* Child */
+      close (fds[0]);
+      if (fds[1] != STDOUT_FILENO)
+	{
+	  dup2 (fds[1], STDOUT_FILENO);
+	  close (fds[1]);
+	}
+
+      /* The cast to (char **) is needed for portability to older
+	 hosts with a nonstandard prototype for execvp.  */
+      execvp (diff_program, (char **) argv);
+
+      _exit (errno == ENOENT ? 127 : 126);
+    }
+
+  if (pid == -1)
+    perror_with_exit ("fork");
+
+  close (fds[1]);		/* Prevent erroneous lack of EOF */
+  fd = fds[0];
+
+#else
+
+  command = system_quote_argv (SCI_SYSTEM, (char **) argv);
+  errno = 0;
+  fpipe = popen (command, "r");
+  if (!fpipe)
+    perror_with_exit (command);
+  free (command);
+  fd = fileno (fpipe);
+
+#endif
+
+  if (fstat (fd, &pipestat) != 0)
+    perror_with_exit ("fstat");
+  current_chunk_size = MAX (1, STAT_BLOCKSIZE (pipestat));
+  diff_result = xmalloc (current_chunk_size);
+  total = 0;
+
+  for (;;)
+    {
+      size_t bytes_to_read = current_chunk_size - total;
+      size_t bytes = block_read (fd, diff_result + total, bytes_to_read);
+      total += bytes;
+      if (bytes != bytes_to_read)
+	{
+	  if (bytes == SIZE_MAX)
+	    perror_with_exit (_("read failed"));
+	  break;
+	}
+      if (PTRDIFF_MAX / 2 <= current_chunk_size)
+	xalloc_die ();
+      current_chunk_size *= 2;
+      diff_result = xrealloc (diff_result, current_chunk_size);
+    }
+
+  if (total != 0 && diff_result[total-1] != '\n')
+    fatal ("invalid diff format; incomplete last line");
+
+  *output_placement = diff_result;
+
+#if ! HAVE_WORKING_FORK
+
+  wstatus = pclose (fpipe);
+  if (wstatus == -1)
+    werrno = errno;
+
+#else
+
+  if (close (fd) != 0)
+    perror_with_exit ("close");
+  if (waitpid (pid, &wstatus, 0) < 0)
+    perror_with_exit ("waitpid");
+
+#endif
+
+  status = ! werrno && WIFEXITED (wstatus) ? WEXITSTATUS (wstatus) : INT_MAX;
+
+  if (EXIT_TROUBLE <= status)
+    die (EXIT_TROUBLE, werrno,
+	   _(status == 126
+	     ? "subsidiary program '%s' could not be invoked"
+	     : status == 127
+	     ? "subsidiary program '%s' not found"
+	     : status == INT_MAX
+	     ? "subsidiary program '%s' failed"
+	     : "subsidiary program '%s' failed (exit status %d)"),
+	   diff_program, status);
+
+  return diff_result + total;
+}
+
+
+/* Scan a regular diff line (consisting of > or <, followed by a
+   space, followed by text (including nulls) up to a newline.
+
+   This next routine began life as a macro and many parameters in it
+   are used as call-by-reference values.  */
+static char *
+scan_diff_line (char *scan_ptr, char **set_start, size_t *set_length,
+		char *limit, char leadingchar)
+{
+  char *line_ptr;
+
+  if (!(scan_ptr[0] == leadingchar
+	&& scan_ptr[1] == ' '))
+    fatal ("invalid diff format; incorrect leading line chars");
+
+  *set_start = line_ptr = scan_ptr + 2;
+  while (*line_ptr++ != '\n')
+    continue;
+
+  /* Include newline if the original line ended in a newline,
+     or if an edit script is being generated.
+     Copy any missing newline message to stderr if an edit script is being
+     generated, because edit scripts cannot handle missing newlines.
+     Return the beginning of the next line.  */
+  *set_length = line_ptr - *set_start;
+  if (line_ptr < limit && *line_ptr == '\\')
+    {
+      if (edscript)
+	fprintf (stderr, "%s:", program_name);
+      else
+	--*set_length;
+      line_ptr++;
+      do
+	{
+	  if (edscript)
+	    putc (*line_ptr, stderr);
+	}
+      while (*line_ptr++ != '\n');
+    }
+
+  return line_ptr;
+}
+
+/* Output a three way diff passed as a list of diff3_block's.  The
+   argument MAPPING is indexed by external file number (in the
+   argument list) and contains the internal file number (from the diff
+   passed).  This is important because the user expects outputs in
+   terms of the argument list number, and the diff passed may have
+   been done slightly differently (if the last argument was "-", for
+   example).  REV_MAPPING is the inverse of MAPPING.  */
+
+static void
+output_diff3 (FILE *outputfile, struct diff3_block *diff,
+	      int const mapping[3], int const rev_mapping[3])
+{
+  int i;
+  int oddoneout;
+  char *cp;
+  struct diff3_block *ptr;
+  lin line;
+  size_t length;
+  int dontprint;
+  static int skew_increment[3] = { 2, 3, 1 }; /* 0==>2==>1==>3 */
+  char const *line_prefix = initial_tab ? "\t" : "  ";
+
+  for (ptr = diff; ptr; ptr = D_NEXT (ptr))
+    {
+      char x[2];
+
+      switch (ptr->correspond)
+	{
+	case DIFF_ALL:
+	  x[0] = 0;
+	  dontprint = 3;	/* Print them all */
+	  oddoneout = 3;	/* Nobody's odder than anyone else */
+	  break;
+	case DIFF_1ST:
+	case DIFF_2ND:
+	case DIFF_3RD:
+	  oddoneout = rev_mapping[ptr->correspond - DIFF_1ST];
+
+	  x[0] = oddoneout + '1';
+	  x[1] = 0;
+	  dontprint = oddoneout == 0;
+	  break;
+	default:
+	  fatal ("internal error: invalid diff type passed to output");
+	}
+      fprintf (outputfile, "====%s\n", x);
+
+      /* Go 0, 2, 1 if the first and third outputs are equivalent.  */
+      for (i = 0; i < 3;
+	   i = (oddoneout == 1 ? skew_increment[i] : i + 1))
+	{
+	  int realfile = mapping[i];
+	  lin lowt = D_LOWLINE (ptr, realfile);
+	  lin hight = D_HIGHLINE (ptr, realfile);
+	  printint llowt = lowt;
+	  printint lhight = hight;
+
+	  fprintf (outputfile, "%d:", i + 1);
+	  switch (lowt - hight)
+	    {
+	    case 1:
+	      fprintf (outputfile, "%"pI"da\n", llowt - 1);
+	      break;
+	    case 0:
+	      fprintf (outputfile, "%"pI"dc\n", llowt);
+	      break;
+	    default:
+	      fprintf (outputfile, "%"pI"d,%"pI"dc\n", llowt, lhight);
+	      break;
+	    }
+
+	  if (i == dontprint) continue;
+
+	  if (lowt <= hight)
+	    {
+	      line = 0;
+	      do
+		{
+		  fputs (line_prefix, outputfile);
+		  cp = D_RELNUM (ptr, realfile, line);
+		  length = D_RELLEN (ptr, realfile, line);
+		  fwrite (cp, sizeof (char), length, outputfile);
+		}
+	      while (++line < hight - lowt + 1);
+	      if (cp[length - 1] != '\n')
+		fprintf (outputfile, "\n\\ %s\n",
+			 _("No newline at end of file"));
+	    }
+	}
+    }
+}
+
+
+/* Output to OUTPUTFILE the lines of B taken from FILENUM.  Double any
+   initial '.'s; yield nonzero if any initial '.'s were doubled.  */
+
+static bool
+dotlines (FILE *outputfile, struct diff3_block *b, int filenum)
+{
+  lin i;
+  bool leading_dot = false;
+
+  for (i = 0;
+       i < D_NUMLINES (b, filenum);
+       i++)
+    {
+      char *line = D_RELNUM (b, filenum, i);
+      if (line[0] == '.')
+	{
+	  leading_dot = true;
+	  fputc ('.', outputfile);
+	}
+      fwrite (line, sizeof (char),
+	      D_RELLEN (b, filenum, i), outputfile);
+    }
+
+  return leading_dot;
+}
+
+/* Output to OUTPUTFILE a '.' line.  If LEADING_DOT is true, also
+   output a command that removes initial '.'s starting with line START
+   and continuing for NUM lines.  */
+
+static void
+undotlines (FILE *outputfile, bool leading_dot, printint start, printint num)
+{
+  fputs (".\n", outputfile);
+  if (leading_dot)
+    {
+      if (num == 1)
+	fprintf (outputfile, "%"pI"ds/^\\.//\n", start);
+      else
+	fprintf (outputfile, "%"pI"d,%"pI"ds/^\\.//\n", start, start + num - 1);
+    }
+}
+
+/* Output a diff3 set of blocks as an ed script.  This script applies
+   the changes between file's 2 & 3 to file 1.  Take the precise
+   format of the ed script to be output from global variables set
+   during options processing.  Reverse the order of
+   the set of diff3 blocks in DIFF; this gets
+   around the problems involved with changing line numbers in an ed
+   script.
+
+   As in 'output_diff3', the variable MAPPING maps from file number
+   according to the argument list to file number according to the diff
+   passed.  All files listed below are in terms of the argument list.
+   REV_MAPPING is the inverse of MAPPING.
+
+   FILE0, FILE1 and FILE2 are the strings to print as the names of the
+   three files.  These may be the actual names, or may be the
+   arguments specified with -L.
+
+   Return 1 if conflicts were found.  */
+
+static bool
+output_diff3_edscript (FILE *outputfile, struct diff3_block *diff,
+		       int const mapping[3], int const rev_mapping[3],
+		       char const *file0, char const *file1, char const *file2)
+{
+  bool leading_dot;
+  bool conflicts_found = false;
+  bool conflict;
+  struct diff3_block *b;
+
+  for (b = reverse_diff3_blocklist (diff); b; b = b->next)
+    {
+      /* Must do mapping correctly.  */
+      enum diff_type type
+	= (b->correspond == DIFF_ALL
+	   ? DIFF_ALL
+	   : DIFF_1ST + rev_mapping[b->correspond - DIFF_1ST]);
+
+      printint low0, high0;
+
+      /* If we aren't supposed to do this output block, skip it.  */
+      switch (type)
+	{
+	default: continue;
+	case DIFF_2ND: if (!show_2nd) continue; conflict = true; break;
+	case DIFF_3RD: if (overlap_only) continue; conflict = false; break;
+	case DIFF_ALL: if (simple_only) continue; conflict = flagging; break;
+	}
+
+      low0 = D_LOWLINE (b, mapping[FILE0]);
+      high0 = D_HIGHLINE (b, mapping[FILE0]);
+
+      if (conflict)
+	{
+	  conflicts_found = true;
+
+
+	  /* Mark end of conflict.  */
+
+	  fprintf (outputfile, "%"pI"da\n", high0);
+	  leading_dot = false;
+	  if (type == DIFF_ALL)
+	    {
+	      if (show_2nd)
+		{
+		  /* Append lines from FILE1.  */
+		  fprintf (outputfile, "||||||| %s\n", file1);
+		  leading_dot = dotlines (outputfile, b, mapping[FILE1]);
+		}
+	      /* Append lines from FILE2.  */
+	      fputs ("=======\n", outputfile);
+	      leading_dot |= dotlines (outputfile, b, mapping[FILE2]);
+	    }
+	  fprintf (outputfile, ">>>>>>> %s\n", file2);
+	  undotlines (outputfile, leading_dot, high0 + 2,
+		      (D_NUMLINES (b, mapping[FILE1])
+		       + D_NUMLINES (b, mapping[FILE2]) + 1));
+
+
+	  /* Mark start of conflict.  */
+
+	  fprintf (outputfile, "%"pI"da\n<<<<<<< %s\n", low0 - 1,
+		   type == DIFF_ALL ? file0 : file1);
+	  leading_dot = false;
+	  if (type == DIFF_2ND)
+	    {
+	      /* Prepend lines from FILE1.  */
+	      leading_dot = dotlines (outputfile, b, mapping[FILE1]);
+	      fputs ("=======\n", outputfile);
+	    }
+	  undotlines (outputfile, leading_dot, low0 + 1,
+		      D_NUMLINES (b, mapping[FILE1]));
+	}
+      else if (D_NUMLINES (b, mapping[FILE2]) == 0)
+	/* Write out a delete */
+	{
+	  if (low0 == high0)
+	    fprintf (outputfile, "%"pI"dd\n", low0);
+	  else
+	    fprintf (outputfile, "%"pI"d,%"pI"dd\n", low0, high0);
+	}
+      else
+	/* Write out an add or change */
+	{
+	  switch (high0 - low0)
+	    {
+	    case -1:
+	      fprintf (outputfile, "%"pI"da\n", high0);
+	      break;
+	    case 0:
+	      fprintf (outputfile, "%"pI"dc\n", high0);
+	      break;
+	    default:
+	      fprintf (outputfile, "%"pI"d,%"pI"dc\n", low0, high0);
+	      break;
+	    }
+
+	  undotlines (outputfile, dotlines (outputfile, b, mapping[FILE2]),
+		      low0, D_NUMLINES (b, mapping[FILE2]));
+	}
+    }
+  if (finalwrite)
+    fputs ("w\nq\n", outputfile);
+  return conflicts_found;
+}
+
+/* Read from INFILE and output to OUTPUTFILE a set of diff3_blocks
+   DIFF as a merged file.  This acts like 'ed file0
+   <[output_diff3_edscript]', except that it works even for binary
+   data or incomplete lines.
+
+   As before, MAPPING maps from arg list file number to diff file
+   number, REV_MAPPING is its inverse, and FILE0, FILE1, and FILE2 are
+   the names of the files.
+
+   Return 1 if conflicts were found.  */
+
+static bool
+output_diff3_merge (FILE *infile, FILE *outputfile, struct diff3_block *diff,
+		    int const mapping[3], int const rev_mapping[3],
+		    char const *file0, char const *file1, char const *file2)
+{
+  int c;
+  lin i;
+  bool conflicts_found = false;
+  bool conflict;
+  struct diff3_block *b;
+  lin linesread = 0;
+
+  for (b = diff; b; b = b->next)
+    {
+      /* Must do mapping correctly.  */
+      enum diff_type type
+	= ((b->correspond == DIFF_ALL)
+	   ? DIFF_ALL
+	   : DIFF_1ST + rev_mapping[b->correspond - DIFF_1ST]);
+      char const *format_2nd = "<<<<<<< %s\n";
+
+      /* If we aren't supposed to do this output block, skip it.  */
+      switch (type)
+	{
+	default: continue;
+	case DIFF_2ND: if (!show_2nd) continue; conflict = true; break;
+	case DIFF_3RD: if (overlap_only) continue; conflict = false; break;
+	case DIFF_ALL: if (simple_only) continue; conflict = flagging;
+	  format_2nd = "||||||| %s\n";
+	  break;
+	}
+
+      /* Copy I lines from file 0.  */
+      i = D_LOWLINE (b, FILE0) - linesread - 1;
+      linesread += i;
+      while (0 <= --i)
+	do
+	  {
+	    c = getc (infile);
+	    if (c == EOF)
+	      {
+		if (ferror (infile))
+		  perror_with_exit (_("read failed"));
+		else if (feof (infile))
+		  fatal ("input file shrank");
+	      }
+	    putc (c, outputfile);
+	  }
+	while (c != '\n');
+
+      if (conflict)
+	{
+	  conflicts_found = true;
+
+	  if (type == DIFF_ALL)
+	    {
+	      /* Put in lines from FILE0 with bracket.  */
+	      fprintf (outputfile, "<<<<<<< %s\n", file0);
+	      for (i = 0;
+		   i < D_NUMLINES (b, mapping[FILE0]);
+		   i++)
+		fwrite (D_RELNUM (b, mapping[FILE0], i), sizeof (char),
+			D_RELLEN (b, mapping[FILE0], i), outputfile);
+	    }
+
+	  if (show_2nd)
+	    {
+	      /* Put in lines from FILE1 with bracket.  */
+	      fprintf (outputfile, format_2nd, file1);
+	      for (i = 0;
+		   i < D_NUMLINES (b, mapping[FILE1]);
+		   i++)
+		fwrite (D_RELNUM (b, mapping[FILE1], i), sizeof (char),
+			D_RELLEN (b, mapping[FILE1], i), outputfile);
+	    }
+
+	  fputs ("=======\n", outputfile);
+	}
+
+      /* Put in lines from FILE2.  */
+      for (i = 0;
+	   i < D_NUMLINES (b, mapping[FILE2]);
+	   i++)
+	fwrite (D_RELNUM (b, mapping[FILE2], i), sizeof (char),
+		D_RELLEN (b, mapping[FILE2], i), outputfile);
+
+      if (conflict)
+	fprintf (outputfile, ">>>>>>> %s\n", file2);
+
+      /* Skip I lines in file 0.  */
+      i = D_NUMLINES (b, FILE0);
+      linesread += i;
+      while (0 <= --i)
+	while ((c = getc (infile)) != '\n')
+	  if (c == EOF)
+	    {
+	      if (ferror (infile))
+		perror_with_exit (_("read failed"));
+	      else if (feof (infile))
+		{
+		  if (i || b->next)
+		    fatal ("input file shrank");
+		  return conflicts_found;
+		}
+	    }
+    }
+  /* Copy rest of common file.  */
+  while ((c = getc (infile)) != EOF || !(ferror (infile) | feof (infile)))
+    putc (c, outputfile);
+  return conflicts_found;
+}
+
+/* Reverse the order of the list of diff3 blocks.  */
+
+static struct diff3_block *
+reverse_diff3_blocklist (struct diff3_block *diff)
+{
+  register struct diff3_block *tmp, *next, *prev;
+
+  for (tmp = diff, prev = 0;  tmp;  tmp = next)
+    {
+      next = tmp->next;
+      tmp->next = prev;
+      prev = tmp;
+    }
+
+  return prev;
+}
+
+static void
+fatal (char const *msgid)
+{
+  die (EXIT_TROUBLE, 0, "%s", _(msgid));
+}
+
+static void
+perror_with_exit (char const *string)
+{
+  die (EXIT_TROUBLE, errno, "%s", string);
+}
diff --git a/test/diffutils-3.0/dir.c b/test/diffutils-3.0/dir.c
new file mode 100644
index 0000000..52c320a
--- /dev/null
+++ b/test/diffutils-3.0/dir.c
@@ -0,0 +1,385 @@
+/* Read, sort and compare two directories.  Used for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006-2007,
+   2009-2013, 2015-2017 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <error.h>
+#include <exclude.h>
+#include <filenamecat.h>
+#include <setjmp.h>
+#include <xalloc.h>
+
+/* Read the directory named by DIR and store into DIRDATA a sorted vector
+   of filenames for its contents.  DIR->desc == -1 means this directory is
+   known to be nonexistent, so set DIRDATA to an empty vector.
+   Return -1 (setting errno) if error, 0 otherwise.  */
+
+struct dirdata
+{
+  size_t nnames;	/* Number of names.  */
+  char const **names;	/* Sorted names of files in dir, followed by 0.  */
+  char *data;	/* Allocated storage for file names.  */
+};
+
+/* Whether file names in directories should be compared with
+   locale-specific sorting.  */
+static bool locale_specific_sorting;
+
+/* Where to go if locale-specific sorting fails.  */
+static jmp_buf failed_locale_specific_sorting;
+
+static bool dir_loop (struct comparison const *, int);
+
+
+/* Read a directory and get its vector of names.  */
+
+static bool
+dir_read (struct file_data const *dir, struct dirdata *dirdata)
+{
+  register struct dirent *next;
+  register size_t i;
+
+  /* Address of block containing the files that are described.  */
+  char const **names;
+
+  /* Number of files in directory.  */
+  size_t nnames;
+
+  /* Allocated and used storage for file name data.  */
+  char *data;
+  size_t data_alloc, data_used;
+
+  dirdata->names = 0;
+  dirdata->data = 0;
+  nnames = 0;
+  data = 0;
+
+  if (dir->desc != -1)
+    {
+      /* Open the directory and check for errors.  */
+      register DIR *reading = opendir (dir->name);
+      if (!reading)
+	return false;
+
+      /* Initialize the table of filenames.  */
+
+      data_alloc = 512;
+      data_used = 0;
+      dirdata->data = data = xmalloc (data_alloc);
+
+      /* Read the directory entries, and insert the subfiles
+	 into the 'data' table.  */
+
+      while ((errno = 0, (next = readdir (reading)) != 0))
+	{
+	  char *d_name = next->d_name;
+	  size_t d_size = _D_EXACT_NAMLEN (next) + 1;
+
+	  /* Ignore "." and "..".  */
+	  if (d_name[0] == '.'
+	      && (d_name[1] == 0 || (d_name[1] == '.' && d_name[2] == 0)))
+	    continue;
+
+	  if (excluded_file_name (excluded, d_name))
+	    continue;
+
+	  while (data_alloc < data_used + d_size)
+	    {
+	      if (PTRDIFF_MAX / 2 <= data_alloc)
+		xalloc_die ();
+	      dirdata->data = data = xrealloc (data, data_alloc *= 2);
+	    }
+
+	  memcpy (data + data_used, d_name, d_size);
+	  data_used += d_size;
+	  nnames++;
+	}
+      if (errno)
+	{
+	  int e = errno;
+	  closedir (reading);
+	  errno = e;
+	  return false;
+	}
+#if CLOSEDIR_VOID
+      closedir (reading);
+#else
+      if (closedir (reading) != 0)
+	return false;
+#endif
+    }
+
+  /* Create the 'names' table from the 'data' table.  */
+  if (PTRDIFF_MAX / sizeof *names - 1 <= nnames)
+    xalloc_die ();
+  dirdata->names = names = xmalloc ((nnames + 1) * sizeof *names);
+  dirdata->nnames = nnames;
+  for (i = 0;  i < nnames;  i++)
+    {
+      names[i] = data;
+      data += strlen (data) + 1;
+    }
+  names[nnames] = 0;
+  return true;
+}
+
+/* Compare strings in a locale-specific way, returning a value
+   compatible with strcmp.  */
+
+static int
+compare_collated (char const *name1, char const *name2)
+{
+  int r;
+  errno = 0;
+  if (ignore_file_name_case)
+    r = strcasecoll (name1, name2);
+  else
+    r = strcoll (name1, name2);
+  if (errno)
+    {
+      error (0, errno, _("cannot compare file names '%s' and '%s'"),
+	     name1, name2);
+      longjmp (failed_locale_specific_sorting, 1);
+    }
+  return r;
+}
+
+/* Compare file names, returning a value compatible with strcmp.  */
+
+static int
+compare_names (char const *name1, char const *name2)
+{
+  if (locale_specific_sorting)
+    {
+      int diff = compare_collated (name1, name2);
+      if (diff || ignore_file_name_case)
+	return diff;
+    }
+  return file_name_cmp (name1, name2);
+}
+
+/* Compare names FILE1 and FILE2 when sorting a directory.
+   Prefer filtered comparison, breaking ties with file_name_cmp.  */
+
+static int
+compare_names_for_qsort (void const *file1, void const *file2)
+{
+  char const *const *f1 = file1;
+  char const *const *f2 = file2;
+  char const *name1 = *f1;
+  char const *name2 = *f2;
+  if (locale_specific_sorting)
+    {
+      int diff = compare_collated (name1, name2);
+      if (diff)
+	return diff;
+    }
+  return file_name_cmp (name1, name2);
+}
+
+/* Compare the contents of two directories named in CMP.
+   This is a top-level routine; it does everything necessary for diff
+   on two directories.
+
+   CMP->file[0].desc == -1 says directory CMP->file[0] doesn't exist,
+   but pretend it is empty.  Likewise for CMP->file[1].
+
+   HANDLE_FILE is a caller-provided subroutine called to handle each file.
+   It gets three operands: CMP, name of file in dir 0, name of file in dir 1.
+   These names are relative to the original working directory.
+
+   For a file that appears in only one of the dirs, one of the name-args
+   to HANDLE_FILE is zero.
+
+   Returns the maximum of all the values returned by HANDLE_FILE,
+   or EXIT_TROUBLE if trouble is encountered in opening files.  */
+
+int
+diff_dirs (struct comparison const *cmp,
+	   int (*handle_file) (struct comparison const *,
+			       char const *, char const *))
+{
+  struct dirdata dirdata[2];
+  int volatile val = EXIT_SUCCESS;
+  int i;
+
+  if ((cmp->file[0].desc == -1 || dir_loop (cmp, 0))
+      && (cmp->file[1].desc == -1 || dir_loop (cmp, 1)))
+    {
+      error (0, 0, _("%s: recursive directory loop"),
+	     cmp->file[cmp->file[0].desc == -1].name);
+      return EXIT_TROUBLE;
+    }
+
+  /* Get contents of both dirs.  */
+  for (i = 0; i < 2; i++)
+    if (! dir_read (&cmp->file[i], &dirdata[i]))
+      {
+	perror_with_name (cmp->file[i].name);
+	val = EXIT_TROUBLE;
+      }
+
+  if (val == EXIT_SUCCESS)
+    {
+      char const **volatile names[2];
+      names[0] = dirdata[0].names;
+      names[1] = dirdata[1].names;
+
+      /* Use locale-specific sorting if possible, else native byte order.  */
+      locale_specific_sorting = true;
+      if (setjmp (failed_locale_specific_sorting))
+	locale_specific_sorting = false;
+
+      /* Sort the directories.  */
+      for (i = 0; i < 2; i++)
+	qsort (names[i], dirdata[i].nnames, sizeof *dirdata[i].names,
+	       compare_names_for_qsort);
+
+      /* If '-S name' was given, and this is the topmost level of comparison,
+	 ignore all file names less than the specified starting name.  */
+
+      if (starting_file && ! cmp->parent)
+	{
+	  while (*names[0] && compare_names (*names[0], starting_file) < 0)
+	    names[0]++;
+	  while (*names[1] && compare_names (*names[1], starting_file) < 0)
+	    names[1]++;
+	}
+
+      /* Loop while files remain in one or both dirs.  */
+      while (*names[0] || *names[1])
+	{
+	  /* Compare next name in dir 0 with next name in dir 1.
+	     At the end of a dir,
+	     pretend the "next name" in that dir is very large.  */
+	  int nameorder = (!*names[0] ? 1 : !*names[1] ? -1
+			   : compare_names (*names[0], *names[1]));
+
+	  /* Prefer a file_name_cmp match if available.  This algorithm is
+	     O(N**2), where N is the number of names in a directory
+	     that compare_names says are all equal, but in practice N
+	     is so small it's not worth tuning.  */
+	  if (nameorder == 0 && ignore_file_name_case)
+	    {
+	      int raw_order = file_name_cmp (*names[0], *names[1]);
+	      if (raw_order != 0)
+		{
+		  int greater_side = raw_order < 0;
+		  int lesser_side = 1 - greater_side;
+		  char const **lesser = names[lesser_side];
+		  char const *greater_name = *names[greater_side];
+		  char const **p;
+
+		  for (p = lesser + 1;
+		       *p && compare_names (*p, greater_name) == 0;
+		       p++)
+		    {
+		      int c = file_name_cmp (*p, greater_name);
+		      if (0 <= c)
+			{
+			  if (c == 0)
+			    {
+			      memmove (lesser + 1, lesser,
+				       (char *) p - (char *) lesser);
+			      *lesser = greater_name;
+			    }
+			  break;
+			}
+		    }
+		}
+	    }
+
+	  int v1 = (*handle_file) (cmp,
+				   0 < nameorder ? 0 : *names[0]++,
+				   nameorder < 0 ? 0 : *names[1]++);
+	  if (val < v1)
+	    val = v1;
+	}
+    }
+
+  for (i = 0; i < 2; i++)
+    {
+      free (dirdata[i].names);
+      free (dirdata[i].data);
+    }
+
+  return val;
+}
+
+/* Return nonzero if CMP is looping recursively in argument I.  */
+
+static bool _GL_ATTRIBUTE_PURE
+dir_loop (struct comparison const *cmp, int i)
+{
+  struct comparison const *p = cmp;
+  while ((p = p->parent))
+    if (0 < same_file (&p->file[i].stat, &cmp->file[i].stat))
+      return true;
+  return false;
+}
+
+/* Find a matching filename in a directory.  */
+
+char *
+find_dir_file_pathname (char const *dir, char const *file)
+{
+  /* The 'IF_LINT (volatile)' works around what appears to be a bug in
+     gcc 4.8.0 20120825; see
+     <http://lists.gnu.org/archive/html/bug-diffutils/2012-08/msg00007.html>.
+     */
+  char const * IF_LINT (volatile) match = file;
+
+  char *val;
+  struct dirdata dirdata;
+  dirdata.names = NULL;
+  dirdata.data = NULL;
+
+  if (ignore_file_name_case)
+    {
+      struct file_data filedata;
+      filedata.name = dir;
+      filedata.desc = 0;
+
+      if (dir_read (&filedata, &dirdata))
+	{
+	  locale_specific_sorting = true;
+	  if (setjmp (failed_locale_specific_sorting))
+	    match = file; /* longjmp may mess up MATCH.  */
+	  else
+	    {
+	      for (char const **p = dirdata.names; *p; p++)
+		if (compare_names (*p, file) == 0)
+		  {
+		    if (file_name_cmp (*p, file) == 0)
+		      {
+			match = *p;
+			break;
+		      }
+		    if (match == file)
+		      match = *p;
+		  }
+	    }
+	}
+    }
+
+  val = file_name_concat (dir, match, NULL);
+  free (dirdata.names);
+  free (dirdata.data);
+  return val;
+}
diff --git a/test/diffutils-3.0/ed.c b/test/diffutils-3.0/ed.c
new file mode 100644
index 0000000..68789a4
--- /dev/null
+++ b/test/diffutils-3.0/ed.c
@@ -0,0 +1,177 @@
+/* Output routines for ed-script format.
+
+   Copyright (C) 1988-1989, 1991-1993, 1995, 1998, 2001, 2004, 2006, 2009-2013,
+   2015-2017 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+
+static void print_ed_hunk (struct change *);
+static void print_rcs_hunk (struct change *);
+static void pr_forward_ed_hunk (struct change *);
+
+/* Print our script as ed commands.  */
+
+void
+print_ed_script (struct change *script)
+{
+  print_script (script, find_reverse_change, print_ed_hunk);
+}
+
+/* Print a hunk of an ed diff */
+
+static void
+print_ed_hunk (struct change *hunk)
+{
+  lin f0, l0, f1, l1;
+  enum changes changes;
+
+#ifdef DEBUG
+  debug_script (hunk);
+#endif
+
+  /* Determine range of line numbers involved in each file.  */
+  changes = analyze_hunk (hunk, &f0, &l0, &f1, &l1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  /* Print out the line number header for this hunk */
+  print_number_range (',', &files[0], f0, l0);
+  fputc (change_letter[changes], outfile);
+  fputc ('\n', outfile);
+
+  /* Print new/changed lines from second file, if needed */
+  if (changes != OLD)
+    {
+      lin i;
+      bool insert_mode = true;
+
+      for (i = f1; i <= l1; i++)
+	{
+	  if (!insert_mode)
+	    {
+	      fputs ("a\n", outfile);
+	      insert_mode = true;
+	    }
+	  if (files[1].linbuf[i][0] == '.' && files[1].linbuf[i][1] == '\n')
+	    {
+	      /* The file's line is just a dot, and it would exit
+		 insert mode.  Precede the dot with another dot, exit
+		 insert mode and remove the extra dot.  */
+	      fputs ("..\n.\ns/.//\n", outfile);
+	      insert_mode = false;
+	    }
+	  else
+	    print_1_line ("", &files[1].linbuf[i]);
+	}
+
+      if (insert_mode)
+	fputs (".\n", outfile);
+    }
+}
+
+/* Print change script in the style of ed commands,
+   but print the changes in the order they appear in the input files,
+   which means that the commands are not truly useful with ed.
+   Because of the issue with lines containing just a dot, the output
+   is not even parseable.  */
+
+void
+pr_forward_ed_script (struct change *script)
+{
+  print_script (script, find_change, pr_forward_ed_hunk);
+}
+
+static void
+pr_forward_ed_hunk (struct change *hunk)
+{
+  lin i, f0, l0, f1, l1;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes = analyze_hunk (hunk, &f0, &l0, &f1, &l1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  fputc (change_letter[changes], outfile);
+  print_number_range (' ', files, f0, l0);
+  fputc ('\n', outfile);
+
+  /* If deletion only, print just the number range.  */
+
+  if (changes == OLD)
+    return;
+
+  /* For insertion (with or without deletion), print the number range
+     and the lines from file 2.  */
+
+  for (i = f1; i <= l1; i++)
+    print_1_line ("", &files[1].linbuf[i]);
+
+  fputs (".\n", outfile);
+}
+
+/* Print in a format somewhat like ed commands
+   except that each insert command states the number of lines it inserts.
+   This format is used for RCS.  */
+
+void
+print_rcs_script (struct change *script)
+{
+  print_script (script, find_change, print_rcs_hunk);
+}
+
+/* Print a hunk of an RCS diff */
+
+static void
+print_rcs_hunk (struct change *hunk)
+{
+  lin i, f0, l0, f1, l1;
+  printint tf0, tl0, tf1, tl1;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes = analyze_hunk (hunk, &f0, &l0, &f1, &l1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  translate_range (&files[0], f0, l0, &tf0, &tl0);
+
+  if (changes & OLD)
+    {
+      /* For deletion, print just the starting line number from file 0
+	 and the number of lines deleted.  */
+      fprintf (outfile, "d%"pI"d %"pI"d\n", tf0,
+	       tf0 <= tl0 ? tl0 - tf0 + 1 : 1);
+    }
+
+  if (changes & NEW)
+    {
+      /* Take last-line-number from file 0 and # lines from file 1.  */
+      translate_range (&files[1], f1, l1, &tf1, &tl1);
+      fprintf (outfile, "a%"pI"d %"pI"d\n", tl0,
+	       tf1 <= tl1 ? tl1 - tf1 + 1 : 1);
+
+      /* Print the inserted lines.  */
+      for (i = f1; i <= l1; i++)
+	print_1_line ("", &files[1].linbuf[i]);
+    }
+}
diff --git a/test/diffutils-3.0/ifdef.c b/test/diffutils-3.0/ifdef.c
new file mode 100644
index 0000000..c7dae8d
--- /dev/null
+++ b/test/diffutils-3.0/ifdef.c
@@ -0,0 +1,431 @@
+/* #ifdef-format output routines for GNU DIFF.
+
+   Copyright (C) 1989, 1991-1994, 2001-2002, 2004, 2006, 2009-2013, 2015-2017
+   Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   GNU DIFF is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.  No author or distributor
+   accepts responsibility to anyone for the consequences of using it
+   or for whether it serves any particular purpose or works at all,
+   unless he says so in writing.  Refer to the GNU General Public
+   License for full details.
+
+   Everyone is granted permission to copy, modify and redistribute
+   GNU DIFF, but only under the conditions described in the
+   GNU General Public License.   A copy of this license is
+   supposed to have been given to you along with GNU DIFF so you
+   can know your rights and responsibilities.  It should be in a
+   file named COPYING.  Among other things, the copyright notice
+   and this notice must be preserved on all copies.  */
+
+#include "diff.h"
+
+#include <xalloc.h>
+
+struct group
+{
+  struct file_data const *file;
+  lin from, upto; /* start and limit lines for this group of lines */
+};
+
+static char const *format_group (FILE *, char const *, char,
+				 struct group const *);
+static char const *do_printf_spec (FILE *, char const *,
+				   struct file_data const *, lin,
+				   struct group const *);
+static char const *scan_char_literal (char const *, char *);
+static lin groups_letter_value (struct group const *, char);
+static void format_ifdef (char const *, lin, lin, lin, lin);
+static void print_ifdef_hunk (struct change *);
+static void print_ifdef_lines (FILE *, char const *, struct group const *);
+
+static lin next_line0;
+static lin next_line1;
+
+/* Print the edit-script SCRIPT as a merged #ifdef file.  */
+
+void
+print_ifdef_script (struct change *script)
+{
+  next_line0 = next_line1 = - files[0].prefix_lines;
+  print_script (script, find_change, print_ifdef_hunk);
+  if (next_line0 < files[0].valid_lines
+      || next_line1 < files[1].valid_lines)
+    {
+      begin_output ();
+      format_ifdef (group_format[UNCHANGED],
+		    next_line0, files[0].valid_lines,
+		    next_line1, files[1].valid_lines);
+    }
+}
+
+/* Print a hunk of an ifdef diff.
+   This is a contiguous portion of a complete edit script,
+   describing changes in consecutive lines.  */
+
+static void
+print_ifdef_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes = analyze_hunk (hunk, &first0, &last0, &first1, &last1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  /* Print lines up to this change.  */
+  if (next_line0 < first0 || next_line1 < first1)
+    format_ifdef (group_format[UNCHANGED],
+		  next_line0, first0,
+		  next_line1, first1);
+
+  /* Print this change.  */
+  next_line0 = last0 + 1;
+  next_line1 = last1 + 1;
+  format_ifdef (group_format[changes],
+		first0, next_line0,
+		first1, next_line1);
+}
+
+/* Print a set of lines according to FORMAT.
+   Lines BEG0 up to END0 are from the first file;
+   lines BEG1 up to END1 are from the second file.  */
+
+static void
+format_ifdef (char const *format, lin beg0, lin end0, lin beg1, lin end1)
+{
+  struct group groups[2];
+
+  groups[0].file = &files[0];
+  groups[0].from = beg0;
+  groups[0].upto = end0;
+  groups[1].file = &files[1];
+  groups[1].from = beg1;
+  groups[1].upto = end1;
+  format_group (outfile, format, 0, groups);
+}
+
+/* Print to file OUT a set of lines according to FORMAT.
+   The format ends at the first free instance of ENDCHAR.
+   Yield the address of the terminating character.
+   GROUPS specifies which lines to print.
+   If OUT is zero, do not actually print anything; just scan the format.  */
+
+static char const *
+format_group (register FILE *out, char const *format, char endchar,
+	      struct group const *groups)
+{
+  register char c;
+  register char const *f = format;
+
+  while ((c = *f) != endchar && c != 0)
+    {
+      char const *f1 = ++f;
+      if (c == '%')
+	switch ((c = *f++))
+	  {
+	  case '%':
+	    break;
+
+	  case '(':
+	    /* Print if-then-else format e.g. '%(n=1?thenpart:elsepart)'.  */
+	    {
+	      int i;
+	      uintmax_t value[2];
+	      FILE *thenout, *elseout;
+
+	      for (i = 0; i < 2; i++)
+		{
+		  if (ISDIGIT (*f))
+		    {
+		      char *fend;
+		      errno = 0;
+		      value[i] = strtoumax (f, &fend, 10);
+		      if (errno)
+			goto bad_format;
+		      f = fend;
+		    }
+		  else
+		    {
+		      value[i] = groups_letter_value (groups, *f);
+		      if (value[i] == -1)
+			goto bad_format;
+		      f++;
+		    }
+		  if (*f++ != "=?"[i])
+		    goto bad_format;
+		}
+	      if (value[0] == value[1])
+		thenout = out, elseout = 0;
+	      else
+		thenout = 0, elseout = out;
+	      f = format_group (thenout, f, ':', groups);
+	      if (*f)
+		{
+		  f = format_group (elseout, f + 1, ')', groups);
+		  if (*f)
+		    f++;
+		}
+	    }
+	    continue;
+
+	  case '<':
+	    /* Print lines deleted from first file.  */
+	    print_ifdef_lines (out, line_format[OLD], &groups[0]);
+	    continue;
+
+	  case '=':
+	    /* Print common lines.  */
+	    print_ifdef_lines (out, line_format[UNCHANGED], &groups[0]);
+	    continue;
+
+	  case '>':
+	    /* Print lines inserted from second file.  */
+	    print_ifdef_lines (out, line_format[NEW], &groups[1]);
+	    continue;
+
+	  default:
+	    f = do_printf_spec (out, f - 2, 0, 0, groups);
+	    if (f)
+	      continue;
+	    /* Fall through. */
+	  bad_format:
+	    c = '%';
+	    f = f1;
+	    break;
+	  }
+
+      if (out)
+	putc (c, out);
+    }
+
+  return f;
+}
+
+/* For the line group pair G, return the number corresponding to LETTER.
+   Return -1 if LETTER is not a group format letter.  */
+static lin
+groups_letter_value (struct group const *g, char letter)
+{
+  switch (letter)
+    {
+    case 'E': letter = 'e'; g++; break;
+    case 'F': letter = 'f'; g++; break;
+    case 'L': letter = 'l'; g++; break;
+    case 'M': letter = 'm'; g++; break;
+    case 'N': letter = 'n'; g++; break;
+    }
+
+  switch (letter)
+    {
+      case 'e': return translate_line_number (g->file, g->from) - 1;
+      case 'f': return translate_line_number (g->file, g->from);
+      case 'l': return translate_line_number (g->file, g->upto) - 1;
+      case 'm': return translate_line_number (g->file, g->upto);
+      case 'n': return g->upto - g->from;
+      default: return -1;
+    }
+}
+
+/* Print to file OUT, using FORMAT to print the line group GROUP.
+   But do nothing if OUT is zero.  */
+static void
+print_ifdef_lines (register FILE *out, char const *format,
+		   struct group const *group)
+{
+  struct file_data const *file = group->file;
+  char const * const *linbuf = file->linbuf;
+  lin from = group->from, upto = group->upto;
+
+  if (!out)
+    return;
+
+  /* If possible, use a single fwrite; it's faster.  */
+  if (!expand_tabs && format[0] == '%')
+    {
+      if (format[1] == 'l' && format[2] == '\n' && !format[3] && from < upto)
+	{
+	  fwrite (linbuf[from], sizeof (char),
+		  linbuf[upto] + (linbuf[upto][-1] != '\n') -  linbuf[from],
+		  out);
+	  return;
+	}
+      if (format[1] == 'L' && !format[2])
+	{
+	  fwrite (linbuf[from], sizeof (char),
+		  linbuf[upto] -  linbuf[from], out);
+	  return;
+	}
+    }
+
+  for (;  from < upto;  from++)
+    {
+      register char c;
+      register char const *f = format;
+
+      while ((c = *f++) != 0)
+	{
+	  char const *f1 = f;
+	  if (c == '%')
+	    switch ((c = *f++))
+	      {
+	      case '%':
+		break;
+
+	      case 'l':
+		output_1_line (linbuf[from],
+			       (linbuf[from + 1]
+				- (linbuf[from + 1][-1] == '\n')),
+			       0, 0);
+		continue;
+
+	      case 'L':
+		output_1_line (linbuf[from], linbuf[from + 1], 0, 0);
+		continue;
+
+	      default:
+		f = do_printf_spec (out, f - 2, file, from, 0);
+		if (f)
+		  continue;
+		c = '%';
+		f = f1;
+		break;
+	      }
+
+	  putc (c, out);
+	}
+    }
+}
+
+static char const *
+do_printf_spec (FILE *out, char const *spec,
+		struct file_data const *file, lin n,
+		struct group const *groups)
+{
+  char const *f = spec;
+  char c;
+  char c1;
+
+  /* Scan printf-style SPEC of the form %[-'0]*[0-9]*(.[0-9]*)?[cdoxX].  */
+  /* assert (*f == '%'); */
+  f++;
+  while ((c = *f++) == '-' || c == '\'' || c == '0')
+    continue;
+  while (ISDIGIT (c))
+    c = *f++;
+  if (c == '.')
+    while (ISDIGIT (c = *f++))
+      continue;
+  c1 = *f++;
+
+  switch (c)
+    {
+    case 'c':
+      if (c1 != '\'')
+	return 0;
+      else
+	{
+	  char value IF_LINT (= 0);
+	  f = scan_char_literal (f, &value);
+	  if (!f)
+	    return 0;
+	  if (out)
+	    putc (value, out);
+	}
+      break;
+
+    case 'd': case 'o': case 'x': case 'X':
+      {
+	lin value;
+
+	if (file)
+	  {
+	    if (c1 != 'n')
+	      return 0;
+	    value = translate_line_number (file, n);
+	  }
+	else
+	  {
+	    value = groups_letter_value (groups, c1);
+	    if (value < 0)
+	      return 0;
+	  }
+
+	if (out)
+	  {
+	    /* For example, if the spec is "%3xn" and pI is "l", use the printf
+	       format spec "%3lx".  Here the spec prefix is "%3".  */
+	    printint print_value = value;
+	    size_t spec_prefix_len = f - spec - 2;
+	    size_t pI_len = sizeof pI - 1;
+#if 0
+	    char format[spec_prefix_len + pI_len + 2];
+#else
+	    char *format = xmalloc (spec_prefix_len + pI_len + 2);
+#endif
+	    char *p = format + spec_prefix_len + pI_len;
+	    memcpy (format, spec, spec_prefix_len);
+	    memcpy (format + spec_prefix_len, pI, pI_len);
+	    *p++ = c;
+	    *p = '\0';
+	    fprintf (out, format, print_value);
+#if ! HAVE_C_VARARRAYS
+	    free (format);
+#endif
+	  }
+      }
+      break;
+
+    default:
+      return 0;
+    }
+
+  return f;
+}
+
+/* Scan the character literal represented in the string LIT; LIT points just
+   after the initial apostrophe.  Put the literal's value into *VALPTR.
+   Yield the address of the first character after the closing apostrophe,
+   or a null pointer if the literal is ill-formed.  */
+static char const *
+scan_char_literal (char const *lit, char *valptr)
+{
+  register char const *p = lit;
+  char value;
+  ptrdiff_t digits;
+  char c = *p++;
+
+  switch (c)
+    {
+      case 0:
+      case '\'':
+	return NULL;
+
+      case '\\':
+	value = 0;
+	while ((c = *p++) != '\'')
+	  {
+	    unsigned int digit = c - '0';
+	    if (8 <= digit)
+	      return NULL;
+	    value = 8 * value + digit;
+	  }
+	digits = p - lit - 2;
+	if (! (1 <= digits && digits <= 3))
+	  return NULL;
+	break;
+
+      default:
+	value = c;
+	if (*p++ != '\'')
+	  return NULL;
+	break;
+    }
+
+  *valptr = value;
+  return p;
+}
diff --git a/test/diffutils-3.0/io.c b/test/diffutils-3.0/io.c
new file mode 100644
index 0000000..b4ef5dc
--- /dev/null
+++ b/test/diffutils-3.0/io.c
@@ -0,0 +1,830 @@
+/* File I/O for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2013,
+   2015-2017 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include <binary-io.h>
+#include <cmpbuf.h>
+#include <file-type.h>
+#include <xalloc.h>
+
+/* Rotate an unsigned value to the left.  */
+#define ROL(v, n) ((v) << (n) | (v) >> (sizeof (v) * CHAR_BIT - (n)))
+
+/* Given a hash value and a new character, return a new hash value.  */
+#define HASH(h, c) ((c) + ROL (h, 7))
+
+/* The type of a hash value.  */
+typedef size_t hash_value;
+verify (! TYPE_SIGNED (hash_value));
+
+/* Lines are put into equivalence classes of lines that match in lines_differ.
+   Each equivalence class is represented by one of these structures,
+   but only while the classes are being computed.
+   Afterward, each class is represented by a number.  */
+struct equivclass
+{
+  lin next;		/* Next item in this bucket.  */
+  hash_value hash;	/* Hash of lines in this class.  */
+  char const *line;	/* A line that fits this class.  */
+  size_t length;	/* That line's length, not counting its newline.  */
+};
+
+/* Hash-table: array of buckets, each being a chain of equivalence classes.
+   buckets[-1] is reserved for incomplete lines.  */
+static lin *buckets;
+
+/* Number of buckets in the hash table array, not counting buckets[-1].  */
+static size_t nbuckets;
+
+/* Array in which the equivalence classes are allocated.
+   The bucket-chains go through the elements in this array.
+   The number of an equivalence class is its index in this array.  */
+static struct equivclass *equivs;
+
+/* Index of first free element in the array 'equivs'.  */
+static lin equivs_index;
+
+/* Number of elements allocated in the array 'equivs'.  */
+static lin equivs_alloc;
+
+/* Read a block of data into a file buffer, checking for EOF and error.  */
+
+void
+file_block_read (struct file_data *current, size_t size)
+{
+  if (size && ! current->eof)
+    {
+      size_t s = block_read (current->desc,
+			     FILE_BUFFER (current) + current->buffered, size);
+      if (s == SIZE_MAX)
+	pfatal_with_name (current->name);
+      current->buffered += s;
+      current->eof = s < size;
+    }
+}
+
+/* Check for binary files and compare them for exact identity.  */
+
+/* Return 1 if BUF contains a non text character.
+   SIZE is the number of characters in BUF.  */
+
+#define binary_file_p(buf, size) (memchr (buf, 0, size) != 0)
+
+/* Get ready to read the current file.
+   Return nonzero if SKIP_TEST is zero,
+   and if it appears to be a binary file.  */
+
+static bool
+sip (struct file_data *current, bool skip_test)
+{
+  /* If we have a nonexistent file at this stage, treat it as empty.  */
+  if (current->desc < 0)
+    {
+      /* Leave room for a sentinel.  */
+      current->bufsize = sizeof (word);
+      current->buffer = xmalloc (current->bufsize);
+    }
+  else
+    {
+      current->bufsize = buffer_lcm (sizeof (word),
+				     STAT_BLOCKSIZE (current->stat),
+				     PTRDIFF_MAX - 2 * sizeof (word));
+      current->buffer = xmalloc (current->bufsize);
+
+#ifdef __KLIBC__
+      /* Skip test if seek is not possible */
+      skip_test = skip_test
+		  || (lseek (current->desc, 0, SEEK_CUR) < 0
+		      && errno == ESPIPE);
+#endif
+
+      if (! skip_test)
+	{
+	  /* Check first part of file to see if it's a binary file.  */
+
+	  int prev_mode = set_binary_mode (current->desc, O_BINARY);
+	  off_t buffered;
+	  file_block_read (current, current->bufsize);
+	  buffered = current->buffered;
+
+	  if (prev_mode != O_BINARY)
+	    {
+	      /* Revert to text mode and seek back to the start to reread
+		 the file.  Use relative seek, since file descriptors
+		 like stdin might not start at offset zero.  */
+	      if (lseek (current->desc, - buffered, SEEK_CUR) < 0)
+		pfatal_with_name (current->name);
+	      set_binary_mode (current->desc, prev_mode);
+	      current->buffered = 0;
+	      current->eof = false;
+	    }
+
+	  return binary_file_p (current->buffer, buffered);
+	}
+    }
+
+  current->buffered = 0;
+  current->eof = false;
+  return false;
+}
+
+/* Slurp the rest of the current file completely into memory.  */
+
+static void
+slurp (struct file_data *current)
+{
+  size_t cc;
+
+  if (current->desc < 0)
+    {
+      /* The file is nonexistent.  */
+      return;
+    }
+
+  if (S_ISREG (current->stat.st_mode))
+    {
+      /* It's a regular file; slurp in the rest all at once.  */
+
+      /* Get the size out of the stat block.
+	 Allocate just enough room for appended newline plus word sentinel,
+	 plus word-alignment since we want the buffer word-aligned.  */
+      size_t file_size = current->stat.st_size;
+      cc = file_size + 2 * sizeof (word) - file_size % sizeof (word);
+      if (file_size != current->stat.st_size || cc < file_size
+	  || PTRDIFF_MAX <= cc)
+	xalloc_die ();
+
+      if (current->bufsize < cc)
+	{
+	  current->bufsize = cc;
+	  current->buffer = xrealloc (current->buffer, cc);
+	}
+
+      /* Try to read at least 1 more byte than the size indicates, to
+	 detect whether the file is growing.  This is a nicety for
+	 users who run 'diff' on files while they are changing.  */
+
+      if (current->buffered <= file_size)
+	{
+	  file_block_read (current, file_size + 1 - current->buffered);
+	  if (current->buffered <= file_size)
+	    return;
+	}
+    }
+
+  /* It's not a regular file, or it's a growing regular file; read it,
+     growing the buffer as needed.  */
+
+  file_block_read (current, current->bufsize - current->buffered);
+
+  if (current->buffered)
+    {
+      while (current->buffered == current->bufsize)
+	{
+	  if (PTRDIFF_MAX / 2 - sizeof (word) < current->bufsize)
+	    xalloc_die ();
+	  current->bufsize *= 2;
+	  current->buffer = xrealloc (current->buffer, current->bufsize);
+	  file_block_read (current, current->bufsize - current->buffered);
+	}
+
+      /* Allocate just enough room for appended newline plus word
+	 sentinel, plus word-alignment.  */
+      cc = current->buffered + 2 * sizeof (word);
+      current->bufsize = cc - cc % sizeof (word);
+      current->buffer = xrealloc (current->buffer, current->bufsize);
+    }
+}
+
+/* Split the file into lines, simultaneously computing the equivalence
+   class for each line.  */
+
+static void
+find_and_hash_each_line (struct file_data *current)
+{
+  char const *p = current->prefix_end;
+  lin i, *bucket;
+  size_t length;
+
+  /* Cache often-used quantities in local variables to help the compiler.  */
+  char const **linbuf = current->linbuf;
+  lin alloc_lines = current->alloc_lines;
+  lin line = 0;
+  lin linbuf_base = current->linbuf_base;
+  lin *cureqs = xmalloc (alloc_lines * sizeof *cureqs);
+  struct equivclass *eqs = equivs;
+  lin eqs_index = equivs_index;
+  lin eqs_alloc = equivs_alloc;
+  char const *suffix_begin = current->suffix_begin;
+  char const *bufend = FILE_BUFFER (current) + current->buffered;
+  bool ig_case = ignore_case;
+  enum DIFF_white_space ig_white_space = ignore_white_space;
+  bool diff_length_compare_anyway =
+    ig_white_space != IGNORE_NO_WHITE_SPACE;
+  bool same_length_diff_contents_compare_anyway =
+    diff_length_compare_anyway | ig_case;
+
+  while (p < suffix_begin)
+    {
+      char const *ip = p;
+      hash_value h = 0;
+      unsigned char c;
+
+      /* Hash this line until we find a newline.  */
+      switch (ig_white_space)
+	{
+	case IGNORE_ALL_SPACE:
+	  while ((c = *p++) != '\n')
+	    if (! isspace (c))
+	      h = HASH (h, ig_case ? tolower (c) : c);
+	  break;
+
+	case IGNORE_SPACE_CHANGE:
+	  while ((c = *p++) != '\n')
+	    {
+	      if (isspace (c))
+		{
+		  do
+		    if ((c = *p++) == '\n')
+		      goto hashing_done;
+		  while (isspace (c));
+
+		  h = HASH (h, ' ');
+		}
+
+	      /* C is now the first non-space.  */
+	      h = HASH (h, ig_case ? tolower (c) : c);
+	    }
+	  break;
+
+	case IGNORE_TAB_EXPANSION:
+	case IGNORE_TAB_EXPANSION_AND_TRAILING_SPACE:
+	case IGNORE_TRAILING_SPACE:
+	  {
+	    size_t column = 0;
+	    while ((c = *p++) != '\n')
+	      {
+		if (ig_white_space & IGNORE_TRAILING_SPACE
+		    && isspace (c))
+		  {
+		    char const *p1 = p;
+		    unsigned char c1;
+		    do
+		      if ((c1 = *p1++) == '\n')
+			{
+			  p = p1;
+			  goto hashing_done;
+			}
+		    while (isspace (c1));
+		  }
+
+		size_t repetitions = 1;
+
+		if (ig_white_space & IGNORE_TAB_EXPANSION)
+		  switch (c)
+		    {
+		    case '\b':
+		      column -= 0 < column;
+		      break;
+
+		    case '\t':
+		      c = ' ';
+		      repetitions = tabsize - column % tabsize;
+		      column = (column + repetitions < column
+				? 0
+				: column + repetitions);
+		      break;
+
+		    case '\r':
+		      column = 0;
+		      break;
+
+		    default:
+		      column++;
+		      break;
+		    }
+
+		if (ig_case)
+		  c = tolower (c);
+
+		do
+		  h = HASH (h, c);
+		while (--repetitions != 0);
+	      }
+	  }
+	  break;
+
+	default:
+	  if (ig_case)
+	    while ((c = *p++) != '\n')
+	      h = HASH (h, tolower (c));
+	  else
+	    while ((c = *p++) != '\n')
+	      h = HASH (h, c);
+	  break;
+	}
+
+   hashing_done:;
+
+      bucket = &buckets[h % nbuckets];
+      length = p - ip - 1;
+
+      if (p == bufend
+	  && current->missing_newline
+	  && ROBUST_OUTPUT_STYLE (output_style))
+	{
+	  /* The last line is incomplete and we do not silently
+	     complete lines.  If the line cannot compare equal to any
+	     complete line, put it into buckets[-1] so that it can
+	     compare equal only to the other file's incomplete line
+	     (if one exists).  */
+	  if (ig_white_space < IGNORE_TRAILING_SPACE)
+	    bucket = &buckets[-1];
+	}
+
+      for (i = *bucket;  ;  i = eqs[i].next)
+	if (!i)
+	  {
+	    /* Create a new equivalence class in this bucket.  */
+	    i = eqs_index++;
+	    if (i == eqs_alloc)
+	      {
+		if (PTRDIFF_MAX / (2 * sizeof *eqs) <= eqs_alloc)
+		  xalloc_die ();
+		eqs_alloc *= 2;
+		eqs = xrealloc (eqs, eqs_alloc * sizeof *eqs);
+	      }
+	    eqs[i].next = *bucket;
+	    eqs[i].hash = h;
+	    eqs[i].line = ip;
+	    eqs[i].length = length;
+	    *bucket = i;
+	    break;
+	  }
+	else if (eqs[i].hash == h)
+	  {
+	    char const *eqline = eqs[i].line;
+
+	    /* Reuse existing class if lines_differ reports the lines
+               equal.  */
+	    if (eqs[i].length == length)
+	      {
+		/* Reuse existing equivalence class if the lines are identical.
+		   This detects the common case of exact identity
+		   faster than lines_differ would.  */
+		if (memcmp (eqline, ip, length) == 0)
+		  break;
+		if (!same_length_diff_contents_compare_anyway)
+		  continue;
+	      }
+	    else if (!diff_length_compare_anyway)
+	      continue;
+
+	    if (! lines_differ (eqline, ip))
+	      break;
+	  }
+
+      /* Maybe increase the size of the line table.  */
+      if (line == alloc_lines)
+	{
+	  /* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
+	  if (PTRDIFF_MAX / 3 <= alloc_lines
+	      || PTRDIFF_MAX / sizeof *cureqs <= 2 * alloc_lines - linbuf_base
+	      || PTRDIFF_MAX / sizeof *linbuf <= alloc_lines - linbuf_base)
+	    xalloc_die ();
+	  alloc_lines = 2 * alloc_lines - linbuf_base;
+	  cureqs = xrealloc (cureqs, alloc_lines * sizeof *cureqs);
+	  linbuf += linbuf_base;
+	  linbuf = xrealloc (linbuf,
+			     (alloc_lines - linbuf_base) * sizeof *linbuf);
+	  linbuf -= linbuf_base;
+	}
+      linbuf[line] = ip;
+      cureqs[line] = i;
+      ++line;
+    }
+
+  current->buffered_lines = line;
+
+  for (i = 0;  ;  i++)
+    {
+      /* Record the line start for lines in the suffix that we care about.
+	 Record one more line start than lines,
+	 so that we can compute the length of any buffered line.  */
+      if (line == alloc_lines)
+	{
+	  /* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
+	  if (PTRDIFF_MAX / 3 <= alloc_lines
+	      || PTRDIFF_MAX / sizeof *cureqs <= 2 * alloc_lines - linbuf_base
+	      || PTRDIFF_MAX / sizeof *linbuf <= alloc_lines - linbuf_base)
+	    xalloc_die ();
+	  alloc_lines = 2 * alloc_lines - linbuf_base;
+	  linbuf += linbuf_base;
+	  linbuf = xrealloc (linbuf,
+			     (alloc_lines - linbuf_base) * sizeof *linbuf);
+	  linbuf -= linbuf_base;
+	}
+      linbuf[line] = p;
+
+      if (p == bufend)
+	{
+	  /* If the last line is incomplete and we do not silently
+	     complete lines, don't count its appended newline.  */
+	  if (current->missing_newline && ROBUST_OUTPUT_STYLE (output_style))
+	    linbuf[line]--;
+	  break;
+	}
+
+      if (context <= i && no_diff_means_no_output)
+	break;
+
+      line++;
+
+      while (*p++ != '\n')
+	continue;
+    }
+
+  /* Done with cache in local variables.  */
+  current->linbuf = linbuf;
+  current->valid_lines = line;
+  current->alloc_lines = alloc_lines;
+  current->equivs = cureqs;
+  equivs = eqs;
+  equivs_alloc = eqs_alloc;
+  equivs_index = eqs_index;
+}
+
+/* Prepare the text.  Make sure the text end is initialized.
+   Make sure text ends in a newline,
+   but remember that we had to add one.
+   Strip trailing CRs, if that was requested.  */
+
+static void
+prepare_text (struct file_data *current)
+{
+  size_t buffered = current->buffered;
+  char *p = FILE_BUFFER (current);
+
+  if (buffered == 0 || p[buffered - 1] == '\n')
+    current->missing_newline = false;
+  else
+    {
+      p[buffered++] = '\n';
+      current->missing_newline = true;
+    }
+
+  if (!p)
+    return;
+
+  /* Don't use uninitialized storage when planting or using sentinels.  */
+  memset (p + buffered, 0, sizeof (word));
+
+  if (strip_trailing_cr)
+    {
+      char *dst;
+      char *srclim = p + buffered;
+      *srclim = '\r';
+      dst = rawmemchr (p, '\r');
+
+      if (dst != srclim)
+	{
+	  char const *src = dst;
+	  do
+	    {
+	      *dst = *src++;
+	      dst += ! (*dst == '\r' && *src == '\n');
+	    }
+	  while (src < srclim);
+
+	  buffered -= src - dst;
+	}
+    }
+
+  current->buffered = buffered;
+}
+
+/* We have found N lines in a buffer of size S; guess the
+   proportionate number of lines that will be found in a buffer of
+   size T.  However, do not guess a number of lines so large that the
+   resulting line table might cause overflow in size calculations.  */
+static lin
+guess_lines (lin n, size_t s, size_t t)
+{
+  size_t guessed_bytes_per_line = n < 10 ? 32 : s / (n - 1);
+  lin guessed_lines = MAX (1, t / guessed_bytes_per_line);
+  return MIN (guessed_lines, PTRDIFF_MAX / (2 * sizeof (char *) + 1) - 5) + 5;
+}
+
+/* Given a vector of two file_data objects, find the identical
+   prefixes and suffixes of each object.  */
+
+static void
+find_identical_ends (struct file_data filevec[])
+{
+  word *w0, *w1;
+  char *p0, *p1, *buffer0, *buffer1;
+  char const *end0, *beg0;
+  char const **linbuf0, **linbuf1;
+  lin i, lines;
+  size_t n0, n1;
+  lin alloc_lines0, alloc_lines1;
+  bool prefix_needed;
+  lin buffered_prefix, prefix_count, prefix_mask;
+  lin middle_guess, suffix_guess;
+
+  slurp (&filevec[0]);
+  prepare_text (&filevec[0]);
+  if (filevec[0].desc != filevec[1].desc)
+    {
+      slurp (&filevec[1]);
+      prepare_text (&filevec[1]);
+    }
+  else
+    {
+      filevec[1].buffer = filevec[0].buffer;
+      filevec[1].bufsize = filevec[0].bufsize;
+      filevec[1].buffered = filevec[0].buffered;
+      filevec[1].missing_newline = filevec[0].missing_newline;
+    }
+
+  /* Find identical prefix.  */
+
+  w0 = filevec[0].buffer;
+  w1 = filevec[1].buffer;
+  p0 = buffer0 = (char *) w0;
+  p1 = buffer1 = (char *) w1;
+  n0 = filevec[0].buffered;
+  n1 = filevec[1].buffered;
+
+  if (p0 == p1)
+    /* The buffers are the same; sentinels won't work.  */
+    p0 = p1 += n1;
+  else
+    {
+      /* Insert end sentinels, in this case characters that are guaranteed
+	 to make the equality test false, and thus terminate the loop.  */
+
+      if (n0 < n1)
+	p0[n0] = ~p1[n0];
+      else
+	p1[n1] = ~p0[n1];
+
+      /* Loop until first mismatch, or to the sentinel characters.  */
+
+      /* Compare a word at a time for speed.  */
+      while (*w0 == *w1)
+	w0++, w1++;
+
+      /* Do the last few bytes of comparison a byte at a time.  */
+      p0 = (char *) w0;
+      p1 = (char *) w1;
+      while (*p0 == *p1)
+	p0++, p1++;
+
+      /* Don't mistakenly count missing newline as part of prefix.  */
+      if (ROBUST_OUTPUT_STYLE (output_style)
+	  && ((buffer0 + n0 - filevec[0].missing_newline < p0)
+	      !=
+	      (buffer1 + n1 - filevec[1].missing_newline < p1)))
+	p0--, p1--;
+    }
+
+  /* Now P0 and P1 point at the first nonmatching characters.  */
+
+  /* Skip back to last line-beginning in the prefix,
+     and then discard up to HORIZON_LINES lines from the prefix.  */
+  i = horizon_lines;
+  while (p0 != buffer0 && (p0[-1] != '\n' || i--))
+    p0--, p1--;
+
+  /* Record the prefix.  */
+  filevec[0].prefix_end = p0;
+  filevec[1].prefix_end = p1;
+
+  /* Find identical suffix.  */
+
+  /* P0 and P1 point beyond the last chars not yet compared.  */
+  p0 = buffer0 + n0;
+  p1 = buffer1 + n1;
+
+  if (! ROBUST_OUTPUT_STYLE (output_style)
+      || filevec[0].missing_newline == filevec[1].missing_newline)
+    {
+      end0 = p0;	/* Addr of last char in file 0.  */
+
+      /* Get value of P0 at which we should stop scanning backward:
+	 this is when either P0 or P1 points just past the last char
+	 of the identical prefix.  */
+      beg0 = filevec[0].prefix_end + (n0 < n1 ? 0 : n0 - n1);
+
+      /* Scan back until chars don't match or we reach that point.  */
+      while (p0 != beg0)
+	if (*--p0 != *--p1)
+	  {
+	    /* Point at the first char of the matching suffix.  */
+	    ++p0, ++p1;
+	    beg0 = p0;
+	    break;
+	  }
+
+      /* Are we at a line-beginning in both files?  If not, add the rest of
+	 this line to the main body.  Discard up to HORIZON_LINES lines from
+	 the identical suffix.  Also, discard one extra line,
+	 because shift_boundaries may need it.  */
+      i = horizon_lines + !((buffer0 == p0 || p0[-1] == '\n')
+			    &&
+			    (buffer1 == p1 || p1[-1] == '\n'));
+      while (i-- && p0 != end0)
+	while (*p0++ != '\n')
+	  continue;
+
+      p1 += p0 - beg0;
+    }
+
+  /* Record the suffix.  */
+  filevec[0].suffix_begin = p0;
+  filevec[1].suffix_begin = p1;
+
+  /* Calculate number of lines of prefix to save.
+
+     prefix_count == 0 means save the whole prefix;
+     we need this for options like -D that output the whole file,
+     or for enormous contexts (to avoid worrying about arithmetic overflow).
+     We also need it for options like -F that output some preceding line;
+     at least we will need to find the last few lines,
+     but since we don't know how many, it's easiest to find them all.
+
+     Otherwise, prefix_count != 0.  Save just prefix_count lines at start
+     of the line buffer; they'll be moved to the proper location later.
+     Handle 1 more line than the context says (because we count 1 too many),
+     rounded up to the next power of 2 to speed index computation.  */
+
+  if (no_diff_means_no_output && ! function_regexp.fastmap
+      && context < LIN_MAX / 4 && context < n0)
+    {
+      middle_guess = guess_lines (0, 0, p0 - filevec[0].prefix_end);
+      suffix_guess = guess_lines (0, 0, buffer0 + n0 - p0);
+      for (prefix_count = 1;  prefix_count <= context;  prefix_count *= 2)
+	continue;
+      alloc_lines0 = (prefix_count + middle_guess
+		      + MIN (context, suffix_guess));
+    }
+  else
+    {
+      prefix_count = 0;
+      alloc_lines0 = guess_lines (0, 0, n0);
+    }
+
+  prefix_mask = prefix_count - 1;
+  lines = 0;
+  linbuf0 = xmalloc (alloc_lines0 * sizeof *linbuf0);
+  prefix_needed = ! (no_diff_means_no_output
+		     && filevec[0].prefix_end == p0
+		     && filevec[1].prefix_end == p1);
+  p0 = buffer0;
+
+  /* If the prefix is needed, find the prefix lines.  */
+  if (prefix_needed)
+    {
+      end0 = filevec[0].prefix_end;
+      while (p0 != end0)
+	{
+	  lin l = lines++ & prefix_mask;
+	  if (l == alloc_lines0)
+	    {
+	      if (PTRDIFF_MAX / (2 * sizeof *linbuf0) <= alloc_lines0)
+		xalloc_die ();
+	      alloc_lines0 *= 2;
+	      linbuf0 = xrealloc (linbuf0, alloc_lines0 * sizeof *linbuf0);
+	    }
+	  linbuf0[l] = p0;
+	  while (*p0++ != '\n')
+	    continue;
+	}
+    }
+  buffered_prefix = prefix_count && context < lines ? context : lines;
+
+  /* Allocate line buffer 1.  */
+
+  middle_guess = guess_lines (lines, p0 - buffer0, p1 - filevec[1].prefix_end);
+  suffix_guess = guess_lines (lines, p0 - buffer0, buffer1 + n1 - p1);
+  alloc_lines1 = buffered_prefix + middle_guess + MIN (context, suffix_guess);
+  if (alloc_lines1 < buffered_prefix
+      || PTRDIFF_MAX / sizeof *linbuf1 <= alloc_lines1)
+    xalloc_die ();
+  linbuf1 = xmalloc (alloc_lines1 * sizeof *linbuf1);
+
+  if (buffered_prefix != lines)
+    {
+      /* Rotate prefix lines to proper location.  */
+      for (i = 0;  i < buffered_prefix;  i++)
+	linbuf1[i] = linbuf0[(lines - context + i) & prefix_mask];
+      for (i = 0;  i < buffered_prefix;  i++)
+	linbuf0[i] = linbuf1[i];
+    }
+
+  /* Initialize line buffer 1 from line buffer 0.  */
+  for (i = 0; i < buffered_prefix; i++)
+    linbuf1[i] = linbuf0[i] - buffer0 + buffer1;
+
+  /* Record the line buffer, adjusted so that
+     linbuf[0] points at the first differing line.  */
+  filevec[0].linbuf = linbuf0 + buffered_prefix;
+  filevec[1].linbuf = linbuf1 + buffered_prefix;
+  filevec[0].linbuf_base = filevec[1].linbuf_base = - buffered_prefix;
+  filevec[0].alloc_lines = alloc_lines0 - buffered_prefix;
+  filevec[1].alloc_lines = alloc_lines1 - buffered_prefix;
+  filevec[0].prefix_lines = filevec[1].prefix_lines = lines;
+}
+
+/* If 1 < k, then (2**k - prime_offset[k]) is the largest prime less
+   than 2**k.  This table is derived from Chris K. Caldwell's list
+   <http://www.utm.edu/research/primes/lists/2small/>.  */
+
+static unsigned char const prime_offset[] =
+{
+  0, 0, 1, 1, 3, 1, 3, 1, 5, 3, 3, 9, 3, 1, 3, 19, 15, 1, 5, 1, 3, 9, 3,
+  15, 3, 39, 5, 39, 57, 3, 35, 1, 5, 9, 41, 31, 5, 25, 45, 7, 87, 21,
+  11, 57, 17, 55, 21, 115, 59, 81, 27, 129, 47, 111, 33, 55, 5, 13, 27,
+  55, 93, 1, 57, 25
+};
+
+/* Verify that this host's size_t is not too wide for the above table.  */
+
+verify (sizeof (size_t) * CHAR_BIT <= sizeof prime_offset);
+
+/* Given a vector of two file_data objects, read the file associated
+   with each one, and build the table of equivalence classes.
+   Return nonzero if either file appears to be a binary file.
+   If PRETEND_BINARY is nonzero, pretend they are binary regardless.  */
+
+bool
+read_files (struct file_data filevec[], bool pretend_binary)
+{
+  int i;
+  bool skip_test = text | pretend_binary;
+  bool appears_binary = pretend_binary | sip (&filevec[0], skip_test);
+
+  if (filevec[0].desc != filevec[1].desc)
+    appears_binary |= sip (&filevec[1], skip_test | appears_binary);
+  else
+    {
+      filevec[1].buffer = filevec[0].buffer;
+      filevec[1].bufsize = filevec[0].bufsize;
+      filevec[1].buffered = filevec[0].buffered;
+    }
+  if (appears_binary)
+    {
+      set_binary_mode (filevec[0].desc, O_BINARY);
+      set_binary_mode (filevec[1].desc, O_BINARY);
+      return true;
+    }
+
+  find_identical_ends (filevec);
+
+  equivs_alloc = filevec[0].alloc_lines + filevec[1].alloc_lines + 1;
+  if (PTRDIFF_MAX / sizeof *equivs <= equivs_alloc)
+    xalloc_die ();
+  equivs = xmalloc (equivs_alloc * sizeof *equivs);
+  /* Equivalence class 0 is permanently safe for lines that were not
+     hashed.  Real equivalence classes start at 1.  */
+  equivs_index = 1;
+
+  /* Allocate (one plus) a prime number of hash buckets.  Use a prime
+     number between 1/3 and 2/3 of the value of equiv_allocs,
+     approximately.  */
+  for (i = 9; (size_t) 1 << i < equivs_alloc / 3; i++)
+    continue;
+  nbuckets = ((size_t) 1 << i) - prime_offset[i];
+  if (PTRDIFF_MAX / sizeof *buckets <= nbuckets)
+    xalloc_die ();
+  buckets = zalloc ((nbuckets + 1) * sizeof *buckets);
+  buckets++;
+
+  for (i = 0; i < 2; i++)
+    find_and_hash_each_line (&filevec[i]);
+
+  filevec[0].equiv_max = filevec[1].equiv_max = equivs_index;
+
+  free (equivs);
+  free (buckets - 1);
+
+  return false;
+}
diff --git a/test/diffutils-3.0/normal.c b/test/diffutils-3.0/normal.c
new file mode 100644
index 0000000..0f809da
--- /dev/null
+++ b/test/diffutils-3.0/normal.c
@@ -0,0 +1,91 @@
+/* Normal-format output routines for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1993, 1995, 1998, 2001, 2006, 2009-2013, 2015-2017
+   Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+
+static void print_normal_hunk (struct change *);
+
+/* Print the edit-script SCRIPT as a normal diff.
+   INF points to an array of descriptions of the two files.  */
+
+void
+print_normal_script (struct change *script)
+{
+  print_script (script, find_change, print_normal_hunk);
+}
+
+/* Print a hunk of a normal diff.
+   This is a contiguous portion of a complete edit script,
+   describing changes in consecutive lines.  */
+
+static void
+print_normal_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1;
+  register lin i;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes = analyze_hunk (hunk, &first0, &last0, &first1, &last1);
+  if (!changes)
+    return;
+
+  begin_output ();
+
+  /* Print out the line number header for this hunk */
+  set_color_context (LINE_NUMBER_CONTEXT);
+  print_number_range (',', &files[0], first0, last0);
+  fputc (change_letter[changes], outfile);
+  print_number_range (',', &files[1], first1, last1);
+  set_color_context (RESET_CONTEXT);
+  fputc ('\n', outfile);
+
+  /* Print the lines that the first file has.  */
+  if (changes & OLD)
+    {
+      if (first0 <= last0)
+        set_color_context (DELETE_CONTEXT);
+      for (i = first0; i <= last0; i++)
+        {
+          print_1_line_nl ("<", &files[0].linbuf[i], true);
+          if (i == last0)
+            set_color_context (RESET_CONTEXT);
+          if (files[0].linbuf[i + 1][-1] == '\n')
+            putc ('\n', outfile);
+        }
+    }
+
+  if (changes == CHANGED)
+    fputs ("---\n", outfile);
+
+  /* Print the lines that the second file has.  */
+  if (changes & NEW)
+    {
+      if (first1 <= last1)
+        set_color_context (ADD_CONTEXT);
+      for (i = first1; i <= last1; i++)
+        {
+          print_1_line_nl (">", &files[1].linbuf[i], true);
+          if (i == last1)
+            set_color_context (RESET_CONTEXT);
+          if (files[1].linbuf[i + 1][-1] == '\n')
+            putc ('\n', outfile);
+        }
+    }
+}
diff --git a/test/diffutils-3.0/sdiff.c b/test/diffutils-3.0/sdiff.c
new file mode 100644
index 0000000..1ae3dcb
--- /dev/null
+++ b/test/diffutils-3.0/sdiff.c
@@ -0,0 +1,1173 @@
+/* sdiff - side-by-side merge of file differences
+
+   Copyright (C) 1992-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2013,
+   2015-2017 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "system.h"
+#include "paths.h"
+
+#include <stdio.h>
+#include <unlocked-io.h>
+
+#include <c-stack.h>
+#include <dirname.h>
+#include "die.h"
+#include <error.h>
+#include <exitfail.h>
+#include <file-type.h>
+#include <getopt.h>
+#include <progname.h>
+#include <system-quote.h>
+#include <version-etc.h>
+#include <xalloc.h>
+
+/* The official name of this program (e.g., no 'g' prefix).  */
+#define PROGRAM_NAME "sdiff"
+
+#define AUTHORS \
+  proper_name ("Thomas Lord")
+
+/* Size of chunks read from files which must be parsed into lines.  */
+#define SDIFF_BUFSIZE ((size_t) 65536)
+
+static char const *editor_program = DEFAULT_EDITOR_PROGRAM;
+static char const **diffargv;
+
+static char * volatile tmpname;
+static FILE *tmp;
+
+#if HAVE_WORKING_FORK
+static pid_t volatile diffpid;
+#endif
+
+struct line_filter;
+
+static void catchsig (int);
+static bool edit (struct line_filter *, char const *, lin, lin, struct line_filter *, char const *, lin, lin, FILE *);
+static bool interact (struct line_filter *, struct line_filter *, char const *, struct line_filter *, char const *, FILE *);
+static void checksigs (void);
+static void diffarg (char const *);
+static void fatal (char const *) __attribute__((noreturn));
+static void perror_fatal (char const *) __attribute__((noreturn));
+static void trapsigs (void);
+static void untrapsig (int);
+
+static int const sigs[] = {
+#ifdef SIGHUP
+       SIGHUP,
+#endif
+#ifdef SIGQUIT
+       SIGQUIT,
+#endif
+#ifdef SIGTERM
+       SIGTERM,
+#endif
+#ifdef SIGXCPU
+       SIGXCPU,
+#endif
+#ifdef SIGXFSZ
+       SIGXFSZ,
+#endif
+#ifdef SIGPIPE
+       SIGPIPE,
+#endif
+       SIGINT
+};
+enum
+  {
+    NUM_SIGS = sizeof sigs / sizeof *sigs,
+    handler_index_of_SIGINT = NUM_SIGS - 1
+  };
+
+#if HAVE_SIGACTION
+  /* Prefer 'sigaction' if available, since 'signal' can lose signals.  */
+  static struct sigaction initial_action[NUM_SIGS];
+# define initial_handler(i) (initial_action[i].sa_handler)
+  static void signal_handler (int, void (*) (int));
+#else
+  static void (*initial_action[NUM_SIGS]) ();
+# define initial_handler(i) (initial_action[i])
+# define signal_handler(sig, handler) signal (sig, handler)
+#endif
+
+static bool diraccess (char const *);
+static int temporary_file (void);
+
+/* Options: */
+
+/* Name of output file if -o specified.  */
+static char const *output;
+
+/* Do not print common lines.  */
+static bool suppress_common_lines;
+
+/* Value for the long option that does not have single-letter equivalents.  */
+enum
+{
+  DIFF_PROGRAM_OPTION = CHAR_MAX + 1,
+  HELP_OPTION,
+  STRIP_TRAILING_CR_OPTION,
+  TABSIZE_OPTION
+};
+
+static struct option const longopts[] =
+{
+  {"diff-program", 1, 0, DIFF_PROGRAM_OPTION},
+  {"expand-tabs", 0, 0, 't'},
+  {"help", 0, 0, HELP_OPTION},
+  {"ignore-all-space", 0, 0, 'W'}, /* swap W and w for historical reasons */
+  {"ignore-blank-lines", 0, 0, 'B'},
+  {"ignore-case", 0, 0, 'i'},
+  {"ignore-matching-lines", 1, 0, 'I'},
+  {"ignore-space-change", 0, 0, 'b'},
+  {"ignore-tab-expansion", 0, 0, 'E'},
+  {"ignore-trailing-space", 0, 0, 'Z'},
+  {"left-column", 0, 0, 'l'},
+  {"minimal", 0, 0, 'd'},
+  {"output", 1, 0, 'o'},
+  {"speed-large-files", 0, 0, 'H'},
+  {"strip-trailing-cr", 0, 0, STRIP_TRAILING_CR_OPTION},
+  {"suppress-common-lines", 0, 0, 's'},
+  {"tabsize", 1, 0, TABSIZE_OPTION},
+  {"text", 0, 0, 'a'},
+  {"version", 0, 0, 'v'},
+  {"width", 1, 0, 'w'},
+  {0, 0, 0, 0}
+};
+
+static void try_help (char const *, char const *) __attribute__((noreturn));
+static void
+try_help (char const *reason_msgid, char const *operand)
+{
+  if (reason_msgid)
+    error (0, 0, _(reason_msgid), operand);
+  die (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+	 program_name);
+}
+
+static void
+check_stdout (void)
+{
+  if (ferror (stdout))
+    fatal ("write failed");
+  else if (fclose (stdout) != 0)
+    perror_fatal (_("standard output"));
+}
+
+static char const * const option_help_msgid[] = {
+  N_("-o, --output=FILE            operate interactively, sending output to FILE"),
+  "",
+  N_("-i, --ignore-case            consider upper- and lower-case to be the same"),
+  N_("-E, --ignore-tab-expansion   ignore changes due to tab expansion"),
+  N_("-Z, --ignore-trailing-space  ignore white space at line end"),
+  N_("-b, --ignore-space-change    ignore changes in the amount of white space"),
+  N_("-W, --ignore-all-space       ignore all white space"),
+  N_("-B, --ignore-blank-lines     ignore changes whose lines are all blank"),
+  N_("-I, --ignore-matching-lines=RE  ignore changes all whose lines match RE"),
+  N_("    --strip-trailing-cr      strip trailing carriage return on input"),
+  N_("-a, --text                   treat all files as text"),
+  "",
+  N_("-w, --width=NUM              output at most NUM (default 130) print columns"),
+  N_("-l, --left-column            output only the left column of common lines"),
+  N_("-s, --suppress-common-lines  do not output common lines"),
+  "",
+  N_("-t, --expand-tabs            expand tabs to spaces in output"),
+  N_("    --tabsize=NUM            tab stops at every NUM (default 8) print columns"),
+  "",
+  N_("-d, --minimal                try hard to find a smaller set of changes"),
+  N_("-H, --speed-large-files      assume large files, many scattered small changes"),
+  N_("    --diff-program=PROGRAM   use PROGRAM to compare files"),
+  "",
+  N_("    --help                   display this help and exit"),
+  N_("-v, --version                output version information and exit"),
+  0
+};
+
+static void
+usage (void)
+{
+  char const * const *p;
+
+  printf (_("Usage: %s [OPTION]... FILE1 FILE2\n"), program_name);
+  printf ("%s\n\n",
+          _("Side-by-side merge of differences between FILE1 and FILE2."));
+
+  fputs (_("\
+Mandatory arguments to long options are mandatory for short options too.\n\
+"), stdout);
+  for (p = option_help_msgid;  *p;  p++)
+    if (**p)
+      printf ("  %s\n", _(*p));
+    else
+      putchar ('\n');
+  printf ("\n%s\n%s\n",
+	  _("If a FILE is '-', read standard input."),
+	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
+  emit_bug_reporting_address ();
+}
+
+/* Clean up after a signal or other failure.  This function is
+   async-signal-safe.  */
+static void
+cleanup (int signo __attribute__((unused)))
+{
+#if HAVE_WORKING_FORK
+  if (0 < diffpid)
+    kill (diffpid, SIGPIPE);
+#endif
+  if (tmpname)
+    unlink (tmpname);
+}
+
+static void exiterr (void) __attribute__((noreturn));
+static void
+exiterr (void)
+{
+  cleanup (0);
+  untrapsig (0);
+  checksigs ();
+  exit (EXIT_TROUBLE);
+}
+
+static void
+fatal (char const *msgid)
+{
+  error (0, 0, "%s", _(msgid));
+  exiterr ();
+}
+
+static void
+perror_fatal (char const *msg)
+{
+  int e = errno;
+  checksigs ();
+  error (0, e, "%s", msg);
+  exiterr ();
+}
+
+static void
+check_child_status (int werrno, int wstatus, int max_ok_status,
+		    char const *subsidiary_program)
+{
+  int status = (! werrno && WIFEXITED (wstatus)
+		? WEXITSTATUS (wstatus)
+		: INT_MAX);
+
+  if (max_ok_status < status)
+    {
+      error (0, werrno,
+	     _(status == 126
+	       ? "subsidiary program '%s' could not be invoked"
+	       : status == 127
+	       ? "subsidiary program '%s' not found"
+	       : status == INT_MAX
+	       ? "subsidiary program '%s' failed"
+	       : "subsidiary program '%s' failed (exit status %d)"),
+	     subsidiary_program, status);
+      exiterr ();
+    }
+}
+
+static FILE *
+ck_fopen (char const *fname, char const *type)
+{
+  FILE *r = fopen (fname, type);
+  if (! r)
+    perror_fatal (fname);
+  return r;
+}
+
+static void
+ck_fclose (FILE *f)
+{
+  if (fclose (f))
+    perror_fatal ("fclose");
+}
+
+static size_t
+ck_fread (char *buf, size_t size, FILE *f)
+{
+  size_t r = fread (buf, sizeof (char), size, f);
+  if (r == 0 && ferror (f))
+    perror_fatal (_("read failed"));
+  return r;
+}
+
+static void
+ck_fwrite (char const *buf, size_t size, FILE *f)
+{
+  if (fwrite (buf, sizeof (char), size, f) != size)
+    perror_fatal (_("write failed"));
+}
+
+static void
+ck_fflush (FILE *f)
+{
+  if (fflush (f) != 0)
+    perror_fatal (_("write failed"));
+}
+
+static char const *
+expand_name (char *name, bool is_dir, char const *other_name)
+{
+  if (STREQ (name, "-"))
+    fatal ("cannot interactively merge standard input");
+  if (! is_dir)
+    return name;
+  else
+    {
+      /* Yield NAME/BASE, where BASE is OTHER_NAME's basename.  */
+      char const *base = last_component (other_name);
+      size_t namelen = strlen (name), baselen = base_len (base);
+      bool insert_slash = *last_component (name) && name[namelen - 1] != '/';
+      char *r = xmalloc (namelen + insert_slash + baselen + 1);
+      memcpy (r, name, namelen);
+      r[namelen] = '/';
+      memcpy (r + namelen + insert_slash, base, baselen);
+      r[namelen + insert_slash + baselen] = '\0';
+      return r;
+    }
+}
+
+struct line_filter {
+  FILE *infile;
+  char *bufpos;
+  char *buffer;
+  char *buflim;
+};
+
+static void
+lf_init (struct line_filter *lf, FILE *infile)
+{
+  lf->infile = infile;
+  lf->bufpos = lf->buffer = lf->buflim = xmalloc (SDIFF_BUFSIZE + 1);
+  lf->buflim[0] = '\n';
+}
+
+/* Fill an exhausted line_filter buffer from its INFILE */
+static size_t
+lf_refill (struct line_filter *lf)
+{
+  size_t s = ck_fread (lf->buffer, SDIFF_BUFSIZE, lf->infile);
+  lf->bufpos = lf->buffer;
+  lf->buflim = lf->buffer + s;
+  lf->buflim[0] = '\n';
+  checksigs ();
+  return s;
+}
+
+/* Advance LINES on LF's infile, copying lines to OUTFILE */
+static void
+lf_copy (struct line_filter *lf, lin lines, FILE *outfile)
+{
+  char *start = lf->bufpos;
+
+  while (lines)
+    {
+      lf->bufpos = rawmemchr (lf->bufpos, '\n');
+      if (lf->bufpos == lf->buflim)
+	{
+	  ck_fwrite (start, lf->buflim - start, outfile);
+	  if (! lf_refill (lf))
+	    return;
+	  start = lf->bufpos;
+	}
+      else
+	{
+	  --lines;
+	  ++lf->bufpos;
+	}
+    }
+
+  ck_fwrite (start, lf->bufpos - start, outfile);
+}
+
+/* Advance LINES on LF's infile without doing output */
+static void
+lf_skip (struct line_filter *lf, lin lines)
+{
+  while (lines)
+    {
+      lf->bufpos = rawmemchr (lf->bufpos, '\n');
+      if (lf->bufpos == lf->buflim)
+	{
+	  if (! lf_refill (lf))
+	    break;
+	}
+      else
+	{
+	  --lines;
+	  ++lf->bufpos;
+	}
+    }
+}
+
+/* Snarf a line into a buffer.  Return EOF if EOF, 0 if error, 1 if OK.  */
+static int
+lf_snarf (struct line_filter *lf, char *buffer, size_t bufsize)
+{
+  for (;;)
+    {
+      char *start = lf->bufpos;
+      char *next = rawmemchr (start, '\n');
+      size_t s = next - start;
+      if (bufsize <= s)
+	return 0;
+      memcpy (buffer, start, s);
+      if (next < lf->buflim)
+	{
+	  buffer[s] = 0;
+	  lf->bufpos = next + 1;
+	  return 1;
+	}
+      if (! lf_refill (lf))
+	return s ? 0 : EOF;
+      buffer += s;
+      bufsize -= s;
+    }
+}
+
+int
+main (int argc, char *argv[])
+{
+  int opt;
+  char const *prog;
+
+  exit_failure = EXIT_TROUBLE;
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+  c_stack_action (cleanup);
+
+  prog = getenv ("EDITOR");
+  if (prog)
+    editor_program = prog;
+
+  diffarg (DEFAULT_DIFF_PROGRAM);
+
+  /* parse command line args */
+  while ((opt = getopt_long (argc, argv, "abBdEHiI:lo:stvw:WZ", longopts, 0))
+	 != -1)
+    {
+      switch (opt)
+	{
+	case 'a':
+	  diffarg ("-a");
+	  break;
+
+	case 'b':
+	  diffarg ("-b");
+	  break;
+
+	case 'B':
+	  diffarg ("-B");
+	  break;
+
+	case 'd':
+	  diffarg ("-d");
+	  break;
+
+	case 'E':
+	  diffarg ("-E");
+	  break;
+
+	case 'H':
+	  diffarg ("-H");
+	  break;
+
+	case 'i':
+	  diffarg ("-i");
+	  break;
+
+	case 'I':
+	  diffarg ("-I");
+	  diffarg (optarg);
+	  break;
+
+	case 'l':
+	  diffarg ("--left-column");
+	  break;
+
+	case 'o':
+	  output = optarg;
+	  break;
+
+	case 's':
+	  suppress_common_lines = true;
+	  break;
+
+	case 't':
+	  diffarg ("-t");
+	  break;
+
+	case 'v':
+	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version,
+		       AUTHORS, (char *) NULL);
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case 'w':
+	  diffarg ("-W");
+	  diffarg (optarg);
+	  break;
+
+	case 'W':
+	  diffarg ("-w");
+	  break;
+
+	case 'Z':
+	  diffarg ("-Z");
+	  break;
+
+	case DIFF_PROGRAM_OPTION:
+	  diffargv[0] = optarg;
+	  break;
+
+	case HELP_OPTION:
+	  usage ();
+	  check_stdout ();
+	  return EXIT_SUCCESS;
+
+	case STRIP_TRAILING_CR_OPTION:
+	  diffarg ("--strip-trailing-cr");
+	  break;
+
+	case TABSIZE_OPTION:
+	  diffarg ("--tabsize");
+	  diffarg (optarg);
+	  break;
+
+	default:
+	  try_help (0, 0);
+	}
+    }
+
+  if (argc - optind != 2)
+    {
+      if (argc - optind < 2)
+	try_help ("missing operand after '%s'", argv[argc - 1]);
+      else
+	try_help ("extra operand '%s'", argv[optind + 2]);
+    }
+
+  if (! output)
+    {
+      /* easy case: diff does everything for us */
+      if (suppress_common_lines)
+	diffarg ("--suppress-common-lines");
+      diffarg ("-y");
+      diffarg ("--");
+      diffarg (argv[optind]);
+      diffarg (argv[optind + 1]);
+      diffarg (0);
+      execvp (diffargv[0], (char **) diffargv);
+      perror_fatal (diffargv[0]);
+    }
+  else
+    {
+      char const *lname, *rname;
+      FILE *left, *right, *out, *diffout;
+      bool interact_ok;
+      struct line_filter lfilt;
+      struct line_filter rfilt;
+      struct line_filter diff_filt;
+      bool leftdir = diraccess (argv[optind]);
+      bool rightdir = diraccess (argv[optind + 1]);
+
+      if (leftdir & rightdir)
+	fatal ("both files to be compared are directories");
+
+      lname = expand_name (argv[optind], leftdir, argv[optind + 1]);
+      left = ck_fopen (lname, "r");
+      rname = expand_name (argv[optind + 1], rightdir, argv[optind]);
+      right = ck_fopen (rname, "r");
+      out = ck_fopen (output, "w");
+
+      diffarg ("--sdiff-merge-assist");
+      diffarg ("--");
+      diffarg (argv[optind]);
+      diffarg (argv[optind + 1]);
+      diffarg (0);
+
+      trapsigs ();
+
+#if ! HAVE_WORKING_FORK
+      {
+	char *command = system_quote_argv (SCI_SYSTEM, (char **) diffargv);
+	errno = 0;
+	diffout = popen (command, "r");
+	if (! diffout)
+	  perror_fatal (command);
+	free (command);
+      }
+#else
+      {
+	int diff_fds[2];
+
+	if (pipe (diff_fds) != 0)
+	  perror_fatal ("pipe");
+
+	diffpid = fork ();
+	if (diffpid < 0)
+	  perror_fatal ("fork");
+	if (! diffpid)
+	  {
+	    /* Alter the child's SIGINT and SIGPIPE handlers;
+	       this may munge the parent.
+	       The child ignores SIGINT in case the user interrupts the editor.
+	       The child does not ignore SIGPIPE, even if the parent does.  */
+	    if (initial_handler (handler_index_of_SIGINT) != SIG_IGN)
+	      signal_handler (SIGINT, SIG_IGN);
+	    signal_handler (SIGPIPE, SIG_DFL);
+	    close (diff_fds[0]);
+	    if (diff_fds[1] != STDOUT_FILENO)
+	      {
+		dup2 (diff_fds[1], STDOUT_FILENO);
+		close (diff_fds[1]);
+	      }
+
+	    execvp (diffargv[0], (char **) diffargv);
+	    _exit (errno == ENOENT ? 127 : 126);
+	  }
+
+	close (diff_fds[1]);
+	diffout = fdopen (diff_fds[0], "r");
+	if (! diffout)
+	  perror_fatal ("fdopen");
+      }
+#endif
+
+      lf_init (&diff_filt, diffout);
+      lf_init (&lfilt, left);
+      lf_init (&rfilt, right);
+
+      interact_ok = interact (&diff_filt, &lfilt, lname, &rfilt, rname, out);
+
+      ck_fclose (left);
+      ck_fclose (right);
+      ck_fclose (out);
+
+      {
+	int wstatus;
+	int werrno = 0;
+
+#if ! HAVE_WORKING_FORK
+	wstatus = pclose (diffout);
+	if (wstatus == -1)
+	  werrno = errno;
+#else
+	ck_fclose (diffout);
+	while (waitpid (diffpid, &wstatus, 0) < 0)
+	  if (errno == EINTR)
+	    checksigs ();
+	  else
+	    perror_fatal ("waitpid");
+	diffpid = 0;
+#endif
+
+	if (tmpname)
+	  {
+	    unlink (tmpname);
+	    tmpname = 0;
+	  }
+
+	if (! interact_ok)
+	  exiterr ();
+
+	check_child_status (werrno, wstatus, EXIT_FAILURE, diffargv[0]);
+	untrapsig (0);
+	checksigs ();
+	exit (WEXITSTATUS (wstatus));
+      }
+    }
+  return EXIT_SUCCESS;			/* Fool '-Wall'.  */
+}
+
+static void
+diffarg (char const *a)
+{
+  static size_t diffargs, diffarglim;
+
+  if (diffargs == diffarglim)
+    {
+      if (! diffarglim)
+	diffarglim = 16;
+      else if (PTRDIFF_MAX / (2 * sizeof *diffargv) <= diffarglim)
+	xalloc_die ();
+      else
+	diffarglim *= 2;
+      diffargv = xrealloc (diffargv, diffarglim * sizeof *diffargv);
+    }
+  diffargv[diffargs++] = a;
+}
+
+/* Signal handling */
+
+static bool volatile ignore_SIGINT;
+static int volatile signal_received;
+static bool sigs_trapped;
+
+static void
+catchsig (int s)
+{
+#if ! HAVE_SIGACTION
+  signal (s, SIG_IGN);
+#endif
+  if (! (s == SIGINT && ignore_SIGINT))
+    signal_received = s;
+}
+
+#if HAVE_SIGACTION
+static struct sigaction catchaction;
+
+static void
+signal_handler (int sig, void (*handler) (int))
+{
+  catchaction.sa_handler = handler;
+  sigaction (sig, &catchaction, 0);
+}
+#endif
+
+static void
+trapsigs (void)
+{
+  int i;
+
+#if HAVE_SIGACTION
+  catchaction.sa_flags = SA_RESTART;
+  sigemptyset (&catchaction.sa_mask);
+  for (i = 0;  i < NUM_SIGS;  i++)
+    sigaddset (&catchaction.sa_mask, sigs[i]);
+#endif
+
+  for (i = 0;  i < NUM_SIGS;  i++)
+    {
+#if HAVE_SIGACTION
+      sigaction (sigs[i], 0, &initial_action[i]);
+#else
+      initial_action[i] = signal (sigs[i], SIG_IGN);
+#endif
+      if (initial_handler (i) != SIG_IGN)
+	signal_handler (sigs[i], catchsig);
+    }
+
+#ifdef SIGCHLD
+  /* System V fork+wait does not work if SIGCHLD is ignored.  */
+  signal (SIGCHLD, SIG_DFL);
+#endif
+
+  sigs_trapped = true;
+}
+
+/* Untrap signal S, or all trapped signals if S is zero.  */
+static void
+untrapsig (int s)
+{
+  int i;
+
+  if (sigs_trapped)
+    for (i = 0;  i < NUM_SIGS;  i++)
+      if ((! s || sigs[i] == s)  &&  initial_handler (i) != SIG_IGN)
+	{
+#if HAVE_SIGACTION
+	  sigaction (sigs[i], &initial_action[i], 0);
+#else
+	  signal (sigs[i], initial_action[i]);
+#endif
+	}
+}
+
+/* Exit if a signal has been received.  */
+static void
+checksigs (void)
+{
+  int s = signal_received;
+  if (s)
+    {
+      cleanup (0);
+
+      /* Yield an exit status indicating that a signal was received.  */
+      untrapsig (s);
+      kill (getpid (), s);
+
+      /* That didn't work, so exit with error status.  */
+      exit (EXIT_TROUBLE);
+    }
+}
+
+static void
+give_help (void)
+{
+  fprintf (stderr, "%s", _("\
+ed:\tEdit then use both versions, each decorated with a header.\n\
+eb:\tEdit then use both versions.\n\
+el or e1:\tEdit then use the left version.\n\
+er or e2:\tEdit then use the right version.\n\
+e:\tDiscard both versions then edit a new one.\n\
+l or 1:\tUse the left version.\n\
+r or 2:\tUse the right version.\n\
+s:\tSilently include common lines.\n\
+v:\tVerbosely include common lines.\n\
+q:\tQuit.\n\
+"));
+}
+
+static int
+skip_white (void)
+{
+  int c;
+  for (;;)
+    {
+      c = getchar ();
+      if (! isspace (c) || c == '\n')
+	break;
+      checksigs ();
+    }
+  if (ferror (stdin))
+    perror_fatal (_("read failed"));
+  return c;
+}
+
+static void
+flush_line (void)
+{
+  int c;
+  while ((c = getchar ()) != '\n' && c != EOF)
+    continue;
+  if (ferror (stdin))
+    perror_fatal (_("read failed"));
+}
+
+
+/* interpret an edit command */
+static bool
+edit (struct line_filter *left, char const *lname, lin lline, lin llen,
+      struct line_filter *right, char const *rname, lin rline, lin rlen,
+      FILE *outfile)
+{
+  for (;;)
+    {
+      int cmd0 IF_LINT (= 0);
+      int cmd1 IF_LINT (= 0);
+      bool gotcmd = false;
+
+      while (! gotcmd)
+	{
+	  if (putchar ('%') != '%')
+	    perror_fatal (_("write failed"));
+	  ck_fflush (stdout);
+
+	  cmd0 = skip_white ();
+	  switch (cmd0)
+	    {
+	    case '1': case '2': case 'l': case 'r':
+	    case 's': case 'v': case 'q':
+	      if (skip_white () != '\n')
+		{
+		  give_help ();
+		  flush_line ();
+		  continue;
+		}
+	      gotcmd = true;
+	      break;
+
+	    case 'e':
+	      cmd1 = skip_white ();
+	      switch (cmd1)
+		{
+		case '1': case '2': case 'b': case 'd': case 'l': case 'r':
+		  if (skip_white () != '\n')
+		    {
+		      give_help ();
+		      flush_line ();
+		      continue;
+		    }
+		  gotcmd = true;
+		  break;
+		case '\n':
+		  gotcmd = true;
+		  break;
+		default:
+		  give_help ();
+		  flush_line ();
+		  continue;
+		}
+	      break;
+
+	    case EOF:
+	      if (feof (stdin))
+		{
+		  gotcmd = true;
+		  cmd0 = 'q';
+		  break;
+		}
+	      FALLTHROUGH;
+	    default:
+	      flush_line ();
+	      FALLTHROUGH;
+	    case '\n':
+	      give_help ();
+	      continue;
+	    }
+	}
+
+      switch (cmd0)
+	{
+	case '1': case 'l':
+	  lf_copy (left, llen, outfile);
+	  lf_skip (right, rlen);
+	  return true;
+	case '2': case 'r':
+	  lf_copy (right, rlen, outfile);
+	  lf_skip (left, llen);
+	  return true;
+	case 's':
+	  suppress_common_lines = true;
+	  break;
+	case 'v':
+	  suppress_common_lines = false;
+	  break;
+	case 'q':
+	  return false;
+	case 'e':
+	  {
+	    int fd;
+
+	    if (tmpname)
+	      tmp = fopen (tmpname, "w");
+	    else
+	      {
+		if ((fd = temporary_file ()) < 0)
+		  perror_fatal ("mkstemp");
+		tmp = fdopen (fd, "w");
+	      }
+
+	    if (! tmp)
+	      perror_fatal (tmpname);
+
+	    switch (cmd1)
+	      {
+	      case 'd':
+		if (llen)
+		  {
+		    printint l1 = lline;
+		    printint l2 = lline + llen - 1;
+		    if (llen == 1)
+		      fprintf (tmp, "--- %s %"pI"d\n", lname, l1);
+		    else
+		      fprintf (tmp, "--- %s %"pI"d,%"pI"d\n", lname, l1, l2);
+		  }
+		FALLTHROUGH;
+	      case '1': case 'b': case 'l':
+		lf_copy (left, llen, tmp);
+		break;
+
+	      default:
+		lf_skip (left, llen);
+		break;
+	      }
+
+	    switch (cmd1)
+	      {
+	      case 'd':
+		if (rlen)
+		  {
+		    printint l1 = rline;
+		    printint l2 = rline + rlen - 1;
+		    if (rlen == 1)
+		      fprintf (tmp, "+++ %s %"pI"d\n", rname, l1);
+		    else
+		      fprintf (tmp, "+++ %s %"pI"d,%"pI"d\n", rname, l1, l2);
+		  }
+		FALLTHROUGH;
+	      case '2': case 'b': case 'r':
+		lf_copy (right, rlen, tmp);
+		break;
+
+	      default:
+		lf_skip (right, rlen);
+		break;
+	      }
+
+	    ck_fclose (tmp);
+
+	    {
+	      int wstatus;
+	      int werrno = 0;
+	      char const *argv[3];
+
+	      ignore_SIGINT = true;
+	      checksigs ();
+	      argv[0] = editor_program;
+	      argv[1] = tmpname;
+	      argv[2] = 0;
+
+	      {
+#if ! HAVE_WORKING_FORK
+		char *command = system_quote_argv (SCI_SYSTEM, (char **) argv);
+		wstatus = system (command);
+		if (wstatus == -1)
+		  werrno = errno;
+		free (command);
+#else
+		pid_t pid;
+
+		pid = fork ();
+		if (pid == 0)
+		  {
+		    execvp (editor_program, (char **) argv);
+		    _exit (errno == ENOENT ? 127 : 126);
+		  }
+
+		if (pid < 0)
+		  perror_fatal ("fork");
+
+		while (waitpid (pid, &wstatus, 0) < 0)
+		  if (errno == EINTR)
+		    checksigs ();
+		  else
+		    perror_fatal ("waitpid");
+#endif
+	      }
+
+	      ignore_SIGINT = false;
+	      check_child_status (werrno, wstatus, EXIT_SUCCESS,
+				  editor_program);
+	    }
+
+	    {
+	      char buf[SDIFF_BUFSIZE];
+	      size_t size;
+	      tmp = ck_fopen (tmpname, "r");
+	      while ((size = ck_fread (buf, SDIFF_BUFSIZE, tmp)) != 0)
+		{
+		  checksigs ();
+		  ck_fwrite (buf, size, outfile);
+		}
+	      ck_fclose (tmp);
+	    }
+	    return true;
+	  }
+	default:
+	  give_help ();
+	  break;
+	}
+    }
+}
+
+/* Alternately reveal bursts of diff output and handle user commands.  */
+static bool
+interact (struct line_filter *diff,
+	  struct line_filter *left, char const *lname,
+	  struct line_filter *right, char const *rname,
+	  FILE *outfile)
+{
+  lin lline = 1, rline = 1;
+
+  for (;;)
+    {
+      char diff_help[256];
+      int snarfed = lf_snarf (diff, diff_help, sizeof diff_help);
+
+      if (snarfed <= 0)
+	return snarfed != 0;
+
+      checksigs ();
+
+      if (diff_help[0] == ' ')
+	puts (diff_help + 1);
+      else
+	{
+	  char *numend;
+	  uintmax_t val;
+	  lin llen, rlen, lenmax;
+	  errno = 0;
+	  val = strtoumax (diff_help + 1, &numend, 10);
+	  if (LIN_MAX < val || errno || *numend != ',')
+	    fatal (diff_help);
+	  llen = val;
+	  val = strtoumax (numend + 1, &numend, 10);
+	  if (LIN_MAX < val || errno || *numend)
+	    fatal (diff_help);
+	  rlen = val;
+
+	  lenmax = MAX (llen, rlen);
+
+	  switch (diff_help[0])
+	    {
+	    case 'i':
+	      if (suppress_common_lines)
+		lf_skip (diff, lenmax);
+	      else
+		lf_copy (diff, lenmax, stdout);
+
+	      lf_copy (left, llen, outfile);
+	      lf_skip (right, rlen);
+	      break;
+
+	    case 'c':
+	      lf_copy (diff, lenmax, stdout);
+	      if (! edit (left, lname, lline, llen,
+			  right, rname, rline, rlen,
+			  outfile))
+		return false;
+	      break;
+
+	    default:
+	      fatal (diff_help);
+	    }
+
+	  lline += llen;
+	  rline += rlen;
+	}
+    }
+}
+
+/* Return true if DIR is an existing directory.  */
+static bool
+diraccess (char const *dir)
+{
+  struct stat buf;
+  return stat (dir, &buf) == 0 && S_ISDIR (buf.st_mode);
+}
+
+#ifndef P_tmpdir
+# define P_tmpdir "/tmp"
+#endif
+#ifndef TMPDIR_ENV
+# define TMPDIR_ENV "TMPDIR"
+#endif
+
+/* Open a temporary file and return its file descriptor.  Put into
+   tmpname the address of a newly allocated buffer that holds the
+   file's name.  Use the prefix "sdiff".  */
+static int
+temporary_file (void)
+{
+  char const *tmpdir = getenv (TMPDIR_ENV);
+  char const *dir = tmpdir ? tmpdir : P_tmpdir;
+  char *buf = xmalloc (strlen (dir) + 1 + 5 + 6 + 1);
+  int fd;
+  sprintf (buf, "%s/sdiffXXXXXX", dir);
+  fd = mkstemp (buf);
+  if (0 <= fd)
+    tmpname = buf;
+  return fd;
+}
diff --git a/test/diffutils-3.0/side.c b/test/diffutils-3.0/side.c
new file mode 100644
index 0000000..7f902da
--- /dev/null
+++ b/test/diffutils-3.0/side.c
@@ -0,0 +1,335 @@
+/* sdiff-format output routines for GNU DIFF.
+
+   Copyright (C) 1991-1993, 1998, 2001-2002, 2004, 2009-2013, 2015-2017 Free
+   Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   GNU DIFF is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY.  No author or distributor
+   accepts responsibility to anyone for the consequences of using it
+   or for whether it serves any particular purpose or works at all,
+   unless he says so in writing.  Refer to the GNU General Public
+   License for full details.
+
+   Everyone is granted permission to copy, modify and redistribute
+   GNU DIFF, but only under the conditions described in the
+   GNU General Public License.   A copy of this license is
+   supposed to have been given to you along with GNU DIFF so you
+   can know your rights and responsibilities.  It should be in a
+   file named COPYING.  Among other things, the copyright notice
+   and this notice must be preserved on all copies.  */
+
+#include "diff.h"
+
+#include <wchar.h>
+
+static void print_sdiff_common_lines (lin, lin);
+static void print_sdiff_hunk (struct change *);
+
+/* Next line number to be printed in the two input files.  */
+static lin next0, next1;
+
+/* Print the edit-script SCRIPT as a sdiff style output.  */
+
+void
+print_sdiff_script (struct change *script)
+{
+  begin_output ();
+
+  next0 = next1 = - files[0].prefix_lines;
+  print_script (script, find_change, print_sdiff_hunk);
+
+  print_sdiff_common_lines (files[0].valid_lines, files[1].valid_lines);
+}
+
+/* Tab from column FROM to column TO, where FROM <= TO.  Yield TO.  */
+
+static size_t
+tab_from_to (size_t from, size_t to)
+{
+  FILE *out = outfile;
+  size_t tab;
+  size_t tab_size = tabsize;
+
+  if (!expand_tabs)
+    for (tab = from + tab_size - from % tab_size;  tab <= to;  tab += tab_size)
+      {
+	putc ('\t', out);
+	from = tab;
+      }
+  while (from++ < to)
+    putc (' ', out);
+  return to;
+}
+
+/* Print the text for half an sdiff line.  This means truncate to
+   width observing tabs, and trim a trailing newline.  Return the
+   last column written (not the number of chars).  */
+
+static size_t
+print_half_line (char const *const *line, size_t indent, size_t out_bound)
+{
+  FILE *out = outfile;
+  register size_t in_position = 0;
+  register size_t out_position = 0;
+  register char const *text_pointer = line[0];
+  register char const *text_limit = line[1];
+  mbstate_t mbstate = { 0 };
+
+  while (text_pointer < text_limit)
+    {
+      char const *tp0 = text_pointer;
+      register char c = *text_pointer++;
+
+      switch (c)
+	{
+	case '\t':
+	  {
+	    size_t spaces = tabsize - in_position % tabsize;
+	    if (in_position == out_position)
+	      {
+		size_t tabstop = out_position + spaces;
+		if (expand_tabs)
+		  {
+		    if (out_bound < tabstop)
+		      tabstop = out_bound;
+		    for (;  out_position < tabstop;  out_position++)
+		      putc (' ', out);
+		  }
+		else
+		  if (tabstop < out_bound)
+		    {
+		      out_position = tabstop;
+		      putc (c, out);
+		    }
+	      }
+	    in_position += spaces;
+	  }
+	  break;
+
+	case '\r':
+	  {
+	    putc (c, out);
+	    tab_from_to (0, indent);
+	    in_position = out_position = 0;
+	  }
+	  break;
+
+	case '\b':
+	  if (in_position != 0 && --in_position < out_bound)
+	    {
+	      if (out_position <= in_position)
+		/* Add spaces to make up for suppressed tab past out_bound.  */
+		for (;  out_position < in_position;  out_position++)
+		  putc (' ', out);
+	      else
+		{
+		  out_position = in_position;
+		  putc (c, out);
+		}
+	    }
+	  break;
+
+	default:
+	  {
+	    wchar_t wc;
+	    size_t bytes = mbrtowc (&wc, tp0, text_limit - tp0, &mbstate);
+
+	    if (0 < bytes && bytes < (size_t) -2)
+	      {
+		int width = wcwidth (wc);
+		if (0 < width)
+		  in_position += width;
+		if (in_position <= out_bound)
+		  {
+		    out_position = in_position;
+		    fwrite (tp0, 1, bytes, stdout);
+		  }
+		text_pointer = tp0 + bytes;
+		break;
+	      }
+	  }
+	  FALLTHROUGH;
+	case '\f':
+	case '\v':
+	  if (in_position < out_bound)
+	    putc (c, out);
+	  break;
+
+	case ' ': case '!': case '"': case '#': case '%':
+	case '&': case '\'': case '(': case ')': case '*':
+	case '+': case ',': case '-': case '.': case '/':
+	case '0': case '1': case '2': case '3': case '4':
+	case '5': case '6': case '7': case '8': case '9':
+	case ':': case ';': case '<': case '=': case '>':
+	case '?':
+	case 'A': case 'B': case 'C': case 'D': case 'E':
+	case 'F': case 'G': case 'H': case 'I': case 'J':
+	case 'K': case 'L': case 'M': case 'N': case 'O':
+	case 'P': case 'Q': case 'R': case 'S': case 'T':
+	case 'U': case 'V': case 'W': case 'X': case 'Y':
+	case 'Z':
+	case '[': case '\\': case ']': case '^': case '_':
+	case 'a': case 'b': case 'c': case 'd': case 'e':
+	case 'f': case 'g': case 'h': case 'i': case 'j':
+	case 'k': case 'l': case 'm': case 'n': case 'o':
+	case 'p': case 'q': case 'r': case 's': case 't':
+	case 'u': case 'v': case 'w': case 'x': case 'y':
+	case 'z': case '{': case '|': case '}': case '~':
+	  /* These characters are printable ASCII characters.  */
+	  if (in_position++ < out_bound)
+	    {
+	      out_position = in_position;
+	      putc (c, out);
+	    }
+	  break;
+
+	case '\n':
+	  return out_position;
+	}
+    }
+
+  return out_position;
+}
+
+/* Print side by side lines with a separator in the middle.
+   0 parameters are taken to indicate white space text.
+   Blank lines that can easily be caught are reduced to a single newline.  */
+
+static void
+print_1sdiff_line (char const *const *left, char sep,
+		   char const *const *right)
+{
+  FILE *out = outfile;
+  size_t hw = sdiff_half_width;
+  size_t c2o = sdiff_column2_offset;
+  size_t col = 0;
+  bool put_newline = false;
+  bool color_to_reset = false;
+
+  if (sep == '<')
+    {
+      set_color_context (DELETE_CONTEXT);
+      color_to_reset = true;
+    }
+  else if (sep == '>')
+    {
+      set_color_context (ADD_CONTEXT);
+      color_to_reset = true;
+    }
+
+  if (left)
+    {
+      put_newline |= left[1][-1] == '\n';
+      col = print_half_line (left, 0, hw);
+    }
+
+  if (sep != ' ')
+    {
+      col = tab_from_to (col, (hw + c2o - 1) / 2) + 1;
+      if (sep == '|' && put_newline != (right[1][-1] == '\n'))
+	sep = put_newline ? '/' : '\\';
+      putc (sep, out);
+    }
+
+  if (right)
+    {
+      put_newline |= right[1][-1] == '\n';
+      if (**right != '\n')
+	{
+	  col = tab_from_to (col, c2o);
+	  print_half_line (right, col, hw);
+	}
+    }
+
+  if (put_newline)
+    putc ('\n', out);
+
+  if (color_to_reset)
+    set_color_context (RESET_CONTEXT);
+}
+
+/* Print lines common to both files in side-by-side format.  */
+static void
+print_sdiff_common_lines (lin limit0, lin limit1)
+{
+  lin i0 = next0, i1 = next1;
+
+  if (!suppress_common_lines && (i0 != limit0 || i1 != limit1))
+    {
+      if (sdiff_merge_assist)
+	{
+	  printint len0 = limit0 - i0;
+	  printint len1 = limit1 - i1;
+	  fprintf (outfile, "i%"pI"d,%"pI"d\n", len0, len1);
+	}
+
+      if (!left_column)
+	{
+	  while (i0 != limit0 && i1 != limit1)
+	    print_1sdiff_line (&files[0].linbuf[i0++], ' ',
+			       &files[1].linbuf[i1++]);
+	  while (i1 != limit1)
+	    print_1sdiff_line (0, ')', &files[1].linbuf[i1++]);
+	}
+      while (i0 != limit0)
+	print_1sdiff_line (&files[0].linbuf[i0++], '(', 0);
+    }
+
+  next0 = limit0;
+  next1 = limit1;
+}
+
+/* Print a hunk of an sdiff diff.
+   This is a contiguous portion of a complete edit script,
+   describing changes in consecutive lines.  */
+
+static void
+print_sdiff_hunk (struct change *hunk)
+{
+  lin first0, last0, first1, last1;
+  register lin i, j;
+
+  /* Determine range of line numbers involved in each file.  */
+  enum changes changes =
+    analyze_hunk (hunk, &first0, &last0, &first1, &last1);
+  if (!changes)
+    return;
+
+  /* Print out lines up to this change.  */
+  print_sdiff_common_lines (first0, first1);
+
+  if (sdiff_merge_assist)
+    {
+      printint len0 = last0 - first0 + 1;
+      printint len1 = last1 - first1 + 1;
+      fprintf (outfile, "c%"pI"d,%"pI"d\n", len0, len1);
+    }
+
+  /* Print "xxx  |  xxx " lines.  */
+  if (changes == CHANGED)
+    {
+      for (i = first0, j = first1;  i <= last0 && j <= last1;  i++, j++)
+	print_1sdiff_line (&files[0].linbuf[i], '|', &files[1].linbuf[j]);
+      changes = (i <= last0 ? OLD : 0) + (j <= last1 ? NEW : 0);
+      next0 = first0 = i;
+      next1 = first1 = j;
+    }
+
+  /* Print "     >  xxx " lines.  */
+  if (changes & NEW)
+    {
+      for (j = first1; j <= last1; ++j)
+	print_1sdiff_line (0, '>', &files[1].linbuf[j]);
+      next1 = j;
+    }
+
+  /* Print "xxx  <     " lines.  */
+  if (changes & OLD)
+    {
+      for (i = first0; i <= last0; ++i)
+	print_1sdiff_line (&files[0].linbuf[i], '<', 0);
+      next0 = i;
+    }
+}
diff --git a/test/diffutils-3.0/system.h b/test/diffutils-3.0/system.h
new file mode 100644
index 0000000..a8936ba
--- /dev/null
+++ b/test/diffutils-3.0/system.h
@@ -0,0 +1,240 @@
+/* System dependent declarations.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2013,
+   2015-2017 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+/* Use this to suppress gcc's "...may be used before initialized" warnings. */
+#ifdef lint
+# define IF_LINT(Code) Code
+#else
+# define IF_LINT(Code) /* empty */
+#endif
+
+/* Define '__attribute__' and 'volatile' first
+   so that they're used consistently in all system includes.  */
+#if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 6) || __STRICT_ANSI__
+# define __attribute__(x)
+#endif
+
+#include <verify.h>
+
+#include <sys/types.h>
+
+#include <sys/stat.h>
+#include "stat-macros.h"
+
+#ifndef STAT_BLOCKSIZE
+# if HAVE_STRUCT_STAT_ST_BLKSIZE
+#  define STAT_BLOCKSIZE(s) ((s).st_blksize)
+# else
+#  define STAT_BLOCKSIZE(s) (8 * 1024)
+# endif
+#endif
+
+#include <unistd.h>
+
+#include <fcntl.h>
+#include <time.h>
+
+#include <sys/wait.h>
+
+#include <dirent.h>
+#ifndef _D_EXACT_NAMLEN
+# define _D_EXACT_NAMLEN(dp) strlen ((dp)->d_name)
+#endif
+
+#include <stdlib.h>
+#define EXIT_TROUBLE 2
+
+#include <limits.h>
+#include <locale.h>
+#include <stddef.h>
+#include <inttypes.h>
+
+#include <string.h>
+#if ! HAVE_STRCASECOLL
+# if HAVE_STRICOLL || defined stricoll
+#  define strcasecoll(a, b) stricoll (a, b)
+# else
+#  define strcasecoll(a, b) strcasecmp (a, b) /* best we can do */
+# endif
+#endif
+#if ! (HAVE_STRCASECMP || defined strcasecmp)
+int strcasecmp (char const *, char const *);
+#endif
+
+#include <gettext.h>
+#if ! ENABLE_NLS
+# undef textdomain
+# define textdomain(Domainname) /* empty */
+# undef bindtextdomain
+# define bindtextdomain(Domainname, Dirname) /* empty */
+#endif
+
+#define _(msgid) gettext (msgid)
+#define N_(msgid) msgid
+
+#include <ctype.h>
+
+/* ISDIGIT differs from isdigit, as follows:
+   - Its arg may be any int or unsigned int; it need not be an unsigned char.
+   - It's guaranteed to evaluate its argument exactly once.
+   - It's typically faster.
+   POSIX 1003.1-2001 says that only '0' through '9' are digits.
+   Prefer ISDIGIT to isdigit unless it's important to use the locale's
+   definition of 'digit' even when the host does not conform to POSIX.  */
+#define ISDIGIT(c) ((unsigned int) (c) - '0' <= 9)
+
+#include <errno.h>
+
+#include <signal.h>
+#if !defined SIGCHLD && defined SIGCLD
+# define SIGCHLD SIGCLD
+#endif
+
+#undef MIN
+#undef MAX
+#define MIN(a, b) ((a) <= (b) ? (a) : (b))
+#define MAX(a, b) ((a) >= (b) ? (a) : (b))
+
+#include <stdbool.h>
+#include <intprops.h>
+#include "propername.h"
+#include "version.h"
+
+/* Type used for fast comparison of several bytes at a time.
+   This used to be uintmax_t, but changing it to size_t
+   made plain 'cmp' 90% faster (GCC 4.8.1, x86).  */
+
+#ifndef word
+# define word size_t
+#endif
+
+/* The signed integer type of a line number.  Since files are read
+   into main memory, ptrdiff_t should be wide enough.  */
+
+typedef ptrdiff_t lin;
+#define LIN_MAX PTRDIFF_MAX
+
+/* The signed integer type for printing line numbers, and its printf
+   length modifier.  This is not simply ptrdiff_t, to cater to older
+   and/or nonstandard C libraries where "l" works but "ll" and "t" do
+   not, or where 'long' is too narrow and "ll" works but "t" does not.  */
+
+#if LIN_MAX <= LONG_MAX
+typedef long int printint;
+# define pI "l"
+#elif LIN_MAX <= LLONG_MAX
+typedef long long int printint;
+# define pI "ll"
+#else
+typedef ptrdiff_t printint;
+# define pI "t"
+#endif
+
+verify (TYPE_SIGNED (lin));
+verify (TYPE_SIGNED (printint));
+verify (LIN_MAX == TYPE_MAXIMUM (lin));
+verify (LIN_MAX <= TYPE_MAXIMUM (printint));
+
+/* Limit so that 2 * CONTEXT + 1 does not overflow.  */
+
+#define CONTEXT_MAX ((LIN_MAX - 1) / 2)
+
+
+/* This section contains POSIX-compliant defaults for macros
+   that are meant to be overridden by hand in config.h as needed.  */
+
+#ifndef file_name_cmp
+# define file_name_cmp strcmp
+#endif
+
+#ifndef initialize_main
+# define initialize_main(argcp, argvp)
+#endif
+
+#ifndef NULL_DEVICE
+# define NULL_DEVICE "/dev/null"
+#endif
+
+/* Do struct stat *S, *T describe the same special file?  */
+#ifndef same_special_file
+# if HAVE_STRUCT_STAT_ST_RDEV && defined S_ISBLK && defined S_ISCHR
+#  define same_special_file(s, t) \
+     (((S_ISBLK ((s)->st_mode) && S_ISBLK ((t)->st_mode)) \
+       || (S_ISCHR ((s)->st_mode) && S_ISCHR ((t)->st_mode))) \
+      && (s)->st_rdev == (t)->st_rdev)
+# else
+#  define same_special_file(s, t) 0
+# endif
+#endif
+
+/* Do struct stat *S, *T describe the same file?  Answer -1 if unknown.  */
+#ifndef same_file
+# define same_file(s, t) \
+    ((((s)->st_ino == (t)->st_ino) && ((s)->st_dev == (t)->st_dev)) \
+     || same_special_file (s, t))
+#endif
+
+/* Do struct stat *S, *T have the same file attributes?
+
+   POSIX says that two files are identical if st_ino and st_dev are
+   the same, but many file systems incorrectly assign the same (device,
+   inode) pair to two distinct files, including:
+
+   - GNU/Linux NFS servers that export all local file systems as a
+     single NFS file system, if a local device number (st_dev) exceeds
+     255, or if a local inode number (st_ino) exceeds 16777215.
+
+   - Network Appliance NFS servers in snapshot directories; see
+     Network Appliance bug #195.
+
+   - ClearCase MVFS; see bug id ATRia04618.
+
+   Check whether two files that purport to be the same have the same
+   attributes, to work around instances of this common bug.  Do not
+   inspect all attributes, only attributes useful in checking for this
+   bug.
+
+   It's possible for two distinct files on a buggy file system to have
+   the same attributes, but it's not worth slowing down all
+   implementations (or complicating the configuration) to cater to
+   these rare cases in buggy implementations.  */
+
+#ifndef same_file_attributes
+# define same_file_attributes(s, t) \
+   ((s)->st_mode == (t)->st_mode \
+    && (s)->st_nlink == (t)->st_nlink \
+    && (s)->st_uid == (t)->st_uid \
+    && (s)->st_gid == (t)->st_gid \
+    && (s)->st_size == (t)->st_size \
+    && (s)->st_mtime == (t)->st_mtime \
+    && (s)->st_ctime == (t)->st_ctime)
+#endif
+
+#define STREQ(a, b) (strcmp (a, b) == 0)
+
+#ifndef FALLTHROUGH
+# if __GNUC__ < 7
+#  define FALLTHROUGH ((void) 0)
+# else
+#  define FALLTHROUGH __attribute__ ((__fallthrough__))
+# endif
+#endif
diff --git a/test/diffutils-3.0/util.c b/test/diffutils-3.0/util.c
new file mode 100644
index 0000000..88955da
--- /dev/null
+++ b/test/diffutils-3.0/util.c
@@ -0,0 +1,1576 @@
+/* Support routines for GNU DIFF.
+
+   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2013,
+   2015-2017 Free Software Foundation, Inc.
+
+   This file is part of GNU DIFF.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "diff.h"
+#include "argmatch.h"
+#include "die.h"
+#include <dirname.h>
+#include <error.h>
+#include <system-quote.h>
+#include <xalloc.h>
+#include "xvasprintf.h"
+#include <signal.h>
+
+/* Use SA_NOCLDSTOP as a proxy for whether the sigaction machinery is
+   present.  */
+#ifndef SA_NOCLDSTOP
+# define SA_NOCLDSTOP 0
+# define sigprocmask(How, Set, Oset) /* empty */
+# define sigset_t int
+# if ! HAVE_SIGINTERRUPT
+#  define siginterrupt(sig, flag) /* empty */
+# endif
+#endif
+
+#ifndef SA_RESTART
+# define SA_RESTART 0
+#endif
+
+char const pr_program[] = PR_PROGRAM;
+
+/* Queue up one-line messages to be printed at the end,
+   when -l is specified.  Each message is recorded with a 'struct msg'.  */
+
+struct msg
+{
+  struct msg *next;
+  char args[1]; /* Format + 4 args, each '\0' terminated, concatenated.  */
+};
+
+/* Head of the chain of queues messages.  */
+
+static struct msg *msg_chain;
+
+/* Tail of the chain of queues messages.  */
+
+static struct msg **msg_chain_end = &msg_chain;
+
+/* Use when a system call returns non-zero status.
+   NAME should normally be the file name.  */
+
+void
+perror_with_name (char const *name)
+{
+  error (0, errno, "%s", name);
+}
+
+/* Use when a system call returns non-zero status and that is fatal.  */
+
+void
+pfatal_with_name (char const *name)
+{
+  int e = errno;
+  print_message_queue ();
+  die (EXIT_TROUBLE, e, "%s", name);
+}
+
+/* Print an error message containing MSGID, then exit.  */
+
+void
+fatal (char const *msgid)
+{
+  print_message_queue ();
+  die (EXIT_TROUBLE, 0, "%s", _(msgid));
+}
+
+/* Like printf, except if -l in effect then save the message and print later.
+   This is used for things like "Only in ...".  */
+
+void
+message (char const *format_msgid, char const *arg1, char const *arg2)
+{
+  message5 (format_msgid, arg1, arg2, 0, 0);
+}
+
+void
+message5 (char const *format_msgid, char const *arg1, char const *arg2,
+	  char const *arg3, char const *arg4)
+{
+  if (paginate)
+    {
+      char *p;
+      char const *arg[5];
+      int i;
+      size_t size[5];
+      size_t total_size = offsetof (struct msg, args);
+      struct msg *new;
+
+      arg[0] = format_msgid;
+      arg[1] = arg1;
+      arg[2] = arg2;
+      arg[3] = arg3 ? arg3 : "";
+      arg[4] = arg4 ? arg4 : "";
+
+      for (i = 0;  i < 5;  i++)
+	total_size += size[i] = strlen (arg[i]) + 1;
+
+      new = xmalloc (total_size);
+
+      for (i = 0, p = new->args;  i < 5;  p += size[i++])
+	memcpy (p, arg[i], size[i]);
+
+      *msg_chain_end = new;
+      new->next = 0;
+      msg_chain_end = &new->next;
+    }
+  else
+    {
+      if (sdiff_merge_assist)
+	putchar (' ');
+      printf (_(format_msgid), arg1, arg2, arg3, arg4);
+    }
+}
+
+/* Output all the messages that were saved up by calls to 'message'.  */
+
+void
+print_message_queue (void)
+{
+  char const *arg[5];
+  int i;
+  struct msg *m = msg_chain;
+
+  while (m)
+    {
+      struct msg *next = m->next;
+      arg[0] = m->args;
+      for (i = 0;  i < 4;  i++)
+	arg[i + 1] = arg[i] + strlen (arg[i]) + 1;
+      printf (_(arg[0]), arg[1], arg[2], arg[3], arg[4]);
+      free (m);
+      m = next;
+    }
+}
+
+/* The set of signals that are caught.  */
+
+static sigset_t caught_signals;
+
+/* If nonzero, the value of the pending fatal signal.  */
+
+static sig_atomic_t volatile interrupt_signal;
+
+/* A count of the number of pending stop signals that have been received.  */
+
+static sig_atomic_t volatile stop_signal_count;
+
+/* An ordinary signal was received; arrange for the program to exit.  */
+
+static void
+sighandler (int sig)
+{
+  if (! SA_NOCLDSTOP)
+    signal (sig, SIG_IGN);
+  if (! interrupt_signal)
+    interrupt_signal = sig;
+}
+
+/* A SIGTSTP was received; arrange for the program to suspend itself.  */
+
+static void
+stophandler (int sig)
+{
+  if (! SA_NOCLDSTOP)
+    signal (sig, stophandler);
+  if (! interrupt_signal)
+    stop_signal_count++;
+}
+/* Process any pending signals.  If signals are caught, this function
+   should be called periodically.  Ideally there should never be an
+   unbounded amount of time when signals are not being processed.
+   Signal handling can restore the default colors, so callers must
+   immediately change colors after invoking this function.  */
+
+static void
+process_signals (void)
+{
+  while (interrupt_signal || stop_signal_count)
+    {
+      int sig;
+      int stops;
+      sigset_t oldset;
+
+      set_color_context (RESET_CONTEXT);
+      fflush (stdout);
+
+      sigprocmask (SIG_BLOCK, &caught_signals, &oldset);
+
+      /* Reload interrupt_signal and stop_signal_count, in case a new
+         signal was handled before sigprocmask took effect.  */
+      sig = interrupt_signal;
+      stops = stop_signal_count;
+
+      /* SIGTSTP is special, since the application can receive that signal
+         more than once.  In this case, don't set the signal handler to the
+         default.  Instead, just raise the uncatchable SIGSTOP.  */
+      if (stops)
+        {
+          stop_signal_count = stops - 1;
+          sig = SIGSTOP;
+        }
+      else
+        signal (sig, SIG_DFL);
+
+      /* Exit or suspend the program.  */
+      raise (sig);
+      sigprocmask (SIG_SETMASK, &oldset, NULL);
+
+      /* If execution reaches here, then the program has been
+         continued (after being suspended).  */
+    }
+}
+
+static void
+install_signal_handlers (void)
+{
+  /* The signals that are trapped, and the number of such signals.  */
+  static int const sig[] =
+    {
+      /* This one is handled specially.  */
+      SIGTSTP,
+
+      /* The usual suspects.  */
+      SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM,
+#ifdef SIGPOLL
+      SIGPOLL,
+#endif
+#ifdef SIGPROF
+      SIGPROF,
+#endif
+#ifdef SIGVTALRM
+      SIGVTALRM,
+#endif
+#ifdef SIGXCPU
+      SIGXCPU,
+#endif
+#ifdef SIGXFSZ
+      SIGXFSZ,
+#endif
+    };
+  enum { nsigs = sizeof (sig) / sizeof *(sig) };
+
+#if ! SA_NOCLDSTOP
+  bool caught_sig[nsigs];
+#endif
+  {
+    int j;
+#if SA_NOCLDSTOP
+    struct sigaction act;
+
+    sigemptyset (&caught_signals);
+    for (j = 0; j < nsigs; j++)
+      {
+        sigaction (sig[j], NULL, &act);
+        if (act.sa_handler != SIG_IGN)
+          sigaddset (&caught_signals, sig[j]);
+      }
+
+    act.sa_mask = caught_signals;
+    act.sa_flags = SA_RESTART;
+
+    for (j = 0; j < nsigs; j++)
+      if (sigismember (&caught_signals, sig[j]))
+        {
+          act.sa_handler = sig[j] == SIGTSTP ? stophandler : sighandler;
+          sigaction (sig[j], &act, NULL);
+        }
+#else
+    for (j = 0; j < nsigs; j++)
+      {
+        caught_sig[j] = (signal (sig[j], SIG_IGN) != SIG_IGN);
+        if (caught_sig[j])
+          {
+            signal (sig[j], sig[j] == SIGTSTP ? stophandler : sighandler);
+            siginterrupt (sig[j], 0);
+          }
+      }
+#endif
+    }
+}
+
+static char const *current_name0;
+static char const *current_name1;
+static bool currently_recursive;
+static bool colors_enabled;
+
+static struct color_ext_type *color_ext_list = NULL;
+
+struct bin_str
+  {
+    size_t len;			/* Number of bytes */
+    const char *string;		/* Pointer to the same */
+  };
+
+struct color_ext_type
+  {
+    struct bin_str ext;		/* The extension we're looking for */
+    struct bin_str seq;		/* The sequence to output when we do */
+    struct color_ext_type *next;	/* Next in list */
+  };
+
+/* Parse a string as part of the --palette argument; this may involve
+   decoding all kinds of escape characters.  If equals_end is set an
+   unescaped equal sign ends the string, otherwise only a : or \0
+   does.  Set *OUTPUT_COUNT to the number of bytes output.  Return
+   true if successful.
+
+   The resulting string is *not* null-terminated, but may contain
+   embedded nulls.
+
+   Note that both dest and src are char **; on return they point to
+   the first free byte after the array and the character that ended
+   the input string, respectively.  */
+
+static bool
+get_funky_string (char **dest, const char **src, bool equals_end,
+                  size_t *output_count)
+{
+  char num;			/* For numerical codes */
+  size_t count;			/* Something to count with */
+  enum {
+    ST_GND, ST_BACKSLASH, ST_OCTAL, ST_HEX, ST_CARET, ST_END, ST_ERROR
+  } state;
+  const char *p;
+  char *q;
+
+  p = *src;			/* We don't want to double-indirect */
+  q = *dest;			/* the whole darn time.  */
+
+  count = 0;			/* No characters counted in yet.  */
+  num = 0;
+
+  state = ST_GND;		/* Start in ground state.  */
+  while (state < ST_END)
+    {
+      switch (state)
+        {
+        case ST_GND:		/* Ground state (no escapes) */
+          switch (*p)
+            {
+            case ':':
+            case '\0':
+              state = ST_END;	/* End of string */
+              break;
+            case '\\':
+              state = ST_BACKSLASH; /* Backslash scape sequence */
+              ++p;
+              break;
+            case '^':
+              state = ST_CARET; /* Caret escape */
+              ++p;
+              break;
+            case '=':
+              if (equals_end)
+                {
+                  state = ST_END; /* End */
+                  break;
+                }
+              FALLTHROUGH;
+            default:
+              *(q++) = *(p++);
+              ++count;
+              break;
+            }
+          break;
+
+        case ST_BACKSLASH:	/* Backslash escaped character */
+          switch (*p)
+            {
+            case '0':
+            case '1':
+            case '2':
+            case '3':
+            case '4':
+            case '5':
+            case '6':
+            case '7':
+              state = ST_OCTAL;	/* Octal sequence */
+              num = *p - '0';
+              break;
+            case 'x':
+            case 'X':
+              state = ST_HEX;	/* Hex sequence */
+              num = 0;
+              break;
+            case 'a':		/* Bell */
+              num = '\a';
+              break;
+            case 'b':		/* Backspace */
+              num = '\b';
+              break;
+            case 'e':		/* Escape */
+              num = 27;
+              break;
+            case 'f':		/* Form feed */
+              num = '\f';
+              break;
+            case 'n':		/* Newline */
+              num = '\n';
+              break;
+            case 'r':		/* Carriage return */
+              num = '\r';
+              break;
+            case 't':		/* Tab */
+              num = '\t';
+              break;
+            case 'v':		/* Vtab */
+              num = '\v';
+              break;
+            case '?':		/* Delete */
+              num = 127;
+              break;
+            case '_':		/* Space */
+              num = ' ';
+              break;
+            case '\0':		/* End of string */
+              state = ST_ERROR;	/* Error! */
+              break;
+            default:		/* Escaped character like \ ^ : = */
+              num = *p;
+              break;
+            }
+          if (state == ST_BACKSLASH)
+            {
+              *(q++) = num;
+              ++count;
+              state = ST_GND;
+            }
+          ++p;
+          break;
+
+        case ST_OCTAL:		/* Octal sequence */
+          if (*p < '0' || *p > '7')
+            {
+              *(q++) = num;
+              ++count;
+              state = ST_GND;
+            }
+          else
+            num = (num << 3) + (*(p++) - '0');
+          break;
+
+        case ST_HEX:		/* Hex sequence */
+          switch (*p)
+            {
+            case '0':
+            case '1':
+            case '2':
+            case '3':
+            case '4':
+            case '5':
+            case '6':
+            case '7':
+            case '8':
+            case '9':
+              num = (num << 4) + (*(p++) - '0');
+              break;
+            case 'a':
+            case 'b':
+            case 'c':
+            case 'd':
+            case 'e':
+            case 'f':
+              num = (num << 4) + (*(p++) - 'a') + 10;
+              break;
+            case 'A':
+            case 'B':
+            case 'C':
+            case 'D':
+            case 'E':
+            case 'F':
+              num = (num << 4) + (*(p++) - 'A') + 10;
+              break;
+            default:
+              *(q++) = num;
+              ++count;
+              state = ST_GND;
+              break;
+            }
+          break;
+
+        case ST_CARET:		/* Caret escape */
+          state = ST_GND;	/* Should be the next state... */
+          if (*p >= '@' && *p <= '~')
+            {
+              *(q++) = *(p++) & 037;
+              ++count;
+            }
+          else if (*p == '?')
+            {
+              *(q++) = 127;
+              ++count;
+            }
+          else
+            state = ST_ERROR;
+          break;
+
+        default:
+          abort ();
+        }
+    }
+
+  *dest = q;
+  *src = p;
+  *output_count = count;
+
+  return state != ST_ERROR;
+}
+
+enum parse_state
+  {
+    PS_START = 1,
+    PS_2,
+    PS_3,
+    PS_4,
+    PS_DONE,
+    PS_FAIL
+  };
+
+#define LEN_STR_PAIR(s) sizeof (s) - 1, s
+
+static struct bin_str color_indicator[] =
+  {
+    { LEN_STR_PAIR ("\033[") },		/* lc: Left of color sequence */
+    { LEN_STR_PAIR ("m") },		/* rc: Right of color sequence */
+    { 0, NULL },			/* ec: End color (replaces lc+rs+rc) */
+    { LEN_STR_PAIR ("0") },		/* rs: Reset to ordinary colors */
+    { LEN_STR_PAIR ("1") },		/* hd: Header */
+    { LEN_STR_PAIR ("32") },		/* ad: Add line */
+    { LEN_STR_PAIR ("31") },		/* de: Delete line */
+    { LEN_STR_PAIR ("36") },		/* ln: Line number */
+  };
+
+static const char *const indicator_name[] =
+  {
+    "lc", "rc", "ec", "rs", "hd", "ad", "de", "ln", NULL
+  };
+ARGMATCH_VERIFY (indicator_name, color_indicator);
+
+static char const *color_palette;
+
+void
+set_color_palette (char const *palette)
+{
+  color_palette = palette;
+}
+
+static void
+parse_diff_color (void)
+{
+  char *color_buf;
+  const char *p;		/* Pointer to character being parsed */
+  char *buf;			/* color_buf buffer pointer */
+  int ind_no;			/* Indicator number */
+  char label[3];		/* Indicator label */
+  struct color_ext_type *ext;	/* Extension we are working on */
+
+  if ((p = color_palette) == NULL || *p == '\0')
+    return;
+
+  ext = NULL;
+  strcpy (label, "??");
+
+  /* This is an overly conservative estimate, but any possible
+     --palette string will *not* generate a color_buf longer than
+     itself, so it is a safe way of allocating a buffer in
+     advance.  */
+  buf = color_buf = xstrdup (p);
+
+  enum parse_state state = PS_START;
+  while (true)
+    {
+      switch (state)
+        {
+        case PS_START:		/* First label character */
+          switch (*p)
+            {
+            case ':':
+              ++p;
+              break;
+
+            case '*':
+              /* Allocate new extension block and add to head of
+                 linked list (this way a later definition will
+                 override an earlier one, which can be useful for
+                 having terminal-specific defs override global).  */
+
+              ext = xmalloc (sizeof *ext);
+              ext->next = color_ext_list;
+              color_ext_list = ext;
+
+              ++p;
+              ext->ext.string = buf;
+
+              state = (get_funky_string (&buf, &p, true, &ext->ext.len)
+                       ? PS_4 : PS_FAIL);
+              break;
+
+            case '\0':
+              state = PS_DONE;	/* Done! */
+              goto done;
+
+            default:	/* Assume it is file type label */
+              label[0] = *(p++);
+              state = PS_2;
+              break;
+            }
+          break;
+
+        case PS_2:		/* Second label character */
+          if (*p)
+            {
+              label[1] = *(p++);
+              state = PS_3;
+            }
+          else
+            state = PS_FAIL;	/* Error */
+          break;
+
+        case PS_3:		/* Equal sign after indicator label */
+          state = PS_FAIL;	/* Assume failure...  */
+          if (*(p++) == '=')/* It *should* be...  */
+            {
+              for (ind_no = 0; indicator_name[ind_no] != NULL; ++ind_no)
+                {
+                  if (STREQ (label, indicator_name[ind_no]))
+                    {
+                      color_indicator[ind_no].string = buf;
+                      state = (get_funky_string (&buf, &p, false,
+                                                 &color_indicator[ind_no].len)
+                               ? PS_START : PS_FAIL);
+                      break;
+                    }
+                }
+              if (state == PS_FAIL)
+                error (0, 0, _("unrecognized prefix: %s"), label);
+            }
+          break;
+
+        case PS_4:		/* Equal sign after *.ext */
+          if (*(p++) == '=')
+            {
+              ext->seq.string = buf;
+              state = (get_funky_string (&buf, &p, false, &ext->seq.len)
+                       ? PS_START : PS_FAIL);
+            }
+          else
+            state = PS_FAIL;
+          break;
+
+        case PS_FAIL:
+          goto done;
+
+        default:
+          abort ();
+        }
+    }
+ done:
+
+  if (state == PS_FAIL)
+    {
+      struct color_ext_type *e;
+      struct color_ext_type *e2;
+
+      error (0, 0,
+             _("unparsable value for --palette"));
+      free (color_buf);
+      for (e = color_ext_list; e != NULL; /* empty */)
+        {
+          e2 = e;
+          e = e->next;
+          free (e2);
+        }
+      colors_enabled = false;
+    }
+}
+
+static void
+check_color_output (bool is_pipe)
+{
+  bool output_is_tty;
+
+  if (! outfile || colors_style == NEVER)
+    return;
+
+  output_is_tty = presume_output_tty || (!is_pipe && isatty (fileno (outfile)));
+
+  colors_enabled = (colors_style == ALWAYS
+                    || (colors_style == AUTO && output_is_tty));
+
+  if (colors_enabled)
+    parse_diff_color ();
+
+  if (output_is_tty)
+    install_signal_handlers ();
+}
+
+/* Call before outputting the results of comparing files NAME0 and NAME1
+   to set up OUTFILE, the stdio stream for the output to go to.
+
+   Usually, OUTFILE is just stdout.  But when -l was specified
+   we fork off a 'pr' and make OUTFILE a pipe to it.
+   'pr' then outputs to our stdout.  */
+
+void
+setup_output (char const *name0, char const *name1, bool recursive)
+{
+  current_name0 = name0;
+  current_name1 = name1;
+  currently_recursive = recursive;
+  outfile = 0;
+}
+
+#if HAVE_WORKING_FORK
+static pid_t pr_pid;
+#endif
+
+static char c_escape_char (char c)
+{
+  switch (c) {
+    case '\a': return 'a';
+    case '\b': return 'b';
+    case '\t': return 't';
+    case '\n': return 'n';
+    case '\v': return 'v';
+    case '\f': return 'f';
+    case '\r': return 'r';
+    case '"': return '"';
+    case '\\': return '\\';
+    default:
+      return c < 32;
+  }
+}
+
+static char *
+c_escape (char const *str)
+{
+  char const *s;
+  size_t plus = 0;
+  bool must_quote = false;
+
+  for (s = str; *s; s++)
+    {
+      char c = *s;
+
+      if (c == ' ')
+	{
+	  must_quote = true;
+	  continue;
+	}
+      switch (c_escape_char (*s))
+	{
+	  case 1:
+	    plus += 3;
+	    /* fall through */
+	  case 0:
+	    break;
+	  default:
+	    plus++;
+	    break;
+	}
+    }
+
+  if (must_quote || plus)
+    {
+      size_t s_len = s - str;
+      char *buffer = xmalloc (s_len + plus + 3);
+      char *b = buffer;
+
+      *b++ = '"';
+      for (s = str; *s; s++)
+	{
+	  char c = *s;
+	  char escape = c_escape_char (c);
+
+	  switch (escape)
+	    {
+	      case 0:
+		*b++ = c;
+		break;
+	      case 1:
+		*b++ = '\\';
+		*b++ = ((c >> 6) & 03) + '0';
+		*b++ = ((c >> 3) & 07) + '0';
+		*b++ = ((c >> 0) & 07) + '0';
+		break;
+	      default:
+		*b++ = '\\';
+		*b++ = escape;
+		break;
+	    }
+	}
+      *b++ = '"';
+      *b = 0;
+      return buffer;
+    }
+
+  return (char *) str;
+}
+
+void
+begin_output (void)
+{
+  char *names[2];
+  char *name;
+
+  if (outfile != 0)
+    return;
+
+  names[0] = c_escape (current_name0);
+  names[1] = c_escape (current_name1);
+
+  /* Construct the header of this piece of diff.  */
+  /* POSIX 1003.1-2001 specifies this format.  But there are some bugs in
+     the standard: it says that we must print only the last component
+     of the pathnames, and it requires two spaces after "diff" if
+     there are no options.  These requirements are silly and do not
+     match historical practice.  */
+  name = xasprintf ("diff%s %s %s", switch_string, names[0], names[1]);
+
+  if (paginate)
+    {
+      char const *argv[4];
+
+      if (fflush (stdout) != 0)
+	pfatal_with_name (_("write failed"));
+
+      argv[0] = pr_program;
+      argv[1] = "-h";
+      argv[2] = name;
+      argv[3] = 0;
+
+      /* Make OUTFILE a pipe to a subsidiary 'pr'.  */
+      {
+#if HAVE_WORKING_FORK
+	int pipes[2];
+
+	if (pipe (pipes) != 0)
+	  pfatal_with_name ("pipe");
+
+	pr_pid = fork ();
+	if (pr_pid < 0)
+	  pfatal_with_name ("fork");
+
+	if (pr_pid == 0)
+	  {
+	    close (pipes[1]);
+	    if (pipes[0] != STDIN_FILENO)
+	      {
+		if (dup2 (pipes[0], STDIN_FILENO) < 0)
+		  pfatal_with_name ("dup2");
+		close (pipes[0]);
+	      }
+
+	    execv (pr_program, (char **) argv);
+	    _exit (errno == ENOENT ? 127 : 126);
+	  }
+	else
+	  {
+	    close (pipes[0]);
+	    outfile = fdopen (pipes[1], "w");
+	    if (!outfile)
+	      pfatal_with_name ("fdopen");
+	    check_color_output (true);
+	  }
+#else
+	char *command = system_quote_argv (SCI_SYSTEM, (char **) argv);
+	errno = 0;
+	outfile = popen (command, "w");
+	if (!outfile)
+	  pfatal_with_name (command);
+	check_color_output (true);
+	free (command);
+#endif
+      }
+    }
+  else
+    {
+
+      /* If -l was not specified, output the diff straight to 'stdout'.  */
+
+      outfile = stdout;
+      check_color_output (false);
+
+      /* If handling multiple files (because scanning a directory),
+	 print which files the following output is about.  */
+      if (currently_recursive)
+	printf ("%s\n", name);
+    }
+
+  free (name);
+
+  /* A special header is needed at the beginning of context output.  */
+  switch (output_style)
+    {
+    case OUTPUT_CONTEXT:
+      print_context_header (files, (char const *const *)names, false);
+      break;
+
+    case OUTPUT_UNIFIED:
+      print_context_header (files, (char const *const *)names, true);
+      break;
+
+    default:
+      break;
+    }
+
+  if (names[0] != current_name0)
+    free (names[0]);
+  if (names[1] != current_name1)
+    free (names[1]);
+}
+
+/* Call after the end of output of diffs for one file.
+   Close OUTFILE and get rid of the 'pr' subfork.  */
+
+void
+finish_output (void)
+{
+  if (outfile != 0 && outfile != stdout)
+    {
+      int status;
+      int wstatus;
+      int werrno = 0;
+      if (ferror (outfile))
+	fatal ("write failed");
+#if ! HAVE_WORKING_FORK
+      wstatus = pclose (outfile);
+      if (wstatus == -1)
+	werrno = errno;
+#else
+      if (fclose (outfile) != 0)
+	pfatal_with_name (_("write failed"));
+      if (waitpid (pr_pid, &wstatus, 0) < 0)
+	pfatal_with_name ("waitpid");
+#endif
+      status = (! werrno && WIFEXITED (wstatus)
+		? WEXITSTATUS (wstatus)
+		: INT_MAX);
+      if (status)
+	die (EXIT_TROUBLE, werrno,
+	       _(status == 126
+		 ? "subsidiary program '%s' could not be invoked"
+		 : status == 127
+		 ? "subsidiary program '%s' not found"
+		 : status == INT_MAX
+		 ? "subsidiary program '%s' failed"
+		 : "subsidiary program '%s' failed (exit status %d)"),
+	       pr_program, status);
+    }
+
+  outfile = 0;
+}
+
+/* Compare two lines (typically one from each input file)
+   according to the command line options.
+   For efficiency, this is invoked only when the lines do not match exactly
+   but an option like -i might cause us to ignore the difference.
+   Return nonzero if the lines differ.  */
+
+bool
+lines_differ (char const *s1, char const *s2)
+{
+  register char const *t1 = s1;
+  register char const *t2 = s2;
+  size_t column = 0;
+
+  while (1)
+    {
+      register unsigned char c1 = *t1++;
+      register unsigned char c2 = *t2++;
+
+      /* Test for exact char equality first, since it's a common case.  */
+      if (c1 != c2)
+	{
+	  switch (ignore_white_space)
+	    {
+	    case IGNORE_ALL_SPACE:
+	      /* For -w, just skip past any white space.  */
+	      while (isspace (c1) && c1 != '\n') c1 = *t1++;
+	      while (isspace (c2) && c2 != '\n') c2 = *t2++;
+	      break;
+
+	    case IGNORE_SPACE_CHANGE:
+	      /* For -b, advance past any sequence of white space in
+		 line 1 and consider it just one space, or nothing at
+		 all if it is at the end of the line.  */
+	      if (isspace (c1))
+		{
+		  while (c1 != '\n')
+		    {
+		      c1 = *t1++;
+		      if (! isspace (c1))
+			{
+			  --t1;
+			  c1 = ' ';
+			  break;
+			}
+		    }
+		}
+
+	      /* Likewise for line 2.  */
+	      if (isspace (c2))
+		{
+		  while (c2 != '\n')
+		    {
+		      c2 = *t2++;
+		      if (! isspace (c2))
+			{
+			  --t2;
+			  c2 = ' ';
+			  break;
+			}
+		    }
+		}
+
+	      if (c1 != c2)
+		{
+		  /* If we went too far when doing the simple test
+		     for equality, go back to the first non-white-space
+		     character in both sides and try again.  */
+		  if (c2 == ' ' && c1 != '\n'
+		      && s1 + 1 < t1
+		      && isspace ((unsigned char) t1[-2]))
+		    {
+		      --t1;
+		      continue;
+		    }
+		  if (c1 == ' ' && c2 != '\n'
+		      && s2 + 1 < t2
+		      && isspace ((unsigned char) t2[-2]))
+		    {
+		      --t2;
+		      continue;
+		    }
+		}
+
+	      break;
+
+	    case IGNORE_TRAILING_SPACE:
+	    case IGNORE_TAB_EXPANSION_AND_TRAILING_SPACE:
+	      if (isspace (c1) && isspace (c2))
+		{
+		  unsigned char c;
+		  if (c1 != '\n')
+		    {
+		      char const *p = t1;
+		      while ((c = *p) != '\n' && isspace (c))
+			++p;
+		      if (c != '\n')
+			break;
+		    }
+		  if (c2 != '\n')
+		    {
+		      char const *p = t2;
+		      while ((c = *p) != '\n' && isspace (c))
+			++p;
+		      if (c != '\n')
+			break;
+		    }
+		  /* Both lines have nothing but whitespace left.  */
+		  return false;
+		}
+	      if (ignore_white_space == IGNORE_TRAILING_SPACE)
+		break;
+	      FALLTHROUGH;
+	    case IGNORE_TAB_EXPANSION:
+	      if ((c1 == ' ' && c2 == '\t')
+		  || (c1 == '\t' && c2 == ' '))
+		{
+		  size_t column2 = column;
+		  for (;; c1 = *t1++)
+		    {
+		      if (c1 == ' ')
+			column++;
+		      else if (c1 == '\t')
+			column += tabsize - column % tabsize;
+		      else
+			break;
+		    }
+		  for (;; c2 = *t2++)
+		    {
+		      if (c2 == ' ')
+			column2++;
+		      else if (c2 == '\t')
+			column2 += tabsize - column2 % tabsize;
+		      else
+			break;
+		    }
+		  if (column != column2)
+		    return true;
+		}
+	      break;
+
+	    case IGNORE_NO_WHITE_SPACE:
+	      break;
+	    }
+
+	  /* Lowercase all letters if -i is specified.  */
+
+	  if (ignore_case)
+	    {
+	      c1 = tolower (c1);
+	      c2 = tolower (c2);
+	    }
+
+	  if (c1 != c2)
+	    break;
+	}
+      if (c1 == '\n')
+	return false;
+
+      column += c1 == '\t' ? tabsize - column % tabsize : 1;
+    }
+
+  return true;
+}
+
+/* Find the consecutive changes at the start of the script START.
+   Return the last link before the first gap.  */
+
+struct change * _GL_ATTRIBUTE_CONST
+find_change (struct change *start)
+{
+  return start;
+}
+
+struct change * _GL_ATTRIBUTE_CONST
+find_reverse_change (struct change *start)
+{
+  return start;
+}
+
+/* Divide SCRIPT into pieces by calling HUNKFUN and
+   print each piece with PRINTFUN.
+   Both functions take one arg, an edit script.
+
+   HUNKFUN is called with the tail of the script
+   and returns the last link that belongs together with the start
+   of the tail.
+
+   PRINTFUN takes a subscript which belongs together (with a null
+   link at the end) and prints it.  */
+
+void
+print_script (struct change *script,
+	      struct change * (*hunkfun) (struct change *),
+	      void (*printfun) (struct change *))
+{
+  struct change *next = script;
+
+  while (next)
+    {
+      struct change *this, *end;
+
+      /* Find a set of changes that belong together.  */
+      this = next;
+      end = (*hunkfun) (next);
+
+      /* Disconnect them from the rest of the changes,
+	 making them a hunk, and remember the rest for next iteration.  */
+      next = end->link;
+      end->link = 0;
+#ifdef DEBUG
+      debug_script (this);
+#endif
+
+      /* Print this hunk.  */
+      (*printfun) (this);
+
+      /* Reconnect the script so it will all be freed properly.  */
+      end->link = next;
+    }
+}
+
+/* Print the text of a single line LINE,
+   flagging it with the characters in LINE_FLAG (which say whether
+   the line is inserted, deleted, changed, etc.).  LINE_FLAG must not
+   end in a blank, unless it is a single blank.  */
+
+void
+print_1_line (char const *line_flag, char const *const *line)
+{
+  print_1_line_nl (line_flag, line, false);
+}
+
+/* Print the text of a single line LINE,
+   flagging it with the characters in LINE_FLAG (which say whether
+   the line is inserted, deleted, changed, etc.).  LINE_FLAG must not
+   end in a blank, unless it is a single blank.  If SKIP_NL is set, then
+   the final '\n' is not printed.  */
+
+void
+print_1_line_nl (char const *line_flag, char const *const *line, bool skip_nl)
+{
+  char const *base = line[0], *limit = line[1]; /* Help the compiler.  */
+  FILE *out = outfile; /* Help the compiler some more.  */
+  char const *flag_format = 0;
+
+  /* If -T was specified, use a Tab between the line-flag and the text.
+     Otherwise use a Space (as Unix diff does).
+     Print neither space nor tab if line-flags are empty.
+     But omit trailing blanks if requested.  */
+
+  if (line_flag && *line_flag)
+    {
+      char const *flag_format_1 = flag_format = initial_tab ? "%s\t" : "%s ";
+      char const *line_flag_1 = line_flag;
+
+      if (suppress_blank_empty && **line == '\n')
+	{
+	  flag_format_1 = "%s";
+
+	  /* This hack to omit trailing blanks takes advantage of the
+	     fact that the only way that LINE_FLAG can end in a blank
+	     is when LINE_FLAG consists of a single blank.  */
+	  line_flag_1 += *line_flag_1 == ' ';
+	}
+
+      fprintf (out, flag_format_1, line_flag_1);
+    }
+
+  output_1_line (base, limit - (skip_nl && limit[-1] == '\n'), flag_format, line_flag);
+
+  if ((!line_flag || line_flag[0]) && limit[-1] != '\n')
+    {
+      set_color_context (RESET_CONTEXT);
+      fprintf (out, "\n\\ %s\n", _("No newline at end of file"));
+    }
+}
+
+/* Output a line from BASE up to LIMIT.
+   With -t, expand white space characters to spaces, and if FLAG_FORMAT
+   is nonzero, output it with argument LINE_FLAG after every
+   internal carriage return, so that tab stops continue to line up.  */
+
+void
+output_1_line (char const *base, char const *limit, char const *flag_format,
+	       char const *line_flag)
+{
+  const size_t MAX_CHUNK = 1024;
+  if (!expand_tabs)
+    {
+      size_t left = limit - base;
+      while (left)
+        {
+          size_t to_write = MIN (left, MAX_CHUNK);
+          size_t written = fwrite (base, sizeof (char), to_write, outfile);
+          if (written < to_write)
+            return;
+          base += written;
+          left -= written;
+          process_signals ();
+        }
+    }
+  else
+    {
+      register FILE *out = outfile;
+      register unsigned char c;
+      register char const *t = base;
+      register size_t column = 0;
+      size_t tab_size = tabsize;
+      size_t counter_proc_signals = 0;
+
+      while (t < limit)
+        {
+          counter_proc_signals++;
+          if (counter_proc_signals == MAX_CHUNK)
+            {
+              process_signals ();
+              counter_proc_signals = 0;
+            }
+
+          switch ((c = *t++))
+            {
+            case '\t':
+              {
+                size_t spaces = tab_size - column % tab_size;
+                column += spaces;
+                do
+                  putc (' ', out);
+                while (--spaces);
+              }
+              break;
+
+            case '\r':
+              putc (c, out);
+              if (flag_format && t < limit && *t != '\n')
+                fprintf (out, flag_format, line_flag);
+              column = 0;
+              break;
+
+            case '\b':
+              if (column == 0)
+                continue;
+              column--;
+              putc (c, out);
+              break;
+
+            default:
+              column += isprint (c) != 0;
+              putc (c, out);
+              break;
+            }
+        }
+    }
+}
+
+enum indicator_no
+  {
+    C_LEFT, C_RIGHT, C_END, C_RESET, C_HEADER, C_ADD, C_DELETE, C_LINE
+  };
+
+static void
+put_indicator (const struct bin_str *ind)
+{
+  fwrite (ind->string, ind->len, 1, outfile);
+}
+
+static enum color_context last_context = RESET_CONTEXT;
+
+void
+set_color_context (enum color_context color_context)
+{
+  if (color_context != RESET_CONTEXT)
+    process_signals ();
+  if (colors_enabled && last_context != color_context)
+    {
+      put_indicator (&color_indicator[C_LEFT]);
+      switch (color_context)
+        {
+        case HEADER_CONTEXT:
+          put_indicator (&color_indicator[C_HEADER]);
+          break;
+
+        case LINE_NUMBER_CONTEXT:
+          put_indicator (&color_indicator[C_LINE]);
+          break;
+
+        case ADD_CONTEXT:
+          put_indicator (&color_indicator[C_ADD]);
+          break;
+
+        case DELETE_CONTEXT:
+          put_indicator (&color_indicator[C_DELETE]);
+          break;
+
+        case RESET_CONTEXT:
+          put_indicator (&color_indicator[C_RESET]);
+          break;
+
+        default:
+          abort ();
+        }
+      put_indicator (&color_indicator[C_RIGHT]);
+      last_context = color_context;
+    }
+}
+
+
+char const change_letter[] = { 0, 'd', 'a', 'c' };
+
+/* Translate an internal line number (an index into diff's table of lines)
+   into an actual line number in the input file.
+   The internal line number is I.  FILE points to the data on the file.
+
+   Internal line numbers count from 0 starting after the prefix.
+   Actual line numbers count from 1 within the entire file.  */
+
+lin _GL_ATTRIBUTE_PURE
+translate_line_number (struct file_data const *file, lin i)
+{
+  return i + file->prefix_lines + 1;
+}
+
+/* Translate a line number range.  This is always done for printing,
+   so for convenience translate to printint rather than lin, so that the
+   caller can use printf with "%"pI"d" without casting.  */
+
+void
+translate_range (struct file_data const *file,
+		 lin a, lin b,
+		 printint *aptr, printint *bptr)
+{
+  *aptr = translate_line_number (file, a - 1) + 1;
+  *bptr = translate_line_number (file, b + 1) - 1;
+}
+
+/* Print a pair of line numbers with SEPCHAR, translated for file FILE.
+   If the two numbers are identical, print just one number.
+
+   Args A and B are internal line numbers.
+   We print the translated (real) line numbers.  */
+
+void
+print_number_range (char sepchar, struct file_data *file, lin a, lin b)
+{
+  printint trans_a, trans_b;
+  translate_range (file, a, b, &trans_a, &trans_b);
+
+  /* Note: we can have B < A in the case of a range of no lines.
+     In this case, we should print the line number before the range,
+     which is B.  */
+  if (trans_b > trans_a)
+    fprintf (outfile, "%"pI"d%c%"pI"d", trans_a, sepchar, trans_b);
+  else
+    fprintf (outfile, "%"pI"d", trans_b);
+}
+
+/* Look at a hunk of edit script and report the range of lines in each file
+   that it applies to.  HUNK is the start of the hunk, which is a chain
+   of 'struct change'.  The first and last line numbers of file 0 are stored in
+   *FIRST0 and *LAST0, and likewise for file 1 in *FIRST1 and *LAST1.
+   Note that these are internal line numbers that count from 0.
+
+   If no lines from file 0 are deleted, then FIRST0 is LAST0+1.
+
+   Return UNCHANGED if only ignorable lines are inserted or deleted,
+   OLD if lines of file 0 are deleted,
+   NEW if lines of file 1 are inserted,
+   and CHANGED if both kinds of changes are found. */
+
+enum changes
+analyze_hunk (struct change *hunk,
+	      lin *first0, lin *last0,
+	      lin *first1, lin *last1)
+{
+  struct change *next;
+  lin l0, l1;
+  lin show_from, show_to;
+  lin i;
+  bool trivial = ignore_blank_lines || ignore_regexp.fastmap;
+  size_t trivial_length = ignore_blank_lines - 1;
+    /* If 0, ignore zero-length lines;
+       if SIZE_MAX, do not ignore lines just because of their length.  */
+
+  bool skip_white_space =
+    ignore_blank_lines && IGNORE_TRAILING_SPACE <= ignore_white_space;
+  bool skip_leading_white_space =
+    skip_white_space && IGNORE_SPACE_CHANGE <= ignore_white_space;
+
+  char const * const *linbuf0 = files[0].linbuf;  /* Help the compiler.  */
+  char const * const *linbuf1 = files[1].linbuf;
+
+  show_from = show_to = 0;
+
+  *first0 = hunk->line0;
+  *first1 = hunk->line1;
+
+  next = hunk;
+  do
+    {
+      l0 = next->line0 + next->deleted - 1;
+      l1 = next->line1 + next->inserted - 1;
+      show_from += next->deleted;
+      show_to += next->inserted;
+
+      for (i = next->line0; i <= l0 && trivial; i++)
+	{
+	  char const *line = linbuf0[i];
+	  char const *lastbyte = linbuf0[i + 1] - 1;
+	  char const *newline = lastbyte + (*lastbyte != '\n');
+	  size_t len = newline - line;
+	  char const *p = line;
+	  if (skip_white_space)
+	    for (; *p != '\n'; p++)
+	      if (! isspace ((unsigned char) *p))
+		{
+		  if (! skip_leading_white_space)
+		    p = line;
+		  break;
+		}
+	  if (newline - p != trivial_length
+	      && (! ignore_regexp.fastmap
+		  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
+	    trivial = 0;
+	}
+
+      for (i = next->line1; i <= l1 && trivial; i++)
+	{
+	  char const *line = linbuf1[i];
+	  char const *lastbyte = linbuf1[i + 1] - 1;
+	  char const *newline = lastbyte + (*lastbyte != '\n');
+	  size_t len = newline - line;
+	  char const *p = line;
+	  if (skip_white_space)
+	    for (; *p != '\n'; p++)
+	      if (! isspace ((unsigned char) *p))
+		{
+		  if (! skip_leading_white_space)
+		    p = line;
+		  break;
+		}
+	  if (newline - p != trivial_length
+	      && (! ignore_regexp.fastmap
+		  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
+	    trivial = 0;
+	}
+    }
+  while ((next = next->link) != 0);
+
+  *last0 = l0;
+  *last1 = l1;
+
+  /* If all inserted or deleted lines are ignorable,
+     tell the caller to ignore this hunk.  */
+
+  if (trivial)
+    return UNCHANGED;
+
+  return (show_from ? OLD : UNCHANGED) | (show_to ? NEW : UNCHANGED);
+}
+
+/* Concatenate three strings, returning a newly malloc'd string.  */
+
+char *
+concat (char const *s1, char const *s2, char const *s3)
+{
+  char *new = xmalloc (strlen (s1) + strlen (s2) + strlen (s3) + 1);
+  sprintf (new, "%s%s%s", s1, s2, s3);
+  return new;
+}
+
+/* Yield a new block of SIZE bytes, initialized to zero.  */
+
+void *
+zalloc (size_t size)
+{
+  void *p = xmalloc (size);
+  memset (p, 0, size);
+  return p;
+}
+
+void
+debug_script (struct change *sp)
+{
+  fflush (stdout);
+
+  for (; sp; sp = sp->link)
+    {
+      printint line0 = sp->line0;
+      printint line1 = sp->line1;
+      printint deleted = sp->deleted;
+      printint inserted = sp->inserted;
+      fprintf (stderr, "%3"pI"d %3"pI"d delete %"pI"d insert %"pI"d\n",
+	       line0, line1, deleted, inserted);
+    }
+
+  fflush (stderr);
+}
diff --git a/test/quote-3.0-test.txt b/test/quote-3.0-test.txt
new file mode 100644
index 0000000..7e06a0b
--- /dev/null
+++ b/test/quote-3.0-test.txt
@@ -0,0 +1,5088 @@
+diff -pru diffutils-3.0/analyze.c diffutils-3.0-patch/analyze.c
+--- diffutils-3.0/analyze.c	2019-03-16 02:28:09.278890000 -0700
++++ diffutils-3.0-patch/analyze.c	2019-03-16 02:29:47.145185000 -0700
+@@ -1,7 +1,7 @@
+ /* Analyze file differences for GNU DIFF.
+ 
+    Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006-2007,
+-   2009-2013, 2015-2017 Free Software Foundation, Inc.
++   2009-2010 Free Software Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -38,7 +38,7 @@
+ 
+    A line which is discarded will not be considered by the actual
+    comparison algorithm; it will be as if that line were not in the file.
+-   The file's 'realindexes' table maps virtual line numbers
++   The file's `realindexes' table maps virtual line numbers
+    (which don't count the discarded lines) into real line numbers;
+    this is how the actual comparison algorithm produces results
+    that are comprehensible when the discarded lines are counted.
+@@ -251,7 +251,7 @@ discard_confusing_lines (struct file_dat
+    We do something when a run of changed lines include a
+    line at one end and have an excluded, identical line at the other.
+    We are free to choose which identical line is included.
+-   'compareseq' usually chooses the one at the beginning,
++   `compareseq' usually chooses the one at the beginning,
+    but usually it is cleaner to consider the following identical line
+    to be the "change".  */
+ 
+@@ -445,16 +445,26 @@ build_script (struct file_data const fil
+   return script;
+ }
+ 
+-/* If CHANGES, briefly report that two files differed.  */
+-static void
++/* If CHANGES, briefly report that two files differed.
++   Return 2 if trouble, CHANGES otherwise.  */
++static int
+ briefly_report (int changes, struct file_data const filevec[])
+ {
+   if (changes)
+-    message ((brief
+-	      ? _("Files %s and %s differ\n")
+-	      : _("Binary files %s and %s differ\n")),
+-	     file_label[0] ? file_label[0] : filevec[0].name,
+-	     file_label[1] ? file_label[1] : filevec[1].name);
++    {
++      char const *label0 = file_label[0] ? file_label[0] : filevec[0].name;
++      char const *label1 = file_label[1] ? file_label[1] : filevec[1].name;
++
++      if (brief)
++	message ("Files %s and %s differ\n", label0, label1);
++      else
++	{
++	  message ("Binary files %s and %s differ\n", label0, label1);
++	  changes = 2;
++	}
++    }
++
++  return changes;
+ }
+ 
+ /* Report the differences of two files.  */
+@@ -477,8 +487,6 @@ diff_2_files (struct comparison *cmp)
+     {
+       /* Files with different lengths must be different.  */
+       if (cmp->file[0].stat.st_size != cmp->file[1].stat.st_size
+-	  && 0 < cmp->file[0].stat.st_size
+-	  && 0 < cmp->file[1].stat.st_size
+ 	  && (cmp->file[0].desc < 0 || S_ISREG (cmp->file[0].stat.st_mode))
+ 	  && (cmp->file[1].desc < 0 || S_ISREG (cmp->file[1].stat.st_mode)))
+ 	changes = 1;
+@@ -528,7 +536,7 @@ diff_2_files (struct comparison *cmp)
+ 	    }
+ 	}
+ 
+-      briefly_report (changes, cmp->file);
++      changes = briefly_report (changes, cmp->file);
+     }
+   else
+     {
+@@ -566,13 +574,12 @@ diff_2_files (struct comparison *cmp)
+ 
+       ctxt.heuristic = speed_large_files;
+ 
+-      /* Set TOO_EXPENSIVE to be the approximate square root of the
+-	 input size, bounded below by 4096.  4096 seems to be good for
+-	 circa-2016 CPUs; see Bug#16848 and Bug#24715.  */
++      /* Set TOO_EXPENSIVE to be approximate square root of input size,
++	 bounded below by 256.  */
+       too_expensive = 1;
+       for (;  diags != 0;  diags >>= 2)
+ 	too_expensive <<= 1;
+-      ctxt.too_expensive = MAX (4096, too_expensive);
++      ctxt.too_expensive = MAX (256, too_expensive);
+ 
+       files[0] = cmp->file[0];
+       files[1] = cmp->file[1];
+@@ -588,7 +595,7 @@ diff_2_files (struct comparison *cmp)
+       shift_boundaries (cmp->file);
+ 
+       /* Get the results of comparison in the form of a chain
+-	 of 'struct change's -- an edit script.  */
++	 of `struct change's -- an edit script.  */
+ 
+       if (output_style == OUTPUT_ED)
+ 	script = build_reverse_script (cmp->file);
+@@ -628,7 +635,7 @@ diff_2_files (struct comparison *cmp)
+ 	changes = (script != 0);
+ 
+       if (brief)
+-	briefly_report (changes, cmp->file);
++	changes = briefly_report (changes, cmp->file);
+       else
+ 	{
+ 	  if (changes || !no_diff_means_no_output)
+Only in diffutils-3.0-patch: analyze.o
+Only in diffutils-3.0-patch: cmp
+diff -pru diffutils-3.0/cmp.c diffutils-3.0-patch/cmp.c
+--- diffutils-3.0/cmp.c	2019-03-16 02:28:09.280890000 -0700
++++ diffutils-3.0-patch/cmp.c	2019-03-16 02:29:47.359200000 -0700
+@@ -1,7 +1,7 @@
+ /* cmp - compare two files byte by byte
+ 
+-   Copyright (C) 1990-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2013,
+-   2015-2017 Free Software Foundation, Inc.
++   Copyright (C) 1990-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2010 Free
++   Software Foundation, Inc.
+ 
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+@@ -23,7 +23,6 @@
+ 
+ #include <c-stack.h>
+ #include <cmpbuf.h>
+-#include "die.h"
+ #include <error.h>
+ #include <exitfail.h>
+ #include <file-type.h>
+@@ -34,10 +33,10 @@
+ #include <unlocked-io.h>
+ #include <version-etc.h>
+ #include <xalloc.h>
+-#include <binary-io.h>
++#include <xfreopen.h>
+ #include <xstrtol.h>
+ 
+-/* The official name of this program (e.g., no 'g' prefix).  */
++/* The official name of this program (e.g., no `g' prefix).  */
+ #define PROGRAM_NAME "cmp"
+ 
+ #define AUTHORS \
+@@ -52,8 +51,8 @@
+ 
+ static int cmp (void);
+ static off_t file_position (int);
+-static size_t block_compare (word const *, word const *) _GL_ATTRIBUTE_PURE;
+-static size_t count_newlines (char *, size_t);
++static size_t block_compare (word const *, word const *);
++static size_t block_compare_and_count (word const *, word const *, off_t *);
+ static void sprintc (char *, unsigned char);
+ 
+ /* Filenames of the compared files.  */
+@@ -115,8 +114,9 @@ try_help (char const *reason_msgid, char
+ {
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+-  die (EXIT_TROUBLE, 0,
++  error (EXIT_TROUBLE, 0,
+ 	 _("Try '%s --help' for more information."), program_name);
++  abort ();
+ }
+ 
+ static char const valid_suffixes[] = "kKMGTPEZY0";
+@@ -152,21 +152,21 @@ static void
+ check_stdout (void)
+ {
+   if (ferror (stdout))
+-    die (EXIT_TROUBLE, 0, "%s", _("write failed"));
++    error (EXIT_TROUBLE, 0, "%s", _("write failed"));
+   else if (fclose (stdout) != 0)
+-    die (EXIT_TROUBLE, errno, "%s", _("standard output"));
++    error (EXIT_TROUBLE, errno, "%s", _("standard output"));
+ }
+ 
+ static char const * const option_help_msgid[] = {
+-  N_("-b, --print-bytes          print differing bytes"),
+-  N_("-i, --ignore-initial=SKIP         skip first SKIP bytes of both inputs"),
+-  N_("-i, --ignore-initial=SKIP1:SKIP2  skip first SKIP1 bytes of FILE1 and\n"
+-     "                                      first SKIP2 bytes of FILE2"),
+-  N_("-l, --verbose              output byte numbers and differing byte values"),
+-  N_("-n, --bytes=LIMIT          compare at most LIMIT bytes"),
+-  N_("-s, --quiet, --silent      suppress all normal output"),
+-  N_("    --help                 display this help and exit"),
+-  N_("-v, --version              output version information and exit"),
++  N_("-b  --print-bytes  Print differing bytes."),
++  N_("-i SKIP  --ignore-initial=SKIP  Skip the first SKIP bytes of input."),
++  N_("-i SKIP1:SKIP2  --ignore-initial=SKIP1:SKIP2"),
++  N_("  Skip the first SKIP1 bytes of FILE1 and the first SKIP2 bytes of FILE2."),
++  N_("-l  --verbose  Output byte numbers and values of all differing bytes."),
++  N_("-n LIMIT  --bytes=LIMIT  Compare at most LIMIT bytes."),
++  N_("-s  --quiet  --silent  Output nothing; yield exit status only."),
++  N_("-v  --version  Output version info."),
++  N_("--help  Output this help."),
+   0
+ };
+ 
+@@ -177,17 +177,11 @@ usage (void)
+ 
+   printf (_("Usage: %s [OPTION]... FILE1 [FILE2 [SKIP1 [SKIP2]]]\n"),
+ 	  program_name);
+-  printf ("%s\n", _("Compare two files byte by byte."));
+-  printf ("\n%s\n\n",
+-_("The optional SKIP1 and SKIP2 specify the number of bytes to skip\n"
+-  "at the beginning of each file (zero by default)."));
+-
+-  fputs (_("\
+-Mandatory arguments to long options are mandatory for short options too.\n\
+-"), stdout);
++  printf ("%s\n\n", _("Compare two files byte by byte."));
+   for (p = option_help_msgid;  *p;  p++)
+     printf ("  %s\n", _(*p));
+-  printf ("\n%s\n\n%s\n%s\n",
++  printf ("\n%s\n%s\n\n%s\n%s\n",
++	  _("SKIP1 and SKIP2 are the number of bytes to skip in each file."),
+ 	  _("SKIP values may be followed by the following multiplicative suffixes:\n\
+ kB 1000, K 1024, MB 1,000,000, M 1,048,576,\n\
+ GB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y."),
+@@ -248,7 +242,7 @@ main (int argc, char **argv)
+ 	break;
+ 
+       case 'v':
+-	version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version,
++	version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+ 		     AUTHORS, (char *) NULL);
+ 	check_stdout ();
+ 	return EXIT_SUCCESS;
+@@ -293,7 +287,7 @@ main (int argc, char **argv)
+ 	{
+ 	  file_desc[f1] = STDIN_FILENO;
+ 	  if (O_BINARY && ! isatty (STDIN_FILENO))
+-	    set_binary_mode (STDIN_FILENO, O_BINARY);
++	    xfreopen (NULL, "rb", stdin);
+ 	}
+       else
+ 	file_desc[f1] = open (file[f1], O_RDONLY | O_BINARY, 0);
+@@ -303,7 +297,7 @@ main (int argc, char **argv)
+ 	  if (file_desc[f1] < 0 && comparison_type == type_status)
+ 	    exit (EXIT_TROUBLE);
+ 	  else
+-	    die (EXIT_TROUBLE, errno, "%s", file[f1]);
++	    error (EXIT_TROUBLE, errno, "%s", file[f1]);
+ 	}
+     }
+ 
+@@ -363,28 +357,27 @@ main (int argc, char **argv)
+ 
+   for (f = 0; f < 2; f++)
+     if (close (file_desc[f]) != 0)
+-      die (EXIT_TROUBLE, errno, "%s", file[f]);
++      error (EXIT_TROUBLE, errno, "%s", file[f]);
+   if (exit_status != EXIT_SUCCESS && comparison_type < type_no_stdout)
+     check_stdout ();
+   exit (exit_status);
+   return exit_status;
+ }
+ 
+-/* Compare the two files already open on 'file_desc[0]' and 'file_desc[1]',
+-   using 'buffer[0]' and 'buffer[1]'.
++/* Compare the two files already open on `file_desc[0]' and `file_desc[1]',
++   using `buffer[0]' and `buffer[1]'.
+    Return EXIT_SUCCESS if identical, EXIT_FAILURE if different,
+    >1 if error.  */
+ 
+ static int
+ cmp (void)
+ {
+-  bool at_line_start = true;
+   off_t line_number = 1;	/* Line number (1...) of difference. */
+   off_t byte_number = 1;	/* Byte number (1...) of difference. */
+   uintmax_t remaining = bytes;	/* Remaining number of bytes to compare.  */
+   size_t read0, read1;		/* Number of bytes read from each file. */
+   size_t first_diff;		/* Offset (0...) in buffers of 1st diff. */
+-  size_t smaller;		/* The lesser of 'read0' and 'read1'. */
++  size_t smaller;		/* The lesser of `read0' and `read1'. */
+   word *buffer0 = buffer[0];
+   word *buffer1 = buffer[1];
+   char *buf0 = (char *) buffer0;
+@@ -422,7 +415,7 @@ cmp (void)
+ 	      if (r != bytes_to_read)
+ 		{
+ 		  if (r == SIZE_MAX)
+-		    die (EXIT_TROUBLE, errno, "%s", file[f]);
++		    error (EXIT_TROUBLE, errno, "%s", file[f]);
+ 		  break;
+ 		}
+ 	      ig -= r;
+@@ -444,31 +437,25 @@ cmp (void)
+ 
+       read0 = block_read (file_desc[0], buf0, bytes_to_read);
+       if (read0 == SIZE_MAX)
+-	die (EXIT_TROUBLE, errno, "%s", file[0]);
++	error (EXIT_TROUBLE, errno, "%s", file[0]);
+       read1 = block_read (file_desc[1], buf1, bytes_to_read);
+       if (read1 == SIZE_MAX)
+-	die (EXIT_TROUBLE, errno, "%s", file[1]);
++	error (EXIT_TROUBLE, errno, "%s", file[1]);
+ 
+-      smaller = MIN (read0, read1);
++      /* Insert sentinels for the block compare.  */
+ 
+-      /* Optimize the common case where the buffers are the same.  */
+-      if (memcmp (buf0, buf1, smaller) == 0)
+-	first_diff = smaller;
+-      else
+-	{
+-	  /* Insert sentinels for the block compare.  */
+-	  buf0[read0] = ~buf1[read0];
+-	  buf1[read1] = ~buf0[read1];
++      buf0[read0] = ~buf1[read0];
++      buf1[read1] = ~buf0[read1];
+ 
+-	  first_diff = block_compare (buffer0, buffer1);
+-	}
++      /* If the line number should be written for differing files,
++	 compare the blocks and count the number of newlines
++	 simultaneously.  */
++      first_diff = (comparison_type == type_first_diff
++		    ? block_compare_and_count (buffer0, buffer1, &line_number)
++		    : block_compare (buffer0, buffer1));
+ 
+       byte_number += first_diff;
+-      if (comparison_type == type_first_diff && first_diff != 0)
+-	{
+-	  line_number += count_newlines (buf0, first_diff);
+-	  at_line_start = buf0[first_diff - 1] == '\n';
+-	}
++      smaller = MIN (read0, read1);
+ 
+       if (first_diff < smaller)
+ 	{
+@@ -482,9 +469,9 @@ cmp (void)
+ 		char const *line_num = offtostr (line_number, line_buf);
+ 		if (!opt_print_bytes)
+ 		  {
+-		    /* See POSIX for this format.  This message is
+-		       used only in the POSIX locale, so it need not
+-		       be translated.  */
++		    /* See POSIX 1003.1-2001 for this format.  This
++		       message is used only in the POSIX locale, so it
++		       need not be translated.  */
+ 		    static char const char_message[] =
+ 		      "%s %s differ: char %s, line %s\n";
+ 
+@@ -514,9 +501,9 @@ cmp (void)
+ 		    printf (_("%s %s differ: byte %s, line %s is %3o %s %3o %s\n"),
+ 			    file[0], file[1], byte_num, line_num,
+ 			    c0, s0, c1, s1);
+-		  }
++		}
+ 	      }
+-	      FALLTHROUGH;
++	      /* Fall through.  */
+ 	    case type_status:
+ 	      return EXIT_FAILURE;
+ 
+@@ -531,7 +518,7 @@ cmp (void)
+ 		      char const *byte_num = offtostr (byte_number, byte_buf);
+ 		      if (!opt_print_bytes)
+ 			{
+-			  /* See POSIX for this format.  */
++			  /* See POSIX 1003.1-2001 for this format.  */
+ 			  printf ("%*s %3o %3o\n",
+ 				  offset_width, byte_num, c0, c1);
+ 			}
+@@ -562,36 +549,8 @@ cmp (void)
+ 	{
+ 	  if (differing <= 0 && comparison_type != type_status)
+ 	    {
+-	      char const *shorter_file = file[read1 < read0];
+-
+-	      /* POSIX says that each of these format strings must be
+-		 "cmp: EOF on %s", optionally followed by a blank and
+-		 extra text sans newline, then terminated by "\n".  */
+-	      if (byte_number == 1)
+-		fprintf (stderr, _("cmp: EOF on %s which is empty\n"),
+-			 shorter_file);
+-	      else
+-		{
+-		  char byte_buf[INT_BUFSIZE_BOUND (off_t)];
+-		  char const *byte_num = offtostr (byte_number - 1, byte_buf);
+-
+-		  if (comparison_type == type_first_diff)
+-		    {
+-		      char line_buf[INT_BUFSIZE_BOUND (off_t)];
+-		      char const *line_num
+-			= offtostr (line_number - at_line_start, line_buf);
+-		      fprintf (stderr,
+-			       (at_line_start
+-				? _("cmp: EOF on %s after byte %s, line %s\n")
+-				: _("cmp: EOF on %s after byte %s,"
+-				    " in line %s\n")),
+-			       shorter_file, byte_num, line_num);
+-		    }
+-		  else
+-		    fprintf (stderr,
+-			     _("cmp: EOF on %s after byte %s\n"),
+-			     shorter_file, byte_num);
+-		}
++	      /* See POSIX 1003.1-2001 for this format.  */
++	      fprintf (stderr, _("cmp: EOF on %s\n"), file[read1 < read0]);
+ 	    }
+ 
+ 	  return EXIT_FAILURE;
+@@ -602,6 +561,54 @@ cmp (void)
+   return differing == 0 ? EXIT_SUCCESS : EXIT_FAILURE;
+ }
+ 
++/* Compare two blocks of memory P0 and P1 until they differ,
++   and count the number of '\n' occurrences in the common
++   part of P0 and P1.
++   If the blocks are not guaranteed to be different, put sentinels at the ends
++   of the blocks before calling this function.
++
++   Return the offset of the first byte that differs.
++   Increment *COUNT by the count of '\n' occurrences.  */
++
++static size_t
++block_compare_and_count (word const *p0, word const *p1, off_t *count)
++{
++  word l;		/* One word from first buffer. */
++  word const *l0, *l1;	/* Pointers into each buffer. */
++  char const *c0, *c1;	/* Pointers for finding exact address. */
++  size_t cnt = 0;	/* Number of '\n' occurrences. */
++  word nnnn;		/* Newline, sizeof (word) times.  */
++  int i;
++
++  nnnn = 0;
++  for (i = 0; i < sizeof nnnn; i++)
++    nnnn = (nnnn << CHAR_BIT) | '\n';
++
++  /* Find the rough position of the first difference by reading words,
++     not bytes.  */
++
++  for (l0 = p0, l1 = p1;  (l = *l0) == *l1;  l0++, l1++)
++    {
++      l ^= nnnn;
++      for (i = 0; i < sizeof l; i++)
++	{
++	  unsigned char uc = l;
++	  cnt += ! uc;
++	  l >>= CHAR_BIT;
++	}
++    }
++
++  /* Find the exact differing position (endianness independent).  */
++
++  for (c0 = (char const *) l0, c1 = (char const *) l1;
++       *c0 == *c1;
++       c0++, c1++)
++    cnt += *c0 == '\n';
++
++  *count += cnt;
++  return c0 - (char const *) p0;
++}
++
+ /* Compare two blocks of memory P0 and P1 until they differ.
+    If the blocks are not guaranteed to be different, put sentinels at the ends
+    of the blocks before calling this function.
+@@ -630,21 +637,6 @@ block_compare (word const *p0, word cons
+   return c0 - (char const *) p0;
+ }
+ 
+-/* Return the number of newlines in BUF, of size BUFSIZE,
+-   where BUF[NBYTES] is available for use as a sentinel.  */
+-
+-static size_t
+-count_newlines (char *buf, size_t bufsize)
+-{
+-  size_t count = 0;
+-  char *p;
+-  char *lim = buf + bufsize;
+-  *lim = '\n';
+-  for (p = buf; (p = rawmemchr (p, '\n')) != lim; p++)
+-    count++;
+-  return count;
+-}
+-
+ /* Put into BUF the unsigned char C, making unprintable bytes
+    visible by quoting like cat -t does.  */
+ 
+Only in diffutils-3.0-patch: cmp.o
+diff -pru diffutils-3.0/context.c diffutils-3.0-patch/context.c
+--- diffutils-3.0/context.c	2019-03-16 02:28:09.282893000 -0700
++++ diffutils-3.0-patch/context.c	2019-03-16 02:29:47.363201000 -0700
+@@ -1,7 +1,7 @@
+ /* Context-format output routines for GNU DIFF.
+ 
+-   Copyright (C) 1988-1989, 1991-1995, 1998, 2001-2002, 2004, 2006, 2009-2013,
+-   2015-2017 Free Software Foundation, Inc.
++   Copyright (C) 1988-1989, 1991-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
++   Free Software Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -20,6 +20,7 @@
+ 
+ #include "diff.h"
+ #include "c-ctype.h"
++#include <inttostr.h>
+ #include <stat-time.h>
+ #include <strftime.h>
+ 
+@@ -40,7 +41,6 @@ static lin find_function_last_match;
+ static void
+ print_context_label (char const *mark,
+ 		     struct file_data *inf,
+-		     char const *name,
+ 		     char const *label)
+ {
+   if (label)
+@@ -71,27 +71,25 @@ print_context_label (char const *mark,
+ 	      sprintf (buf, "%"PRIuMAX".%.9d", sec, nsec);
+ 	    }
+ 	}
+-      fprintf (outfile, "%s %s\t%s\n", mark, name, buf);
++      fprintf (outfile, "%s %s\t%s\n", mark, inf->name, buf);
+     }
+ }
+ 
+ /* Print a header for a context diff, with the file names and dates.  */
+ 
+ void
+-print_context_header (struct file_data inf[], char const *const *names, bool unidiff)
++print_context_header (struct file_data inf[], bool unidiff)
+ {
+-  set_color_context (HEADER_CONTEXT);
+   if (unidiff)
+     {
+-      print_context_label ("---", &inf[0], names[0], file_label[0]);
+-      print_context_label ("+++", &inf[1], names[1], file_label[1]);
++      print_context_label ("---", &inf[0], file_label[0]);
++      print_context_label ("+++", &inf[1], file_label[1]);
+     }
+   else
+     {
+-      print_context_label ("***", &inf[0], names[0], file_label[0]);
+-      print_context_label ("---", &inf[1], names[1], file_label[1]);
++      print_context_label ("***", &inf[0], file_label[0]);
++      print_context_label ("---", &inf[1], file_label[1]);
+     }
+-  set_color_context (RESET_CONTEXT);
+ }
+ 
+ /* Print an edit script in context format.  */
+@@ -126,7 +124,7 @@ print_context_script (struct change *scr
+ static void
+ print_context_number_range (struct file_data const *file, lin a, lin b)
+ {
+-  printint trans_a, trans_b;
++  long int trans_a, trans_b;
+   translate_range (file, a, b, &trans_a, &trans_b);
+ 
+   /* We can have B <= A in the case of a range of no lines.
+@@ -139,9 +137,9 @@ print_context_number_range (struct file_
+      specification.  */
+ 
+   if (trans_b <= trans_a)
+-    fprintf (outfile, "%"pI"d", trans_b);
++    fprintf (outfile, "%ld", trans_b);
+   else
+-    fprintf (outfile, "%"pI"d,%"pI"d", trans_a, trans_b);
++    fprintf (outfile, "%ld,%ld", trans_a, trans_b);
+ }
+ 
+ /* Print FUNCTION in a context header.  */
+@@ -161,7 +159,7 @@ print_context_function (FILE *out, char
+ 
+ /* Print a portion of an edit script in context format.
+    HUNK is the beginning of the portion to be printed.
+-   The end is marked by a 'link' that has been nulled out.
++   The end is marked by a `link' that has been nulled out.
+ 
+    Prints out lines from both files, and precedes each
+    line with the appropriate flag-character.  */
+@@ -207,21 +205,14 @@ pr_context_hunk (struct change *hunk)
+   if (function)
+     print_context_function (out, function);
+ 
+-  putc ('\n', out);
+-  set_color_context (LINE_NUMBER_CONTEXT);
+-  fputs ("*** ", out);
++  fputs ("\n*** ", out);
+   print_context_number_range (&files[0], first0, last0);
+-  fputs (" ****", out);
+-  set_color_context (RESET_CONTEXT);
+-  putc ('\n', out);
++  fputs (" ****\n", out);
+ 
+   if (changes & OLD)
+     {
+       struct change *next = hunk;
+ 
+-      if (first0 <= last0)
+-        set_color_context (DELETE_CONTEXT);
+-
+       for (i = first0; i <= last0; i++)
+ 	{
+ 	  /* Skip past changes that apply (in file 0)
+@@ -234,34 +225,23 @@ pr_context_hunk (struct change *hunk)
+ 
+ 	  prefix = " ";
+ 	  if (next && next->line0 <= i)
+-            {
+-              /* The change NEXT covers this line.
+-                 If lines were inserted here in file 1, this is "changed".
+-                 Otherwise it is "deleted".  */
+-              prefix = (next->inserted > 0 ? "!" : "-");
+-            }
+-	  print_1_line_nl (prefix, &files[0].linbuf[i], true);
+-          if (i == last0)
+-            set_color_context (RESET_CONTEXT);
+-          if (files[0].linbuf[i + 1][-1] == '\n')
+-            putc ('\n', out);
++	    /* The change NEXT covers this line.
++	       If lines were inserted here in file 1, this is "changed".
++	       Otherwise it is "deleted".  */
++	    prefix = (next->inserted > 0 ? "!" : "-");
++
++	  print_1_line (prefix, &files[0].linbuf[i]);
+ 	}
+     }
+ 
+-  set_color_context (LINE_NUMBER_CONTEXT);
+   fputs ("--- ", out);
+   print_context_number_range (&files[1], first1, last1);
+-  fputs (" ----", out);
+-  set_color_context (RESET_CONTEXT);
+-  putc ('\n', out);
++  fputs (" ----\n", out);
+ 
+   if (changes & NEW)
+     {
+       struct change *next = hunk;
+ 
+-      if (first1 <= last1)
+-        set_color_context (ADD_CONTEXT);
+-
+       for (i = first1; i <= last1; i++)
+ 	{
+ 	  /* Skip past changes that apply (in file 1)
+@@ -274,17 +254,12 @@ pr_context_hunk (struct change *hunk)
+ 
+ 	  prefix = " ";
+ 	  if (next && next->line1 <= i)
+-            {
+-              /* The change NEXT covers this line.
+-                 If lines were deleted here in file 0, this is "changed".
+-                 Otherwise it is "inserted".  */
+-              prefix = (next->deleted > 0 ? "!" : "+");
+-            }
+-	  print_1_line_nl (prefix, &files[1].linbuf[i], true);
+-          if (i == last1)
+-            set_color_context (RESET_CONTEXT);
+-          if (files[1].linbuf[i + 1][-1] == '\n')
+-            putc ('\n', out);
++	    /* The change NEXT covers this line.
++	       If lines were deleted here in file 0, this is "changed".
++	       Otherwise it is "inserted".  */
++	    prefix = (next->deleted > 0 ? "!" : "+");
++
++	  print_1_line (prefix, &files[1].linbuf[i]);
+ 	}
+     }
+ }
+@@ -299,7 +274,7 @@ pr_context_hunk (struct change *hunk)
+ static void
+ print_unidiff_number_range (struct file_data const *file, lin a, lin b)
+ {
+-  printint trans_a, trans_b;
++  long int trans_a, trans_b;
+   translate_range (file, a, b, &trans_a, &trans_b);
+ 
+   /* We can have B < A in the case of a range of no lines.
+@@ -307,14 +282,14 @@ print_unidiff_number_range (struct file_
+      which is B.  It would be more logical to print A, but
+      'patch' expects B in order to detect diffs against empty files.  */
+   if (trans_b <= trans_a)
+-    fprintf (outfile, trans_b < trans_a ? "%"pI"d,0" : "%"pI"d", trans_b);
++    fprintf (outfile, trans_b < trans_a ? "%ld,0" : "%ld", trans_b);
+   else
+-    fprintf (outfile, "%"pI"d,%"pI"d", trans_a, trans_b - trans_a + 1);
++    fprintf (outfile, "%ld,%ld", trans_a, trans_b - trans_a + 1);
+ }
+ 
+ /* Print a portion of an edit script in unidiff format.
+    HUNK is the beginning of the portion to be printed.
+-   The end is marked by a 'link' that has been nulled out.
++   The end is marked by a `link' that has been nulled out.
+ 
+    Prints out lines from both files, and precedes each
+    line with the appropriate flag-character.  */
+@@ -355,13 +330,11 @@ pr_unidiff_hunk (struct change *hunk)
+   begin_output ();
+   out = outfile;
+ 
+-  set_color_context (LINE_NUMBER_CONTEXT);
+   fputs ("@@ -", out);
+   print_unidiff_number_range (&files[0], first0, last0);
+   fputs (" +", out);
+   print_unidiff_number_range (&files[1], first1, last1);
+   fputs (" @@", out);
+-  set_color_context (RESET_CONTEXT);
+ 
+   if (function)
+     print_context_function (out, function);
+@@ -390,43 +363,25 @@ pr_unidiff_hunk (struct change *hunk)
+ 	  /* For each difference, first output the deleted part. */
+ 
+ 	  k = next->deleted;
+-          if (k)
+-            set_color_context (DELETE_CONTEXT);
+-
+ 	  while (k--)
+ 	    {
+ 	      char const * const *line = &files[0].linbuf[i++];
+ 	      putc ('-', out);
+ 	      if (initial_tab && ! (suppress_blank_empty && **line == '\n'))
+ 		putc ('\t', out);
+-	      print_1_line_nl (NULL, line, true);
+-
+-              if (!k)
+-                set_color_context (RESET_CONTEXT);
+-
+-              if (line[1][-1] == '\n')
+-                putc ('\n', out);
++	      print_1_line (NULL, line);
+ 	    }
+ 
+ 	  /* Then output the inserted part. */
+ 
+ 	  k = next->inserted;
+-          if (k)
+-            set_color_context (ADD_CONTEXT);
+-
+-          while (k--)
++	  while (k--)
+ 	    {
+ 	      char const * const *line = &files[1].linbuf[j++];
+ 	      putc ('+', out);
+ 	      if (initial_tab && ! (suppress_blank_empty && **line == '\n'))
+ 		putc ('\t', out);
+-	      print_1_line_nl (NULL, line, true);
+-
+-              if (!k)
+-                set_color_context (RESET_CONTEXT);
+-
+-              if (line[1][-1] == '\n')
+-                putc ('\n', out);
++	      print_1_line (NULL, line);
+ 	    }
+ 
+ 	  /* We're done with this hunk, so on to the next! */
+@@ -438,20 +393,21 @@ pr_unidiff_hunk (struct change *hunk)
+ 
+ /* Scan a (forward-ordered) edit script for the first place that more than
+    2*CONTEXT unchanged lines appear, and return a pointer
+-   to the 'struct change' for the last change before those lines.  */
++   to the `struct change' for the last change before those lines.  */
+ 
+-static struct change * _GL_ATTRIBUTE_PURE
++static struct change *
+ find_hunk (struct change *start)
+ {
+   struct change *prev;
+   lin top0, top1;
+   lin thresh;
+ 
+-  /* Threshold distance is CONTEXT if the second change is ignorable,
+-     2 * CONTEXT + 1 otherwise.  Integer overflow can't happen, due
+-     to CONTEXT_LIM.  */
++  /* Threshold distance is 2 * CONTEXT + 1 between two non-ignorable
++     changes, but only CONTEXT if one is ignorable.  Watch out for
++     integer overflow, though.  */
++  lin non_ignorable_threshold =
++    (LIN_MAX - 1) / 2 < context ? LIN_MAX : 2 * context + 1;
+   lin ignorable_threshold = context;
+-  lin non_ignorable_threshold = 2 * context + 1;
+ 
+   do
+     {
+@@ -460,7 +416,7 @@ find_hunk (struct change *start)
+       top1 = start->line1 + start->inserted;
+       prev = start;
+       start = start->link;
+-      thresh = (start && start->ignore
++      thresh = (prev->ignore || (start && start->ignore)
+ 		? ignorable_threshold
+ 		: non_ignorable_threshold);
+       /* It is not supposed to matter which file we check in the end-test.
+@@ -475,7 +431,7 @@ find_hunk (struct change *start)
+   return prev;
+ }
+ 
+-/* Set the 'ignore' flag properly in each change in SCRIPT.
++/* Set the `ignore' flag properly in each change in SCRIPT.
+    It should be 1 if all the lines inserted or deleted in that change
+    are ignorable lines.  */
+ 
+@@ -503,7 +459,7 @@ mark_ignorable (struct change *script)
+ }
+ 
+ /* Find the last function-header line in LINBUF prior to line number LINENUM.
+-   This is a line containing a match for the regexp in 'function_regexp'.
++   This is a line containing a match for the regexp in `function_regexp'.
+    Return the address of the text, or NULL if no function-header is found.  */
+ 
+ static char const *
+Only in diffutils-3.0-patch: context.o
+Only in diffutils-3.0-patch: .deps
+Only in diffutils-3.0: die.h
+Only in diffutils-3.0-patch: diff
+Only in diffutils-3.0-patch: diff3
+diff -pru diffutils-3.0/diff3.c diffutils-3.0-patch/diff3.c
+--- diffutils-3.0/diff3.c	2019-03-16 02:28:09.294894000 -0700
++++ diffutils-3.0-patch/diff3.c	2019-03-16 02:29:47.371207000 -0700
+@@ -1,7 +1,7 @@
+ /* diff3 - compare three files line by line
+ 
+-   Copyright (C) 1988-1989, 1992-1996, 1998, 2001-2002, 2004, 2006, 2009-2013,
+-   2015-2017 Free Software Foundation, Inc.
++   Copyright (C) 1988-1989, 1992-1996, 1998, 2001-2002, 2004, 2006, 2009-2010
++   Free Software Foundation, Inc.
+ 
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+@@ -24,18 +24,18 @@
+ 
+ #include <c-stack.h>
+ #include <cmpbuf.h>
+-#include "die.h"
+ #include <error.h>
+ #include <exitfail.h>
+ #include <file-type.h>
+ #include <getopt.h>
++#include <inttostr.h>
+ #include <progname.h>
+-#include <system-quote.h>
++#include <sh-quote.h>
+ #include <version-etc.h>
+ #include <xalloc.h>
+ #include <xfreopen.h>
+ 
+-/* The official name of this program (e.g., no 'g' prefix).  */
++/* The official name of this program (e.g., no `g' prefix).  */
+ #define PROGRAM_NAME "diff3"
+ 
+ #define AUTHORS \
+@@ -79,9 +79,6 @@ struct diff_block {
+   char **lines[2];		/* The actual lines (may contain nulls) */
+   size_t *lengths[2];		/* Line lengths (including newlines, if any) */
+   struct diff_block *next;
+-#ifdef lint
+-  struct diff_block *n2;	/* Used only when freeing.  */
+-#endif
+ };
+ 
+ /* Three way diff */
+@@ -162,7 +159,7 @@ static bool overlap_only;
+ /* If nonzero, show information for DIFF_2ND diffs.  */
+ static bool show_2nd;
+ 
+-/* If nonzero, include ':wq' at the end of the script
++/* If nonzero, include `:wq' at the end of the script
+    to write out the file being edited.   */
+ static bool finalwrite;
+ 
+@@ -180,7 +177,7 @@ static struct diff3_block *create_diff3_
+ static struct diff3_block *make_3way_diff (struct diff_block *, struct diff_block *);
+ static struct diff3_block *reverse_diff3_blocklist (struct diff3_block *);
+ static struct diff3_block *using_to_diff3_block (struct diff_block *[2], struct diff_block *[2], int, int, struct diff3_block const *);
+-static struct diff_block *process_diff (char const *, char const *, struct diff_block **, char **);
++static struct diff_block *process_diff (char const *, char const *, struct diff_block **);
+ static void check_stdout (void);
+ static void fatal (char const *) __attribute__((noreturn));
+ static void output_diff3 (FILE *, struct diff3_block *, int const[3], int const[3]);
+@@ -216,38 +213,6 @@ static struct option const longopts[] =
+   {0, 0, 0, 0}
+ };
+ 
+-static void
+-free_diff_block (struct diff_block *p)
+-{
+-#ifndef lint
+-  (void)p;
+-#else
+-  while (p)
+-    {
+-      free (p->lines[0]);
+-      free (p->lines[1]);
+-      free (p->lengths[0]);
+-      free (p->lengths[1]);
+-      struct diff_block *next = p->n2;
+-      free (p);
+-      p = next;
+-    }
+-#endif
+-}
+-
+-/* Copy each next pointer to n2, since make_3way_diff would clobber the former,
+-   yet we will still need something to free these buffers.  */
+-static void
+-next_to_n2 (struct diff_block *p)
+-{
+-#ifndef lint
+-  (void)p;
+-#else
+-  while (p)
+-    p = p->n2 = p->next;
+-#endif
+-}
+-
+ int
+ main (int argc, char **argv)
+ {
+@@ -301,10 +266,10 @@ main (int argc, char **argv)
+ 	  break;
+ 	case 'X':
+ 	  overlap_only = true;
+-	  FALLTHROUGH;
++	  /* Fall through.  */
+ 	case 'E':
+ 	  flagging = true;
+-	  FALLTHROUGH;
++	  /* Fall through.  */
+ 	case 'e':
+ 	  incompat++;
+ 	  break;
+@@ -315,7 +280,7 @@ main (int argc, char **argv)
+ 	  strip_trailing_cr = true;
+ 	  break;
+ 	case 'v':
+-	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version,
++	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+ 		       AUTHORS, (char *) NULL);
+ 	  check_stdout ();
+ 	  return EXIT_SUCCESS;
+@@ -339,9 +304,7 @@ main (int argc, char **argv)
+ 	}
+     }
+ 
+-  /* -AeExX3 without -m implies ed script.  */
+-  edscript = incompat & ~(int) merge;
+-
++  edscript = incompat & ~merge;  /* -AeExX3 without -m implies ed script.  */
+   show_2nd |= ~incompat & merge;  /* -m without -AeExX3 implies -A.  */
+   flagging |= ~incompat & merge;
+ 
+@@ -399,12 +362,12 @@ main (int argc, char **argv)
+     rev_mapping[mapping[i]] = i;
+ 
+   for (i = 0; i < 3; i++)
+-    if (! STREQ (file[i], "-"))
++    if (strcmp (file[i], "-") != 0)
+       {
+ 	if (stat (file[i], &statb) < 0)
+ 	  perror_with_exit (file[i]);
+ 	else if (S_ISDIR (statb.st_mode))
+-	  die (EXIT_TROUBLE, EISDIR, "%s", file[i]);
++	  error (EXIT_TROUBLE, EISDIR, "%s", file[i]);
+       }
+ 
+ #ifdef SIGCHLD
+@@ -415,19 +378,10 @@ main (int argc, char **argv)
+   /* Invoke diff twice on two pairs of input files, combine the two
+      diffs, and output them.  */
+ 
+-  char *b0, *b1;
+   commonname = file[rev_mapping[FILEC]];
+-  thread1 = process_diff (file[rev_mapping[FILE1]], commonname, &last_block, &b1);
+-  thread0 = process_diff (file[rev_mapping[FILE0]], commonname, &last_block, &b0);
+-
+-  next_to_n2 (thread0);
+-  next_to_n2 (thread1);
+-
++  thread1 = process_diff (file[rev_mapping[FILE1]], commonname, &last_block);
++  thread0 = process_diff (file[rev_mapping[FILE0]], commonname, &last_block);
+   diff3 = make_3way_diff (thread0, thread1);
+-
+-  free_diff_block (thread0);
+-  free_diff_block (thread1);
+-
+   if (edscript)
+     conflicts_found
+       = output_diff3_edscript (stdout, diff3, mapping, rev_mapping,
+@@ -447,10 +401,9 @@ main (int argc, char **argv)
+       conflicts_found = false;
+     }
+ 
+-  free (b0);
+-  free (b1);
+   check_stdout ();
+   exit (conflicts_found);
++  return conflicts_found;
+ }
+ 
+ static void
+@@ -458,8 +411,9 @@ try_help (char const *reason_msgid, char
+ {
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+-  die (EXIT_TROUBLE, 0,
++  error (EXIT_TROUBLE, 0,
+ 	 _("Try '%s --help' for more information."), program_name);
++  abort ();
+ }
+ 
+ static void
+@@ -472,28 +426,23 @@ check_stdout (void)
+ }
+ 
+ static char const * const option_help_msgid[] = {
+-  N_("-A, --show-all              output all changes, bracketing conflicts"),
+-  "",
+-  N_("-e, --ed                    output ed script incorporating changes\n"
+-     "                                from OLDFILE to YOURFILE into MYFILE"),
+-  N_("-E, --show-overlap          like -e, but bracket conflicts"),
+-  N_("-3, --easy-only             like -e, but incorporate only nonoverlapping changes"),
+-  N_("-x, --overlap-only          like -e, but incorporate only overlapping changes"),
+-  N_("-X                          like -x, but bracket conflicts"),
+-  N_("-i                          append 'w' and 'q' commands to ed scripts"),
+-  "",
+-  N_("-m, --merge                 output actual merged file, according to\n"
+-     "                                -A if no other options are given"),
++  N_("-e  --ed  Output unmerged changes from OLDFILE to YOURFILE into MYFILE."),
++  N_("-E  --show-overlap  Output unmerged changes, bracketing conflicts."),
++  N_("-A  --show-all  Output all changes, bracketing conflicts."),
++  N_("-x  --overlap-only  Output overlapping changes."),
++  N_("-X  Output overlapping changes, bracketing them."),
++  N_("-3  --easy-only  Output unmerged nonoverlapping changes."),
+   "",
+-  N_("-a, --text                  treat all files as text"),
+-  N_("    --strip-trailing-cr     strip trailing carriage return on input"),
+-  N_("-T, --initial-tab           make tabs line up by prepending a tab"),
+-  N_("    --diff-program=PROGRAM  use PROGRAM to compare files"),
+-  N_("-L, --label=LABEL           use LABEL instead of file name\n"
+-     "                                (can be repeated up to three times)"),
++  N_("-m  --merge  Output merged file instead of ed script (default -A)."),
++  N_("-L LABEL  --label=LABEL  Use LABEL instead of file name."),
++  N_("-i  Append 'w' and 'q' commands to ed scripts."),
++  N_("-a  --text  Treat all files as text."),
++  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
++  N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
++  N_("--diff-program=PROGRAM  Use PROGRAM to compare files."),
+   "",
+-  N_("    --help                  display this help and exit"),
+-  N_("-v, --version               output version information and exit"),
++  N_("-v  --version  Output version info."),
++  N_("--help  Output this help."),
+   0
+ };
+ 
+@@ -505,25 +454,11 @@ usage (void)
+   printf (_("Usage: %s [OPTION]... MYFILE OLDFILE YOURFILE\n"),
+ 	  program_name);
+   printf ("%s\n\n", _("Compare three files line by line."));
+-
+-  fputs (_("\
+-Mandatory arguments to long options are mandatory for short options too.\n\
+-"), stdout);
+   for (p = option_help_msgid;  *p;  p++)
+     if (**p)
+       printf ("  %s\n", _(*p));
+     else
+       putchar ('\n');
+-  fputs (_("\n\
+-The default output format is a somewhat human-readable representation of\n\
+-the changes.\n\
+-\n\
+-The -e, -E, -x, -X (and corresponding long) options cause an ed script\n\
+-to be output instead of the default.\n\
+-\n\
+-Finally, the -m (--merge) option causes diff3 to do the merge internally\n\
+-and output the actual merged file.  For unusual input, this is more\n\
+-robust than using ed.\n"), stdout);
+   printf ("\n%s\n%s\n",
+ 	  _("If a FILE is '-', read standard input."),
+ 	  _("Exit status is 0 if successful, 1 if conflicts, 2 if trouble."));
+@@ -986,8 +921,7 @@ compare_line_list (char * const list1[],
+ static struct diff_block *
+ process_diff (char const *filea,
+ 	      char const *fileb,
+-	      struct diff_block **last_block,
+-	      char **buf_to_free)
++	      struct diff_block **last_block)
+ {
+   char *diff_contents;
+   char *diff_limit;
+@@ -1002,7 +936,6 @@ process_diff (char const *filea,
+ 				  sizeof *bptr->lengths[1]));
+ 
+   diff_limit = read_diff (filea, fileb, &diff_contents);
+-  *buf_to_free = diff_contents;
+   scan_diff = diff_contents;
+ 
+   while (scan_diff < diff_limit)
+@@ -1094,7 +1027,7 @@ process_diff (char const *filea,
+ 
+ /* Skip tabs and spaces, and return the first character after them.  */
+ 
+-static char * _GL_ATTRIBUTE_PURE
++static char *
+ skipwhite (char *s)
+ {
+   while (*s == ' ' || *s == '\t')
+@@ -1210,15 +1143,13 @@ read_diff (char const *filea,
+   int fd, wstatus, status;
+   int werrno = 0;
+   struct stat pipestat;
++
++#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
++
+   char const *argv[9];
+   char const **ap;
+-#if HAVE_WORKING_FORK
+   int fds[2];
+   pid_t pid;
+-#else
+-  FILE *fpipe;
+-  char *command;
+-#endif
+ 
+   ap = argv;
+   *ap++ = diff_program;
+@@ -1232,12 +1163,10 @@ read_diff (char const *filea,
+   *ap++ = fileb;
+   *ap = 0;
+ 
+-#if HAVE_WORKING_FORK
+-
+   if (pipe (fds) != 0)
+     perror_with_exit ("pipe");
+ 
+-  pid = fork ();
++  pid = vfork ();
+   if (pid == 0)
+     {
+       /* Child */
+@@ -1263,7 +1192,32 @@ read_diff (char const *filea,
+ 
+ #else
+ 
+-  command = system_quote_argv (SCI_SYSTEM, (char **) argv);
++  FILE *fpipe;
++  char const args[] = " --horizon-lines=100 -- ";
++  char *command = xmalloc (shell_quote_length (diff_program)
++			   + sizeof "-a"
++			   + sizeof "--strip-trailing-cr"
++			   + sizeof args - 1
++			   + shell_quote_length (filea) + 1
++			   + shell_quote_length (fileb) + 1);
++  char *p = command;
++  p = shell_quote_copy (p, diff_program);
++  if (text)
++    {
++      strcpy (p, " -a");
++      p += 3;
++    }
++  if (strip_trailing_cr)
++    {
++      strcpy (p, " --strip-trailing-cr");
++      p += 20;
++    }
++  strcpy (p, args);
++  p += sizeof args - 1;
++  p = shell_quote_copy (p, filea);
++  *p++ = ' ';
++  p = shell_quote_copy (p, fileb);
++  *p = 0;
+   errno = 0;
+   fpipe = popen (command, "r");
+   if (!fpipe)
+@@ -1301,7 +1255,7 @@ read_diff (char const *filea,
+ 
+   *output_placement = diff_result;
+ 
+-#if ! HAVE_WORKING_FORK
++#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+ 
+   wstatus = pclose (fpipe);
+   if (wstatus == -1)
+@@ -1319,7 +1273,7 @@ read_diff (char const *filea,
+   status = ! werrno && WIFEXITED (wstatus) ? WEXITSTATUS (wstatus) : INT_MAX;
+ 
+   if (EXIT_TROUBLE <= status)
+-    die (EXIT_TROUBLE, werrno,
++    error (EXIT_TROUBLE, werrno,
+ 	   _(status == 126
+ 	     ? "subsidiary program '%s' could not be invoked"
+ 	     : status == 127
+@@ -1430,20 +1384,20 @@ output_diff3 (FILE *outputfile, struct d
+ 	  int realfile = mapping[i];
+ 	  lin lowt = D_LOWLINE (ptr, realfile);
+ 	  lin hight = D_HIGHLINE (ptr, realfile);
+-	  printint llowt = lowt;
+-	  printint lhight = hight;
++	  long int llowt = lowt;
++	  long int lhight = hight;
+ 
+ 	  fprintf (outputfile, "%d:", i + 1);
+ 	  switch (lowt - hight)
+ 	    {
+ 	    case 1:
+-	      fprintf (outputfile, "%"pI"da\n", llowt - 1);
++	      fprintf (outputfile, "%lda\n", llowt - 1);
+ 	      break;
+ 	    case 0:
+-	      fprintf (outputfile, "%"pI"dc\n", llowt);
++	      fprintf (outputfile, "%ldc\n", llowt);
+ 	      break;
+ 	    default:
+-	      fprintf (outputfile, "%"pI"d,%"pI"dc\n", llowt, lhight);
++	      fprintf (outputfile, "%ld,%ldc\n", llowt, lhight);
+ 	      break;
+ 	    }
+ 
+@@ -1497,18 +1451,19 @@ dotlines (FILE *outputfile, struct diff3
+ 
+ /* Output to OUTPUTFILE a '.' line.  If LEADING_DOT is true, also
+    output a command that removes initial '.'s starting with line START
+-   and continuing for NUM lines.  */
++   and continuing for NUM lines.  (START is long int, not lin, for
++   convenience with printf %ld formats.)  */
+ 
+ static void
+-undotlines (FILE *outputfile, bool leading_dot, printint start, printint num)
++undotlines (FILE *outputfile, bool leading_dot, long int start, lin num)
+ {
+   fputs (".\n", outputfile);
+   if (leading_dot)
+     {
+       if (num == 1)
+-	fprintf (outputfile, "%"pI"ds/^\\.//\n", start);
++	fprintf (outputfile, "%lds/^\\.//\n", start);
+       else
+-	fprintf (outputfile, "%"pI"d,%"pI"ds/^\\.//\n", start, start + num - 1);
++	fprintf (outputfile, "%ld,%lds/^\\.//\n", start, start + num - 1);
+     }
+ }
+ 
+@@ -1520,7 +1475,7 @@ undotlines (FILE *outputfile, bool leadi
+    around the problems involved with changing line numbers in an ed
+    script.
+ 
+-   As in 'output_diff3', the variable MAPPING maps from file number
++   As in `output_diff3', the variable MAPPING maps from file number
+    according to the argument list to file number according to the diff
+    passed.  All files listed below are in terms of the argument list.
+    REV_MAPPING is the inverse of MAPPING.
+@@ -1549,7 +1504,7 @@ output_diff3_edscript (FILE *outputfile,
+ 	   ? DIFF_ALL
+ 	   : DIFF_1ST + rev_mapping[b->correspond - DIFF_1ST]);
+ 
+-      printint low0, high0;
++      long int low0, high0;
+ 
+       /* If we aren't supposed to do this output block, skip it.  */
+       switch (type)
+@@ -1570,7 +1525,7 @@ output_diff3_edscript (FILE *outputfile,
+ 
+ 	  /* Mark end of conflict.  */
+ 
+-	  fprintf (outputfile, "%"pI"da\n", high0);
++	  fprintf (outputfile, "%lda\n", high0);
+ 	  leading_dot = false;
+ 	  if (type == DIFF_ALL)
+ 	    {
+@@ -1592,7 +1547,7 @@ output_diff3_edscript (FILE *outputfile,
+ 
+ 	  /* Mark start of conflict.  */
+ 
+-	  fprintf (outputfile, "%"pI"da\n<<<<<<< %s\n", low0 - 1,
++	  fprintf (outputfile, "%lda\n<<<<<<< %s\n", low0 - 1,
+ 		   type == DIFF_ALL ? file0 : file1);
+ 	  leading_dot = false;
+ 	  if (type == DIFF_2ND)
+@@ -1608,9 +1563,9 @@ output_diff3_edscript (FILE *outputfile,
+ 	/* Write out a delete */
+ 	{
+ 	  if (low0 == high0)
+-	    fprintf (outputfile, "%"pI"dd\n", low0);
++	    fprintf (outputfile, "%ldd\n", low0);
+ 	  else
+-	    fprintf (outputfile, "%"pI"d,%"pI"dd\n", low0, high0);
++	    fprintf (outputfile, "%ld,%ldd\n", low0, high0);
+ 	}
+       else
+ 	/* Write out an add or change */
+@@ -1618,13 +1573,13 @@ output_diff3_edscript (FILE *outputfile,
+ 	  switch (high0 - low0)
+ 	    {
+ 	    case -1:
+-	      fprintf (outputfile, "%"pI"da\n", high0);
++	      fprintf (outputfile, "%lda\n", high0);
+ 	      break;
+ 	    case 0:
+-	      fprintf (outputfile, "%"pI"dc\n", high0);
++	      fprintf (outputfile, "%ldc\n", high0);
+ 	      break;
+ 	    default:
+-	      fprintf (outputfile, "%"pI"d,%"pI"dc\n", low0, high0);
++	      fprintf (outputfile, "%ld,%ldc\n", low0, high0);
+ 	      break;
+ 	    }
+ 
+@@ -1776,15 +1731,17 @@ reverse_diff3_blocklist (struct diff3_bl
+ 
+   return prev;
+ }
+-
++
+ static void
+ fatal (char const *msgid)
+ {
+-  die (EXIT_TROUBLE, 0, "%s", _(msgid));
++  error (EXIT_TROUBLE, 0, "%s", _(msgid));
++  abort ();
+ }
+ 
+ static void
+ perror_with_exit (char const *string)
+ {
+-  die (EXIT_TROUBLE, errno, "%s", string);
++  error (EXIT_TROUBLE, errno, "%s", string);
++  abort ();
+ }
+Only in diffutils-3.0-patch: diff3.o
+diff -pru diffutils-3.0/diff.c diffutils-3.0-patch/diff.c
+--- diffutils-3.0/diff.c	2019-03-16 02:28:09.288890000 -0700
++++ diffutils-3.0-patch/diff.c	2019-03-16 02:29:47.366203000 -0700
+@@ -1,7 +1,7 @@
+ /* diff - compare files line by line
+ 
+    Copyright (C) 1988-1989, 1992-1994, 1996, 1998, 2001-2002, 2004, 2006-2007,
+-   2009-2013, 2015-2017 Free Software Foundation, Inc.
++   2009-2010 Free Software Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -20,7 +20,6 @@
+ 
+ #define GDIFF_MAIN
+ #include "diff.h"
+-#include "die.h"
+ #include <assert.h>
+ #include "paths.h"
+ #include <c-stack.h>
+@@ -28,7 +27,6 @@
+ #include <error.h>
+ #include <exclude.h>
+ #include <exitfail.h>
+-#include <filenamecat.h>
+ #include <file-type.h>
+ #include <fnmatch.h>
+ #include <getopt.h>
+@@ -40,10 +38,9 @@
+ #include <timespec.h>
+ #include <version-etc.h>
+ #include <xalloc.h>
+-#include <xreadlink.h>
+-#include <binary-io.h>
++#include <xfreopen.h>
+ 
+-/* The official name of this program (e.g., no 'g' prefix).  */
++/* The official name of this program (e.g., no `g' prefix).  */
+ #define PROGRAM_NAME "diff"
+ 
+ #define AUTHORS \
+@@ -60,9 +57,9 @@
+ struct regexp_list
+ {
+   char *regexps;	/* chars representing disjunction of the regexps */
+-  size_t len;		/* chars used in 'regexps' */
+-  size_t size;		/* size malloc'ed for 'regexps'; 0 if not malloc'ed */
+-  bool multiple_regexps;/* Does 'regexps' represent a disjunction?  */
++  size_t len;		/* chars used in `regexps' */
++  size_t size;		/* size malloc'ed for `regexps'; 0 if not malloc'ed */
++  bool multiple_regexps;/* Does `regexps' represent a disjunction?  */
+   struct re_pattern_buffer *buf;
+ };
+ 
+@@ -71,7 +68,6 @@ static void add_regexp (struct regexp_li
+ static void summarize_regexp_list (struct regexp_list *);
+ static void specify_style (enum output_style);
+ static void specify_value (char const **, char const *, char const *);
+-static void specify_colors_style (char const *);
+ static void try_help (char const *, char const *) __attribute__((noreturn));
+ static void check_stdout (void);
+ static void usage (void);
+@@ -94,11 +90,15 @@ static bool binary;
+ enum { binary = true };
+ #endif
+ 
+-/* If one file is missing, treat it as present but empty (-N).  */
++/* When comparing directories, if a file appears only in one
++   directory, treat it as present but empty in the other (-N).
++   Then `patch' would create the file with appropriate contents.  */
+ static bool new_file;
+ 
+-/* If the first file is missing, treat it as present but empty
+-   (--unidirectional-new-file).  */
++/* When comparing directories, if a file appears only in the second
++   directory of the two, treat it as present but empty in the other
++   (--unidirectional-new-file).
++   Then `patch' would create the file with appropriate contents.  */
+ static bool unidirectional_new_file;
+ 
+ /* Report files compared that are the same (-s).
+@@ -106,7 +106,7 @@ static bool unidirectional_new_file;
+ static bool report_identical_files;
+ 
+ static char const shortopts[] =
+-"0123456789abBcC:dD:eEfF:hHiI:lL:nNpPqrsS:tTuU:vwW:x:X:yZ";
++"0123456789abBcC:dD:eEfF:hHiI:lL:nNpPqrsS:tTuU:vwW:x:X:y";
+ 
+ /* Values for long options that do not have single-letter equivalents.  */
+ enum
+@@ -119,7 +119,6 @@ enum
+   INHIBIT_HUNK_MERGE_OPTION,
+   LEFT_COLUMN_OPTION,
+   LINE_FORMAT_OPTION,
+-  NO_DEREFERENCE_OPTION,
+   NO_IGNORE_FILE_NAME_CASE_OPTION,
+   NORMAL_OPTION,
+   SDIFF_MERGE_ASSIST_OPTION,
+@@ -138,12 +137,7 @@ enum
+   UNCHANGED_GROUP_FORMAT_OPTION,
+   OLD_GROUP_FORMAT_OPTION,
+   NEW_GROUP_FORMAT_OPTION,
+-  CHANGED_GROUP_FORMAT_OPTION,
+-
+-  COLOR_OPTION,
+-  COLOR_PALETTE_OPTION,
+-
+-  PRESUME_OUTPUT_TTY_OPTION,
++  CHANGED_GROUP_FORMAT_OPTION
+ };
+ 
+ static char const group_format_option[][sizeof "--unchanged-group-format"] =
+@@ -166,7 +160,6 @@ static struct option const longopts[] =
+   {"binary", 0, 0, BINARY_OPTION},
+   {"brief", 0, 0, 'q'},
+   {"changed-group-format", 1, 0, CHANGED_GROUP_FORMAT_OPTION},
+-  {"color", 2, 0, COLOR_OPTION},
+   {"context", 2, 0, 'C'},
+   {"ed", 0, 0, 'e'},
+   {"exclude", 1, 0, 'x'},
+@@ -184,7 +177,6 @@ static struct option const longopts[] =
+   {"ignore-matching-lines", 1, 0, 'I'},
+   {"ignore-space-change", 0, 0, 'b'},
+   {"ignore-tab-expansion", 0, 0, 'E'},
+-  {"ignore-trailing-space", 0, 0, 'Z'},
+   {"inhibit-hunk-merge", 0, 0, INHIBIT_HUNK_MERGE_OPTION},
+   {"initial-tab", 0, 0, 'T'},
+   {"label", 1, 0, 'L'},
+@@ -194,13 +186,11 @@ static struct option const longopts[] =
+   {"new-file", 0, 0, 'N'},
+   {"new-group-format", 1, 0, NEW_GROUP_FORMAT_OPTION},
+   {"new-line-format", 1, 0, NEW_LINE_FORMAT_OPTION},
+-  {"no-dereference", 0, 0, NO_DEREFERENCE_OPTION},
+   {"no-ignore-file-name-case", 0, 0, NO_IGNORE_FILE_NAME_CASE_OPTION},
+   {"normal", 0, 0, NORMAL_OPTION},
+   {"old-group-format", 1, 0, OLD_GROUP_FORMAT_OPTION},
+   {"old-line-format", 1, 0, OLD_LINE_FORMAT_OPTION},
+   {"paginate", 0, 0, 'l'},
+-  {"palette", 1, 0, COLOR_PALETTE_OPTION},
+   {"rcs", 0, 0, 'n'},
+   {"recursive", 0, 0, 'r'},
+   {"report-identical-files", 0, 0, 's'},
+@@ -222,9 +212,6 @@ static struct option const longopts[] =
+   {"unified", 2, 0, 'U'},
+   {"version", 0, 0, 'v'},
+   {"width", 1, 0, 'W'},
+-
+-  /* This is solely for testing.  Do not document.  */
+-  {"-presume-output-tty", no_argument, NULL, PRESUME_OUTPUT_TTY_OPTION},
+   {0, 0, 0, 0}
+ };
+ 
+@@ -296,7 +283,6 @@ main (int argc, char **argv)
+   ignore_regexp_list.buf = &ignore_regexp;
+   re_set_syntax (RE_SYNTAX_GREP | RE_NO_POSIX_BACKTRACKING);
+   excluded = new_exclude ();
+-  presume_output_tty = false;
+ 
+   /* Decode the options.  */
+ 
+@@ -317,12 +303,11 @@ main (int argc, char **argv)
+ 	case '7':
+ 	case '8':
+ 	case '9':
+-	  ocontext = (! ISDIGIT (prev)
+-		      ? c - '0'
+-		      : (ocontext - (c - '0' <= CONTEXT_MAX % 10)
+-			 < CONTEXT_MAX / 10)
+-		      ? 10 * ocontext + (c - '0')
+-		      : CONTEXT_MAX);
++	  if (! ISDIGIT (prev))
++	    ocontext = c - '0';
++	  else if (LIN_MAX / 10 < ocontext
++		   || ((ocontext = 10 * ocontext + c - '0') < 0))
++	    ocontext = LIN_MAX;
+ 	  break;
+ 
+ 	case 'a':
+@@ -334,11 +319,6 @@ main (int argc, char **argv)
+ 	    ignore_white_space = IGNORE_SPACE_CHANGE;
+ 	  break;
+ 
+-	case 'Z':
+-	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
+-	    ignore_white_space |= IGNORE_TRAILING_SPACE;
+-	  break;
+-
+ 	case 'B':
+ 	  ignore_blank_lines = true;
+ 	  break;
+@@ -351,8 +331,8 @@ main (int argc, char **argv)
+ 		numval = strtoumax (optarg, &numend, 10);
+ 		if (*numend)
+ 		  try_help ("invalid context length '%s'", optarg);
+-		if (CONTEXT_MAX < numval)
+-		  numval = CONTEXT_MAX;
++		if (LIN_MAX < numval)
++		  numval = LIN_MAX;
+ 	      }
+ 	    else
+ 	      numval = 3;
+@@ -400,8 +380,8 @@ main (int argc, char **argv)
+ 	  break;
+ 
+ 	case 'E':
+-	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
+-	    ignore_white_space |= IGNORE_TAB_EXPANSION;
++	  if (ignore_white_space < IGNORE_TAB_EXPANSION)
++	    ignore_white_space = IGNORE_TAB_EXPANSION;
+ 	  break;
+ 
+ 	case 'f':
+@@ -499,7 +479,7 @@ main (int argc, char **argv)
+ 	  break;
+ 
+ 	case 'v':
+-	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version,
++	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+ 		       AUTHORS, (char *) NULL);
+ 	  check_stdout ();
+ 	  return EXIT_SUCCESS;
+@@ -538,7 +518,7 @@ main (int argc, char **argv)
+ #if O_BINARY
+ 	  binary = true;
+ 	  if (! isatty (STDOUT_FILENO))
+-	    set_binary_mode (STDOUT_FILENO, O_BINARY);
++	    xfreopen (NULL, "wb", stdout);
+ #endif
+ 	  break;
+ 
+@@ -577,10 +557,6 @@ main (int argc, char **argv)
+ 	    specify_value (&line_format[i], optarg, "--line-format");
+ 	  break;
+ 
+-	case NO_DEREFERENCE_OPTION:
+-	  no_dereference_symlinks = true;
+-	  break;
+-
+ 	case NO_IGNORE_FILE_NAME_CASE_OPTION:
+ 	  ignore_file_name_case = false;
+ 	  break;
+@@ -608,8 +584,7 @@ main (int argc, char **argv)
+ 
+ 	case TABSIZE_OPTION:
+ 	  numval = strtoumax (optarg, &numend, 10);
+-	  if (! (0 < numval && numval <= SIZE_MAX - GUTTER_WIDTH_MINIMUM)
+-	      || *numend)
++	  if (! (0 < numval && numval <= SIZE_MAX) || *numend)
+ 	    try_help ("invalid tabsize '%s'", optarg);
+ 	  if (tabsize != numval)
+ 	    {
+@@ -640,31 +615,12 @@ main (int argc, char **argv)
+ 	  specify_value (&group_format[c], optarg, group_format_option[c]);
+ 	  break;
+ 
+-	case COLOR_OPTION:
+-	  specify_colors_style (optarg);
+-	  break;
+-
+-	case COLOR_PALETTE_OPTION:
+-	  set_color_palette (optarg);
+-	  break;
+-
+-        case PRESUME_OUTPUT_TTY_OPTION:
+-          presume_output_tty = true;
+-          break;
+-
+ 	default:
+ 	  try_help (NULL, NULL);
+ 	}
+       prev = c;
+     }
+ 
+-  if (colors_style == AUTO)
+-    {
+-      char const *t = getenv ("TERM");
+-      if (t && STREQ (t, "dumb"))
+-        colors_style = NEVER;
+-    }
+-
+   if (output_style == OUTPUT_UNSPECIFIED)
+     {
+       if (show_c_function)
+@@ -715,14 +671,10 @@ main (int argc, char **argv)
+ 		a half line plus a gutter is an integral number of tabs,
+ 		so that tabs in the right column line up.  */
+ 
+-    size_t t = expand_tabs ? 1 : tabsize;
+-    size_t w = width;
+-    size_t t_plus_g = t + GUTTER_WIDTH_MINIMUM;
+-    size_t unaligned_off = (w >> 1) + (t_plus_g >> 1) + (w & t_plus_g & 1);
+-    size_t off = unaligned_off - unaligned_off % t;
+-    sdiff_half_width = (off <= GUTTER_WIDTH_MINIMUM || w <= off
+-			? 0
+-			: MIN (off - GUTTER_WIDTH_MINIMUM, w - off));
++    intmax_t t = expand_tabs ? 1 : tabsize;
++    intmax_t w = width;
++    intmax_t off = (w + t + GUTTER_WIDTH_MINIMUM) / (2 * t)  *  t;
++    sdiff_half_width = MAX (0, MIN (off - GUTTER_WIDTH_MINIMUM, w - off)),
+     sdiff_column2_offset = sdiff_half_width ? off : w;
+   }
+ 
+@@ -818,7 +770,7 @@ add_regexp (struct regexp_list *reglist,
+   char const *m = re_compile_pattern (pattern, patlen, reglist->buf);
+ 
+   if (m != 0)
+-    error (EXIT_TROUBLE, 0, "%s: %s", pattern, m);
++    error (0, 0, "%s: %s", pattern, m);
+   else
+     {
+       char *regexps = reglist->regexps;
+@@ -864,7 +816,7 @@ summarize_regexp_list (struct regexp_lis
+ 	  char const *m = re_compile_pattern (reglist->regexps, reglist->len,
+ 					      reglist->buf);
+ 	  if (m)
+-	    die (EXIT_TROUBLE, 0, "%s: %s", reglist->regexps, m);
++	    error (EXIT_TROUBLE, 0, "%s: %s", reglist->regexps, m);
+ 	}
+     }
+ }
+@@ -874,8 +826,9 @@ try_help (char const *reason_msgid, char
+ {
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+-  die (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
++  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+ 	 program_name);
++  abort ();
+ }
+ 
+ static void
+@@ -888,65 +841,41 @@ check_stdout (void)
+ }
+ 
+ static char const * const option_help_msgid[] = {
+-  N_("    --normal                  output a normal diff (the default)"),
+-  N_("-q, --brief                   report only when files differ"),
+-  N_("-s, --report-identical-files  report when two files are the same"),
+-  N_("-c, -C NUM, --context[=NUM]   output NUM (default 3) lines of copied context"),
+-  N_("-u, -U NUM, --unified[=NUM]   output NUM (default 3) lines of unified context"),
+-  N_("-e, --ed                      output an ed script"),
+-  N_("-n, --rcs                     output an RCS format diff"),
+-  N_("-y, --side-by-side            output in two columns"),
+-  N_("-W, --width=NUM               output at most NUM (default 130) print columns"),
+-  N_("    --left-column             output only the left column of common lines"),
+-  N_("    --suppress-common-lines   do not output common lines"),
+-  "",
+-  N_("-p, --show-c-function         show which C function each change is in"),
+-  N_("-F, --show-function-line=RE   show the most recent line matching RE"),
+-  N_("    --label LABEL             use LABEL instead of file name and timestamp\n"
+-     "                                (can be repeated)"),
+-  "",
+-  N_("-t, --expand-tabs             expand tabs to spaces in output"),
+-  N_("-T, --initial-tab             make tabs line up by prepending a tab"),
+-  N_("    --tabsize=NUM             tab stops every NUM (default 8) print columns"),
+-  N_("    --suppress-blank-empty    suppress space or tab before empty output lines"),
+-  N_("-l, --paginate                pass output through 'pr' to paginate it"),
+-  "",
+-  N_("-r, --recursive                 recursively compare any subdirectories found"),
+-  N_("    --no-dereference            don't follow symbolic links"),
+-  N_("-N, --new-file                  treat absent files as empty"),
+-  N_("    --unidirectional-new-file   treat absent first files as empty"),
+-  N_("    --ignore-file-name-case     ignore case when comparing file names"),
+-  N_("    --no-ignore-file-name-case  consider case when comparing file names"),
+-  N_("-x, --exclude=PAT               exclude files that match PAT"),
+-  N_("-X, --exclude-from=FILE         exclude files that match any pattern in FILE"),
+-  N_("-S, --starting-file=FILE        start with FILE when comparing directories"),
+-  N_("    --from-file=FILE1           compare FILE1 to all operands;\n"
+-     "                                  FILE1 can be a directory"),
+-  N_("    --to-file=FILE2             compare all operands to FILE2;\n"
+-     "                                  FILE2 can be a directory"),
+-  "",
+-  N_("-i, --ignore-case               ignore case differences in file contents"),
+-  N_("-E, --ignore-tab-expansion      ignore changes due to tab expansion"),
+-  N_("-Z, --ignore-trailing-space     ignore white space at line end"),
+-  N_("-b, --ignore-space-change       ignore changes in the amount of white space"),
+-  N_("-w, --ignore-all-space          ignore all white space"),
+-  N_("-B, --ignore-blank-lines        ignore changes where lines are all blank"),
+-  N_("-I, --ignore-matching-lines=RE  ignore changes where all lines match RE"),
++  N_("Compare files line by line."),
+   "",
+-  N_("-a, --text                      treat all files as text"),
+-  N_("    --strip-trailing-cr         strip trailing carriage return on input"),
++  N_("-i  --ignore-case  Ignore case differences in file contents."),
++  N_("--ignore-file-name-case  Ignore case when comparing file names."),
++  N_("--no-ignore-file-name-case  Consider case when comparing file names."),
++  N_("-E  --ignore-tab-expansion  Ignore changes due to tab expansion."),
++  N_("-b  --ignore-space-change  Ignore changes in the amount of white space."),
++  N_("-w  --ignore-all-space  Ignore all white space."),
++  N_("-B  --ignore-blank-lines  Ignore changes whose lines are all blank."),
++  N_("-I RE  --ignore-matching-lines=RE  Ignore changes whose lines all match RE."),
++  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
+ #if O_BINARY
+-  N_("    --binary                    read and write data in binary mode"),
++  N_("--binary  Read and write data in binary mode."),
+ #endif
++  N_("-a  --text  Treat all files as text."),
+   "",
+-  N_("-D, --ifdef=NAME                output merged file with '#ifdef NAME' diffs"),
+-  N_("    --GTYPE-group-format=GFMT   format GTYPE input groups with GFMT"),
+-  N_("    --line-format=LFMT          format all input lines with LFMT"),
+-  N_("    --LTYPE-line-format=LFMT    format LTYPE input lines with LFMT"),
+-  N_("  These format options provide fine-grained control over the output\n"
+-     "    of diff, generalizing -D/--ifdef."),
++  N_("-c  -C NUM  --context[=NUM]  Output NUM (default 3) lines of copied context.\n\
++-u  -U NUM  --unified[=NUM]  Output NUM (default 3) lines of unified context.\n\
++  --label LABEL  Use LABEL instead of file name.\n\
++  -p  --show-c-function  Show which C function each change is in.\n\
++  -F RE  --show-function-line=RE  Show the most recent line matching RE."),
++  N_("-q  --brief  Output only whether files differ."),
++  N_("-e  --ed  Output an ed script."),
++  N_("--normal  Output a normal diff."),
++  N_("-n  --rcs  Output an RCS format diff."),
++  N_("-y  --side-by-side  Output in two columns.\n\
++  -W NUM  --width=NUM  Output at most NUM (default 130) print columns.\n\
++  --left-column  Output only the left column of common lines.\n\
++  --suppress-common-lines  Do not output common lines."),
++  N_("-D NAME  --ifdef=NAME  Output merged file to show '#ifdef NAME' diffs."),
++  N_("--GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT."),
++  N_("--line-format=LFMT  Similar, but format all input lines with LFMT."),
++  N_("--LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT."),
+   N_("  LTYPE is 'old', 'new', or 'unchanged'.  GTYPE is LTYPE or 'changed'."),
+-  N_("  GFMT (only) may contain:\n\
++  N_("  GFMT may contain:\n\
+     %<  lines from FILE1\n\
+     %>  lines from FILE2\n\
+     %=  lines common to FILE1 and FILE2\n\
+@@ -956,31 +885,41 @@ static char const * const option_help_ms
+         L  last line number\n\
+         N  number of lines = L-F+1\n\
+         E  F-1\n\
+-        M  L+1\n\
+-    %(A=B?T:E)  if A equals B then T else E"),
+-  N_("  LFMT (only) may contain:\n\
++        M  L+1"),
++  N_("  LFMT may contain:\n\
+     %L  contents of line\n\
+     %l  contents of line, excluding any trailing newline\n\
+     %[-][WIDTH][.[PREC]]{doxX}n  printf-style spec for input line number"),
+-  N_("  Both GFMT and LFMT may contain:\n\
++  N_("  Either GFMT or LFMT may contain:\n\
+     %%  %\n\
+     %c'C'  the single character C\n\
+-    %c'\\OOO'  the character with octal code OOO\n\
+-    C    the character C (other characters represent themselves)"),
++    %c'\\OOO'  the character with octal code OOO"),
+   "",
+-  N_("-d, --minimal            try hard to find a smaller set of changes"),
+-  N_("    --horizon-lines=NUM  keep NUM lines of the common prefix and suffix"),
+-  N_("    --speed-large-files  assume large files and many scattered small changes"),
+-  N_("    --color[=WHEN]       colorize the output; WHEN can be 'never', 'always',\n"
+-     "                           or 'auto' (the default)"),
+-  N_("    --palette=PALETTE    the colors to use when --color is active; PALETTE is\n"
+-     "                           a colon-separated list of terminfo capabilities"),
++  N_("-l  --paginate  Pass the output through 'pr' to paginate it."),
++  N_("-t  --expand-tabs  Expand tabs to spaces in output."),
++  N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
++  N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
++  N_("--suppress-blank-empty  Suppress space or tab before empty output lines."),
+   "",
+-  N_("    --help               display this help and exit"),
+-  N_("-v, --version            output version information and exit"),
++  N_("-r  --recursive  Recursively compare any subdirectories found."),
++  N_("-N  --new-file  Treat absent files as empty."),
++  N_("--unidirectional-new-file  Treat absent first files as empty."),
++  N_("-s  --report-identical-files  Report when two files are the same."),
++  N_("-x PAT  --exclude=PAT  Exclude files that match PAT."),
++  N_("-X FILE  --exclude-from=FILE  Exclude files that match any pattern in FILE."),
++  N_("-S FILE  --starting-file=FILE  Start with FILE when comparing directories."),
++  N_("--from-file=FILE1  Compare FILE1 to all operands.  FILE1 can be a directory."),
++  N_("--to-file=FILE2  Compare all operands to FILE2.  FILE2 can be a directory."),
+   "",
+-  N_("FILES are 'FILE1 FILE2' or 'DIR1 DIR2' or 'DIR FILE' or 'FILE DIR'."),
+-  N_("If --from-file or --to-file is given, there are no restrictions on FILE(s)."),
++  N_("--horizon-lines=NUM  Keep NUM lines of the common prefix and suffix."),
++  N_("-d  --minimal  Try hard to find a smaller set of changes."),
++  N_("--speed-large-files  Assume large files and many scattered small changes."),
++  "",
++  N_("-v  --version  Output version info."),
++  N_("--help  Output this help."),
++  "",
++  N_("FILES are 'FILE1 FILE2' or 'DIR1 DIR2' or 'DIR FILE...' or 'FILE... DIR'."),
++  N_("If --from-file or --to-file is given, there are no restrictions on FILES."),
+   N_("If a FILE is '-', read standard input."),
+   N_("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."),
+   0
+@@ -992,11 +931,6 @@ usage (void)
+   char const * const *p;
+ 
+   printf (_("Usage: %s [OPTION]... FILES\n"), program_name);
+-  printf ("%s\n\n", _("Compare FILES line by line."));
+-
+-  fputs (_("\
+-Mandatory arguments to long options are mandatory for short options too.\n\
+-"), stdout);
+ 
+   for (p = option_help_msgid;  *p;  p++)
+     {
+@@ -1024,7 +958,7 @@ Mandatory arguments to long options are
+ static void
+ specify_value (char const **var, char const *value, char const *option)
+ {
+-  if (*var && ! STREQ (*var, value))
++  if (*var && strcmp (*var, value) != 0)
+     {
+       error (0, 0, _("conflicting %s option value '%s'"), option, value);
+       try_help (NULL, NULL);
+@@ -1043,21 +977,6 @@ specify_style (enum output_style style)
+       output_style = style;
+     }
+ }
+-
+-/* Set the color mode.  */
+-static void
+-specify_colors_style (char const *value)
+-{
+-  if (value == NULL || STREQ (value, "auto"))
+-    colors_style = AUTO;
+-  else if (STREQ (value, "always"))
+-    colors_style = ALWAYS;
+-  else if (STREQ (value, "never"))
+-    colors_style = NEVER;
+-  else
+-    try_help ("invalid color '%s'", value);
+-}
+-
+ 
+ /* Set the last-modified time of *ST to be the current time.  */
+ 
+@@ -1148,9 +1067,9 @@ compare_files (struct comparison const *
+   else
+     {
+       cmp.file[0].name = free0
+-	= file_name_concat (parent->file[0].name, name0, NULL);
++	= dir_file_pathname (parent->file[0].name, name0);
+       cmp.file[1].name = free1
+-	= file_name_concat (parent->file[1].name, name1, NULL);
++	= dir_file_pathname (parent->file[1].name, name1);
+     }
+ 
+   /* Stat the files.  */
+@@ -1167,8 +1086,8 @@ compare_files (struct comparison const *
+ 	  else if (STREQ (cmp.file[f].name, "-"))
+ 	    {
+ 	      cmp.file[f].desc = STDIN_FILENO;
+-	      if (binary && ! isatty (STDIN_FILENO))
+-		set_binary_mode (STDIN_FILENO, O_BINARY);
++	      if (O_BINARY && binary && ! isatty (STDIN_FILENO))
++		xfreopen (NULL, "rb", stdin);
+ 	      if (fstat (STDIN_FILENO, &cmp.file[f].stat) != 0)
+ 		cmp.file[f].desc = ERRNO_ENCODE (errno);
+ 	      else
+@@ -1188,10 +1107,7 @@ compare_files (struct comparison const *
+ 		  set_mtime_to_now (&cmp.file[f].stat);
+ 		}
+ 	    }
+-	  else if ((no_dereference_symlinks
+-		    ? lstat (cmp.file[f].name, &cmp.file[f].stat)
+-		    : stat (cmp.file[f].name, &cmp.file[f].stat))
+-		   != 0)
++	  else if (stat (cmp.file[f].name, &cmp.file[f].stat) != 0)
+ 	    cmp.file[f].desc = ERRNO_ENCODE (errno);
+ 	}
+     }
+@@ -1207,11 +1123,9 @@ compare_files (struct comparison const *
+ 	    ? (S_ISREG (cmp.file[f].stat.st_mode)
+ 	       && ! (cmp.file[f].stat.st_mode & (S_IRWXU | S_IRWXG | S_IRWXO))
+ 	       && cmp.file[f].stat.st_size == 0)
+-	    : ((cmp.file[f].desc == ERRNO_ENCODE (ENOENT)
+-		|| cmp.file[f].desc == ERRNO_ENCODE (EBADF))
++	    : (cmp.file[f].desc == ERRNO_ENCODE (ENOENT)
+ 	       && ! parent
+-	       && (cmp.file[1 - f].desc == UNOPENED
+-		   || cmp.file[1 - f].desc == STDIN_FILENO))))
++	       && cmp.file[1 - f].desc == UNOPENED)))
+       cmp.file[f].desc = NONEXISTENT;
+ 
+   for (f = 0; f < 2; f++)
+@@ -1242,15 +1156,12 @@ compare_files (struct comparison const *
+       char const *fnm = cmp.file[fnm_arg].name;
+       char const *dir = cmp.file[dir_arg].name;
+       char const *filename = cmp.file[dir_arg].name = free0
+-	= find_dir_file_pathname (dir, last_component (fnm));
++	= dir_file_pathname (dir, last_component (fnm));
+ 
+       if (STREQ (fnm, "-"))
+ 	fatal ("cannot compare '-' to a directory");
+ 
+-      if ((no_dereference_symlinks
+-	   ? lstat (filename, &cmp.file[dir_arg].stat)
+-	   : stat (filename, &cmp.file[dir_arg].stat))
+-	  != 0)
++      if (stat (filename, &cmp.file[dir_arg].stat) != 0)
+ 	{
+ 	  perror_with_name (filename);
+ 	  status = EXIT_TROUBLE;
+@@ -1297,10 +1208,8 @@ compare_files (struct comparison const *
+     }
+   else if ((DIR_P (0) | DIR_P (1))
+ 	   || (parent
+-	       && !((S_ISREG (cmp.file[0].stat.st_mode)
+-		     || S_ISLNK (cmp.file[0].stat.st_mode))
+-		    && (S_ISREG (cmp.file[1].stat.st_mode)
+-			|| S_ISLNK  (cmp.file[1].stat.st_mode)))))
++	       && (! S_ISREG (cmp.file[0].stat.st_mode)
++		   || ! S_ISREG (cmp.file[1].stat.st_mode))))
+     {
+       if (cmp.file[0].desc == NONEXISTENT || cmp.file[1].desc == NONEXISTENT)
+ 	{
+@@ -1341,62 +1250,10 @@ compare_files (struct comparison const *
+ 	  status = EXIT_FAILURE;
+ 	}
+     }
+-  else if (S_ISLNK (cmp.file[0].stat.st_mode)
+-	   || S_ISLNK (cmp.file[1].stat.st_mode))
+-    {
+-      /* We get here only if we use lstat(), not stat().  */
+-      assert (no_dereference_symlinks);
+-
+-      if (S_ISLNK (cmp.file[0].stat.st_mode)
+-	  && S_ISLNK (cmp.file[1].stat.st_mode))
+-	{
+-	  /* Compare the values of the symbolic links.  */
+-	  char *link_value[2] = { NULL, NULL };
+-
+-	  for (f = 0; f < 2; f++)
+-	    {
+-	      link_value[f] = xreadlink (cmp.file[f].name);
+-	      if (link_value[f] == NULL)
+-		{
+-		  perror_with_name (cmp.file[f].name);
+-		  status = EXIT_TROUBLE;
+-		  break;
+-		}
+-	    }
+-	  if (status == EXIT_SUCCESS)
+-	    {
+-	      if ( ! STREQ (link_value[0], link_value[1]))
+-		{
+-		  message ("Symbolic links %s and %s differ\n",
+-			   cmp.file[0].name, cmp.file[1].name);
+-		  /* This is a difference.  */
+-		  status = EXIT_FAILURE;
+-		}
+-	    }
+-	  for (f = 0; f < 2; f++)
+-	    free (link_value[f]);
+-	}
+-      else
+-	{
+-	  /* We have two files that are not to be compared, because
+-	     one of them is a symbolic link and the other one is not.  */
+-
+-	  message5 ("File %s is a %s while file %s is a %s\n",
+-		    file_label[0] ? file_label[0] : cmp.file[0].name,
+-		    file_type (&cmp.file[0].stat),
+-		    file_label[1] ? file_label[1] : cmp.file[1].name,
+-		    file_type (&cmp.file[1].stat));
+-
+-	  /* This is a difference.  */
+-	  status = EXIT_FAILURE;
+-	}
+-    }
+   else if (files_can_be_treated_as_binary
+ 	   && S_ISREG (cmp.file[0].stat.st_mode)
+ 	   && S_ISREG (cmp.file[1].stat.st_mode)
+-	   && cmp.file[0].stat.st_size != cmp.file[1].stat.st_size
+-	   && 0 < cmp.file[0].stat.st_size
+-	   && 0 < cmp.file[1].stat.st_size)
++	   && cmp.file[0].stat.st_size != cmp.file[1].stat.st_size)
+     {
+       message ("Files %s and %s differ\n",
+ 	       file_label[0] ? file_label[0] : cmp.file[0].name,
+diff -pru diffutils-3.0/diff.h diffutils-3.0-patch/diff.h
+--- diffutils-3.0/diff.h	2019-03-16 02:28:09.291892000 -0700
++++ diffutils-3.0-patch/diff.h	2019-03-16 02:29:47.369202000 -0700
+@@ -1,7 +1,7 @@
+ /* Shared definitions for GNU DIFF
+ 
+-   Copyright (C) 1988-1989, 1991-1995, 1998, 2001-2002, 2004, 2009-2013,
+-   2015-2017 Free Software Foundation, Inc.
++   Copyright (C) 1988-1989, 1991-1995, 1998, 2001-2002, 2004, 2009-2010 Free
++   Software Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -38,19 +38,6 @@ enum changes
+   /* Both deletes and inserts: a hunk containing both old and new lines.  */
+   CHANGED
+ };
+-
+-/* When colors should be used in the output.  */
+-enum colors_style
+-{
+-  /* Never output colors.  */
+-  NEVER,
+-
+-  /* Output colors if the output is a terminal.  */
+-  AUTO,
+-
+-  /* Always output colors.  */
+-  ALWAYS,
+-};
+ 
+ /* Variables for command line options */
+ 
+@@ -74,7 +61,7 @@ enum output_style
+   /* Output the differences in a unified context diff format (-u).  */
+   OUTPUT_UNIFIED,
+ 
+-  /* Output the differences as commands suitable for 'ed' (-e).  */
++  /* Output the differences as commands suitable for `ed' (-e).  */
+   OUTPUT_ED,
+ 
+   /* Output the diff as a forward ed script (-f).  */
+@@ -96,9 +83,6 @@ enum output_style
+ 
+ XTERN enum output_style output_style;
+ 
+-/* Define the current color context used to print a line.  */
+-XTERN enum colors_style colors_style;
+-
+ /* Nonzero if output cannot be generated for identical files.  */
+ XTERN bool no_diff_means_no_output;
+ 
+@@ -114,7 +98,7 @@ XTERN bool text;
+ XTERN lin horizon_lines;
+ 
+ /* The significance of white space during comparisons.  */
+-enum DIFF_white_space
++XTERN enum
+ {
+   /* All white space is significant (the default).  */
+   IGNORE_NO_WHITE_SPACE,
+@@ -122,21 +106,12 @@ enum DIFF_white_space
+   /* Ignore changes due to tab expansion (-E).  */
+   IGNORE_TAB_EXPANSION,
+ 
+-  /* Ignore changes in trailing horizontal white space (-Z).  */
+-  IGNORE_TRAILING_SPACE,
+-
+-  /* IGNORE_TAB_EXPANSION and IGNORE_TRAILING_SPACE are a special case
+-     because they are independent and can be ORed together, yielding
+-     IGNORE_TAB_EXPANSION_AND_TRAILING_SPACE.  */
+-  IGNORE_TAB_EXPANSION_AND_TRAILING_SPACE,
+-
+   /* Ignore changes in horizontal white space (-b).  */
+   IGNORE_SPACE_CHANGE,
+ 
+   /* Ignore all horizontal white space (-w).  */
+   IGNORE_ALL_SPACE
+-};
+-XTERN enum DIFF_white_space ignore_white_space;
++} ignore_white_space;
+ 
+ /* Ignore changes that affect only blank lines (-B).  */
+ XTERN bool ignore_blank_lines;
+@@ -151,11 +126,7 @@ XTERN bool ignore_case;
+ /* Ignore differences in case of letters in file names.  */
+ XTERN bool ignore_file_name_case;
+ 
+-/* Act on symbolic links themselves rather than on their target
+-   (--no-dereference).  */
+-XTERN bool no_dereference_symlinks;
+-
+-/* File labels for '-c' output headers (--label).  */
++/* File labels for `-c' output headers (--label).  */
+ XTERN char *file_label[2];
+ 
+ /* Regexp to identify function-header lines (-F).  */
+@@ -231,8 +202,8 @@ XTERN bool minimal;
+ /* The strftime format to use for time strings.  */
+ XTERN char const *time_format;
+ 
+-/* The result of comparison is an "edit script": a chain of 'struct change'.
+-   Each 'struct change' represents one place where some lines are deleted
++/* The result of comparison is an "edit script": a chain of `struct change'.
++   Each `struct change' represents one place where some lines are deleted
+    and some are inserted.
+ 
+    LINE0 and LINE1 are the first affected lines in the two files (origin 0).
+@@ -345,79 +316,58 @@ XTERN FILE *outfile;
+ /* Declare various functions.  */
+ 
+ /* analyze.c */
+-extern int diff_2_files (struct comparison *);
++int diff_2_files (struct comparison *);
+ 
+ /* context.c */
+-extern void print_context_header (struct file_data[], char const * const *, bool);
+-extern void print_context_script (struct change *, bool);
++void print_context_header (struct file_data[], bool);
++void print_context_script (struct change *, bool);
+ 
+ /* dir.c */
+-extern int diff_dirs (struct comparison const *,
+-                      int (*) (struct comparison const *,
+-                               char const *, char const *));
+-extern char *find_dir_file_pathname (char const *, char const *);
++int diff_dirs (struct comparison const *, int (*) (struct comparison const *, char const *, char const *));
+ 
+ /* ed.c */
+-extern void print_ed_script (struct change *);
+-extern void pr_forward_ed_script (struct change *);
++void print_ed_script (struct change *);
++void pr_forward_ed_script (struct change *);
+ 
+ /* ifdef.c */
+-extern void print_ifdef_script (struct change *);
++void print_ifdef_script (struct change *);
+ 
+ /* io.c */
+-extern void file_block_read (struct file_data *, size_t);
+-extern bool read_files (struct file_data[], bool);
++void file_block_read (struct file_data *, size_t);
++bool read_files (struct file_data[], bool);
+ 
+ /* normal.c */
+-extern void print_normal_script (struct change *);
++void print_normal_script (struct change *);
+ 
+ /* rcs.c */
+-extern void print_rcs_script (struct change *);
++void print_rcs_script (struct change *);
+ 
+ /* side.c */
+-extern void print_sdiff_script (struct change *);
++void print_sdiff_script (struct change *);
+ 
+ /* util.c */
+ extern char const change_letter[4];
+ extern char const pr_program[];
+-extern char *concat (char const *, char const *, char const *);
+-extern bool lines_differ (char const *, char const *) _GL_ATTRIBUTE_PURE;
+-extern lin translate_line_number (struct file_data const *, lin);
+-extern struct change *find_change (struct change *);
+-extern struct change *find_reverse_change (struct change *);
+-extern void *zalloc (size_t);
+-extern enum changes analyze_hunk (struct change *, lin *, lin *, lin *, lin *);
+-extern void begin_output (void);
+-extern void debug_script (struct change *);
+-extern void fatal (char const *) __attribute__((noreturn));
+-extern void finish_output (void);
+-extern void message (char const *, char const *, char const *);
+-extern void message5 (char const *, char const *, char const *,
+-                      char const *, char const *);
+-extern void output_1_line (char const *, char const *, char const *,
+-                           char const *);
+-extern void perror_with_name (char const *);
+-extern void pfatal_with_name (char const *) __attribute__((noreturn));
+-extern void print_1_line (char const *, char const * const *);
+-extern void print_1_line_nl (char const *, char const * const *, bool);
+-extern void print_message_queue (void);
+-extern void print_number_range (char, struct file_data *, lin, lin);
+-extern void print_script (struct change *, struct change * (*) (struct change *),
+-                          void (*) (struct change *));
+-extern void setup_output (char const *, char const *, bool);
+-extern void translate_range (struct file_data const *, lin, lin,
+-                             printint *, printint *);
+-
+-enum color_context
+-{
+-  HEADER_CONTEXT,
+-  ADD_CONTEXT,
+-  DELETE_CONTEXT,
+-  RESET_CONTEXT,
+-  LINE_NUMBER_CONTEXT,
+-};
+-
+-XTERN bool presume_output_tty;
+-
+-extern void set_color_context (enum color_context color_context);
+-extern void set_color_palette (char const *palette);
++char *concat (char const *, char const *, char const *);
++char *dir_file_pathname (char const *, char const *);
++bool lines_differ (char const *, char const *);
++lin translate_line_number (struct file_data const *, lin);
++struct change *find_change (struct change *);
++struct change *find_reverse_change (struct change *);
++void *zalloc (size_t);
++enum changes analyze_hunk (struct change *, lin *, lin *, lin *, lin *);
++void begin_output (void);
++void debug_script (struct change *);
++void fatal (char const *) __attribute__((noreturn));
++void finish_output (void);
++void message (char const *, char const *, char const *);
++void message5 (char const *, char const *, char const *, char const *, char const *);
++void output_1_line (char const *, char const *, char const *, char const *);
++void perror_with_name (char const *);
++void pfatal_with_name (char const *) __attribute__((noreturn));
++void print_1_line (char const *, char const * const *);
++void print_message_queue (void);
++void print_number_range (char, struct file_data *, lin, lin);
++void print_script (struct change *, struct change * (*) (struct change *), void (*) (struct change *));
++void setup_output (char const *, char const *, bool);
++void translate_range (struct file_data const *, lin, lin, long int *, long int *);
+Only in diffutils-3.0-patch: diff.o
+diff -pru diffutils-3.0/dir.c diffutils-3.0-patch/dir.c
+--- diffutils-3.0/dir.c	2019-03-16 02:28:09.297894000 -0700
++++ diffutils-3.0-patch/dir.c	2019-03-16 02:29:47.374201000 -0700
+@@ -1,7 +1,7 @@
+ /* Read, sort and compare two directories.  Used for GNU DIFF.
+ 
+    Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006-2007,
+-   2009-2013, 2015-2017 Free Software Foundation, Inc.
++   2009-2010 Free Software Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -21,7 +21,6 @@
+ #include "diff.h"
+ #include <error.h>
+ #include <exclude.h>
+-#include <filenamecat.h>
+ #include <setjmp.h>
+ #include <xalloc.h>
+ 
+@@ -45,6 +44,7 @@ static bool locale_specific_sorting;
+ static jmp_buf failed_locale_specific_sorting;
+ 
+ static bool dir_loop (struct comparison const *, int);
++static int compare_names_for_qsort (void const *, void const *);
+ 
+ 
+ /* Read a directory and get its vector of names.  */
+@@ -84,7 +84,7 @@ dir_read (struct file_data const *dir, s
+       dirdata->data = data = xmalloc (data_alloc);
+ 
+       /* Read the directory entries, and insert the subfiles
+-	 into the 'data' table.  */
++	 into the `data' table.  */
+ 
+       while ((errno = 0, (next = readdir (reading)) != 0))
+ 	{
+@@ -125,7 +125,7 @@ dir_read (struct file_data const *dir, s
+ #endif
+     }
+ 
+-  /* Create the 'names' table from the 'data' table.  */
++  /* Create the `names' table from the `data' table.  */
+   if (PTRDIFF_MAX / sizeof *names - 1 <= nnames)
+     xalloc_die ();
+   dirdata->names = names = xmalloc ((nnames + 1) * sizeof *names);
+@@ -139,27 +139,6 @@ dir_read (struct file_data const *dir, s
+   return true;
+ }
+ 
+-/* Compare strings in a locale-specific way, returning a value
+-   compatible with strcmp.  */
+-
+-static int
+-compare_collated (char const *name1, char const *name2)
+-{
+-  int r;
+-  errno = 0;
+-  if (ignore_file_name_case)
+-    r = strcasecoll (name1, name2);
+-  else
+-    r = strcoll (name1, name2);
+-  if (errno)
+-    {
+-      error (0, errno, _("cannot compare file names '%s' and '%s'"),
+-	     name1, name2);
+-      longjmp (failed_locale_specific_sorting, 1);
+-    }
+-  return r;
+-}
+-
+ /* Compare file names, returning a value compatible with strcmp.  */
+ 
+ static int
+@@ -167,30 +146,34 @@ compare_names (char const *name1, char c
+ {
+   if (locale_specific_sorting)
+     {
+-      int diff = compare_collated (name1, name2);
+-      if (diff || ignore_file_name_case)
+-	return diff;
++      int r;
++      errno = 0;
++      if (ignore_file_name_case)
++	r = strcasecoll (name1, name2);
++      else
++	r = strcoll (name1, name2);
++      if (errno)
++	{
++	  error (0, errno, _("cannot compare file names '%s' and '%s'"),
++		 name1, name2);
++	  longjmp (failed_locale_specific_sorting, 1);
++	}
++      return r;
+     }
+-  return file_name_cmp (name1, name2);
++
++  return (ignore_file_name_case
++	  ? strcasecmp (name1, name2)
++	  : file_name_cmp (name1, name2));
+ }
+ 
+-/* Compare names FILE1 and FILE2 when sorting a directory.
+-   Prefer filtered comparison, breaking ties with file_name_cmp.  */
++/* A wrapper for compare_names suitable as an argument for qsort.  */
+ 
+ static int
+ compare_names_for_qsort (void const *file1, void const *file2)
+ {
+   char const *const *f1 = file1;
+   char const *const *f2 = file2;
+-  char const *name1 = *f1;
+-  char const *name2 = *f2;
+-  if (locale_specific_sorting)
+-    {
+-      int diff = compare_collated (name1, name2);
+-      if (diff)
+-	return diff;
+-    }
+-  return file_name_cmp (name1, name2);
++  return compare_names (*f1, *f2);
+ }
+ 
+ /* Compare the contents of two directories named in CMP.
+@@ -251,7 +234,7 @@ diff_dirs (struct comparison const *cmp,
+ 	qsort (names[i], dirdata[i].nnames, sizeof *dirdata[i].names,
+ 	       compare_names_for_qsort);
+ 
+-      /* If '-S name' was given, and this is the topmost level of comparison,
++      /* If `-S name' was given, and this is the topmost level of comparison,
+ 	 ignore all file names less than the specified starting name.  */
+ 
+       if (starting_file && ! cmp->parent)
+@@ -270,41 +253,6 @@ diff_dirs (struct comparison const *cmp,
+ 	     pretend the "next name" in that dir is very large.  */
+ 	  int nameorder = (!*names[0] ? 1 : !*names[1] ? -1
+ 			   : compare_names (*names[0], *names[1]));
+-
+-	  /* Prefer a file_name_cmp match if available.  This algorithm is
+-	     O(N**2), where N is the number of names in a directory
+-	     that compare_names says are all equal, but in practice N
+-	     is so small it's not worth tuning.  */
+-	  if (nameorder == 0 && ignore_file_name_case)
+-	    {
+-	      int raw_order = file_name_cmp (*names[0], *names[1]);
+-	      if (raw_order != 0)
+-		{
+-		  int greater_side = raw_order < 0;
+-		  int lesser_side = 1 - greater_side;
+-		  char const **lesser = names[lesser_side];
+-		  char const *greater_name = *names[greater_side];
+-		  char const **p;
+-
+-		  for (p = lesser + 1;
+-		       *p && compare_names (*p, greater_name) == 0;
+-		       p++)
+-		    {
+-		      int c = file_name_cmp (*p, greater_name);
+-		      if (0 <= c)
+-			{
+-			  if (c == 0)
+-			    {
+-			      memmove (lesser + 1, lesser,
+-				       (char *) p - (char *) lesser);
+-			      *lesser = greater_name;
+-			    }
+-			  break;
+-			}
+-		    }
+-		}
+-	    }
+-
+ 	  int v1 = (*handle_file) (cmp,
+ 				   0 < nameorder ? 0 : *names[0]++,
+ 				   nameorder < 0 ? 0 : *names[1]++);
+@@ -324,7 +272,7 @@ diff_dirs (struct comparison const *cmp,
+ 
+ /* Return nonzero if CMP is looping recursively in argument I.  */
+ 
+-static bool _GL_ATTRIBUTE_PURE
++static bool
+ dir_loop (struct comparison const *cmp, int i)
+ {
+   struct comparison const *p = cmp;
+@@ -333,53 +281,3 @@ dir_loop (struct comparison const *cmp,
+       return true;
+   return false;
+ }
+-
+-/* Find a matching filename in a directory.  */
+-
+-char *
+-find_dir_file_pathname (char const *dir, char const *file)
+-{
+-  /* The 'IF_LINT (volatile)' works around what appears to be a bug in
+-     gcc 4.8.0 20120825; see
+-     <http://lists.gnu.org/archive/html/bug-diffutils/2012-08/msg00007.html>.
+-     */
+-  char const * IF_LINT (volatile) match = file;
+-
+-  char *val;
+-  struct dirdata dirdata;
+-  dirdata.names = NULL;
+-  dirdata.data = NULL;
+-
+-  if (ignore_file_name_case)
+-    {
+-      struct file_data filedata;
+-      filedata.name = dir;
+-      filedata.desc = 0;
+-
+-      if (dir_read (&filedata, &dirdata))
+-	{
+-	  locale_specific_sorting = true;
+-	  if (setjmp (failed_locale_specific_sorting))
+-	    match = file; /* longjmp may mess up MATCH.  */
+-	  else
+-	    {
+-	      for (char const **p = dirdata.names; *p; p++)
+-		if (compare_names (*p, file) == 0)
+-		  {
+-		    if (file_name_cmp (*p, file) == 0)
+-		      {
+-			match = *p;
+-			break;
+-		      }
+-		    if (match == file)
+-		      match = *p;
+-		  }
+-	    }
+-	}
+-    }
+-
+-  val = file_name_concat (dir, match, NULL);
+-  free (dirdata.names);
+-  free (dirdata.data);
+-  return val;
+-}
+Only in diffutils-3.0-patch: dir.o
+diff -pru diffutils-3.0/ed.c diffutils-3.0-patch/ed.c
+--- diffutils-3.0/ed.c	2019-03-16 02:28:09.300895000 -0700
++++ diffutils-3.0-patch/ed.c	2019-03-16 02:29:47.376206000 -0700
+@@ -1,7 +1,7 @@
+ /* Output routines for ed-script format.
+ 
+-   Copyright (C) 1988-1989, 1991-1993, 1995, 1998, 2001, 2004, 2006, 2009-2013,
+-   2015-2017 Free Software Foundation, Inc.
++   Copyright (C) 1988-1989, 1991-1993, 1995, 1998, 2001, 2004, 2006, 2009-2010
++   Free Software Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -144,7 +144,7 @@ static void
+ print_rcs_hunk (struct change *hunk)
+ {
+   lin i, f0, l0, f1, l1;
+-  printint tf0, tl0, tf1, tl1;
++  long int tf0, tl0, tf1, tl1;
+ 
+   /* Determine range of line numbers involved in each file.  */
+   enum changes changes = analyze_hunk (hunk, &f0, &l0, &f1, &l1);
+@@ -159,16 +159,14 @@ print_rcs_hunk (struct change *hunk)
+     {
+       /* For deletion, print just the starting line number from file 0
+ 	 and the number of lines deleted.  */
+-      fprintf (outfile, "d%"pI"d %"pI"d\n", tf0,
+-	       tf0 <= tl0 ? tl0 - tf0 + 1 : 1);
++      fprintf (outfile, "d%ld %ld\n", tf0, tf0 <= tl0 ? tl0 - tf0 + 1 : 1);
+     }
+ 
+   if (changes & NEW)
+     {
+       /* Take last-line-number from file 0 and # lines from file 1.  */
+       translate_range (&files[1], f1, l1, &tf1, &tl1);
+-      fprintf (outfile, "a%"pI"d %"pI"d\n", tl0,
+-	       tf1 <= tl1 ? tl1 - tf1 + 1 : 1);
++      fprintf (outfile, "a%ld %ld\n", tl0, tf1 <= tl1 ? tl1 - tf1 + 1 : 1);
+ 
+       /* Print the inserted lines.  */
+       for (i = f1; i <= l1; i++)
+Only in diffutils-3.0-patch: ed.o
+diff -pru diffutils-3.0/ifdef.c diffutils-3.0-patch/ifdef.c
+--- diffutils-3.0/ifdef.c	2019-03-16 02:28:09.303899000 -0700
++++ diffutils-3.0-patch/ifdef.c	2019-03-16 02:29:47.379206000 -0700
+@@ -1,7 +1,7 @@
+ /* #ifdef-format output routines for GNU DIFF.
+ 
+-   Copyright (C) 1989, 1991-1994, 2001-2002, 2004, 2006, 2009-2013, 2015-2017
+-   Free Software Foundation, Inc.
++   Copyright (C) 1989, 1991-1994, 2001-2002, 2004, 2006, 2009-2010 Free
++   Software Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -132,7 +132,7 @@ format_group (register FILE *out, char c
+ 	    break;
+ 
+ 	  case '(':
+-	    /* Print if-then-else format e.g. '%(n=1?thenpart:elsepart)'.  */
++	    /* Print if-then-else format e.g. `%(n=1?thenpart:elsepart)'.  */
+ 	    {
+ 	      int i;
+ 	      uintmax_t value[2];
+@@ -357,22 +357,21 @@ do_printf_spec (FILE *out, char const *s
+ 
+ 	if (out)
+ 	  {
+-	    /* For example, if the spec is "%3xn" and pI is "l", use the printf
++	    /* For example, if the spec is "%3xn", use the printf
+ 	       format spec "%3lx".  Here the spec prefix is "%3".  */
+-	    printint print_value = value;
++	    long int long_value = value;
+ 	    size_t spec_prefix_len = f - spec - 2;
+-	    size_t pI_len = sizeof pI - 1;
+-#if 0
+-	    char format[spec_prefix_len + pI_len + 2];
++#if HAVE_C_VARARRAYS
++	    char format[spec_prefix_len + 3];
+ #else
+-	    char *format = xmalloc (spec_prefix_len + pI_len + 2);
++	    char *format = xmalloc (spec_prefix_len + 3);
+ #endif
+-	    char *p = format + spec_prefix_len + pI_len;
++	    char *p = format + spec_prefix_len;
+ 	    memcpy (format, spec, spec_prefix_len);
+-	    memcpy (format + spec_prefix_len, pI, pI_len);
++	    *p++ = 'l';
+ 	    *p++ = c;
+ 	    *p = '\0';
+-	    fprintf (out, format, print_value);
++	    fprintf (out, format, long_value);
+ #if ! HAVE_C_VARARRAYS
+ 	    free (format);
+ #endif
+Only in diffutils-3.0-patch: ifdef.o
+diff -pru diffutils-3.0/io.c diffutils-3.0-patch/io.c
+--- diffutils-3.0/io.c	2019-03-16 02:28:09.306894000 -0700
++++ diffutils-3.0-patch/io.c	2019-03-16 02:29:47.382211000 -0700
+@@ -1,7 +1,7 @@
+ /* File I/O for GNU DIFF.
+ 
+-   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2013,
+-   2015-2017 Free Software Foundation, Inc.
++   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
++   Free Software Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -19,7 +19,6 @@
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+ 
+ #include "diff.h"
+-#include <binary-io.h>
+ #include <cmpbuf.h>
+ #include <file-type.h>
+ #include <xalloc.h>
+@@ -58,10 +57,10 @@ static size_t nbuckets;
+    The number of an equivalence class is its index in this array.  */
+ static struct equivclass *equivs;
+ 
+-/* Index of first free element in the array 'equivs'.  */
++/* Index of first free element in the array `equivs'.  */
+ static lin equivs_index;
+ 
+-/* Number of elements allocated in the array 'equivs'.  */
++/* Number of elements allocated in the array `equivs'.  */
+ static lin equivs_alloc;
+ 
+ /* Read a block of data into a file buffer, checking for EOF and error.  */
+@@ -108,35 +107,15 @@ sip (struct file_data *current, bool ski
+ 				     PTRDIFF_MAX - 2 * sizeof (word));
+       current->buffer = xmalloc (current->bufsize);
+ 
+-#ifdef __KLIBC__
+-      /* Skip test if seek is not possible */
+-      skip_test = skip_test
+-		  || (lseek (current->desc, 0, SEEK_CUR) < 0
+-		      && errno == ESPIPE);
+-#endif
+-
+       if (! skip_test)
+ 	{
+ 	  /* Check first part of file to see if it's a binary file.  */
+ 
+-	  int prev_mode = set_binary_mode (current->desc, O_BINARY);
+-	  off_t buffered;
+-	  file_block_read (current, current->bufsize);
+-	  buffered = current->buffered;
+-
+-	  if (prev_mode != O_BINARY)
+-	    {
+-	      /* Revert to text mode and seek back to the start to reread
+-		 the file.  Use relative seek, since file descriptors
+-		 like stdin might not start at offset zero.  */
+-	      if (lseek (current->desc, - buffered, SEEK_CUR) < 0)
+-		pfatal_with_name (current->name);
+-	      set_binary_mode (current->desc, prev_mode);
+-	      current->buffered = 0;
+-	      current->eof = false;
+-	    }
++	  /* FIXME: if O_BINARY, this should revert to text mode
++	     if the file is not binary.  */
+ 
+-	  return binary_file_p (current->buffer, buffered);
++	  file_block_read (current, current->bufsize);
++	  return binary_file_p (current->buffer, current->buffered);
+ 	}
+     }
+ 
+@@ -219,7 +198,9 @@ slurp (struct file_data *current)
+ static void
+ find_and_hash_each_line (struct file_data *current)
+ {
++  hash_value h;
+   char const *p = current->prefix_end;
++  unsigned char c;
+   lin i, *bucket;
+   size_t length;
+ 
+@@ -234,70 +215,122 @@ find_and_hash_each_line (struct file_dat
+   lin eqs_alloc = equivs_alloc;
+   char const *suffix_begin = current->suffix_begin;
+   char const *bufend = FILE_BUFFER (current) + current->buffered;
+-  bool ig_case = ignore_case;
+-  enum DIFF_white_space ig_white_space = ignore_white_space;
+   bool diff_length_compare_anyway =
+-    ig_white_space != IGNORE_NO_WHITE_SPACE;
++    ignore_white_space != IGNORE_NO_WHITE_SPACE;
+   bool same_length_diff_contents_compare_anyway =
+-    diff_length_compare_anyway | ig_case;
++    diff_length_compare_anyway | ignore_case;
+ 
+   while (p < suffix_begin)
+     {
+       char const *ip = p;
+-      hash_value h = 0;
+-      unsigned char c;
++
++      h = 0;
+ 
+       /* Hash this line until we find a newline.  */
+-      switch (ig_white_space)
+-	{
+-	case IGNORE_ALL_SPACE:
+-	  while ((c = *p++) != '\n')
+-	    if (! isspace (c))
+-	      h = HASH (h, ig_case ? tolower (c) : c);
+-	  break;
++      if (ignore_case)
++	switch (ignore_white_space)
++	  {
++	  case IGNORE_ALL_SPACE:
++	    while ((c = *p++) != '\n')
++	      if (! isspace (c))
++		h = HASH (h, tolower (c));
++	    break;
++
++	  case IGNORE_SPACE_CHANGE:
++	    while ((c = *p++) != '\n')
++	      {
++		if (isspace (c))
++		  {
++		    do
++		      if ((c = *p++) == '\n')
++			goto hashing_done;
++		    while (isspace (c));
++
++		    h = HASH (h, ' ');
++		  }
+ 
+-	case IGNORE_SPACE_CHANGE:
+-	  while ((c = *p++) != '\n')
++		/* C is now the first non-space.  */
++		h = HASH (h, tolower (c));
++	      }
++	    break;
++
++	  case IGNORE_TAB_EXPANSION:
+ 	    {
+-	      if (isspace (c))
++	      size_t column = 0;
++	      while ((c = *p++) != '\n')
+ 		{
+-		  do
+-		    if ((c = *p++) == '\n')
+-		      goto hashing_done;
+-		  while (isspace (c));
++		  size_t repetitions = 1;
+ 
+-		  h = HASH (h, ' ');
+-		}
++		  switch (c)
++		    {
++		    case '\b':
++		      column -= 0 < column;
++		      break;
++
++		    case '\t':
++		      c = ' ';
++		      repetitions = tabsize - column % tabsize;
++		      column = (column + repetitions < column
++				? 0
++				: column + repetitions);
++		      break;
++
++		    case '\r':
++		      column = 0;
++		      break;
+ 
+-	      /* C is now the first non-space.  */
+-	      h = HASH (h, ig_case ? tolower (c) : c);
++		    default:
++		      c = tolower (c);
++		      column++;
++		      break;
++		    }
++
++		  do
++		    h = HASH (h, c);
++		  while (--repetitions != 0);
++		}
+ 	    }
+-	  break;
++	    break;
+ 
+-	case IGNORE_TAB_EXPANSION:
+-	case IGNORE_TAB_EXPANSION_AND_TRAILING_SPACE:
+-	case IGNORE_TRAILING_SPACE:
++	  default:
++	    while ((c = *p++) != '\n')
++	      h = HASH (h, tolower (c));
++	    break;
++	  }
++      else
++	switch (ignore_white_space)
+ 	  {
+-	    size_t column = 0;
++	  case IGNORE_ALL_SPACE:
++	    while ((c = *p++) != '\n')
++	      if (! isspace (c))
++		h = HASH (h, c);
++	    break;
++
++	  case IGNORE_SPACE_CHANGE:
+ 	    while ((c = *p++) != '\n')
+ 	      {
+-		if (ig_white_space & IGNORE_TRAILING_SPACE
+-		    && isspace (c))
++		if (isspace (c))
+ 		  {
+-		    char const *p1 = p;
+-		    unsigned char c1;
+ 		    do
+-		      if ((c1 = *p1++) == '\n')
+-			{
+-			  p = p1;
+-			  goto hashing_done;
+-			}
+-		    while (isspace (c1));
++		      if ((c = *p++) == '\n')
++			goto hashing_done;
++		    while (isspace (c));
++
++		    h = HASH (h, ' ');
+ 		  }
+ 
+-		size_t repetitions = 1;
++		/* C is now the first non-space.  */
++		h = HASH (h, c);
++	      }
++	    break;
++
++	  case IGNORE_TAB_EXPANSION:
++	    {
++	      size_t column = 0;
++	      while ((c = *p++) != '\n')
++		{
++		  size_t repetitions = 1;
+ 
+-		if (ig_white_space & IGNORE_TAB_EXPANSION)
+ 		  switch (c)
+ 		    {
+ 		    case '\b':
+@@ -321,25 +354,18 @@ find_and_hash_each_line (struct file_dat
+ 		      break;
+ 		    }
+ 
+-		if (ig_case)
+-		  c = tolower (c);
+-
+-		do
+-		  h = HASH (h, c);
+-		while (--repetitions != 0);
+-	      }
+-	  }
+-	  break;
++		  do
++		    h = HASH (h, c);
++		  while (--repetitions != 0);
++		}
++	    }
++	    break;
+ 
+-	default:
+-	  if (ig_case)
+-	    while ((c = *p++) != '\n')
+-	      h = HASH (h, tolower (c));
+-	  else
++	  default:
+ 	    while ((c = *p++) != '\n')
+ 	      h = HASH (h, c);
+-	  break;
+-	}
++	    break;
++	  }
+ 
+    hashing_done:;
+ 
+@@ -355,7 +381,7 @@ find_and_hash_each_line (struct file_dat
+ 	     complete line, put it into buckets[-1] so that it can
+ 	     compare equal only to the other file's incomplete line
+ 	     (if one exists).  */
+-	  if (ig_white_space < IGNORE_TRAILING_SPACE)
++	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
+ 	    bucket = &buckets[-1];
+ 	}
+ 
+@@ -481,6 +507,7 @@ prepare_text (struct file_data *current)
+ {
+   size_t buffered = current->buffered;
+   char *p = FILE_BUFFER (current);
++  char *dst;
+ 
+   if (buffered == 0 || p[buffered - 1] == '\n')
+     current->missing_newline = false;
+@@ -496,25 +523,16 @@ prepare_text (struct file_data *current)
+   /* Don't use uninitialized storage when planting or using sentinels.  */
+   memset (p + buffered, 0, sizeof (word));
+ 
+-  if (strip_trailing_cr)
++  if (strip_trailing_cr && (dst = memchr (p, '\r', buffered)))
+     {
+-      char *dst;
+-      char *srclim = p + buffered;
+-      *srclim = '\r';
+-      dst = rawmemchr (p, '\r');
++      char const *src = dst;
++      char const *srclim = p + buffered;
+ 
+-      if (dst != srclim)
+-	{
+-	  char const *src = dst;
+-	  do
+-	    {
+-	      *dst = *src++;
+-	      dst += ! (*dst == '\r' && *src == '\n');
+-	    }
+-	  while (src < srclim);
++      do
++	dst += ! ((*dst = *src++) == '\r' && *src == '\n');
++      while (src < srclim);
+ 
+-	  buffered -= src - dst;
+-	}
++      buffered -= src - dst;
+     }
+ 
+   current->buffered = buffered;
+@@ -545,7 +563,6 @@ find_identical_ends (struct file_data fi
+   lin i, lines;
+   size_t n0, n1;
+   lin alloc_lines0, alloc_lines1;
+-  bool prefix_needed;
+   lin buffered_prefix, prefix_count, prefix_mask;
+   lin middle_guess, suffix_guess;
+ 
+@@ -695,13 +712,12 @@ find_identical_ends (struct file_data fi
+   prefix_mask = prefix_count - 1;
+   lines = 0;
+   linbuf0 = xmalloc (alloc_lines0 * sizeof *linbuf0);
+-  prefix_needed = ! (no_diff_means_no_output
+-		     && filevec[0].prefix_end == p0
+-		     && filevec[1].prefix_end == p1);
+   p0 = buffer0;
+ 
+   /* If the prefix is needed, find the prefix lines.  */
+-  if (prefix_needed)
++  if (! (no_diff_means_no_output
++	 && filevec[0].prefix_end == p0
++	 && filevec[1].prefix_end == p1))
+     {
+       end0 = filevec[0].prefix_end;
+       while (p0 != end0)
+@@ -792,8 +808,7 @@ read_files (struct file_data filevec[],
+     }
+   if (appears_binary)
+     {
+-      set_binary_mode (filevec[0].desc, O_BINARY);
+-      set_binary_mode (filevec[1].desc, O_BINARY);
++      /* FIXME: If O_BINARY, this should set both files to binary mode.  */
+       return true;
+     }
+ 
+Only in diffutils-3.0-patch: io.o
+Only in diffutils-3.0-patch: Makefile
+diff -pru diffutils-3.0/Makefile.am diffutils-3.0-patch/Makefile.am
+--- diffutils-3.0/Makefile.am	2019-03-16 02:28:09.276889000 -0700
++++ diffutils-3.0-patch/Makefile.am	2019-03-16 02:29:47.142181000 -0700
+@@ -1,7 +1,6 @@
+ # Automakefile for GNU diffutils programs.
+ 
+-# Copyright (C) 2001-2002, 2006, 2009-2013, 2015-2017 Free Software Foundation,
+-# Inc.
++# Copyright (C) 2001-2002, 2006, 2009-2010 Free Software Foundation, Inc.
+ 
+ # This program is free software: you can redistribute it and/or modify
+ # it under the terms of the GNU General Public License as published by
+@@ -18,13 +17,14 @@
+ 
+ bin_PROGRAMS = cmp diff diff3 sdiff
+ 
++noinst_HEADERS = system.h
++
+ localedir = $(datadir)/locale
+ 
+ AM_CPPFLAGS = -I../lib -I$(top_srcdir)/lib
+ AM_CFLAGS = $(WARN_CFLAGS) $(WERROR_CFLAGS)
+ 
+ LDADD = \
+-  libver.a \
+   ../lib/libdiffutils.a \
+   $(LIBCSTACK) \
+   $(LIBINTL) \
+@@ -41,12 +41,8 @@ cmp_SOURCES = cmp.c
+ diff3_SOURCES = diff3.c
+ sdiff_SOURCES = sdiff.c
+ diff_SOURCES = \
+-  analyze.c context.c diff.c dir.c ed.c ifdef.c io.c \
++  analyze.c context.c diff.c diff.h dir.c ed.c ifdef.c io.c \
+   normal.c side.c util.c
+-noinst_HEADERS =	\
+-  die.h			\
+-  diff.h		\
+-  system.h
+ 
+ MOSTLYCLEANFILES = paths.h paths.ht
+ 
+@@ -57,24 +53,3 @@ BUILT_SOURCES = paths.h
+ paths.h: Makefile.am
+ 	$(AM_V_GEN)(echo '#define DEFAULT_DIFF_PROGRAM "'$(gdiff)'"' && \
+ 	  echo '#define LOCALEDIR "$(localedir)"') >$@t && mv $@t $@
+-
+-noinst_LIBRARIES = libver.a
+-nodist_libver_a_SOURCES = version.c version.h
+-
+-BUILT_SOURCES += version.c
+-version.c: Makefile
+-	$(AM_V_GEN)rm -f $@
+-	$(AM_V_at)printf '#include <config.h>\n' > $@t
+-	$(AM_V_at)printf 'char const *Version = "$(PACKAGE_VERSION)";\n' >> $@t
+-	$(AM_V_at)chmod a-w $@t
+-	$(AM_V_at)mv $@t $@
+-
+-BUILT_SOURCES += version.h
+-version.h: Makefile
+-	$(AM_V_GEN)rm -f $@
+-	$(AM_V_at)printf 'extern char const *Version;\n' > $@t
+-	$(AM_V_at)chmod a-w $@t
+-	$(AM_V_at)mv $@t $@
+-
+-DISTCLEANFILES = version.c version.h
+-MAINTAINERCLEANFILES = $(BUILT_SOURCES)
+Only in diffutils-3.0-patch: Makefile.in
+diff -pru diffutils-3.0/normal.c diffutils-3.0-patch/normal.c
+--- diffutils-3.0/normal.c	2019-03-16 02:28:09.308894000 -0700
++++ diffutils-3.0-patch/normal.c	2019-03-16 02:29:47.385206000 -0700
+@@ -1,7 +1,7 @@
+ /* Normal-format output routines for GNU DIFF.
+ 
+-   Copyright (C) 1988-1989, 1993, 1995, 1998, 2001, 2006, 2009-2013, 2015-2017
+-   Free Software Foundation, Inc.
++   Copyright (C) 1988-1989, 1993, 1995, 1998, 2001, 2006, 2009-2010 Free
++   Software Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -49,43 +49,21 @@ print_normal_hunk (struct change *hunk)
+   begin_output ();
+ 
+   /* Print out the line number header for this hunk */
+-  set_color_context (LINE_NUMBER_CONTEXT);
+   print_number_range (',', &files[0], first0, last0);
+   fputc (change_letter[changes], outfile);
+   print_number_range (',', &files[1], first1, last1);
+-  set_color_context (RESET_CONTEXT);
+   fputc ('\n', outfile);
+ 
+   /* Print the lines that the first file has.  */
+   if (changes & OLD)
+-    {
+-      if (first0 <= last0)
+-        set_color_context (DELETE_CONTEXT);
+-      for (i = first0; i <= last0; i++)
+-        {
+-          print_1_line_nl ("<", &files[0].linbuf[i], true);
+-          if (i == last0)
+-            set_color_context (RESET_CONTEXT);
+-          if (files[0].linbuf[i + 1][-1] == '\n')
+-            putc ('\n', outfile);
+-        }
+-    }
++    for (i = first0; i <= last0; i++)
++      print_1_line ("<", &files[0].linbuf[i]);
+ 
+   if (changes == CHANGED)
+     fputs ("---\n", outfile);
+ 
+   /* Print the lines that the second file has.  */
+   if (changes & NEW)
+-    {
+-      if (first1 <= last1)
+-        set_color_context (ADD_CONTEXT);
+-      for (i = first1; i <= last1; i++)
+-        {
+-          print_1_line_nl (">", &files[1].linbuf[i], true);
+-          if (i == last1)
+-            set_color_context (RESET_CONTEXT);
+-          if (files[1].linbuf[i + 1][-1] == '\n')
+-            putc ('\n', outfile);
+-        }
+-    }
++    for (i = first1; i <= last1; i++)
++      print_1_line (">", &files[1].linbuf[i]);
+ }
+Only in diffutils-3.0-patch: normal.o
+Only in diffutils-3.0-patch: paths.h
+Only in diffutils-3.0-patch: sdiff
+diff -pru diffutils-3.0/sdiff.c diffutils-3.0-patch/sdiff.c
+--- diffutils-3.0/sdiff.c	2019-03-16 02:28:09.311893000 -0700
++++ diffutils-3.0-patch/sdiff.c	2019-03-16 02:29:47.388202000 -0700
+@@ -1,7 +1,7 @@
+ /* sdiff - side-by-side merge of file differences
+ 
+-   Copyright (C) 1992-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2013,
+-   2015-2017 Free Software Foundation, Inc.
++   Copyright (C) 1992-1996, 1998, 2001-2002, 2004, 2006-2007, 2009-2010 Free
++   Software Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -26,17 +26,16 @@
+ 
+ #include <c-stack.h>
+ #include <dirname.h>
+-#include "die.h"
+ #include <error.h>
+ #include <exitfail.h>
+ #include <file-type.h>
+ #include <getopt.h>
+ #include <progname.h>
+-#include <system-quote.h>
++#include <sh-quote.h>
+ #include <version-etc.h>
+ #include <xalloc.h>
+ 
+-/* The official name of this program (e.g., no 'g' prefix).  */
++/* The official name of this program (e.g., no `g' prefix).  */
+ #define PROGRAM_NAME "sdiff"
+ 
+ #define AUTHORS \
+@@ -51,7 +50,7 @@ static char const **diffargv;
+ static char * volatile tmpname;
+ static FILE *tmp;
+ 
+-#if HAVE_WORKING_FORK
++#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+ static pid_t volatile diffpid;
+ #endif
+ 
+@@ -67,6 +66,7 @@ static void perror_fatal (char const *)
+ static void trapsigs (void);
+ static void untrapsig (int);
+ 
++#define NUM_SIGS (sizeof sigs / sizeof *sigs)
+ static int const sigs[] = {
+ #ifdef SIGHUP
+        SIGHUP,
+@@ -85,17 +85,14 @@ static int const sigs[] = {
+ #endif
+ #ifdef SIGPIPE
+        SIGPIPE,
++# define handler_index_of_SIGPIPE (NUM_SIGS - 2)
+ #endif
+        SIGINT
++#define handler_index_of_SIGINT (NUM_SIGS - 1)
+ };
+-enum
+-  {
+-    NUM_SIGS = sizeof sigs / sizeof *sigs,
+-    handler_index_of_SIGINT = NUM_SIGS - 1
+-  };
+ 
+ #if HAVE_SIGACTION
+-  /* Prefer 'sigaction' if available, since 'signal' can lose signals.  */
++  /* Prefer `sigaction' if available, since `signal' can lose signals.  */
+   static struct sigaction initial_action[NUM_SIGS];
+ # define initial_handler(i) (initial_action[i].sa_handler)
+   static void signal_handler (int, void (*) (int));
+@@ -105,6 +102,29 @@ enum
+ # define signal_handler(sig, handler) signal (sig, handler)
+ #endif
+ 
++#if ! HAVE_SIGPROCMASK
++# define sigset_t int
++# define sigemptyset(s) (*(s) = 0)
++# ifndef sigmask
++#  define sigmask(sig) (1 << ((sig) - 1))
++# endif
++# define sigaddset(s, sig) (*(s) |= sigmask (sig))
++# ifndef SIG_BLOCK
++#  define SIG_BLOCK 0
++# endif
++# ifndef SIG_SETMASK
++#  define SIG_SETMASK (! SIG_BLOCK)
++# endif
++# if ! HAVE_SIGBLOCK
++#  define sigblock(mask) (mask)
++#  define sigsetmask(mask) (mask)
++# endif
++# define sigprocmask(how, n, o) \
++    ((how) == SIG_BLOCK \
++     ? ((o) ? (*(sigset_t *) (o) = sigblock (*(n))) : sigblock (*(n))) \
++     : sigsetmask (*(n)))
++#endif
++
+ static bool diraccess (char const *);
+ static int temporary_file (void);
+ 
+@@ -136,7 +156,6 @@ static struct option const longopts[] =
+   {"ignore-matching-lines", 1, 0, 'I'},
+   {"ignore-space-change", 0, 0, 'b'},
+   {"ignore-tab-expansion", 0, 0, 'E'},
+-  {"ignore-trailing-space", 0, 0, 'Z'},
+   {"left-column", 0, 0, 'l'},
+   {"minimal", 0, 0, 'd'},
+   {"output", 1, 0, 'o'},
+@@ -156,8 +175,9 @@ try_help (char const *reason_msgid, char
+ {
+   if (reason_msgid)
+     error (0, 0, _(reason_msgid), operand);
+-  die (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
++  error (EXIT_TROUBLE, 0, _("Try '%s --help' for more information."),
+ 	 program_name);
++  abort ();
+ }
+ 
+ static void
+@@ -170,31 +190,30 @@ check_stdout (void)
+ }
+ 
+ static char const * const option_help_msgid[] = {
+-  N_("-o, --output=FILE            operate interactively, sending output to FILE"),
++  N_("-o FILE  --output=FILE  Operate interactively, sending output to FILE."),
+   "",
+-  N_("-i, --ignore-case            consider upper- and lower-case to be the same"),
+-  N_("-E, --ignore-tab-expansion   ignore changes due to tab expansion"),
+-  N_("-Z, --ignore-trailing-space  ignore white space at line end"),
+-  N_("-b, --ignore-space-change    ignore changes in the amount of white space"),
+-  N_("-W, --ignore-all-space       ignore all white space"),
+-  N_("-B, --ignore-blank-lines     ignore changes whose lines are all blank"),
+-  N_("-I, --ignore-matching-lines=RE  ignore changes all whose lines match RE"),
+-  N_("    --strip-trailing-cr      strip trailing carriage return on input"),
+-  N_("-a, --text                   treat all files as text"),
++  N_("-i  --ignore-case  Consider upper- and lower-case to be the same."),
++  N_("-E  --ignore-tab-expansion  Ignore changes due to tab expansion."),
++  N_("-b  --ignore-space-change  Ignore changes in the amount of white space."),
++  N_("-W  --ignore-all-space  Ignore all white space."),
++  N_("-B  --ignore-blank-lines  Ignore changes whose lines are all blank."),
++  N_("-I RE  --ignore-matching-lines=RE  Ignore changes whose lines all match RE."),
++  N_("--strip-trailing-cr  Strip trailing carriage return on input."),
++  N_("-a  --text  Treat all files as text."),
+   "",
+-  N_("-w, --width=NUM              output at most NUM (default 130) print columns"),
+-  N_("-l, --left-column            output only the left column of common lines"),
+-  N_("-s, --suppress-common-lines  do not output common lines"),
++  N_("-w NUM  --width=NUM  Output at most NUM (default 130) print columns."),
++  N_("-l  --left-column  Output only the left column of common lines."),
++  N_("-s  --suppress-common-lines  Do not output common lines."),
+   "",
+-  N_("-t, --expand-tabs            expand tabs to spaces in output"),
+-  N_("    --tabsize=NUM            tab stops at every NUM (default 8) print columns"),
++  N_("-t  --expand-tabs  Expand tabs to spaces in output."),
++  N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
+   "",
+-  N_("-d, --minimal                try hard to find a smaller set of changes"),
+-  N_("-H, --speed-large-files      assume large files, many scattered small changes"),
+-  N_("    --diff-program=PROGRAM   use PROGRAM to compare files"),
++  N_("-d  --minimal  Try hard to find a smaller set of changes."),
++  N_("-H  --speed-large-files  Assume large files and many scattered small changes."),
++  N_("--diff-program=PROGRAM  Use PROGRAM to compare files."),
+   "",
+-  N_("    --help                   display this help and exit"),
+-  N_("-v, --version                output version information and exit"),
++  N_("-v  --version  Output version info."),
++  N_("--help  Output this help."),
+   0
+ };
+ 
+@@ -204,12 +223,7 @@ usage (void)
+   char const * const *p;
+ 
+   printf (_("Usage: %s [OPTION]... FILE1 FILE2\n"), program_name);
+-  printf ("%s\n\n",
+-          _("Side-by-side merge of differences between FILE1 and FILE2."));
+-
+-  fputs (_("\
+-Mandatory arguments to long options are mandatory for short options too.\n\
+-"), stdout);
++  printf ("%s\n\n", _("Side-by-side merge of file differences."));
+   for (p = option_help_msgid;  *p;  p++)
+     if (**p)
+       printf ("  %s\n", _(*p));
+@@ -226,7 +240,7 @@ Mandatory arguments to long options are
+ static void
+ cleanup (int signo __attribute__((unused)))
+ {
+-#if HAVE_WORKING_FORK
++#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+   if (0 < diffpid)
+     kill (diffpid, SIGPIPE);
+ #endif
+@@ -379,8 +393,8 @@ lf_copy (struct line_filter *lf, lin lin
+ 
+   while (lines)
+     {
+-      lf->bufpos = rawmemchr (lf->bufpos, '\n');
+-      if (lf->bufpos == lf->buflim)
++      lf->bufpos = (char *) memchr (lf->bufpos, '\n', lf->buflim - lf->bufpos);
++      if (! lf->bufpos)
+ 	{
+ 	  ck_fwrite (start, lf->buflim - start, outfile);
+ 	  if (! lf_refill (lf))
+@@ -403,8 +417,8 @@ lf_skip (struct line_filter *lf, lin lin
+ {
+   while (lines)
+     {
+-      lf->bufpos = rawmemchr (lf->bufpos, '\n');
+-      if (lf->bufpos == lf->buflim)
++      lf->bufpos = (char *) memchr (lf->bufpos, '\n', lf->buflim - lf->bufpos);
++      if (! lf->bufpos)
+ 	{
+ 	  if (! lf_refill (lf))
+ 	    break;
+@@ -424,7 +438,7 @@ lf_snarf (struct line_filter *lf, char *
+   for (;;)
+     {
+       char *start = lf->bufpos;
+-      char *next = rawmemchr (start, '\n');
++      char *next = (char *) memchr (start, '\n', lf->buflim + 1 - start);
+       size_t s = next - start;
+       if (bufsize <= s)
+ 	return 0;
+@@ -463,7 +477,7 @@ main (int argc, char *argv[])
+   diffarg (DEFAULT_DIFF_PROGRAM);
+ 
+   /* parse command line args */
+-  while ((opt = getopt_long (argc, argv, "abBdEHiI:lo:stvw:WZ", longopts, 0))
++  while ((opt = getopt_long (argc, argv, "abBdEHiI:lo:stvw:W", longopts, 0))
+ 	 != -1)
+     {
+       switch (opt)
+@@ -518,7 +532,7 @@ main (int argc, char *argv[])
+ 	  break;
+ 
+ 	case 'v':
+-	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, Version,
++	  version_etc (stdout, PROGRAM_NAME, PACKAGE_NAME, PACKAGE_VERSION,
+ 		       AUTHORS, (char *) NULL);
+ 	  check_stdout ();
+ 	  return EXIT_SUCCESS;
+@@ -532,10 +546,6 @@ main (int argc, char *argv[])
+ 	  diffarg ("-w");
+ 	  break;
+ 
+-	case 'Z':
+-	  diffarg ("-Z");
+-	  break;
+-
+ 	case DIFF_PROGRAM_OPTION:
+ 	  diffargv[0] = optarg;
+ 	  break;
+@@ -608,9 +618,21 @@ main (int argc, char *argv[])
+ 
+       trapsigs ();
+ 
+-#if ! HAVE_WORKING_FORK
++#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+       {
+-	char *command = system_quote_argv (SCI_SYSTEM, (char **) diffargv);
++	size_t cmdsize = 1;
++	char *p, *command;
++	int i;
++
++	for (i = 0;  diffargv[i];  i++)
++	  cmdsize += shell_quote_length (diffargv[i]) + 1;
++	command = p = xmalloc (cmdsize);
++	for (i = 0;  diffargv[i];  i++)
++	  {
++	    p = shell_quote_copy (p, diffargv[i]);
++	    *p++ = ' ';
++	  }
++	p[-1] = 0;
+ 	errno = 0;
+ 	diffout = popen (command, "r");
+ 	if (! diffout)
+@@ -620,11 +642,22 @@ main (int argc, char *argv[])
+ #else
+       {
+ 	int diff_fds[2];
++# if HAVE_WORKING_VFORK
++	sigset_t procmask;
++	sigset_t blocked;
++# endif
+ 
+ 	if (pipe (diff_fds) != 0)
+ 	  perror_fatal ("pipe");
+ 
+-	diffpid = fork ();
++# if HAVE_WORKING_VFORK
++	/* Block SIGINT and SIGPIPE.  */
++	sigemptyset (&blocked);
++	sigaddset (&blocked, SIGINT);
++	sigaddset (&blocked, SIGPIPE);
++	sigprocmask (SIG_BLOCK, &blocked, &procmask);
++# endif
++	diffpid = vfork ();
+ 	if (diffpid < 0)
+ 	  perror_fatal ("fork");
+ 	if (! diffpid)
+@@ -636,6 +669,10 @@ main (int argc, char *argv[])
+ 	    if (initial_handler (handler_index_of_SIGINT) != SIG_IGN)
+ 	      signal_handler (SIGINT, SIG_IGN);
+ 	    signal_handler (SIGPIPE, SIG_DFL);
++# if HAVE_WORKING_VFORK
++	    /* Stop blocking SIGINT and SIGPIPE in the child.  */
++	    sigprocmask (SIG_SETMASK, &procmask, 0);
++# endif
+ 	    close (diff_fds[0]);
+ 	    if (diff_fds[1] != STDOUT_FILENO)
+ 	      {
+@@ -647,6 +684,19 @@ main (int argc, char *argv[])
+ 	    _exit (errno == ENOENT ? 127 : 126);
+ 	  }
+ 
++# if HAVE_WORKING_VFORK
++	/* Restore the parent's SIGINT and SIGPIPE behavior.  */
++	if (initial_handler (handler_index_of_SIGINT) != SIG_IGN)
++	  signal_handler (SIGINT, catchsig);
++	if (initial_handler (handler_index_of_SIGPIPE) != SIG_IGN)
++	  signal_handler (SIGPIPE, catchsig);
++	else
++	  signal_handler (SIGPIPE, SIG_IGN);
++
++	/* Stop blocking SIGINT and SIGPIPE in the parent.  */
++	sigprocmask (SIG_SETMASK, &procmask, 0);
++# endif
++
+ 	close (diff_fds[1]);
+ 	diffout = fdopen (diff_fds[0], "r");
+ 	if (! diffout)
+@@ -668,7 +718,7 @@ main (int argc, char *argv[])
+ 	int wstatus;
+ 	int werrno = 0;
+ 
+-#if ! HAVE_WORKING_FORK
++#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+ 	wstatus = pclose (diffout);
+ 	if (wstatus == -1)
+ 	  werrno = errno;
+@@ -697,7 +747,7 @@ main (int argc, char *argv[])
+ 	exit (WEXITSTATUS (wstatus));
+       }
+     }
+-  return EXIT_SUCCESS;			/* Fool '-Wall'.  */
++  return EXIT_SUCCESS;			/* Fool `-Wall'.  */
+ }
+ 
+ static void
+@@ -918,10 +968,10 @@ edit (struct line_filter *left, char con
+ 		  cmd0 = 'q';
+ 		  break;
+ 		}
+-	      FALLTHROUGH;
++	      /* Fall through.  */
+ 	    default:
+ 	      flush_line ();
+-	      FALLTHROUGH;
++	      /* Fall through.  */
+ 	    case '\n':
+ 	      give_help ();
+ 	      continue;
+@@ -967,14 +1017,14 @@ edit (struct line_filter *left, char con
+ 	      case 'd':
+ 		if (llen)
+ 		  {
+-		    printint l1 = lline;
+-		    printint l2 = lline + llen - 1;
+ 		    if (llen == 1)
+-		      fprintf (tmp, "--- %s %"pI"d\n", lname, l1);
++		      fprintf (tmp, "--- %s %ld\n", lname, (long int) lline);
+ 		    else
+-		      fprintf (tmp, "--- %s %"pI"d,%"pI"d\n", lname, l1, l2);
++		      fprintf (tmp, "--- %s %ld,%ld\n", lname,
++			       (long int) lline,
++			       (long int) (lline + llen - 1));
+ 		  }
+-		FALLTHROUGH;
++		/* Fall through.  */
+ 	      case '1': case 'b': case 'l':
+ 		lf_copy (left, llen, tmp);
+ 		break;
+@@ -989,14 +1039,14 @@ edit (struct line_filter *left, char con
+ 	      case 'd':
+ 		if (rlen)
+ 		  {
+-		    printint l1 = rline;
+-		    printint l2 = rline + rlen - 1;
+ 		    if (rlen == 1)
+-		      fprintf (tmp, "+++ %s %"pI"d\n", rname, l1);
++		      fprintf (tmp, "+++ %s %ld\n", rname, (long int) rline);
+ 		    else
+-		      fprintf (tmp, "+++ %s %"pI"d,%"pI"d\n", rname, l1, l2);
++		      fprintf (tmp, "+++ %s %ld,%ld\n", rname,
++			       (long int) rline,
++			       (long int) (rline + rlen - 1));
+ 		  }
+-		FALLTHROUGH;
++		/* Fall through.  */
+ 	      case '2': case 'b': case 'r':
+ 		lf_copy (right, rlen, tmp);
+ 		break;
+@@ -1011,17 +1061,16 @@ edit (struct line_filter *left, char con
+ 	    {
+ 	      int wstatus;
+ 	      int werrno = 0;
+-	      char const *argv[3];
+-
+ 	      ignore_SIGINT = true;
+ 	      checksigs ();
+-	      argv[0] = editor_program;
+-	      argv[1] = tmpname;
+-	      argv[2] = 0;
+ 
+ 	      {
+-#if ! HAVE_WORKING_FORK
+-		char *command = system_quote_argv (SCI_SYSTEM, (char **) argv);
++#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
++		char *command =
++		  xmalloc (shell_quote_length (editor_program)
++			   + 1 + strlen (tmpname) + 1);
++		sprintf (shell_quote_copy (command, editor_program),
++			 " %s", tmpname);
+ 		wstatus = system (command);
+ 		if (wstatus == -1)
+ 		  werrno = errno;
+@@ -1029,9 +1078,16 @@ edit (struct line_filter *left, char con
+ #else
+ 		pid_t pid;
+ 
+-		pid = fork ();
++		pid = vfork ();
+ 		if (pid == 0)
+ 		  {
++		    char const *argv[3];
++		    int i = 0;
++
++		    argv[i++] = editor_program;
++		    argv[i++] = tmpname;
++		    argv[i] = 0;
++
+ 		    execvp (editor_program, (char **) argv);
+ 		    _exit (errno == ENOENT ? 127 : 126);
+ 		  }
+@@ -1099,14 +1155,12 @@ interact (struct line_filter *diff,
+ 	  uintmax_t val;
+ 	  lin llen, rlen, lenmax;
+ 	  errno = 0;
+-	  val = strtoumax (diff_help + 1, &numend, 10);
+-	  if (LIN_MAX < val || errno || *numend != ',')
++	  llen = val = strtoumax (diff_help + 1, &numend, 10);
++	  if (llen < 0 || llen != val || errno || *numend != ',')
+ 	    fatal (diff_help);
+-	  llen = val;
+-	  val = strtoumax (numend + 1, &numend, 10);
+-	  if (LIN_MAX < val || errno || *numend)
++	  rlen = val = strtoumax (numend + 1, &numend, 10);
++	  if (rlen < 0 || rlen != val || errno || *numend)
+ 	    fatal (diff_help);
+-	  rlen = val;
+ 
+ 	  lenmax = MAX (llen, rlen);
+ 
+@@ -1165,9 +1219,18 @@ temporary_file (void)
+   char const *dir = tmpdir ? tmpdir : P_tmpdir;
+   char *buf = xmalloc (strlen (dir) + 1 + 5 + 6 + 1);
+   int fd;
++  int e;
++  sigset_t procmask;
++  sigset_t blocked;
+   sprintf (buf, "%s/sdiffXXXXXX", dir);
++  sigemptyset (&blocked);
++  sigaddset (&blocked, SIGINT);
++  sigprocmask (SIG_BLOCK, &blocked, &procmask);
+   fd = mkstemp (buf);
++  e = errno;
+   if (0 <= fd)
+     tmpname = buf;
++  sigprocmask (SIG_SETMASK, &procmask, 0);
++  errno = e;
+   return fd;
+ }
+Only in diffutils-3.0-patch: sdiff.o
+diff -pru diffutils-3.0/side.c diffutils-3.0-patch/side.c
+--- diffutils-3.0/side.c	2019-03-16 02:28:09.314893000 -0700
++++ diffutils-3.0-patch/side.c	2019-03-16 02:29:47.391203000 -0700
+@@ -1,7 +1,7 @@
+ /* sdiff-format output routines for GNU DIFF.
+ 
+-   Copyright (C) 1991-1993, 1998, 2001-2002, 2004, 2009-2013, 2015-2017 Free
+-   Software Foundation, Inc.
++   Copyright (C) 1991-1993, 1998, 2001-2002, 2004, 2009-2010 Free Software
++   Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -150,7 +150,7 @@ print_half_line (char const *const *line
+ 		break;
+ 	      }
+ 	  }
+-	  FALLTHROUGH;
++	  /* Fall through.  */
+ 	case '\f':
+ 	case '\v':
+ 	  if (in_position < out_bound)
+@@ -206,18 +206,6 @@ print_1sdiff_line (char const *const *le
+   size_t c2o = sdiff_column2_offset;
+   size_t col = 0;
+   bool put_newline = false;
+-  bool color_to_reset = false;
+-
+-  if (sep == '<')
+-    {
+-      set_color_context (DELETE_CONTEXT);
+-      color_to_reset = true;
+-    }
+-  else if (sep == '>')
+-    {
+-      set_color_context (ADD_CONTEXT);
+-      color_to_reset = true;
+-    }
+ 
+   if (left)
+     {
+@@ -245,9 +233,6 @@ print_1sdiff_line (char const *const *le
+ 
+   if (put_newline)
+     putc ('\n', out);
+-
+-  if (color_to_reset)
+-    set_color_context (RESET_CONTEXT);
+ }
+ 
+ /* Print lines common to both files in side-by-side format.  */
+@@ -260,9 +245,9 @@ print_sdiff_common_lines (lin limit0, li
+     {
+       if (sdiff_merge_assist)
+ 	{
+-	  printint len0 = limit0 - i0;
+-	  printint len1 = limit1 - i1;
+-	  fprintf (outfile, "i%"pI"d,%"pI"d\n", len0, len1);
++	  long int len0 = limit0 - i0;
++	  long int len1 = limit1 - i1;
++	  fprintf (outfile, "i%ld,%ld\n", len0, len1);
+ 	}
+ 
+       if (!left_column)
+@@ -302,12 +287,12 @@ print_sdiff_hunk (struct change *hunk)
+ 
+   if (sdiff_merge_assist)
+     {
+-      printint len0 = last0 - first0 + 1;
+-      printint len1 = last1 - first1 + 1;
+-      fprintf (outfile, "c%"pI"d,%"pI"d\n", len0, len1);
++      long int len0 = last0 - first0 + 1;
++      long int len1 = last1 - first1 + 1;
++      fprintf (outfile, "c%ld,%ld\n", len0, len1);
+     }
+ 
+-  /* Print "xxx  |  xxx " lines.  */
++  /* Print ``xxx  |  xxx '' lines */
+   if (changes == CHANGED)
+     {
+       for (i = first0, j = first1;  i <= last0 && j <= last1;  i++, j++)
+@@ -317,7 +302,7 @@ print_sdiff_hunk (struct change *hunk)
+       next1 = first1 = j;
+     }
+ 
+-  /* Print "     >  xxx " lines.  */
++  /* Print ``     >  xxx '' lines */
+   if (changes & NEW)
+     {
+       for (j = first1; j <= last1; ++j)
+@@ -325,7 +310,7 @@ print_sdiff_hunk (struct change *hunk)
+       next1 = j;
+     }
+ 
+-  /* Print "xxx  <     " lines.  */
++  /* Print ``xxx  <     '' lines */
+   if (changes & OLD)
+     {
+       for (i = first0; i <= last0; ++i)
+Only in diffutils-3.0-patch: side.o
+diff -pru diffutils-3.0/system.h diffutils-3.0-patch/system.h
+--- diffutils-3.0/system.h	2019-03-16 02:28:09.316895000 -0700
++++ diffutils-3.0-patch/system.h	2019-03-16 02:29:47.393233000 -0700
+@@ -1,7 +1,7 @@
+ /* System dependent declarations.
+ 
+-   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2013,
+-   2015-2017 Free Software Foundation, Inc.
++   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
++   Free Software Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -20,14 +20,14 @@
+ 
+ #include <config.h>
+ 
+-/* Use this to suppress gcc's "...may be used before initialized" warnings. */
++/* Use this to suppress gcc's `...may be used before initialized' warnings. */
+ #ifdef lint
+ # define IF_LINT(Code) Code
+ #else
+ # define IF_LINT(Code) /* empty */
+ #endif
+ 
+-/* Define '__attribute__' and 'volatile' first
++/* Define `__attribute__' and `volatile' first
+    so that they're used consistently in all system includes.  */
+ #if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 6) || __STRICT_ANSI__
+ # define __attribute__(x)
+@@ -54,6 +54,12 @@
+ #include <time.h>
+ 
+ #include <sys/wait.h>
++#ifndef WEXITSTATUS
++# define WEXITSTATUS(stat_val) ((unsigned int) (stat_val) >> 8)
++#endif
++#ifndef WIFEXITED
++# define WIFEXITED(stat_val) (((stat_val) & 255) == 0)
++#endif
+ 
+ #include <dirent.h>
+ #ifndef _D_EXACT_NAMLEN
+@@ -99,12 +105,19 @@ int strcasecmp (char const *, char const
+    - It's typically faster.
+    POSIX 1003.1-2001 says that only '0' through '9' are digits.
+    Prefer ISDIGIT to isdigit unless it's important to use the locale's
+-   definition of 'digit' even when the host does not conform to POSIX.  */
++   definition of `digit' even when the host does not conform to POSIX.  */
+ #define ISDIGIT(c) ((unsigned int) (c) - '0' <= 9)
+ 
+ #include <errno.h>
+ 
+ #include <signal.h>
++#ifndef SA_RESTART
++# ifdef SA_INTERRUPT /* e.g. SunOS 4.1.x */
++#  define SA_RESTART SA_INTERRUPT
++# else
++#  define SA_RESTART 0
++# endif
++#endif
+ #if !defined SIGCHLD && defined SIGCLD
+ # define SIGCHLD SIGCLD
+ #endif
+@@ -115,49 +128,32 @@ int strcasecmp (char const *, char const
+ #define MAX(a, b) ((a) >= (b) ? (a) : (b))
+ 
+ #include <stdbool.h>
++
++#if HAVE_VFORK_H
++# include <vfork.h>
++#endif
++
++#if ! HAVE_WORKING_VFORK
++# define vfork fork
++#endif
++
+ #include <intprops.h>
+ #include "propername.h"
+-#include "version.h"
+ 
+-/* Type used for fast comparison of several bytes at a time.
+-   This used to be uintmax_t, but changing it to size_t
+-   made plain 'cmp' 90% faster (GCC 4.8.1, x86).  */
++/* Type used for fast comparison of several bytes at a time.  */
+ 
+ #ifndef word
+-# define word size_t
++# define word uintmax_t
+ #endif
+ 
+-/* The signed integer type of a line number.  Since files are read
+-   into main memory, ptrdiff_t should be wide enough.  */
++/* The integer type of a line number.  Since files are read into main
++   memory, ptrdiff_t should be wide enough.  */
+ 
+ typedef ptrdiff_t lin;
+ #define LIN_MAX PTRDIFF_MAX
+-
+-/* The signed integer type for printing line numbers, and its printf
+-   length modifier.  This is not simply ptrdiff_t, to cater to older
+-   and/or nonstandard C libraries where "l" works but "ll" and "t" do
+-   not, or where 'long' is too narrow and "ll" works but "t" does not.  */
+-
+-#if LIN_MAX <= LONG_MAX
+-typedef long int printint;
+-# define pI "l"
+-#elif LIN_MAX <= LLONG_MAX
+-typedef long long int printint;
+-# define pI "ll"
+-#else
+-typedef ptrdiff_t printint;
+-# define pI "t"
+-#endif
+-
+ verify (TYPE_SIGNED (lin));
+-verify (TYPE_SIGNED (printint));
+-verify (LIN_MAX == TYPE_MAXIMUM (lin));
+-verify (LIN_MAX <= TYPE_MAXIMUM (printint));
+-
+-/* Limit so that 2 * CONTEXT + 1 does not overflow.  */
+-
+-#define CONTEXT_MAX ((LIN_MAX - 1) / 2)
+-
++verify (sizeof (ptrdiff_t) <= sizeof (lin));
++verify (sizeof (lin) <= sizeof (long int));
+ 
+ /* This section contains POSIX-compliant defaults for macros
+    that are meant to be overridden by hand in config.h as needed.  */
+@@ -176,7 +172,7 @@ verify (LIN_MAX <= TYPE_MAXIMUM (printin
+ 
+ /* Do struct stat *S, *T describe the same special file?  */
+ #ifndef same_special_file
+-# if HAVE_STRUCT_STAT_ST_RDEV && defined S_ISBLK && defined S_ISCHR
++# if HAVE_ST_RDEV && defined S_ISBLK && defined S_ISCHR
+ #  define same_special_file(s, t) \
+      (((S_ISBLK ((s)->st_mode) && S_ISBLK ((t)->st_mode)) \
+        || (S_ISCHR ((s)->st_mode) && S_ISCHR ((t)->st_mode))) \
+@@ -230,11 +226,3 @@ verify (LIN_MAX <= TYPE_MAXIMUM (printin
+ #endif
+ 
+ #define STREQ(a, b) (strcmp (a, b) == 0)
+-
+-#ifndef FALLTHROUGH
+-# if __GNUC__ < 7
+-#  define FALLTHROUGH ((void) 0)
+-# else
+-#  define FALLTHROUGH __attribute__ ((__fallthrough__))
+-# endif
+-#endif
+diff -pru diffutils-3.0/util.c diffutils-3.0-patch/util.c
+--- diffutils-3.0/util.c	2019-03-16 02:28:09.320894000 -0700
++++ diffutils-3.0-patch/util.c	2019-03-16 02:29:47.396210000 -0700
+@@ -1,7 +1,7 @@
+ /* Support routines for GNU DIFF.
+ 
+-   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2013,
+-   2015-2017 Free Software Foundation, Inc.
++   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
++   Free Software Foundation, Inc.
+ 
+    This file is part of GNU DIFF.
+ 
+@@ -19,34 +19,15 @@
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+ 
+ #include "diff.h"
+-#include "argmatch.h"
+-#include "die.h"
+ #include <dirname.h>
+ #include <error.h>
+-#include <system-quote.h>
++#include <sh-quote.h>
+ #include <xalloc.h>
+-#include "xvasprintf.h"
+-#include <signal.h>
+-
+-/* Use SA_NOCLDSTOP as a proxy for whether the sigaction machinery is
+-   present.  */
+-#ifndef SA_NOCLDSTOP
+-# define SA_NOCLDSTOP 0
+-# define sigprocmask(How, Set, Oset) /* empty */
+-# define sigset_t int
+-# if ! HAVE_SIGINTERRUPT
+-#  define siginterrupt(sig, flag) /* empty */
+-# endif
+-#endif
+-
+-#ifndef SA_RESTART
+-# define SA_RESTART 0
+-#endif
+ 
+ char const pr_program[] = PR_PROGRAM;
+ 
+ /* Queue up one-line messages to be printed at the end,
+-   when -l is specified.  Each message is recorded with a 'struct msg'.  */
++   when -l is specified.  Each message is recorded with a `struct msg'.  */
+ 
+ struct msg
+ {
+@@ -78,7 +59,8 @@ pfatal_with_name (char const *name)
+ {
+   int e = errno;
+   print_message_queue ();
+-  die (EXIT_TROUBLE, e, "%s", name);
++  error (EXIT_TROUBLE, e, "%s", name);
++  abort ();
+ }
+ 
+ /* Print an error message containing MSGID, then exit.  */
+@@ -87,7 +69,8 @@ void
+ fatal (char const *msgid)
+ {
+   print_message_queue ();
+-  die (EXIT_TROUBLE, 0, "%s", _(msgid));
++  error (EXIT_TROUBLE, 0, "%s", _(msgid));
++  abort ();
+ }
+ 
+ /* Like printf, except if -l in effect then save the message and print later.
+@@ -138,7 +121,7 @@ message5 (char const *format_msgid, char
+     }
+ }
+ 
+-/* Output all the messages that were saved up by calls to 'message'.  */
++/* Output all the messages that were saved up by calls to `message'.  */
+ 
+ void
+ print_message_queue (void)
+@@ -159,574 +142,16 @@ print_message_queue (void)
+     }
+ }
+ 
+-/* The set of signals that are caught.  */
+-
+-static sigset_t caught_signals;
+-
+-/* If nonzero, the value of the pending fatal signal.  */
+-
+-static sig_atomic_t volatile interrupt_signal;
+-
+-/* A count of the number of pending stop signals that have been received.  */
+-
+-static sig_atomic_t volatile stop_signal_count;
+-
+-/* An ordinary signal was received; arrange for the program to exit.  */
+-
+-static void
+-sighandler (int sig)
+-{
+-  if (! SA_NOCLDSTOP)
+-    signal (sig, SIG_IGN);
+-  if (! interrupt_signal)
+-    interrupt_signal = sig;
+-}
+-
+-/* A SIGTSTP was received; arrange for the program to suspend itself.  */
+-
+-static void
+-stophandler (int sig)
+-{
+-  if (! SA_NOCLDSTOP)
+-    signal (sig, stophandler);
+-  if (! interrupt_signal)
+-    stop_signal_count++;
+-}
+-/* Process any pending signals.  If signals are caught, this function
+-   should be called periodically.  Ideally there should never be an
+-   unbounded amount of time when signals are not being processed.
+-   Signal handling can restore the default colors, so callers must
+-   immediately change colors after invoking this function.  */
+-
+-static void
+-process_signals (void)
+-{
+-  while (interrupt_signal || stop_signal_count)
+-    {
+-      int sig;
+-      int stops;
+-      sigset_t oldset;
+-
+-      set_color_context (RESET_CONTEXT);
+-      fflush (stdout);
+-
+-      sigprocmask (SIG_BLOCK, &caught_signals, &oldset);
+-
+-      /* Reload interrupt_signal and stop_signal_count, in case a new
+-         signal was handled before sigprocmask took effect.  */
+-      sig = interrupt_signal;
+-      stops = stop_signal_count;
+-
+-      /* SIGTSTP is special, since the application can receive that signal
+-         more than once.  In this case, don't set the signal handler to the
+-         default.  Instead, just raise the uncatchable SIGSTOP.  */
+-      if (stops)
+-        {
+-          stop_signal_count = stops - 1;
+-          sig = SIGSTOP;
+-        }
+-      else
+-        signal (sig, SIG_DFL);
+-
+-      /* Exit or suspend the program.  */
+-      raise (sig);
+-      sigprocmask (SIG_SETMASK, &oldset, NULL);
+-
+-      /* If execution reaches here, then the program has been
+-         continued (after being suspended).  */
+-    }
+-}
+-
+-static void
+-install_signal_handlers (void)
+-{
+-  /* The signals that are trapped, and the number of such signals.  */
+-  static int const sig[] =
+-    {
+-      /* This one is handled specially.  */
+-      SIGTSTP,
+-
+-      /* The usual suspects.  */
+-      SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM,
+-#ifdef SIGPOLL
+-      SIGPOLL,
+-#endif
+-#ifdef SIGPROF
+-      SIGPROF,
+-#endif
+-#ifdef SIGVTALRM
+-      SIGVTALRM,
+-#endif
+-#ifdef SIGXCPU
+-      SIGXCPU,
+-#endif
+-#ifdef SIGXFSZ
+-      SIGXFSZ,
+-#endif
+-    };
+-  enum { nsigs = sizeof (sig) / sizeof *(sig) };
+-
+-#if ! SA_NOCLDSTOP
+-  bool caught_sig[nsigs];
+-#endif
+-  {
+-    int j;
+-#if SA_NOCLDSTOP
+-    struct sigaction act;
+-
+-    sigemptyset (&caught_signals);
+-    for (j = 0; j < nsigs; j++)
+-      {
+-        sigaction (sig[j], NULL, &act);
+-        if (act.sa_handler != SIG_IGN)
+-          sigaddset (&caught_signals, sig[j]);
+-      }
+-
+-    act.sa_mask = caught_signals;
+-    act.sa_flags = SA_RESTART;
++/* Call before outputting the results of comparing files NAME0 and NAME1
++   to set up OUTFILE, the stdio stream for the output to go to.
+ 
+-    for (j = 0; j < nsigs; j++)
+-      if (sigismember (&caught_signals, sig[j]))
+-        {
+-          act.sa_handler = sig[j] == SIGTSTP ? stophandler : sighandler;
+-          sigaction (sig[j], &act, NULL);
+-        }
+-#else
+-    for (j = 0; j < nsigs; j++)
+-      {
+-        caught_sig[j] = (signal (sig[j], SIG_IGN) != SIG_IGN);
+-        if (caught_sig[j])
+-          {
+-            signal (sig[j], sig[j] == SIGTSTP ? stophandler : sighandler);
+-            siginterrupt (sig[j], 0);
+-          }
+-      }
+-#endif
+-    }
+-}
++   Usually, OUTFILE is just stdout.  But when -l was specified
++   we fork off a `pr' and make OUTFILE a pipe to it.
++   `pr' then outputs to our stdout.  */
+ 
+ static char const *current_name0;
+ static char const *current_name1;
+ static bool currently_recursive;
+-static bool colors_enabled;
+-
+-static struct color_ext_type *color_ext_list = NULL;
+-
+-struct bin_str
+-  {
+-    size_t len;			/* Number of bytes */
+-    const char *string;		/* Pointer to the same */
+-  };
+-
+-struct color_ext_type
+-  {
+-    struct bin_str ext;		/* The extension we're looking for */
+-    struct bin_str seq;		/* The sequence to output when we do */
+-    struct color_ext_type *next;	/* Next in list */
+-  };
+-
+-/* Parse a string as part of the --palette argument; this may involve
+-   decoding all kinds of escape characters.  If equals_end is set an
+-   unescaped equal sign ends the string, otherwise only a : or \0
+-   does.  Set *OUTPUT_COUNT to the number of bytes output.  Return
+-   true if successful.
+-
+-   The resulting string is *not* null-terminated, but may contain
+-   embedded nulls.
+-
+-   Note that both dest and src are char **; on return they point to
+-   the first free byte after the array and the character that ended
+-   the input string, respectively.  */
+-
+-static bool
+-get_funky_string (char **dest, const char **src, bool equals_end,
+-                  size_t *output_count)
+-{
+-  char num;			/* For numerical codes */
+-  size_t count;			/* Something to count with */
+-  enum {
+-    ST_GND, ST_BACKSLASH, ST_OCTAL, ST_HEX, ST_CARET, ST_END, ST_ERROR
+-  } state;
+-  const char *p;
+-  char *q;
+-
+-  p = *src;			/* We don't want to double-indirect */
+-  q = *dest;			/* the whole darn time.  */
+-
+-  count = 0;			/* No characters counted in yet.  */
+-  num = 0;
+-
+-  state = ST_GND;		/* Start in ground state.  */
+-  while (state < ST_END)
+-    {
+-      switch (state)
+-        {
+-        case ST_GND:		/* Ground state (no escapes) */
+-          switch (*p)
+-            {
+-            case ':':
+-            case '\0':
+-              state = ST_END;	/* End of string */
+-              break;
+-            case '\\':
+-              state = ST_BACKSLASH; /* Backslash scape sequence */
+-              ++p;
+-              break;
+-            case '^':
+-              state = ST_CARET; /* Caret escape */
+-              ++p;
+-              break;
+-            case '=':
+-              if (equals_end)
+-                {
+-                  state = ST_END; /* End */
+-                  break;
+-                }
+-              FALLTHROUGH;
+-            default:
+-              *(q++) = *(p++);
+-              ++count;
+-              break;
+-            }
+-          break;
+-
+-        case ST_BACKSLASH:	/* Backslash escaped character */
+-          switch (*p)
+-            {
+-            case '0':
+-            case '1':
+-            case '2':
+-            case '3':
+-            case '4':
+-            case '5':
+-            case '6':
+-            case '7':
+-              state = ST_OCTAL;	/* Octal sequence */
+-              num = *p - '0';
+-              break;
+-            case 'x':
+-            case 'X':
+-              state = ST_HEX;	/* Hex sequence */
+-              num = 0;
+-              break;
+-            case 'a':		/* Bell */
+-              num = '\a';
+-              break;
+-            case 'b':		/* Backspace */
+-              num = '\b';
+-              break;
+-            case 'e':		/* Escape */
+-              num = 27;
+-              break;
+-            case 'f':		/* Form feed */
+-              num = '\f';
+-              break;
+-            case 'n':		/* Newline */
+-              num = '\n';
+-              break;
+-            case 'r':		/* Carriage return */
+-              num = '\r';
+-              break;
+-            case 't':		/* Tab */
+-              num = '\t';
+-              break;
+-            case 'v':		/* Vtab */
+-              num = '\v';
+-              break;
+-            case '?':		/* Delete */
+-              num = 127;
+-              break;
+-            case '_':		/* Space */
+-              num = ' ';
+-              break;
+-            case '\0':		/* End of string */
+-              state = ST_ERROR;	/* Error! */
+-              break;
+-            default:		/* Escaped character like \ ^ : = */
+-              num = *p;
+-              break;
+-            }
+-          if (state == ST_BACKSLASH)
+-            {
+-              *(q++) = num;
+-              ++count;
+-              state = ST_GND;
+-            }
+-          ++p;
+-          break;
+-
+-        case ST_OCTAL:		/* Octal sequence */
+-          if (*p < '0' || *p > '7')
+-            {
+-              *(q++) = num;
+-              ++count;
+-              state = ST_GND;
+-            }
+-          else
+-            num = (num << 3) + (*(p++) - '0');
+-          break;
+-
+-        case ST_HEX:		/* Hex sequence */
+-          switch (*p)
+-            {
+-            case '0':
+-            case '1':
+-            case '2':
+-            case '3':
+-            case '4':
+-            case '5':
+-            case '6':
+-            case '7':
+-            case '8':
+-            case '9':
+-              num = (num << 4) + (*(p++) - '0');
+-              break;
+-            case 'a':
+-            case 'b':
+-            case 'c':
+-            case 'd':
+-            case 'e':
+-            case 'f':
+-              num = (num << 4) + (*(p++) - 'a') + 10;
+-              break;
+-            case 'A':
+-            case 'B':
+-            case 'C':
+-            case 'D':
+-            case 'E':
+-            case 'F':
+-              num = (num << 4) + (*(p++) - 'A') + 10;
+-              break;
+-            default:
+-              *(q++) = num;
+-              ++count;
+-              state = ST_GND;
+-              break;
+-            }
+-          break;
+-
+-        case ST_CARET:		/* Caret escape */
+-          state = ST_GND;	/* Should be the next state... */
+-          if (*p >= '@' && *p <= '~')
+-            {
+-              *(q++) = *(p++) & 037;
+-              ++count;
+-            }
+-          else if (*p == '?')
+-            {
+-              *(q++) = 127;
+-              ++count;
+-            }
+-          else
+-            state = ST_ERROR;
+-          break;
+-
+-        default:
+-          abort ();
+-        }
+-    }
+-
+-  *dest = q;
+-  *src = p;
+-  *output_count = count;
+-
+-  return state != ST_ERROR;
+-}
+-
+-enum parse_state
+-  {
+-    PS_START = 1,
+-    PS_2,
+-    PS_3,
+-    PS_4,
+-    PS_DONE,
+-    PS_FAIL
+-  };
+-
+-#define LEN_STR_PAIR(s) sizeof (s) - 1, s
+-
+-static struct bin_str color_indicator[] =
+-  {
+-    { LEN_STR_PAIR ("\033[") },		/* lc: Left of color sequence */
+-    { LEN_STR_PAIR ("m") },		/* rc: Right of color sequence */
+-    { 0, NULL },			/* ec: End color (replaces lc+rs+rc) */
+-    { LEN_STR_PAIR ("0") },		/* rs: Reset to ordinary colors */
+-    { LEN_STR_PAIR ("1") },		/* hd: Header */
+-    { LEN_STR_PAIR ("32") },		/* ad: Add line */
+-    { LEN_STR_PAIR ("31") },		/* de: Delete line */
+-    { LEN_STR_PAIR ("36") },		/* ln: Line number */
+-  };
+-
+-static const char *const indicator_name[] =
+-  {
+-    "lc", "rc", "ec", "rs", "hd", "ad", "de", "ln", NULL
+-  };
+-ARGMATCH_VERIFY (indicator_name, color_indicator);
+-
+-static char const *color_palette;
+-
+-void
+-set_color_palette (char const *palette)
+-{
+-  color_palette = palette;
+-}
+-
+-static void
+-parse_diff_color (void)
+-{
+-  char *color_buf;
+-  const char *p;		/* Pointer to character being parsed */
+-  char *buf;			/* color_buf buffer pointer */
+-  int ind_no;			/* Indicator number */
+-  char label[3];		/* Indicator label */
+-  struct color_ext_type *ext;	/* Extension we are working on */
+-
+-  if ((p = color_palette) == NULL || *p == '\0')
+-    return;
+-
+-  ext = NULL;
+-  strcpy (label, "??");
+-
+-  /* This is an overly conservative estimate, but any possible
+-     --palette string will *not* generate a color_buf longer than
+-     itself, so it is a safe way of allocating a buffer in
+-     advance.  */
+-  buf = color_buf = xstrdup (p);
+-
+-  enum parse_state state = PS_START;
+-  while (true)
+-    {
+-      switch (state)
+-        {
+-        case PS_START:		/* First label character */
+-          switch (*p)
+-            {
+-            case ':':
+-              ++p;
+-              break;
+-
+-            case '*':
+-              /* Allocate new extension block and add to head of
+-                 linked list (this way a later definition will
+-                 override an earlier one, which can be useful for
+-                 having terminal-specific defs override global).  */
+-
+-              ext = xmalloc (sizeof *ext);
+-              ext->next = color_ext_list;
+-              color_ext_list = ext;
+-
+-              ++p;
+-              ext->ext.string = buf;
+-
+-              state = (get_funky_string (&buf, &p, true, &ext->ext.len)
+-                       ? PS_4 : PS_FAIL);
+-              break;
+-
+-            case '\0':
+-              state = PS_DONE;	/* Done! */
+-              goto done;
+-
+-            default:	/* Assume it is file type label */
+-              label[0] = *(p++);
+-              state = PS_2;
+-              break;
+-            }
+-          break;
+-
+-        case PS_2:		/* Second label character */
+-          if (*p)
+-            {
+-              label[1] = *(p++);
+-              state = PS_3;
+-            }
+-          else
+-            state = PS_FAIL;	/* Error */
+-          break;
+-
+-        case PS_3:		/* Equal sign after indicator label */
+-          state = PS_FAIL;	/* Assume failure...  */
+-          if (*(p++) == '=')/* It *should* be...  */
+-            {
+-              for (ind_no = 0; indicator_name[ind_no] != NULL; ++ind_no)
+-                {
+-                  if (STREQ (label, indicator_name[ind_no]))
+-                    {
+-                      color_indicator[ind_no].string = buf;
+-                      state = (get_funky_string (&buf, &p, false,
+-                                                 &color_indicator[ind_no].len)
+-                               ? PS_START : PS_FAIL);
+-                      break;
+-                    }
+-                }
+-              if (state == PS_FAIL)
+-                error (0, 0, _("unrecognized prefix: %s"), label);
+-            }
+-          break;
+-
+-        case PS_4:		/* Equal sign after *.ext */
+-          if (*(p++) == '=')
+-            {
+-              ext->seq.string = buf;
+-              state = (get_funky_string (&buf, &p, false, &ext->seq.len)
+-                       ? PS_START : PS_FAIL);
+-            }
+-          else
+-            state = PS_FAIL;
+-          break;
+-
+-        case PS_FAIL:
+-          goto done;
+-
+-        default:
+-          abort ();
+-        }
+-    }
+- done:
+-
+-  if (state == PS_FAIL)
+-    {
+-      struct color_ext_type *e;
+-      struct color_ext_type *e2;
+-
+-      error (0, 0,
+-             _("unparsable value for --palette"));
+-      free (color_buf);
+-      for (e = color_ext_list; e != NULL; /* empty */)
+-        {
+-          e2 = e;
+-          e = e->next;
+-          free (e2);
+-        }
+-      colors_enabled = false;
+-    }
+-}
+-
+-static void
+-check_color_output (bool is_pipe)
+-{
+-  bool output_is_tty;
+-
+-  if (! outfile || colors_style == NEVER)
+-    return;
+-
+-  output_is_tty = presume_output_tty || (!is_pipe && isatty (fileno (outfile)));
+-
+-  colors_enabled = (colors_style == ALWAYS
+-                    || (colors_style == AUTO && output_is_tty));
+-
+-  if (colors_enabled)
+-    parse_diff_color ();
+-
+-  if (output_is_tty)
+-    install_signal_handlers ();
+-}
+-
+-/* Call before outputting the results of comparing files NAME0 and NAME1
+-   to set up OUTFILE, the stdio stream for the output to go to.
+-
+-   Usually, OUTFILE is just stdout.  But when -l was specified
+-   we fork off a 'pr' and make OUTFILE a pipe to it.
+-   'pr' then outputs to our stdout.  */
+ 
+ void
+ setup_output (char const *name0, char const *name1, bool recursive)
+@@ -737,134 +162,43 @@ setup_output (char const *name0, char co
+   outfile = 0;
+ }
+ 
+-#if HAVE_WORKING_FORK
++#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+ static pid_t pr_pid;
+ #endif
+ 
+-static char c_escape_char (char c)
+-{
+-  switch (c) {
+-    case '\a': return 'a';
+-    case '\b': return 'b';
+-    case '\t': return 't';
+-    case '\n': return 'n';
+-    case '\v': return 'v';
+-    case '\f': return 'f';
+-    case '\r': return 'r';
+-    case '"': return '"';
+-    case '\\': return '\\';
+-    default:
+-      return c < 32;
+-  }
+-}
+-
+-static char *
+-c_escape (char const *str)
+-{
+-  char const *s;
+-  size_t plus = 0;
+-  bool must_quote = false;
+-
+-  for (s = str; *s; s++)
+-    {
+-      char c = *s;
+-
+-      if (c == ' ')
+-	{
+-	  must_quote = true;
+-	  continue;
+-	}
+-      switch (c_escape_char (*s))
+-	{
+-	  case 1:
+-	    plus += 3;
+-	    /* fall through */
+-	  case 0:
+-	    break;
+-	  default:
+-	    plus++;
+-	    break;
+-	}
+-    }
+-
+-  if (must_quote || plus)
+-    {
+-      size_t s_len = s - str;
+-      char *buffer = xmalloc (s_len + plus + 3);
+-      char *b = buffer;
+-
+-      *b++ = '"';
+-      for (s = str; *s; s++)
+-	{
+-	  char c = *s;
+-	  char escape = c_escape_char (c);
+-
+-	  switch (escape)
+-	    {
+-	      case 0:
+-		*b++ = c;
+-		break;
+-	      case 1:
+-		*b++ = '\\';
+-		*b++ = ((c >> 6) & 03) + '0';
+-		*b++ = ((c >> 3) & 07) + '0';
+-		*b++ = ((c >> 0) & 07) + '0';
+-		break;
+-	      default:
+-		*b++ = '\\';
+-		*b++ = escape;
+-		break;
+-	    }
+-	}
+-      *b++ = '"';
+-      *b = 0;
+-      return buffer;
+-    }
+-
+-  return (char *) str;
+-}
+-
+ void
+ begin_output (void)
+ {
+-  char *names[2];
+   char *name;
+ 
+   if (outfile != 0)
+     return;
+ 
+-  names[0] = c_escape (current_name0);
+-  names[1] = c_escape (current_name1);
+-
+   /* Construct the header of this piece of diff.  */
++  name = xmalloc (strlen (current_name0) + strlen (current_name1)
++		  + strlen (switch_string) + 7);
++
+   /* POSIX 1003.1-2001 specifies this format.  But there are some bugs in
+      the standard: it says that we must print only the last component
+      of the pathnames, and it requires two spaces after "diff" if
+      there are no options.  These requirements are silly and do not
+      match historical practice.  */
+-  name = xasprintf ("diff%s %s %s", switch_string, names[0], names[1]);
++  sprintf (name, "diff%s %s %s", switch_string, current_name0, current_name1);
+ 
+   if (paginate)
+     {
+-      char const *argv[4];
+-
+       if (fflush (stdout) != 0)
+ 	pfatal_with_name (_("write failed"));
+ 
+-      argv[0] = pr_program;
+-      argv[1] = "-h";
+-      argv[2] = name;
+-      argv[3] = 0;
+-
+-      /* Make OUTFILE a pipe to a subsidiary 'pr'.  */
++      /* Make OUTFILE a pipe to a subsidiary `pr'.  */
+       {
+-#if HAVE_WORKING_FORK
++#if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
+ 	int pipes[2];
+ 
+ 	if (pipe (pipes) != 0)
+ 	  pfatal_with_name ("pipe");
+ 
+-	pr_pid = fork ();
++	pr_pid = vfork ();
+ 	if (pr_pid < 0)
+ 	  pfatal_with_name ("fork");
+ 
+@@ -878,7 +212,7 @@ begin_output (void)
+ 		close (pipes[0]);
+ 	      }
+ 
+-	    execv (pr_program, (char **) argv);
++	    execl (pr_program, pr_program, "-h", name, (char *) 0);
+ 	    _exit (errno == ENOENT ? 127 : 126);
+ 	  }
+ 	else
+@@ -887,15 +221,19 @@ begin_output (void)
+ 	    outfile = fdopen (pipes[1], "w");
+ 	    if (!outfile)
+ 	      pfatal_with_name ("fdopen");
+-	    check_color_output (true);
+ 	  }
+ #else
+-	char *command = system_quote_argv (SCI_SYSTEM, (char **) argv);
++	char *command = xmalloc (sizeof pr_program - 1 + 7
++				 + shell_quote_length (name) + 1);
++	char *p;
++	sprintf (command, "%s -f -h ", pr_program);
++	p = command + sizeof pr_program - 1 + 7;
++	p = shell_quote_copy (p, name);
++	*p = 0;
+ 	errno = 0;
+ 	outfile = popen (command, "w");
+ 	if (!outfile)
+ 	  pfatal_with_name (command);
+-	check_color_output (true);
+ 	free (command);
+ #endif
+       }
+@@ -903,10 +241,9 @@ begin_output (void)
+   else
+     {
+ 
+-      /* If -l was not specified, output the diff straight to 'stdout'.  */
++      /* If -l was not specified, output the diff straight to `stdout'.  */
+ 
+       outfile = stdout;
+-      check_color_output (false);
+ 
+       /* If handling multiple files (because scanning a directory),
+ 	 print which files the following output is about.  */
+@@ -920,25 +257,20 @@ begin_output (void)
+   switch (output_style)
+     {
+     case OUTPUT_CONTEXT:
+-      print_context_header (files, (char const *const *)names, false);
++      print_context_header (files, false);
+       break;
+ 
+     case OUTPUT_UNIFIED:
+-      print_context_header (files, (char const *const *)names, true);
++      print_context_header (files, true);
+       break;
+ 
+     default:
+       break;
+     }
+-
+-  if (names[0] != current_name0)
+-    free (names[0]);
+-  if (names[1] != current_name1)
+-    free (names[1]);
+ }
+ 
+ /* Call after the end of output of diffs for one file.
+-   Close OUTFILE and get rid of the 'pr' subfork.  */
++   Close OUTFILE and get rid of the `pr' subfork.  */
+ 
+ void
+ finish_output (void)
+@@ -950,7 +282,7 @@ finish_output (void)
+       int werrno = 0;
+       if (ferror (outfile))
+ 	fatal ("write failed");
+-#if ! HAVE_WORKING_FORK
++#if ! (HAVE_WORKING_FORK || HAVE_WORKING_VFORK)
+       wstatus = pclose (outfile);
+       if (wstatus == -1)
+ 	werrno = errno;
+@@ -964,7 +296,7 @@ finish_output (void)
+ 		? WEXITSTATUS (wstatus)
+ 		: INT_MAX);
+       if (status)
+-	die (EXIT_TROUBLE, werrno,
++	error (EXIT_TROUBLE, werrno,
+ 	       _(status == 126
+ 		 ? "subsidiary program '%s' could not be invoked"
+ 		 : status == 127
+@@ -1063,33 +395,6 @@ lines_differ (char const *s1, char const
+ 
+ 	      break;
+ 
+-	    case IGNORE_TRAILING_SPACE:
+-	    case IGNORE_TAB_EXPANSION_AND_TRAILING_SPACE:
+-	      if (isspace (c1) && isspace (c2))
+-		{
+-		  unsigned char c;
+-		  if (c1 != '\n')
+-		    {
+-		      char const *p = t1;
+-		      while ((c = *p) != '\n' && isspace (c))
+-			++p;
+-		      if (c != '\n')
+-			break;
+-		    }
+-		  if (c2 != '\n')
+-		    {
+-		      char const *p = t2;
+-		      while ((c = *p) != '\n' && isspace (c))
+-			++p;
+-		      if (c != '\n')
+-			break;
+-		    }
+-		  /* Both lines have nothing but whitespace left.  */
+-		  return false;
+-		}
+-	      if (ignore_white_space == IGNORE_TRAILING_SPACE)
+-		break;
+-	      FALLTHROUGH;
+ 	    case IGNORE_TAB_EXPANSION:
+ 	      if ((c1 == ' ' && c2 == '\t')
+ 		  || (c1 == '\t' && c2 == ' '))
+@@ -1145,13 +450,13 @@ lines_differ (char const *s1, char const
+ /* Find the consecutive changes at the start of the script START.
+    Return the last link before the first gap.  */
+ 
+-struct change * _GL_ATTRIBUTE_CONST
++struct change *
+ find_change (struct change *start)
+ {
+   return start;
+ }
+ 
+-struct change * _GL_ATTRIBUTE_CONST
++struct change *
+ find_reverse_change (struct change *start)
+ {
+   return start;
+@@ -1207,18 +512,6 @@ print_script (struct change *script,
+ void
+ print_1_line (char const *line_flag, char const *const *line)
+ {
+-  print_1_line_nl (line_flag, line, false);
+-}
+-
+-/* Print the text of a single line LINE,
+-   flagging it with the characters in LINE_FLAG (which say whether
+-   the line is inserted, deleted, changed, etc.).  LINE_FLAG must not
+-   end in a blank, unless it is a single blank.  If SKIP_NL is set, then
+-   the final '\n' is not printed.  */
+-
+-void
+-print_1_line_nl (char const *line_flag, char const *const *line, bool skip_nl)
+-{
+   char const *base = line[0], *limit = line[1]; /* Help the compiler.  */
+   FILE *out = outfile; /* Help the compiler some more.  */
+   char const *flag_format = 0;
+@@ -1246,13 +539,10 @@ print_1_line_nl (char const *line_flag,
+       fprintf (out, flag_format_1, line_flag_1);
+     }
+ 
+-  output_1_line (base, limit - (skip_nl && limit[-1] == '\n'), flag_format, line_flag);
++  output_1_line (base, limit, flag_format, line_flag);
+ 
+   if ((!line_flag || line_flag[0]) && limit[-1] != '\n')
+-    {
+-      set_color_context (RESET_CONTEXT);
+-      fprintf (out, "\n\\ %s\n", _("No newline at end of file"));
+-    }
++    fprintf (out, "\n\\ %s\n", _("No newline at end of file"));
+ }
+ 
+ /* Output a line from BASE up to LIMIT.
+@@ -1264,21 +554,8 @@ void
+ output_1_line (char const *base, char const *limit, char const *flag_format,
+ 	       char const *line_flag)
+ {
+-  const size_t MAX_CHUNK = 1024;
+   if (!expand_tabs)
+-    {
+-      size_t left = limit - base;
+-      while (left)
+-        {
+-          size_t to_write = MIN (left, MAX_CHUNK);
+-          size_t written = fwrite (base, sizeof (char), to_write, outfile);
+-          if (written < to_write)
+-            return;
+-          base += written;
+-          left -= written;
+-          process_signals ();
+-        }
+-    }
++    fwrite (base, sizeof (char), limit - base, outfile);
+   else
+     {
+       register FILE *out = outfile;
+@@ -1286,104 +563,42 @@ output_1_line (char const *base, char co
+       register char const *t = base;
+       register size_t column = 0;
+       size_t tab_size = tabsize;
+-      size_t counter_proc_signals = 0;
+ 
+       while (t < limit)
+-        {
+-          counter_proc_signals++;
+-          if (counter_proc_signals == MAX_CHUNK)
+-            {
+-              process_signals ();
+-              counter_proc_signals = 0;
+-            }
+-
+-          switch ((c = *t++))
+-            {
+-            case '\t':
+-              {
+-                size_t spaces = tab_size - column % tab_size;
+-                column += spaces;
+-                do
+-                  putc (' ', out);
+-                while (--spaces);
+-              }
+-              break;
+-
+-            case '\r':
+-              putc (c, out);
+-              if (flag_format && t < limit && *t != '\n')
+-                fprintf (out, flag_format, line_flag);
+-              column = 0;
+-              break;
+-
+-            case '\b':
+-              if (column == 0)
+-                continue;
+-              column--;
+-              putc (c, out);
+-              break;
+-
+-            default:
+-              column += isprint (c) != 0;
+-              putc (c, out);
+-              break;
+-            }
+-        }
+-    }
+-}
+-
+-enum indicator_no
+-  {
+-    C_LEFT, C_RIGHT, C_END, C_RESET, C_HEADER, C_ADD, C_DELETE, C_LINE
+-  };
++	switch ((c = *t++))
++	  {
++	  case '\t':
++	    {
++	      size_t spaces = tab_size - column % tab_size;
++	      column += spaces;
++	      do
++		putc (' ', out);
++	      while (--spaces);
++	    }
++	    break;
+ 
+-static void
+-put_indicator (const struct bin_str *ind)
+-{
+-  fwrite (ind->string, ind->len, 1, outfile);
+-}
++	  case '\r':
++	    putc (c, out);
++	    if (flag_format && t < limit && *t != '\n')
++	      fprintf (out, flag_format, line_flag);
++	    column = 0;
++	    break;
+ 
+-static enum color_context last_context = RESET_CONTEXT;
++	  case '\b':
++	    if (column == 0)
++	      continue;
++	    column--;
++	    putc (c, out);
++	    break;
+ 
+-void
+-set_color_context (enum color_context color_context)
+-{
+-  if (color_context != RESET_CONTEXT)
+-    process_signals ();
+-  if (colors_enabled && last_context != color_context)
+-    {
+-      put_indicator (&color_indicator[C_LEFT]);
+-      switch (color_context)
+-        {
+-        case HEADER_CONTEXT:
+-          put_indicator (&color_indicator[C_HEADER]);
+-          break;
+-
+-        case LINE_NUMBER_CONTEXT:
+-          put_indicator (&color_indicator[C_LINE]);
+-          break;
+-
+-        case ADD_CONTEXT:
+-          put_indicator (&color_indicator[C_ADD]);
+-          break;
+-
+-        case DELETE_CONTEXT:
+-          put_indicator (&color_indicator[C_DELETE]);
+-          break;
+-
+-        case RESET_CONTEXT:
+-          put_indicator (&color_indicator[C_RESET]);
+-          break;
+-
+-        default:
+-          abort ();
+-        }
+-      put_indicator (&color_indicator[C_RIGHT]);
+-      last_context = color_context;
++	  default:
++	    column += isprint (c) != 0;
++	    putc (c, out);
++	    break;
++	  }
+     }
+ }
+ 
+-
+ char const change_letter[] = { 0, 'd', 'a', 'c' };
+ 
+ /* Translate an internal line number (an index into diff's table of lines)
+@@ -1393,20 +608,20 @@ char const change_letter[] = { 0, 'd', '
+    Internal line numbers count from 0 starting after the prefix.
+    Actual line numbers count from 1 within the entire file.  */
+ 
+-lin _GL_ATTRIBUTE_PURE
++lin
+ translate_line_number (struct file_data const *file, lin i)
+ {
+   return i + file->prefix_lines + 1;
+ }
+ 
+ /* Translate a line number range.  This is always done for printing,
+-   so for convenience translate to printint rather than lin, so that the
+-   caller can use printf with "%"pI"d" without casting.  */
++   so for convenience translate to long int rather than lin, so that the
++   caller can use printf with "%ld" without casting.  */
+ 
+ void
+ translate_range (struct file_data const *file,
+ 		 lin a, lin b,
+-		 printint *aptr, printint *bptr)
++		 long int *aptr, long int *bptr)
+ {
+   *aptr = translate_line_number (file, a - 1) + 1;
+   *bptr = translate_line_number (file, b + 1) - 1;
+@@ -1421,21 +636,21 @@ translate_range (struct file_data const
+ void
+ print_number_range (char sepchar, struct file_data *file, lin a, lin b)
+ {
+-  printint trans_a, trans_b;
++  long int trans_a, trans_b;
+   translate_range (file, a, b, &trans_a, &trans_b);
+ 
+   /* Note: we can have B < A in the case of a range of no lines.
+      In this case, we should print the line number before the range,
+      which is B.  */
+   if (trans_b > trans_a)
+-    fprintf (outfile, "%"pI"d%c%"pI"d", trans_a, sepchar, trans_b);
++    fprintf (outfile, "%ld%c%ld", trans_a, sepchar, trans_b);
+   else
+-    fprintf (outfile, "%"pI"d", trans_b);
++    fprintf (outfile, "%ld", trans_b);
+ }
+ 
+ /* Look at a hunk of edit script and report the range of lines in each file
+    that it applies to.  HUNK is the start of the hunk, which is a chain
+-   of 'struct change'.  The first and last line numbers of file 0 are stored in
++   of `struct change'.  The first and last line numbers of file 0 are stored in
+    *FIRST0 and *LAST0, and likewise for file 1 in *FIRST1 and *LAST1.
+    Note that these are internal line numbers that count from 0.
+ 
+@@ -1459,11 +674,8 @@ analyze_hunk (struct change *hunk,
+   size_t trivial_length = ignore_blank_lines - 1;
+     /* If 0, ignore zero-length lines;
+        if SIZE_MAX, do not ignore lines just because of their length.  */
+-
+-  bool skip_white_space =
+-    ignore_blank_lines && IGNORE_TRAILING_SPACE <= ignore_white_space;
+   bool skip_leading_white_space =
+-    skip_white_space && IGNORE_SPACE_CHANGE <= ignore_white_space;
++    (ignore_blank_lines && IGNORE_SPACE_CHANGE <= ignore_white_space);
+ 
+   char const * const *linbuf0 = files[0].linbuf;  /* Help the compiler.  */
+   char const * const *linbuf1 = files[1].linbuf;
+@@ -1484,18 +696,12 @@ analyze_hunk (struct change *hunk,
+       for (i = next->line0; i <= l0 && trivial; i++)
+ 	{
+ 	  char const *line = linbuf0[i];
+-	  char const *lastbyte = linbuf0[i + 1] - 1;
+-	  char const *newline = lastbyte + (*lastbyte != '\n');
++	  char const *newline = linbuf0[i + 1] - 1;
+ 	  size_t len = newline - line;
+ 	  char const *p = line;
+-	  if (skip_white_space)
+-	    for (; *p != '\n'; p++)
+-	      if (! isspace ((unsigned char) *p))
+-		{
+-		  if (! skip_leading_white_space)
+-		    p = line;
+-		  break;
+-		}
++	  if (skip_leading_white_space)
++	    while (isspace ((unsigned char) *p) && *p != '\n')
++	      p++;
+ 	  if (newline - p != trivial_length
+ 	      && (! ignore_regexp.fastmap
+ 		  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
+@@ -1505,18 +711,12 @@ analyze_hunk (struct change *hunk,
+       for (i = next->line1; i <= l1 && trivial; i++)
+ 	{
+ 	  char const *line = linbuf1[i];
+-	  char const *lastbyte = linbuf1[i + 1] - 1;
+-	  char const *newline = lastbyte + (*lastbyte != '\n');
++	  char const *newline = linbuf1[i + 1] - 1;
+ 	  size_t len = newline - line;
+ 	  char const *p = line;
+-	  if (skip_white_space)
+-	    for (; *p != '\n'; p++)
+-	      if (! isspace ((unsigned char) *p))
+-		{
+-		  if (! skip_leading_white_space)
+-		    p = line;
+-		  break;
+-		}
++	  if (skip_leading_white_space)
++	    while (isspace ((unsigned char) *p) && *p != '\n')
++	      p++;
+ 	  if (newline - p != trivial_length
+ 	      && (! ignore_regexp.fastmap
+ 		  || re_search (&ignore_regexp, line, len, 0, len, 0) < 0))
+@@ -1556,6 +756,18 @@ zalloc (size_t size)
+   memset (p, 0, size);
+   return p;
+ }
++
++/* Yield the newly malloc'd pathname
++   of the file in DIR whose filename is FILE.  */
++
++char *
++dir_file_pathname (char const *dir, char const *file)
++{
++  char const *base = last_component (dir);
++  size_t baselen = base_len (base);
++  bool omit_slash = baselen == 0 || base[baselen - 1] == '/';
++  return concat (dir, "/" + omit_slash, file);
++}
+ 
+ void
+ debug_script (struct change *sp)
+@@ -1564,11 +776,11 @@ debug_script (struct change *sp)
+ 
+   for (; sp; sp = sp->link)
+     {
+-      printint line0 = sp->line0;
+-      printint line1 = sp->line1;
+-      printint deleted = sp->deleted;
+-      printint inserted = sp->inserted;
+-      fprintf (stderr, "%3"pI"d %3"pI"d delete %"pI"d insert %"pI"d\n",
++      long int line0 = sp->line0;
++      long int line1 = sp->line1;
++      long int deleted = sp->deleted;
++      long int inserted = sp->inserted;
++      fprintf (stderr, "%3ld %3ld delete %ld insert %ld\n",
+ 	       line0, line1, deleted, inserted);
+     }
+ 
+Only in diffutils-3.0-patch: util.o
-- 
1.8.3.1

